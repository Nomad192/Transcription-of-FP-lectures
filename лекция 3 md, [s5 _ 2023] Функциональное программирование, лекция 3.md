# Text

Рад вас видеть на третьей лекции по функциональному программированию. Давайте краткий план у нас на сегодня. Мы научимся создавать свои собственные типы данных, поговорим про алгебрические типы данных, про рекорды, нью-тайпы, разные способы создать свои типы данных в Haskell. Поговорим про type-классы, про полиморфизм. Довольно интересная тема.

И какие-то разные мелочи про модули. Погнали. Мы хотим создавать свои типы данных. Давайте сначала подумаем, почему нам это нужно. Если нам нужен какой-то набор данных, который как-то связан, например, какой-то юзер, то почему не можем использовать просто tuple? Передаем tuple, можем написать функцию, типа сгенерить full ID для юзера.

Казалось бы, в чем проблема? Но понятно, что есть разные неудобства с этим. Я забыл сказать, если у вас есть какие-то вопросы, можете любое время меня прерывать. Можно просто говорить, потому что я, скорее всего, не буду смотреть чат во время лекции. Можно просто голосом становиться и говорить. Я буду стараться делать паузы в каких-то тривиальных местах, чтобы вы тоже могли немножко подумать, сознать, понимаете ли вы все.

Но если вопросы возникнут после, опять же, у нас есть чат в Телеграме, там можно задавать вопросы. Я думаю, что по этой лекции, как минимум, и по остальным тоже я смогу что-нибудь ответить. Коллеги мне помогут. Продолжаем. Понятно, какая проблема здесь.

Во-первых, что если мы возьмем какой-нибудь другой тип данных, какой-нибудь другой набор данных, не юзер, а аккаунт, у которого такой же набор данных. Мы можем что-то перепутать. В общем, у нас никаких проверок. У нас такой тип питон, грубо говоря. Значит, первая операция.

Что мы можем улучшить? Мы можем создать type alias, то есть синоним, который, во-первых, у нас уже сигнатура будет выглядеть удобно, красиво, но опять же, у нас есть проблема в том, что синоним совершенно не добавляет никаких новых проверок в compile-time. То есть если у нас будет юзер и будет аккаунт с одинаковым набором полей, то, грубо говоря, у нас они будут совершенно взаимозаменяемы. То есть если мы где-то сделаем ошибку, все еще компилятор никак не сможет нам помочь. Но, как минимум, читаемость у нас улучшилась. Собственно, вот какие-то такие распространенные type alias, их примеры.

То есть string — это просто лист черов, например. Ну, не всегда, на самом деле. Можно использовать разные вероятности, которых string будет означать разная. В этом тоже некоторые удобства есть. Но, значит, что тут важно отметить, что type alias спокойно могут быть параметрическими, то есть принимать различные аргументы, что довольно естественно и удобно.

Да, тут вроде пока все понятно. Значит, агибарические типы данных. Пытаемся сделать какое-то более правильное решение. И для этого немножко теории. Haskell-ные типы строятся на так называемой теории агибарических типов.

Суть в том, что у нас есть типы, у нас есть одними операции произведения, что, по сути, просто tuple. И почему произведение? Тут проводится такая аналогия, что типы — это как бы... их можно, если не копать глубоко, воспринимать как множество. И, в общем, когда мы хотим... если мы делаем пару из двух типов, то у нас получается количество элементов, которые населяют произведение типов, это произведение множества.

То есть мы берем любой элемент первый из первого множества, любой второй элемент из второго множества, получается произведение. Ну, в общем, да. User — это произведение int, двух стрингов. Собственно, да. В Haskell мы это уже видели, это tuple.

Ну и раз у нас есть произведение, давайте введем и сумму. Сумма означается знаком плюс. Написано сложно найти какие-то аналогии в нефункциональных языках. В целом, да, но сейчас во многих современных языках они впитывают функциональную парадигму и вносят ее. И, в общем, какие тут примеры? Самый оперативный — это union, который есть еще в плюсах, но там далеко от того, что воспринимается обычно под суммами типов.

Это еще называют вариантами. То есть в -х плюсах, например, введен стандартный вариант. Это, по сути, суммы типов. То есть у нас есть тип, который умеет хранить несколько разных вариантов других типов, и они помечены тегом, и мы можем их различить, делать на нем паттерн-матчинг и так далее. Собственно, героические типы — это, значит, либо какой-то атомарный тип, int, char, double, либо сумма типов, либо произведение типов.

То есть мы задаем некоторую грамматику, как могут выглядеть типы. Ну и, собственно, понятно, суть в том, что это напоминает нам некоторую алгебру, мы можем выписать для них какие-то правила, работать с ними как с математическими объектами. В общем, довольно удобно, когда у вас есть формальное определение того, что вы вообще можете написать в своей программе. Значит, давайте посмотрим, как это выглядит в Haskell, например. Самый простой пример — это enum.

То есть есть TrafficLight, у него есть почему-то четыре цвета. Я не совсем понимаю, почему, но для прикола. В общем, мы можем написать функцию для работы с ним, просто как бы разобрав все случаи. Значит, вроде бы все понятно. Значит, понятно.

Дальше мы можем эту функцию использовать, сделать map по листу, каждому применить, увидеть результат. Да, и тут важно то, что компилятор может вам помочь проверить, что ваш pattern matching, то есть сопоставление с образцом, что вы рассматриваете все варианты в нем, то есть что он полный, что вы делаете полный разбор всех случаев. Да. Для этого нужно включить нужные флажки, и будет вам счастье. Значит, окей, давайте посмотрим дальше.

У нас есть ключевое слово — data. По сути, мы создаем кастомный тип данных. Это уже не alias, это уже новый тип, который не совпадает со всеми остальными. И, значит, у него есть... Давайте разберем сигнатуру.

У нас data, дальше идет имя, дальше идет название конструктора. Оно все начинается с большой буквы, потом идут его параметры. То есть, по сути, у нас тут задана... Давайте посмотрим, как с этим работать дальше. Как получить доступ к полям? Мы можем просто сметчиться на конструкторе.

То есть мы делаем паттерн-матчинг, указываем имя конструктора, имя полей, на которых мы матчимся. Если какие-то не нужны, заменяем их класс-холдерами, чтобы не было опять варлинга, что мы не используем какие-то переменные или что-то такое. И, в общем, вот у нас есть геттеры. Значит, да, конструкторы — это просто функции. Просто функции, которые принимают, по сути, инк, стринг, стринг, в данном случае возвращают нам тип, который мы только что создали.

Они ничем особо не отличаются. Везде, где можно использовать функции, можно использовать конструктор. В общем, довольно удобно. Да, можно опять же в jash-сайт посмотреть тип. Значит, да, можно создать список юзеров, применить им какую-нибудь функцию.

Например, список уникальных имен. Выглядит, собственно, как какие-нибудь джаоские стримы. Собственно, они берут свое начало отсюда. Окей, значит, типы данных могут быть параметрическими. Можно вопрос? Да, вопрос.

Да, я слушаю. Я не слышу, к сожалению. Получается это круг? Да. Давайте вы напишите вопрос в чате. Я не знаю, я не слышу вас.

Вы очень сильно пропадаете. Что, серьезно? В каких-то странах есть голубой цвет светофора? Офигеть. Ну, ладно. Напишите, пожалуйста, вопрос в чате. Я его посмотрю буквально через пару минут.

Собственно, давайте продолжим. У нас есть... Извините, у меня сейчас должно быть лучше слышно, у меня просто был интернет выходит. На предыдущем слайде был мк-юзер и юзер. Мк-юзер – это, получается, имя конструктора? Да, мк-юзер – это имя конструктора, совершенно верно.

А юзер – это имя? А это имя, да. То есть, да, смотрите. Если, допустим, у вас больше опыта работать с плюсами, то тут конструкторы и имена типов – они разные. Это удобно, потому что, на самом деле, если в плюсах вы создаете разными конструкторами тип, вы получаете один и тот же тип. То есть их никак нельзя различить.

Нельзя узнать, с помощью какого конструктора был создан тип. Это неинтересно в плюсах. Здесь немножко другая концепция. Тут все конструкторы помечают наш объект. Мы можем узнать, с помощью какого конструктора был создан объект.

Тут конструктор является неотъемлемой частью представления типа. То есть это его как бы часть структурная. То есть в этом есть немножко отличие, более какой-то математичный подход здесь. Но мы это все увидим. Например, дальше, если будут вопросы, я отвечу.

Еще вопросы? Там вопрос в чате задали, можно ли создать более одного конструктора для одного типа. Да, можно. Сейчас мы увидим. Мы пока разобрали тип с одним конструктором. Когда мы пройдем дальше, мы увидим все.

Мы не зря говорили про суммы типов. Сейчас все будет. Давайте закончим эту часть, потом тут вопрос. Я спрошу. Типы могут быть параметрическими.

Параметрический параметризм, как говорится. Понятно зачем. Мы хотим точку, допустим, написать какой-то код общий, без указывания конкретных типов. Мы хотим, чтобы и длинна работала, и для дабла, и, допустим, для двухмерной точки. Вот простые примеры.

Типа, точку в список превратить, взять точку и превратить ее в точку, в которой пространство, а осями являются тоже 2D пространства, удвоить. Взять максимальную координату, остальные от нуля посчитать. Такие простые, хоть понятные, примеры, на которых должно быть просто видно, что вообще происходит. Создаем типы, видим результат. Получается конструктор имеет такое же название, как и тип данных.

Да, совершенно верно. Здесь у нас немножко другой пример, тут конструктор имеет такое же название, как тип данных, и в Haskell это разные синтаксические вещи. Там, где предполагается тип, и вы пишете Point2D, он будет депортироваться как тип. Там, где предполагается какая-то функция, будет восприниматься как конструктор. То есть они вообще разнесены.

Пока что. Пока у нас нет зависимых типов. Но, в общем, да. Вполне из контекста понятно, что такое Point2D, конструктор и тип. В целом, довольно удобно.

Давайте пойдем дальше. Суммы типов. Когда у нас может быть несколько конструкторов. Если у нас есть intResult, у нас intResult воплощает в себе либо успешное вычисление числа, какой-то совочисленный результат вычислений, или это ошибка с сообщением. И success и failure — это две функции, которые принимают параметры за счет типа.

Если проводить аналогию с пульсами, это такой вариант, в котором лежат string и int. И как в варианте, мы можем по индексу спросить, какой из вариантов лежит. То есть у нас они протеганы, в отличие от union, у нас есть доступ к тому, что мы можем спросить, какой из вариантов лежит сделать pattern matching. И давайте реализуем saveDiff. Если у нас деление на 0, то мы кидаем ошибку, грубо говоря.

Такой способ обрабатывать ошибки. Мы возвращаем сообщение. Вот. ShowResult. Собственно, да.

Вот так вот. Все понятно. Давайте дальше. Параметрические суммы могут быть легко. Допустим, у нас есть вектор, и мы хотим с ним работать как с вектором, вне зависимости от того, сколько там 2D это вектор или 3D.

Ну, такие игрушечные примеры. Наверное, нет у них большого смысла, но, в общем, можно писать функцию, которая из обоих вариантов делает список. Посчитать длину. Собственно, да. Превращаем все в список.

И дальше берем сумму квадратов, корень суммы квадратов, и, собственно, всякие конкретные примеры. Да, и при этом, понятно, все еще конструкты — это функции, просто теперь эти функции полиморфные. А вот вопрос. В самой первой строчке у нас написано «вектор А» после даты. Это полностью название? Ну, типа, «А» — это что такое? «А» — это параметр.

Это тип параметра. А, типа, генерик какой-то? Типа, type name А. Да, это генерик. Да, и вектор, собственно, «АА» — это немножко такой, на мой взгляд, немножко странноватый синтаксис. Довольно легко привыкнуть.

Ну, типа, если бы мы использовали в конструкторе какие-то дефолтные типы, а не генерики, то нам бы не нужно было «вектор А» указать. Достаточно было бы просто написать «вектор». Дата, вектор равно. Да, если мы не используем... Если у нас тип не параметризован никаким типом, то мы как бы не пишем никаких аргументов, как это было там с юзером.

Ну, понятно. Да, спасибо. Да. То есть, по факту, мы это делаем, чтобы сузить возможный аргумент, типа, аргумент, который мы можем принять. То есть, грубо говоря, мы сузили до того, что у нас должны быть аргументы в векторе 2D и в векторе 3D строго одного и того же типа.

То есть, что они там не могут быть разных типов, там, int и string. Да, да, да. То есть, это как темплейты, грубо говоря, в плюсах. Да, все верно. Это действительно как темплейты в плюсах.

Ну, то есть, и то, и то. Это способ создать генерик, тип проэматризованный типом. И да, если мы делаем более полиморфный тип, мы с ним меньше чего можем сделать, потому что у нас меньше информации о типе и у нас меньше способов облажаться в некотором смысле. Если мы правильно задизайнили тип и мы все еще можем сделать все, что мы хотим с ним делать, то да, каких-то вариантов, что мы можем сделать не так, меньше. Это правда.

А можно несколько конструкторов с одинаковым названием, но разными типами? К сожалению, нет. Потому что в Haskell нет такой штуки, как оверлоадинг. То есть не может быть одной и той же функции с разными реализациями, как в плюсах, например. Но есть способ сделать такой ad-hoc полиморфизм, как он называется, но с конструкторами это не совсем прокатит. Потому что, допустим, мы все еще хотим их различать.

Если мы делаем pattern match, мы хотим знать, мы сматчились на, не знаю, на что-то name конструктор и как понять, сколько у него параметров. То есть мы все еще хотим их как-то различать. Да, есть некоторые неудобства, возможно, если мы, допустим, не знаю, можно представить себе ситуацию, какая-то неудобная, но как бы это некоторые трейдов, что все остальное продолжает работать. Давайте закончим эту главу все-таки. Еще последний вещь, которую я хотел сказать.

Понятно, если мы вызовем функцию Vector2D242 со стрингами, что-нибудь вызовем, один будет VectorInt, на выходе другой будет VectorString, это будут разные типы. Ну, понятно. И мы их никак не просоцировать не сможем. То есть нет какого-то общего типа у них вектор. Это скорее как плюсах.

Это совершенно разные классы, разные типы. Так, окей, значит, maybe, значит, очень полезный тип. А можно еще по параметрам такой вопрос? Мы можем как-нибудь из вот типа вектора, который у нас здесь, который параметризованный, можем ли мы из него сделать его непараметризованный аналог для какого-то конкретного типа? Взять и вычли из него вектор от Int? Ну, ты можешь написать TypeAlias, IntVector, TypeIntVector равно VectorInt. То есть можешь. Да, все можно.

То есть можно сделать TypeAlias, можно сделать NewType, NewType будет дальше. Мы как бы разберем это тоже. Окей, давайте дальше. Все можно, сейчас увидим. Думаю, что вопросы сами эти отпадут.

В общем, давайте разберем maybe. Maybe, значит, похожая штука, только мы, похожая штука, что из IntResult, только у нас здесь как бы более общий тип. То есть у нас можно вспомнить, что это некоторые вычисления, то есть некоторые результаты вычисления, которые имеют тип A, и у него она может свейлиться, то есть может вернуть просто nothing. То есть, по сути, это optional. Optional в плюсах.

Не помню, наверное, в Java тоже есть что-то похожее. В общем, да, это некий подход, чтобы моделировать нул-пойнтеры, то есть либо pointer, либо null. С помощью этого можно писать некоторые такие безопасные функции, типа maybe second, то есть взять второй элемент массива, но если как бы не получилось его взять, то nothing. Безопасные в том смысле, что мы можем легко проверить результат работы. У нас нет какого-то ошибки, которые мы не можем поймать.

В общем, исключение. Плюс maybe, забегая вперед, это monad, очень полезная. То есть мы можем использовать ее для вычислений, композировать вычисления, которые нам дают, могут вернуть ошибку или нет. Это все будет в следующей лекции. В общем, можно представить, что maybe это некий такой бокс, некая коробка, в которой либо есть что-то, либо нет.

То есть это значение и некоторый контекст, который еще называют эффект. Пока это, наверное, просто слова. Дальше будет все более понятна аналогия. А можно вопрос по поводу в коде предпоследней строчкой, тут maybe second, и дальше аргумент в скобках. Можно это расшифровать? Да, это происходит pattern matching по листу.

Значит, у листа есть конструктор, он принимает два аргумента. Он принимает элемент и список, то есть хвост, head и хвост. Ну и, понятно, возвращается список. То есть мы сматчились. По сути, что тут происходит? Первый underscore значит первый элемент, x значит второй элемент, а второй placeholder значит остальной список.

То есть мы вызвали просто just от второго элемента списка? Да. Спасибо. То есть что мы сделали? Мы взяли x, передали в конструктор, и нам вернулся maybe. То есть мы завернули наше значение в эту коробку maybe и вернули пользователю. А он же там сам будет проверять, есть что-то в коробке или нет.

Так, ну давайте дальше. Azure – другой способ обрабатывать ошибки, когда мы хотим знать какое-то еще сообщение. Ну или тег какой-то нашей ошибки, строковый, не строковый. В общем, left значит, что все, капут, у нас вычисление исправилось, right значит, что нормально вычислилось. И вот, например, azure second.

Опять делаем matching, проверяем, какие у нас могут быть ошибки, разбираем случаи и возвращаем right x, если все хорошо. Да, ну и такой маленький совет, что надо смотреть за порядком матчинга. Потому что в прошлой лекции, вы знаете, что нужно в правильном порядке заставлять потом матчинг, потому что он идет сверху вниз, всегда проверяется. Ну и вот ссылочка на какое-то обсуждение, у нас такое info про ошибку в функциональном программировании. Интересная тема, много вариантов есть.

С вами проблемами. Давайте дальше. Рекурсивность. Ну, понятно. Дошли наконец-то до листа.

Типы могут быть рекурсивны. То есть мы можем использовать в параметре сам тип, который мы сейчас определяем, тем самым получая рекурсивные типы. В общем, у нас есть два конструктора, nil и cons. nil – это просто пустой список, cons – это head, хвост. И мы возвращаем уже наш тип.

Понятно, вот список из 2, 1, 3. Можно писать свой мэп. Вот, пожалуйста. Ну да. Отличие от реального листа только в том, что у нас конструктор у листа – это оператор.

То есть мы не пишем cons, мы просто используем оператор в двоеточии. Ну и плюс там еще какой-то синтаксический сахар сверху всего этого. Вот. Да. Ну да, собственно, вот определение, как оно могло бы быть в основном в библиотеке.

Ну да, и у нас еще есть специальный синтез для типа, потому что у нас имени для листа нет. У нас квадратные скобки для этого используются, для краткости. Не уверен, кстати, что это можно самому определить. Мне кажется, это вшито скорее в язык, но, в общем, потому что здесь используется. Хорошо.

Извините, а можете, пожалуйста, объяснить, что происходит в myList, когда myList равно cons 2, cons 1, cons 3. Да, давайте, смотрите. Ну еще раз. Мы читаем эту запись, читаем ее по порядку, как мы вычисляем лямбдовыражение. То есть в самом начале вычисляется, грубо говоря, внутреннее.

Мы парсим это. Что тут происходит? Функция cons, сам внутри. Ей передается два параметра, 3 и nil. То есть смотрим, совпадает это ли с сигнатурой. Да, совпадает.

То есть мы передаем 3 и nil. И в итоге эта скобка имеет тип list. Дальше следующий конс принимает 1. И вот эту скобку, которую мы поняли, что тоже возвращает list int. То есть опять мы возвращаем.

Опять внешняя скобка, вот этот тоже list. Мы конструируем наш список. Получается будет длиной 3. Да, да. То есть мы сделали просто...

Это тип или что это? Это переменная. Это не функция, я так понимаю. Константы. Константы, да. Это философский вопрос.

Все функции. Сори, я до этого читал курс по теории типов, поэтому у меня немножко сдвиг. Константы и функции большой разницы не имеют. Функция, которая понимает ноль аргументов, это константы. Ну да, это константы.

Не переменные, потому что у нас все немутабельное пока что. Потом будут переменные. Сразу видно, как они выглядят. Ну, в общем, да. То есть еще раз.

Давайте такая интуиция. Что такое конструктор? Конструктор это функция. В целом обычная функция. У нее есть сигнатура, которая принимает элемент, принимает хвост списка и возвращает список, прибавляя к нему вот этот один элемент. Но при этом она еще и является представлением типа.

То есть, грубо говоря, посмотрев на то, как мы определили этот список из трех элементов, мы можем понять, как оно и в памяти представляется. Оно точно так же представляется. То есть у нас есть тег конструктора, его параметры. И второй параметр это тоже лист, у которого тег конс и два параметра и так далее. То есть у нас такая как бы древовидная структура.

В общем, если вы напишите это на вариантах, в плюсах, будет так же выглядеть. В нормальной ситуации мы здесь не увидим скобок, а тут будут доллары. Что? Ну, где вот моя лист равна конус 2, конус 1. Сейчас, не понял. По какую строчку вы говорите? Моя лист равна конус 2, конус 1.

Там будут вместо скобок деньги. Ну, да. Можно продать скобки, получить деньги. Можно написать везде доллары без проблем. Потому что конструкторы нормальной функции, они так же композируются без проблем.

А вот где мы определяем... Я правильно понимаю, что вот этот тип представляет просто нам список? Да, это просто список. А вот где мы определяем... Ну, допустим, мы написали конус 1, конус 3. И почему оно переводится в список? То есть мы же потом обращаемся в MyMap как к первому элементу и хвосту.

Но, допустим, не особо видно. То есть у нас есть у списка конструктор с двоеточием. Но когда мы делаем... Мы просто определили тут какой-то конструктор с именем конус, и не определили, как он работает, или я что-то не понял? Вот, окей, смотри, я понял вопрос. Мы нигде не определяем, как работает конструктор.

В этом смысле разница между конструкторами в плюсах и конструкторами в функциональных языках в algebraических типах данных. Конструктор представляет собой просто структуру, структуру типа. Он никак не работает. Он как бы... Ну, не знаю, если я скажу...

Я понял, о чем вы. Датакласс, ты понимаешь, о чем я говорю? Да, я понимаю, о чем вы. Я тогда не понимаю просто, почему мы там можем обращаться как к голове и хвосту. Как он определяет, что есть голова, что есть хвост? По параметрам. Ты матчишься типа на...

То есть еще раз, вот MyMap как работает. Мы делаем паттерн-матчинг по листу. Это либо nil, либо cons. Это switch-кейс такой. Мы делаем кейс.

Мы видим, что если nil, вернем nil. Если cons, то мы матчимся на параметрах, и мы знаем, что есть x, а есть xs. Значит, x это первый параметр, он имеет тип a, и xs это второй параметр, он имеет тип лист a. Вот мы сматчились на... Я все понял, да, спасибо.

То есть это такие как бы дата-классы. В питоне есть... В общем, это класс, который представлен... Его определение класса, это то, какая у него структура. То есть в плюсах, как ты пишешь конструкцию, ты можешь написать какое-то сложное определение, как конструировать твой тип, сделать какие-то вычисления перед этим, еще что-то.

Здесь это все не нужно. Здесь ты сначала пишешь, как у тебя представляется тип, а дальше ты можешь просто рядом написать функцию, какую-то умную, которая конструирует этот тип, используя меньшее количество данных, например, что-то вычисляя или еще что-то. Она просто рядом, сбоку. Да, я все понял, спасибо. Дата от TypeAlias отличается только конструктором? Она много чем отличается.

TypeAlias это просто синтоксический сакр, грубо говоря. Грубо говоря, это макрос такой. Везде, где мы пишем имя alias, мы можем подставить его определение. Ну, по сути, перед определением просто напишешь имя конструктора и получишь TypeAlias. Ну, и как там дата? Нет, это разные вещи, потому что, когда мы пишем дата, мы определяем новый тип.

Мы не можем заменить его на какое-то определение, то есть мы определяем новый тип. Принципиальная разница, мы определяем новый тип или мы создаем просто синоним. Синоним это не новый тип. Он совпадает совершенно с его определением. Ну, типа, в плюсах есть, опять, понятные плюсы.

Типа, using это алиас. Класс это новый тип. Это разные вещи. Мы дальше увидим что-то между ними, какую-то конструкцию. Думаю, что будет понятнее.

Хорошо, значит, по героическому типу данных есть еще вопросы? У нас лекция не сложная. Я думаю, что есть вопросы. Ок, давайте дальше. Значит, как это называется по-русски? Записи. Нанозаписи.

В общем, я буду говорить с рекорды. Значит, у нас есть возможность определить рекорды. Это, по сути, такие кюплы с именованными полями. В общем, да. Можно представить, как такой синтактический сахар, просто с такими гетерами, которые написаны на правом слайде.

То есть, понятно. Опять же, логин, пасвод это просто функции, которые определяются вместе с типом. Есть специальный синтаксис для определения. Понятно. В общем, хотим спросить, чему равен какое-то поле.

Взяли сначала у юзера, примели функцию логин к рекорду юзера, получили строчку, сравнили с Иваном. Если Иван, то вернули трубку. Собственно, да, хоть понятно. Значит, паттерн-матчинг. Мы можем делать паттерн-матчинг на рекордах очень удобно.

То есть, если мы хотим сматчить только какой-то один элемент, можем сделать такой синтаксис фигурной скобки логин равный юзернейм, где логин, первое, это имя поля, юзернейм это переменная, которую мы хотим забиндить, привязать к этому значению. То есть, опять, какую проблему мы здесь решаем? Если у нас, допустим, есть юзер, как в самом начале нашей лекции, возвращаясь к ней, у нас есть два стринга. Есть логин и что-то еще, пасворд. Чтобы их не перепутать, они оба стринг, мы их именуем, и теперь мы должны все представить, что юзернейм это именно логин и пасворд. Можем делать паттерн-матчинг такой вот.

В любом паттерн-матчинге мы можем записать вместо переменной, которую мы хотим забиндить значение, можем писать само значение, тогда будет поверх то, что это равно имя. В общем, очень удобно. Есть такой специальный синтаксис update-синтакс. В смысле, мы хотим взять Ivan, взять запись и поменять только одно поле, а все остальные оставить на своем месте. Это, кажется, называется как-то функциональное обновление, что ли, в оперативном мире.

В общем, да, у нас все иммутабельное, поэтому мы вынуждены скопировать весь объект, но поменять только одно поле. Чтобы не писать слишком много, есть такой удобный синтаксис. Там прям все копируются, да? Ну как, по сути, да. Но как это представляется, вопрос. Скорее всего, копируется...

В общем, если не лезть глубоко, какие-то вещи могут просто скопироваться как ссылки, грубо говоря. Но копируется все, да. В общем, операторы... Да, собственно, полем могут быть операторы тоже. Честно говоря, я никогда не видел это, чтобы оно так использовалось.

Но, в общем, может быть, это удобно. В общем, да. Понятно, операторы — это просто функции. И, в общем, тут получается, у нас мы сделали такой тип данных R, у которого есть оператор, который делает что-то с n, например, прибавляет 1. Это будет конкретный какой-то...

По сути, один объект типа R — это какой-то оператор, который что-то делает. И дальше мы можем через стрелочку его применить к числу. То есть можно с помощью этого какой-то прикольный синдекс создавать. В общем, enjoy. Понятно.

Мы можем использовать вместе суммы типов и записи. Например, person — это может быть админ или юзер. У них одинаковые поля, но не совсем одинаковые поля. Но даже если они были одинаковые, мы их можем всегда различить. Есть такой нюанс, что, допустим, у нас есть теперь функция login.

Что же она делает? Она принимает person и возвращает поле юзера или админа. Но если мы вызовем UID, то для админа она не определена, потому что у нее просто нет такого поля. То есть эта функция не полная. Она может упасть, что может быть потенциально опасно. То есть лучше бы написать какой-нибудь типа maybe UID или что-то такое.

В общем, можно все безопаснее сделать. По дефолту оно, к сожалению, вот так. Да, собственно, можно писать функцию проверки, что это админ. Тут такой синдекс тоже. Если нам неважно, какие поля находятся, мы можем проверить, это юзер или админ, пишутся пустые фигурные скобки.

Это важно. По-моему, нельзя просто написать фигурные скобки. В смысле, опустить фигурные скобки и просто написать админ. Но это не точно. В общем, можно написать админ и подчеркивать.

А не одно подчеркивание? Одно, по-моему, нельзя, да? Два надо написать. Да, тут есть такой прикол, что в целом у нас все еще есть функция админ, которая принимает int и string и возвращает нам person. То есть мы можем использовать как рекорд синдекс, так и просто обычные конструкторы. Потому что, как мы поняли, рекорд это тоже синдексический саппорт, по сути. Окей.

Есть некоторые проблемы с этим. То, что, допустим, у нас есть два типа данных, у которых одинаковые имена, одинаковые имена полей. Что такое функция name здесь? Она не может принимать совершенно любой тип. Это другая ситуация по сравнению с логином, который здесь был. Потому что тут можно нормально выписать сигнатуру функции логина, а тут уже нельзя.

То есть это либо main, либо cat. Непонятно. И, в общем, одно из решений не использовать одинаковые поля, что может быть как бы... В целом это возможно, и я думаю, что на практике тоже многие так делают. То есть дальше мы посмотрим, какие Haskell предоставляет возможности для сокрытия какой-то реализации через модули.

То есть не все совсем плохо. Также есть расширение, которое пытается убрать такое неудобство. Мы добавляем это расширение, пишем language duplicated record fields, и после этого у нас создается некий статистический сакр, который при компиляции делает эти неймы, эти функции разными. И пытается из контекста понять, какая из них используется заменить. И, например, у нас есть какая-то функция, которая принимает main и использует функцию name к нему, но тут проблема есть некая, что нам приходится указывать явно тип функции, потому что иначе он не может догадаться...

Далеко не во всех случаях он может догадаться, какая функция name используется. В общем, есть нюансы с этим. Но да, для паттерн-матчинга это спокойно работает. То есть для некоторых случаев это работает всегда, например, для паттерн-матчинга, а для применения функции приходится выписывать тип. Ну, в общем, некоторые трейдовы опять.

Когда-то удобно одно, когда-то другое. Значит, давайте дальше. Да, вот тут есть ссылочка, кстати, обратите внимание, про inference. Собственно, как это примерно работает. Вот это расширение.

Так, record wildcard, значит, тоже удобная штука. Допустим, у нас есть юзер, у него есть опять вот эти поля, и мы хотим сматчиться... Да, смотрите, тут суть в том, что мы не хотим выписывать все поля совершенно. То есть мы хотим на них сматчиться, но просто на те имена, которые у них есть. То есть мы просто пишем в синдексе с UID 0, 1, 2 точки, и дальше мы можем использовать как UID, так и логин, и пасворд.

Если мы не хотим матчиться на поля или их как-то переименовывать, мы просто пишем 2, 2 точки и используем их. Понятно, еще один синтезический сахар. И для этого нужно подключить расширение record wildcard. Да, и это даже работает с duplicate fields, что реально выглядит немножко как магия. Окей, ну, собственно, мы переприсвоили name из man.

Окей, new type. Очень интересная штука. В общем, у нас есть 2 синтаксиса, data message и new type, имя типа. Сразу скажу, что у Haskell очень странное название типов. Есть data, которое можно как-то еще просоцировать с датаклассом, а new type это новый тип, но как бы data это тоже новый тип.

В общем, не обращайте внимания на название, скорее запоминайте, в чем суть. То есть если data это какой-то общий тип, то new type это некоторый его частный случай, когда у типа всего один конструктор и, возможно, одно поле. То есть оно может быть именованное, может быть нет. В общем, в чем прикол? Прикол в том, что если у нас всего один конструктор, мы можем как бы избавиться вообще от тега. То есть когда мы делаем паттерн-матч, у нас всего один вариант.

По сути, паттерн-матч можно вообще убрать. И на самом деле Haskell поступает намного умнее, он вообще не делает между ними различий в рантайме. То есть после компиляции у нас нет различия между месседжем и стрингом. То есть мы используем, как бы, мы вводим новый тип, месседж. Он отличается от всех остальных.

И в compile-time он будет проводиться проверки, в отличие от type-alias. Но в рантайме это будет одно и то же. То есть мы получаем больше гарантии, не платя за это реформенсом. Собственно, давайте посмотрим на примере. Значит, да, тут такой предысторий к примеру, что у нас есть какая-то функция derivePublicKey.

Она как бы из публичного ключа дает секретный ключ. Есть функция, которая проверяет пару, что она корректная. И, в общем, у нас publicKey и secretKey это один и тот же тип. То есть, грубо говоря, легко их перепутать, и последствия будут страшные. То есть мы используем типы, но они нам не особо помогают.

Как сделать так, чтобы они помогали? Давайте просто скажем, что publicKey и secretKey — это разные типы. И после этого мы никогда не сможем их перепутать. То есть как мы не можем перепутать int и bool, точно так же мы не можем перепутать эти два типа. И теперь у нас derivePublicKey имеет осмысленную сигнатуру. То есть это не просто из string в string, так же как функция inside.

А это конкретный тип из secretKey в publicKey. И на самом деле это один из способов прототипирования в Haskell. То есть ты сначала думаешь о типах, пишешь только типы, а потом уже пишешь для них реализацию. Причем не реализуя все в правильном порядке. Да, ну и, собственно, функция checkKeyPair тоже выглядит теперь более осмысленно.

И мем, что если код не компилируется, он не может работать неправильно. Прекрасно. Так, какие вопросы по newType? Есть? Окей. Меня же слышно еще? Да, хорошо слышно, все прекрасно. Хорошо, идем дальше.

Type классы. Самое, наверное, интересное в этой лекции, на мой вкус. В общем, ad-hoc полиморфизм. Что значит ad-hoc? В общем, это значит, что мы используем то, что мы сейчас хотим использовать, то и используем. Грубо говоря, мы из контекста использования понимаем, что нам нужно.

Например, overloading в плюсах — это тоже ad-hoc, типа полиморфизм. Мы пишем функцию плюс, и независимо от того, что мы... Мы не указываем, какой конкретный плюс мы используем, оно просто выводится из контекста. Если рядом стоят строки, мы складываем строки — это одна реализация. Если мы складываем числи — это другая реализация.

И, собственно, мы посмотрим, как такие же штуки делать в Haskell. Значит, у нас есть type классы, это называется. Мы, значит, классы типов. Мы объявляем это с помощью следующего синтеза — класс printable P. Это интерфейс.

То есть мы говорим, что у нас есть некоторый интерфейс, которому некоторые типы могут удовлетворять или нет. То есть какие-то типы могут входить в этот класс или нет. Значит, этот интерфейс обязует реализовать следующие функции. printme, который принимает, собственно, тип P. P — это, собственно, тот класс, который будет реализовывать.

Это тот тип, который будет реализовывать этот класс. И, собственно, простыми словами, это класс объектов, который мы можем распечатать. Распечатать куда-то в конце, в строчку, в общем. И, допустим, у нас есть некоторый класс просто enum из foo и bar. И, значит, да, то есть тут давайте это немножко опустим.

Значит, дальше мы можем написать, значит, instance. То есть объявить то, что наш тип foo удовлетворяет этому интерфейсу. То есть его можно распечатать. Для этого нужно реализовать функцию printme. Вот так это работает.

Значит, понятно, у нас есть тут кейворды. Класс — это определение класса. Инстанс — это определение инстанса. Определение того, что мы... Определение имплементации.

Инстанс — это имплементация. Класс — это интерфейс. Вот. И теперь, допустим, мы хотим использовать этот type class, чтобы написать некую полиморфную функцию, собственно, которая использует этот полиморфизм. Как? Мы пишем, допустим, helloP.

Это некая функция, которая принимает объект и печатает его в консоль, добавляя там hello. И мы хотим потребовать, что обязательно P, которое мы хотим распечатать, должно удовлетворять интерфейсу printableP. То есть, говоря на других языках, это значит, что мы проверяем из instance of P printable. То есть, если P удовлетворяет этому интерфейсу, то тогда у нас type checking проходит. Иначе он не проходит.

То есть, огромный плюс всего этого, что все эти проверки происходят в compile-time, а не в run-time. Да, собственно, так это можно выглядеть. Ошибки, если мы передадим true, для которого мы не реализовали наш интерфейс, то нам скажут, что sorry, не могу найти instance. То есть, не могу найти реализацию этого дела. В общем, давайте посмотрим какие-то базовые примеры всего этого.

Допустим, type class equal. То есть, это интерфейс объектов, которые можно сравнивать на равно. Ну и соответственно, если есть равно, есть и не равно. И дальше мы видим один пример такого классного аспекта в Haskell. То, что можно писать интерфейсы с дефолтными реализациями.

Здесь мы объявили сначала типы. Не обязательно делать это прям так, можно это писать рядом. То есть, тип, потом ниже реализация, как это обычно пишут на топ-левеле. Но смотрите, в чем тут соль. То, что у нас есть дефолтная реализация для обоих методов.

И она взаимно рекурсивная. То есть, мы равно можем реализовать через неровно, неровно можем реализовать через равно. И плюс этого, что мы даем выбор пользователю, точнее, пользователю нашего интерфейса, кто будет реализовывать его. Если мы реализуем только равно, то мы получим сразу оба метода. То есть, по сути, у нас просто дефолтная реализация перекроется реализацией, которая в инстанте написана.

Или, допустим, для какого-то типа сложно написать равно, удобнее написать неровно. Немножко игрушечный пример, но все же. В общем, он может реализовать только функцию неровно, и у него будет автоматом функция равно. И дальше есть специальная директива, которая добавляет... Собственно, все это проверяется.

То есть, комператор должен удостовериться, что ты реализовал все нужные функции. Но тут такая проблема, что может быть так, что у тебя функции реализованы, но взаимно рекурсивно. Чтобы такого не было, есть специальная директива, которая указывает, какие наборы операторов ты должен реализовать. Какие из них является полными, а какие нет. Ну и также, если мы хотим как-то оптимизировать оба оператора, мы можем это сделать без проблем.

Да, но, кажется, чтобы писать вот эти типы, явно выписывать типы для операторов, нужно instance.sig расширение. Это нужно, чтобы в реализации выписывать тип. Чтобы явно написать тип в реализации, нужно вот этот instance. В общем, можно просто всегда использовать, и все. Смотрим теперь, допустим, здесь TrafficLight.

Мы реализуем для него интерфейс ик таким естественным образом. Матчимся на всех парах, которые равны. Все остальные пары false. Все понятно. Теперь у нас есть instance TrafficLight, и мы можем сравнивать.

Ниже еще один пример, как написать полиморфную функцию, которая, допустим, берет три объекта, которые можно сравнивать, и проверяет, что они все три равны. То есть пишем полиморфный код и радуемся жизни. Потому что не нужно делать какое-то копипасту. Давайте посмотрим следующий пример. Ордеринг, когда мы хотим проверить на равенство.

Когда мы проверили на равенство, теперь мы хотим проверить на неравенство. В общем, понятно, что если мы проверяем на неравенство, то для этого нужно, чтобы изначально интерфейс удовлетворял свойства, что у него есть равенство. Мы расширяем наш type класс, добавляем в него две функции, и с помощью этого у нас есть специальный синтезис. Опять же, eq равно больше, такая стрелочка. Эта стрелочка обозначает, что мы предоставляем требования к типу A.

Справа от стрелочки обычный тип, а слева от стрелочки constraint, то есть ограничение. И как это было для функции, мы объявляем, что тип A должен удовлетворять constraint, это ограничение, что у него должен быть instance eq. И также мы объявляем это для класса. То есть мы объявляем класс для тех типов, для которых уже есть eq. Ну и понятно, дальше мы можем в дефолтной реализации использовать те методы, которые мы потребовали, что существуют у этих типов.

Ну и тут видно, зачем нужна вот эта дефолтная реализация. То есть можно реализовать compare, как это, 3-way comparing, типа spaceship оператор в плюсах. В общем, одну функцию достаточно реализовать и автоматно получить все остальные операторы, которые несложно выражаются через него. В общем, да, вот такая штука. Да, ну и опять же какие-то ссылочки для монетного чтения.

Ну, значит, числа в Haskell тоже полиморфные. То есть если мы пишем семерка, это просто, на самом деле, как бы семерка некоторого типа num. То есть она может быть и флотовая, так и целочисленная. И, значит, давайте посмотрим, вот прям так выглядит базовый тип num. У него есть плюс, минус, умножить.

Прошу прощения, а minimal.complete. definition в Word надо было написать или нет? Нет, смотрите, у нас есть compare и... Ща. Хороший вопрос, кстати, сейчас. У нас получается как? У нас compare реализован через меньше либо равно.

И равно, да? То есть мы можем реализовать либо compare, либо меньше, либо равно. Ну, учитывая, что у нас есть равно уже. Наверное, можно написать типа compare или меньше, либо равно. Возможно, тут просто опущены для краткости. А может быть, какие-то вещи компилятор сам умеет выводить.

Может быть, я не знаю, за последнее время. Может выводить больше или меньше, в общем. Поэтому это немножко на расширениях все еще остается, потому что не совсем стабильная штука. То есть что-то может компилятор вывести, а что-то нет. А раз уж вернулись, можете, пожалуйста, еще раз повторить.

Где у нас написано class ик а стрелочка орт а. Еще раз, что это значит? Это означает, что мы определяем интерфейс орт для типа а и требуем, чтобы для него уже был реализован интерфейс ик. То есть, когда мы будем определять instance орт, мы перед этим обязаны объявить instance ик. Все, понял, спасибо. Мы расширяем интерфейс, грубо говоря.

То есть это некоторый такой способ расширения интерфейса, который у нас уже есть. Так, раз уж мы остановились, время . Мы начали в .. Сколько? Пошло почти полтора часа. Хотите ли вы сделать перерыв? Ну, по идее, минут , если как-то вместится.

В целом мы больше половины рассмотрели, мне кажется. Поэтому можно сделать перерыв. Вот. Ну, давайте, сколько? , 5 минут. Давайте .

, ок. ., тогда возвращаемся. Можете какие-то вопросы задать, если есть. Да, вопрос был в слайде .1. .1...

Вот этот? Да, что за оператор такой, стрелочка с двумя адефисами, и не будет ли это считаться комментарием? Потому что он у вас выделил, ну, подчеркнулся. Да-да-да. Я, честно говоря, не уверен. У меня в репле тоже не получилось, я не особо встал. Ну, да, то есть как бы это такое себе...

Ну... Может, это пример неудачный. Может, так можно сделать. И на -ом слайде там еще hype-классы, а не type-классы. Я не знаю, может, это intended? Возможно, это intended.

Короче, я не знаю. Ну, не знаю, поменяй на Unicode стрелочку, типа. Ну, грубо говоря, типа... Сейчас, а три тоже нельзя, да? Три адефиса. Ну...

Блин, сейчас. Может, надо в хугле просто забить, есть там такие операторы или нет. Есть, слушай. Есть такие операторы. Значит, как-то можно.

Может, это проблемы чисто репла? Наверняка, спасибо. А можно вот еще раз объяснить, что значит фигурные скобочки? Это, получается, мы объявляем функции в них? Что мы делаем? Фигурные скобки — это синтексис рекордов, синтексис записей. Ну вот. А запись — это сокращение от того, что мы делали до этого? Или как бы. ..

Запись — это такое понятие, как бы это тюпл с помеченными полями. То есть мы, грубо говоря, дали имя... Аргументам компьютера, грубо говоря. Да. Это такие геттеры.

А? Ну, учитывая то, что все это, по сути, функции, это вот такие геттеры. Ну да, вот по сути, вот слайд, собственно, который на экране, мы просто, ну, как бы статистически сахар. Типа мы... дали имена, значит, полям. То же самое, что просто объявить геттеры.

Вроде бы очень тихо, но может быть это только у меня. Нет, у меня тоже. Можно вопрос? Вопрос по поводу -теряжного слайда, где мы объявляли базовый пассворд. Здесь же мы, как бы, получается, что объявили в борде функцию compare, и операторы меньше, меньше, равно, больше, равно, больше. Но вот дальше мы ниже написали, что x меньше равно y, равно compare xy, не равно gt.

А можно как-то расшифровать, что здесь происходит? Ну, что происходит? Типа. .. вспоминаем порядок, как это, операторов, как называется, я не помню. Ну, типа, приоритет операции, что сначала применяется функция compare к xy, возвращается значение, типа ordering, и мы сравниваем, что оно не равно gt. Вопрос, почему это именно меньше, либо равно? Вопрос, скорее, просто в синтексисе, потому что, кажется...

В синтексисе... Так, какой вопрос в синтексисе? Ну, просто мы не должны нигде скобочки поставить, потому что мы сначала функцию вызываем, потом применяем оператор к результату. Как-то не очень понятно, как это сработает. Так это же прекрасно. Меньше скобочек, как бы, компактный код.

Ну, типа, смотри, в Haskell интересный синтексис в целом. То есть, нужно запомнить порядок операторов. То есть, есть как бы всего , по-моему, уровней. Вроде бы, да, . Ну, это нормальный порядок операции.

То есть, как в математике умножение, оно сильнее, чем сложение. Поэтому сначала мы вычисляем умножение. И тут то же самое. Самое сильное – это применение функции. Функция – это compare функция.

Значит, мы ее применяем к x и y. Дальше идет оператор. Типа, он слабее, чем применение функции. Поэтому сначала мы вычисляем его операнды. Все, я понял, я распортил.

То есть, если хочешь, можешь выделить скобочки compare и x и y. Но тебе compare расскажет, что можно убрать, если хочешь. Что из этого нам дает ику, которую мы просим от класса? Еще раз. Мы пишем класс ико а. Что он нам дает, этот ико? Допустим, мы уберем эту ико-стрелочку.

В чем получим? Сейчас, секунду. Смотри, допустим, мы уберем ико, что сломается? Он нам в моменте использования x равно y скажет, что это за функция. А остальное при этом не сломается. То есть, если мы уберем это равно-равно, у нас все сработает. Ну как, если ты уберешь равно-равно, то у тебя в целом попадет смысл этого класса, но да.

Там же еще останется lt, gt. Представь, что у тебя элементы можно сравнивать на меньше, но нельзя сравнивать на равно. Это как? Я не понимаю, как такое может быть. Ну это когда не меньше и не больше. Да, можно же выразить равно-через меньше-больше.

Ну можно, да. Это правда. То есть, можно написать какой-то другой класс, орд, который не требует этого constraint, который не требует равно-равно. Это вопрос дизайна, наверное. Я думаю, что есть какие-то математические вариации, когда другая иерархия классов строится, но тут вот так, в стандартной библиотеке.

В целом, довольно разумно. Но существует такой вопрос, что если мы используем равно-равно, то мы должны в сигнатуре функции или класса указать, что мы требуем выполнения этого constraint, что действительно эти элементы можно сравнить на равно. Для compare x, y, первая строчка это x равно-равно y. Понятно, мы ее просим у ICO. А вторая, x меньше-равно y, она откуда берется? А это мы вызываем recursive на функцию, которую в этом же классе определяем.

Так, а у нас очередь происходит через compare. Да, это взаимная рекурсия опять. То есть до этого класса нам нужно где-то instance написать, и в этом instance что должно быть? После этого класса мы напишем instance, и там минимально мы должны определить либо compare, либо меньше-равно. Ага, класс, супер. И еще должен быть ICO, который бы определил нам равно-равно.

Да, он просто должен быть виден в этом месте. Там не надо указывать. Так, но если все равно нужно определять меньше-равно, то ICO ни через что не выражается в определении, то, в принципе, он нам не особо нужен здесь. Сейчас, не понял. Ну вот, кроме строчки, где x равно-равно y равно ICO, он нигде ни через что не выражается.

Ну да. Тогда, по сути, можно убрать ICO, вообще не просить больше. И, например, внизу добавить x равно-равно y, а compare x, y не равно gt и lt. Да, так можно. Но, по сути, ты что сделаешь тем самым? Ты просто одну из функций ICO перенесешь в ORD.

Ну да, зато нам теперь не нужно будет требовать от A, чтобы был реализован ICO. Окей, согласен. Но выиграли ли мы от этого что-нибудь? То есть сейчас мы хотим, чтобы у нас до этого был какой-то instance, который реализует меньше либо равно знак, и плюс еще ICO. А так нам на одно требование меньше. Это просто интерфейс ICO понадобится кому-то другому, кто хочет именно ICO, а не ORD.

И ты его не будешь реализовывать, и будет грустно в такой ситуации. То есть, да, вопрос. Во-первых, декомпозиция — это хорошо. Во-вторых, допустим, у тебя есть тип, у которого ты требуешь ORD. Для него количество constraint не изменилось.

Ему как нужно было определить равно-равно, так и остается. Ничего не меняется. Убрав constraint у класса, по сути оставив все равно то, что нужно определить равенство, ничего не меняется. То есть, смотри, ты не упрощаешь constraint какой-то функции, ты упрощаешь constraint класса. Constraint всех функций остаются такие же.

Может, я запутал? Нет? Понятно? Так, значит, давайте вернемся. Сейчас, а можно еще один небольшой вопрос здесь? Мы там внизу, вот, compareXY не равно GT, так легко используем, а мы же нигде не писали реализацию equal для ordering. Она автоматически где-то згенерировалась или ее надо тоже писать? Да, хорошее замечание, его тут нет. Его нужно, ну, надо либо его определить, instance, либо задеравить. То есть, deriving значит, что он автоматически может быть сгенерен.

Инстанцы могут автоматически генериться, мы тоже сейчас увидим. Не всегда нужно все это определять руками. Спасибо. В этом смысле Haskell прекрасен в том, что он, как сказать, мотивирует тебя создавать новые типы. То есть, на любой чих новый тип, без проблем вообще.

Мы хотим сделать новый тип, я не знаю, для security. Без проблем, создавай. Равенство для этого нужно переопределять. Равенство, типа, орд, еще что-то. Все это можно сгенерить.

То есть, это как бы прекрасно. Да, еще я хотел, это один момент, а второй момент, который я хотел сказать, в целом, чтобы было понимание общее, почему вообще вот то, что я сейчас рассказываю, важно. Даже если вы не будете писать на Haskell, вообще сама концепция тип-классов, она очень интересная. Потому что, во-первых, она теоретически интересная, то есть, там можно посчитать статью, она будет либо где-то в конце слайдов, либо я так могу скинуть про тип-классы. То есть, она с точки зрения теории типов интересная.

Плюс еще тип-классы, например, есть язык Rust. У него тоже такая же система тип-классов. Ну, она не такая же, она похожая, но они как бы вдохновлялись тем же самым. Там это называется Type Traces. Плюсы, по-моему, тоже в какую-то эту же сторону двигаются.

Если раньше там было вот эти enable-if-t или что-то такое, то есть, это компиляторная магия, то в целом, по-моему, они двигаются в сторону концептов, которые, если я не ошибаюсь, они тоже... Суть в том, что ты декларативно указываешь какие-то constraints на классы, на реализацию. В общем, идея очень классная, прикольная. И при этом в Haskell она реализована. Это, наверное, одна из лучших реализаций тип-классов, потому что они довольно мощные в Haskell.

То есть, мы там дальше увидим, они могут быть и параметрические, и, в смысле, полиморфные, и можно писать инстансы полиморфные, и, в общем, там есть какие-то функциональные зависимости. В общем, куча разных фич. Я даже видел какой-то чувак, типа, зависимые типы кодировал с помощью этих тип-классов. Там можно вараги делать, вараг-функцию с помощью тип-класса. В общем, прикольная штука.

Вот. Собственно, давайте дальше ее взбирать. А как работает тип, который внизу написан? Который от Summa, от Moe University и Sirocco. Хорошая шутка. Или нет, подожди.

Ты шутишь или, типа, я реально вопрос? Ну, вообще шучу. Окей, все. Ну, на всякий случай, типа. Мало ли. Может, у нас такой уровень понимания не терялось сейчас, я не знаю.

Вы говорите, мне тоже сложно понимать, что понятно, что нет. Вот. Да, тип. В общем, давайте дальше. Ну, мы смотрели уже.

У нас есть класс, есть у него куча всяких методов. Типа, плюс, негейт, апс, ну и так далее. Вот. Интересный у него метод, наверное, fromInteger. То есть это, типа, из любого интеджера можно сконвертировать в...

То есть... Как из интеджера, типа, можно сделать int, можно сделать double и так далее. То есть... Это полезно для как раз вот этих вот литералов, которые полиморфные. То есть когда мы пишем, если мы в Haskell напишем...

Спросим у GHCI, типа, тип. Спросим тип. В чиселке у нас будет 0p. То есть это, на самом деле, синтаксический сахар для fromInteger 5. FromInteger 5.

Значит, и... В зависимости от того, в каком контексте будет использоваться это выражение, там уже будет вывозиться, типа, это double, int. В общем, очень удобно. Да. Ну и мы видим, что у нас, типа, у нас тут...

Вот тут класс, типа, тоже не сильно дробится. То есть его, наверное, можно было разбить, типа, вот это вот на кольцо, на что-то еще. В общем, можно было так сделать. В стандартной библиотеке вот такое принято решение. Ну, это вот набор вот таких классов.

Значит, дальше у нас есть type класс, height класс show. Ну, это, типа, printable, который у нас до этого был. Так он называется в стандартной библиотеке, он называется show. Значит, он должен быть... Он всегда используется в JSCI.

Всегда мы пишем... Когда мы пишем, типа, 5, он показывает это с помощью show. Значит... Ну, вот. Да.

В общем, как-то так. Ну да. Есть разные num типы, которые творятся в интерфейсе num. Это int, double, rational. У них там тоже есть какая-то иерархия.

Есть fractional, который, по-моему, включает в себя num. Вот. Ну, это можете в стандартной библиотеке там... В этом... В кугле поискать.

Вот. В общем, да. Read. Тоже важный тип. Потому что...

Важный type класс, потому что он на самом деле... Нужен для парсинга. Да. Вот. Короче...

Понятно. Чтение... Чтение строки. Ну, понятно, что это не полная функция. Да, и тут есть такой момент, что...

Когда мы пишем read, мы не можем... Из строчки понять, что нам нужно... Какую функцию вызывать. Допустим, double или int. Непонятно.

То есть для этого нужно явно указывать тип, который возвращаем, и мы хотим. Потому что иначе... Есть какая-то неоднозначность. Вот. Ну, и по дефолту, возможно, это может как-то вам выстрелиться в ногу.

То, что, допустим, если мы напишем read true, там вывезется какой-то непонятный тип. Возможно, случайный. Возможно, он вывезется как-то из вашего использования. И read просто упадет. Потому что...

Вот как-то вывелось, что там должен быть такой тип, а вы думаете, что там должен быть bool. Вот. Поэтому, в общем, в таких случаях лучше всегда указывать, что вы ожидаете типом. Вот. Но это прекрасно, что не нужно называть функцию по-разному как-то.

Типа read bool, read true. Это все одна и та же функция. Она полиморфная. И если из контекста реально понятно, если вы сразу после read композируете из какой-то функции, которая принимает bool, оно вывезется, что там должен быть bool. Просто не всегда это может быть очевидно.

Да. И есть функции readMaybe, readEither, которые позволяют чекнуть, проверить, что результат правильный. Вот, собственно, пример использования. Такие вот типы у них. То есть по типу, наверное, должно быть уже понятно, что readA стрелочка значит, что мы требуем, что тип A должен быть читаемый.

И у него должна быть реализована функция read. Ну, в общем, вот все понятно должно быть. Полиморфные примеры. Допустим, вычитание. Собственно, мы требуем, чтобы был тип num у A.

После этого мы можем вычитать, использовать минус. И как бы неважно, какой это конкретный тип. Да, вот я, кстати, говорил уже про fractional. Есть fractional, который расширяет класс num, добавляет деления. Есть инстансы такие.

Если мы хотим посчитать, например, среднее, то нам нужно деление. Нам уже num не достаточно. Нужно fractional. Но давайте посмотрим, например, у нас есть функция. Какой у нас наиболее общий тип этой функции? Причем этот тип сам выведется компилятором, если вы его спросите.

Причем прелесть type-классов, что у них есть какая-то под ними теория, есть алгоритм вывода и все такое. В общем, они могут вводиться. Смотрим, у нас используется меньше оператор. Значит, мы идем туда, где он определен. Он определен в классе орд.

Значит, у нас x и y должны быть орд. Иметь тип какой-то орд а. Плюс, значит, нам нужен num. Умножить тоже num. Можем проверить себя, спросить GHCI, он скажет, орд и num должны быть.

То есть, да, если не оставлять комплиментов, они указываются просто в скобочках через запятую. На самом деле, никакой магии нет под type-классами. Это работает как? У нас нет каких-то виртуальных таблиц или чего-то такого. На самом деле, вот эти орд а и num а это можно воспринимать как неявные аргументы. То есть, функция cmp сам принимает instance, который определяет для а функцию орд, интерфейс орд, и использует их внутри своего тела, внутри, значит, определения.

А почему недостаточно только одного num? Мы и так можем число сравнивать, зачем num явно указывает, что мы еще орд требуем? Давайте посмотрим определение num. Num не требует орда. То есть, по дефолту num не может сравниваться друг с другом? Да, да, да. Это специально сделано или просто для непонятной магии? Нет, я думаю, что это специально сделано. То есть, к чему обязательно числа должны сравниваться? Какие числа буквально сравниваются? Ну, допустим, это...

Ладно, мы не говорим про комплексные числа. Нет, ну, допустим, комплексные, я не знаю. Допустим, это, я не знаю, какие-то кольца, я не знаю, в кольце у тебя есть сравнение? Ну, оно как бы есть, но там толку от него. Если все равно все операции замкнуты. Ну, там типа не выполняется какое-нибудь правило треугольника, или что-нибудь такое, я не знаю.

Ну, короче... Ну, вот так сделано, я не знаю. Мне кажется, что можно пойти в Google. Давайте сходим. Есть Num, да? Класс Num в Prelude.

Да, и вот мы видим его определение. Видно, да, что я показываю? Да, да, да, видно. Вот определение, написаны какие-то его законы, к которым должны удовлетворяться инстансы. Ну, это они неформальные, они не могут быть проверены компилятором, но их часто указывают в документации, какие свойства должны выполняться. Значит, да, вот мы видим, значит, все это определение.

Вот есть инстансы, по крайней мере, которые есть в Prelude. И вот что тут есть? bool float int. Вот строки, например, есть. Строки как сравниваются? Ну, окей, строки можно литерографически сравнивать, в целом, но можно притвориться, что есть несколько способов, как сравнивать строки, поэтому непонятно. Не обязательно, чтобы они были.

Ну, не знаю. Короче, в целом тут как раз это про то, про что говорил ваш коллега, что зачем нам требовать больше, чем нужно? Мы нигде не используем ORD. Зачем нам его требовать? Если бы мы его использовали, то да. Типа, окей. А так зачем? Так, спойлеры.

Ага, вот, мы здесь остановились. Да, я сказал про то, что, на самом деле, type classes — это просто как бы некоторые такие неявные параметры у функций. Которые компилятор может выводить и подставлять вместо нас. То есть, поэтому можно... Зачем я это говорю? Потому что дает такую некоторую интуицию, почему вот пишется вот так вот, типа там, круглые скобочки, запятая.

Потому что это, на самом деле, реально typo из instances. Вот. У нас вот этот вывод типов, ну вот из значка плюс мы, например, выводили num. А если я заведу свой type класс со значком плюс, то будет ambiguous? Да. А в цупле у нас есть порядок? В цупле есть ли порядок? В смысле? Ну, ort a и num a, и num a, ort a — это не одно и то же? А, нет, это одно и то же.

Нет, нет порядка. В смысле, да, я понял. Нет, констрейты указываются в любом порядке. Констрейты в любом, а вот если бы у нас был нормальный tuple, то там уже не в любом. Ну, типа два стринга, наверное, перепутать не очень хочется.

В смысле, у тебя же у конструктора есть первый, второй? Да, конечно. Ну, типа да, обычно у tuple есть. Нет, конечно, haskell — это странный немножко язык, когда ты первый раз на него пишешь, но не настолько. Так, а tuple у нас встречаются вообще вне контекста этих констрейнтов? В смысле? Ну, там, типа, первые слайды там были. Вот tuple.

А, так, ну вот type alias как раз. Ну, вот здесь уже порядок важен. Да. Ага, в порядках есть, прикольно. Ну, синтактически, как бы, и круглые скобочки не всегда одно и то же получаются сначала.

Ну, да. Так и почти во всех языках. Ну, блин, нет, в смысле, короче, есть tuples, да? Типа, вот внизу написано, типа, uid.login.name — это tuple выражение, да? Оно имеет тип tuple int string string. Окей. То, что я сказал про констрейнты, это как бы интуиция.

Это не обязательно, типа, так. Это тоже просто синтаксис. Ну, да, короче, порядок констрейнтов неважен. Скобочки, значит, разные, да. Например, можно выражение в скобочке взять.

Это не значит, что это tuple. Ну, понятно, что в контексте, когда там у нас в скобочках типы записаны. Да, да, да. То есть порядок как бы в типе важен, порядок в констрейнтах не важен. Да, да, все верно.

Окей. Окей. Так. Полиморфные штуки. Короче, да, это мы все посмотрели.

Что дальше? Ну, это маленькое такое отступление. То, что есть... Есть такие функции, как undefined, которые означают как бы... Ну, это типа bottom в теории типов, если кто ходил, слышал. Короче, это вычисление некоторое, которое не завершается.

В бесконечной циклице, грубо говоря. И теоретически это значит, что оно имеет false. Типа ложь. Оно совершенно любого типа. То есть если мы спросим тип undefined, у него тип A.

То есть его можно подставить совершенно вместо любого выражения в коде, чтобы как бы заткнуть любую дырку им можно. Например, у нас есть тип fu. У него какой-то сложный тип. Он принимает string. Там A, 2B, возвращает string.

Есть какие-то constraints на A и B. Но, допустим, мы пока что только прототипируем. И мы пока придумывали только тип. Мы можем просто воткнуть undefined и все. И потом это реализовать когда-нибудь потом.

То есть мы завтра это реализуем, а сегодня оно уже будет отчекаться. То есть в этом примере понятно, немножко непонятно, что такое A, что такое B, что такое fu. Но если как-то ее нормально назвать, то это очень удобно. Можно определить функцию. Я не знаю, вы пишете код.

Не обязательно все писать с начала до конца. Вы пишете код, вам нужна какая-то функция. Вы выше определили ее тип, который вам нужен. Дописываете интересную часть. Потом реализуются всякие скучные вещи.

Понятно. Я просто объясняю, наверное, что такое прототипирование. Это, я думаю, вам понятно. Есть еще функция error, которая такая же, только она еще принимает строчку. То есть она умеет кидать какое-то сообщение об ошибке.

То есть если мы попытаемся вычислить undefined, это будет exception. А если мы пытаемся вычислить error, это будет exception, но с каким-то сообщением. То есть если у нас есть в нескольких местах эти error, можем их различить. Понятно. Понятно.

Варнинг все выполнен профессионалами. В реальном коде не надо использовать. То есть код, который вы уже не прототипируете, запускаете, там оставлять error и undefined – плохая идея. Ну а если мы хотим обработать какой-то кейс, когда у нас какая-то невыполнимая ситуация, то есть какая-то ошибка, которая не должна случиться? В этом случае тут разговор про обработку ошибок. Чего мы хотим? Чего мы хотим, зависит от ситуации.

Если это ошибка, которая типа паник, error, все, мы никогда не хотим восстанавливаться после нее, да, можно, наверное, написать error и все. Но мы хотим как-то на уровне типов нам себя гарантировать, что этой ошибке не случится. Если мы хотим на уровне типов обеспечить себе, чтобы эта ошибка не случалась, то error нам никак не поможет, понятно, да? Ну, в итоге были прикольные всякие штуки по типу вывода отрицаний в функциях в этих типах. Ну и вот можно что-то там придумать, например. Вывод отрицания...

Короче, все еще мое утверждение, мне кажется, верным, что error никак не поможет. Или подождите, что ты имеешь в виду? Типа отрицание через ложь выразить? Короче, я не очень понял тебя. Ну да, можно некоторые ошибки избегать с помощью типов. Haskell в целом про это. Но тут вопрос, по какие конкретно ошибки мы говорим, не все можно избежать с помощью типов, по крайней мере, haskellных.

И это зависит от ошибки. То есть даже если мы просто заведем new type для secret и public key, мы уже избежим от этого... С помощью этого куча ошибок, правильно? У нас будет тапчекаться, что они разные, что мы никуда не передадим. Secret, там должен быть public. Ну да, ты правильно говоришь.

Но в целом... Окей, у нас есть тип еще, этот void, который data void. Так. Какое это имеет отношение к MDF? Типа абсурд. Ну, я вообще имел в виду именно функцию absurd, когда говорил про Matlab.

Абсурд. Из индреса, что ли? Которая используется... Я понял тебя. Это немножко не то. Это, короче...

Окей, void это такая штука... Сейчас. Немножко... Время у нас, наверное, есть? Можно немножко отвлечься. Короче, void...

Если мы откроем data void, то это немножко... Это тип, у которого нет конструкторов. Это не то же самое, что undefined. Undefined, как бы, это любой тип, а void это. ..

Это как бы тоже ложь. Немножко по-другому закодированная. С точки зрения теоретиков. Он буквально возвращает a, что по сути собой является undefined. Потому что тип undefined a.

Абсурд возвращает a. Ты имеешь в виду? Да, да. Да, но ты не можешь передать абсурду никакое реальное значение, потому что он не существует. Да, все верно. Знаешь, вся эта логическая суть прекрасна, но она вся ломается, когда появляется undefined.

Потому что ты можешь сломать... Ты можешь в месте, где у тебя предполагалось доказательство, подсунуть undefined. И ты уже не можешь гарантировать, что если ты что-то доказал, если у тебя все скомпилировалось, то нет никаких ошибок. Потому что, возможно, ты просто это сделал с помощью undefined. Я думаю, что void немножко для этих целей существует.

Если мы притворимся, что у нас нет undefined, то что-то можно, наверное, доказывать. Какие-то constraints на уровне типов. Это немножко другая тема. Это тема формального доказательства и теорем прулеров. Пока не про это.

Deriving. Что такое deriving? Допустим, у нас есть traffic. light, и мы не хотим для него определять все инстансы. Можем писать просто deriving, специальный кейворд deriving, и он выведет нам все инстансы. Если мы хотим, можем написать их кучу.

Янум, орд, шоу. И он все это выведет. Компилятор за нас. Нам ничего не нужно делать. Это пожалуйста.

Очень удобно. Все автоматизировано за вас. Можно сравнивать, можно проверять неравенство. Есть всякие toYanum, fromYanum. У нас есть bound, поэтому мы можем создавать list comprehensions.

Сравнение лексикографическое, или что это вообще? Сравнение работает просто по номеру. Red меньше, чем green. Red меньше, чем yellow. Янумы. Если ты определяешь какие-то янумы, обычно оно работает в плюсах каких-то.

Есть у этого некоторое неудобство. Если я хочу что-то умное, хочу, чтобы у меня орд как-то по-другому работал, но я все равно не хочу его писать руками. Тут уже все становится сложнее. Иногда приходится писать много руками. А что это i.x.

сверху? i.x. ShowRead и i.x. Это в блоке deriving на первой строчке. Все, я вижу. x это индекс.

Он является индексом, что ли. Ну, в общем, посмотри в кугле. Тут такой слайд вопрос. Что если у нас есть какой-то дататайп, который хранит функцию? Что если мы для него попросим вывести? Суть в том, что мы не можем гарантировать, что во всех случаях мы можем вывести хотя бы какой-то тривиальный инстанс. То есть есть функции, которые непонятно, как печатать, например, или читать из строки.

Поэтому нужно понимать, что все это некоторые эвристики, которые не всегда работают. Причем... Сейчас я немножко забыл. Короче, надо уточнить. Бывает так, что он сгенерит тебе что-то, но для функции она не работает совсем.

Или она сгенерит тебе какой-нибудь инстанс, в котором будут взаимно рекурсивные просто дефолтные реализации. Это надо уточнить. А правила для дерайвинга, они вообще зашиты в компилятор для контрактных типов? Или они где-то в исходниках есть? Это не зашиты в компилятор. Вот эти все дерайвинги, они предоставляются компилятором, но есть способы писать свои дерайвинги. Там, мне кажется, подключается немножко метапрограммирование, когда тебе хочется потраверсить тип, взять все его конструкторы.

Короче, какие-то рефлекшены там есть, говоря языком Java, для которых ты можешь генерить эти все дерайвинги. Поэтому, в общем, это не first class сущность в языке, но есть поддержка. В общем, например, есть NewType, любимый. Давайте посмотрим, какие есть проблемы с NewType, например. Нам, допустим, нужно реализовать метод show.

Для этого нужно сделать паттерн-матчинг по этому элементу. Если мы делаем, допустим, ик, мы должны сделать паттерн-матчинг на левом и правом операнде, взять инты оттуда и сравнить их. То есть мы предполагаем, что NewType — это некоторый синоним инта, но не совсем, которые отличаются от него по тигму. И у нас проблема. У нас уже нет реальный какой-то код.

У нас не просто enum и сравниваются, а надо какой-то паттерн-матчинг делать, еще что-то, потом обратно это заворачивать, наверное, где-то там в плюсе. В общем, с этим есть проблема. Это уже не включено в язык стандартный, но есть расширение, называется generalized NewType deriving, который это все делает. Ну и вот deriving может быть довольно большим для NewType, потому что, смотрите, тут как это работает. Например, функтор.

Он не генерирует с нуля функтор, но если у типа, который внутри, уже есть функтор, например, у инта, но у инта нет, допустим, NewType, какой-нибудь параметр list есть, аргумент, то для него уже есть функтор. Ему нужно просто, по сути, написать определение, которое делает паттерн-матчинг на одном, единственном существующем конструкторе, применяет функцию, потом опять это заворачивает, если нужно. И в антайме вообще-то вот эти вот боксинги, анбоксинги, они будут вообще, типа, они будут уничтожены, их не будет в антайме. Поэтому для NewType все проще, и существуют эти директивы, которые почти все можно для него вывести вообще. То есть там никаких ручных действий не нужно.

Причем тут, видите, даже какие-то есть параметры у deriving, типа. В общем, да. Довольно удобно на практике. Да, и там вот ссылочки есть, какой-то комментарий про то, что делать, если вот этот список deriving слишком длинный, и хочется у каждого повторять. Хорошо.

Теперь давайте посмотрим модули. Значит, смотрите, какая есть проблема вот с type-классами, которые мы до этого смотрели. Чем они отличаются от классов в плюсах, например. У нас нет области видимости, у нас нет вот этого вот public полей, private полей, вот этого всего нет. У нас все public всегда.

Что как бы на самом деле не очень хорошо. Оно как бы упрощает жизнь и позволяет реализовать какие-то механизмы, какой-то type-checking, наверное, упрощает. Но вообще это не очень удобно в жизни. Но это можно похожую функциональность реализовать с помощью модулей. То есть, смотрите, у нас, допустим, смотрим с первой строчки.

У нас есть модуль lib, то, что в начале каждого файла мы пишем модуль lib. Это модуль, который определяется в этом файле. Ну, понятно. Модуль — это набор кода, который мы можем отдельно скомпилировать, потом куда-то заимпортить. И мы указываем после lib в скобочках те функции, те модули, те типы, которые мы экспозируем, которые мы делаем открытыми для импорта.

То есть, если есть какие-то детали реализации, мы просто их не добавляем в этот список, и они остаются закрытыми. Понятно, зачем это нужно. Если мы захотим поменять реализацию, мы это можем сделать. И будем уверены, что никто, ни пользователя, никого пользователя мы не сломаем в нашей библиотеке, потому что он не мог использовать эти детали реализации. Посмотрим, как мы делаем импорт.

Мы пишем foo.a, например. То есть, у нас модули имеют иерархию какую-то. Иерархия строится, по-моему, как в Java, значит, по файловой системе. То есть, есть папка foo, в ней есть файл a, файл b, в нем определяются модули a и b, поэтому мы определяем еще рядом файл foo, в котором описывается модуль foo. Причем модуль foo может импортить, значит, какие-то, грубо говоря, protected вещи, какие-то детали реализации, которые доступны всему модулю foo, но не выдавать их туда наверх.

То есть, не делать их видимыми для всего модуля foo. Для всей библиотеки, грубо говоря. Давайте пробежимся еще раз по синтаксису. Значит, у нас есть импорт, мы можем дальше в скобочках написать, что мы конкретно хотим заимпортить. Вот, например, мы здесь, посчитаю, что здесь написано, мы импортим тип foo b2 и один его конструктор mkb1.

Возможно, это не один конструктор, а их несколько. Мы только этот хотим заимпортить. Ну, собственно, справа у нас есть определение, foo b2 у него два конструктора, мы только один из них импортим. Ну, то есть, когда-нибудь, наверное, это нужно. То есть, наверное, уже потомачить мы уже не сможем сделать, но пока немного создать элемент мы сможем.

Вот, foo b3 значит, с этим типом мы импортим все его конструкторы. Да, если мы не напишем вот эти скобочки с двумя точками, мы вообще не будем импортить конструкторы. Это тоже нужно учитывать. Мы можем импортить тип, но не его конструкторы. Это разные вещи.

Ну, мы помним, что конструкторы просто функции. Вот, значит, дальше мы можем сделать хайдинг. То есть, мы можем заимпортить все, кроме. Например, это удобно для прелюда, когда мы хотим... Есть какая-то функция, которая называется print, но нам она не нравится, мы хотим ее по-своему реализовать.

Мы ее не импортим, чтобы у нас не было переопределения, не было одинаковых имен. Дальше у нас пример, как можно импортить операторы. Они в скобочках указываются. Отдельных обязательно. Потом мы можем заимпортить пустые скобочки.

Смотрите, какой смысл пустых скобочек. Казалось бы, мы делаем импорт, но ничего не импортим. То есть, как будто бы ничего. На самом деле, тут важный вопрос, а как происходит импорт инстансов и классов? Потому что для них на самом деле нет никакого отдельного синдекса. Например, я хочу заимпортить только вот этот класс, и вот этот класс, и вот этот инстанс.

Для этого работает правило, что если мы импортим модуль, то мы импортим все его инстансы и все классы. То есть, принято такое решение в Хаскере. То есть, понятно, у него есть свои плюсы и минусы, но, в общем, инстансы должны быть видны, если мы импортим какой-то модуль, все его инстансы видны и все классы. Да, еще раз повторюсь. И такой синдекс позволяет заимпортить только инстансы и классы, если мы не указываем в скобках ничего.

Мы все еще импортим так классы. Давайте дальше разберем. Импорт. База. Мы можем как-то по-другому назвать модуль.

Например, x, y, z у нас какое-то длинное название, мы не хотим постоянно его писать, мы можем переназвать как-нибудь, дать короткое имя. Потом есть специальное слово qualified, которое означает, что любой символ, который мы заимпортили, который мы импортировали из этого модуля, мы обязаны указывать его квалификатора, то есть указывать его полное имя. Допустим, есть какая-нибудь функция fold из data. list модуля, мы обязаны везде писать data. list data.list.

fold fold fold в общем. Это удобно, потому что опять же, если у нас есть своя функция fold, и она совпадает с тем, что мы импортировали, мы указываем qualified, и у нас неоднозначность пропадает, потому что мы знаем, что один из них обязан быть указан с полным путем модуля. Но, понятно, полный путь указать постоянно неудобно, поэтому мы можем комбинировать это с синонимом, допустим, c, опять же, можно спрятать какие-то вещи и не импортить их. Можно заимпортировать только что-то, что мы хотим. В общем, понятно.

Причем, да, смотрите, в последнем примере у нас есть, мы импортируем модуль x и y, и оба из них называем export, тем самым мы их как бы собираем в один модуль, мы их как бы объединяем. Тоже может быть удобно. Вот, вроде бы все разобрал. Давайте, какие есть вопросы? А если мы заимпортировали fu.x и fu. y одним и тем же именем, как мы сможем к ним обращаться? Смотри, они оба обозначены как qualified, поэтому мы обращаемся как export.что-то.

Если они оба импортируют одинаковое имя, я думаю, что очень жаль. Ага, хорошо. А чем отличается просто import fu. y s-export от import qualified fu. y s-export? Смотрите, повторяю, qualified значит, что ко всем символам из этого модуля ты обязан обращаться с квалификатором.

То есть ты обязан писать fu.x.имя. Ну а если не qualified, то я тоже могу так сделать, но не обязательно. Да. Ну то есть слайд выглядит на самом деле сложно, но на самом деле тут как бы все довольно понятно, и все что хотелось бы иметь от модулей, оно есть. Изначально в Haskell нельзя два модуля в одном файле объявлять, это неудобно.

Ну, какие-то трейд-оффы. Но при этом, при том, что нельзя объявлять два модуля в одном файле, модуль может экспортировать модуль, потому что он может его перед этим заимпортить. То есть, видите, модуль lib импортит fu.x и fu.y как экспорт, и потом экспорт экспортирует дальше. То есть, как бы, lib, он немножко пересобирает область видимости библиотеки и создает такой интерфейс. Вот.

Ну ладно, если понятно, давайте пойдем дальше. Там осталось вроде немного. Значит, extra knowledges. Тут, короче, какие-то интересные ссылочки. Вот последняя-то статья, про которую я говорил.

How to make ad-hoc polymorphism less ad-hoc. Кому интересно, почитайте. Прикольно должно быть. Вот. И какие-то еще фичи тэп-классов мы еще будем говорить в следующих лекциях.

Что тут осталось? Нерекурсивные ADT. А, ну, такой теоретический пассаж, наверное. Сейчас я попытаюсь сказать более простыми словами, что, допустим, у нас есть вот такой тип DoctorWho, это Tardis или Dalek, в общем, какая-то сумма типов у нас есть. И, на самом деле, можно закодировать с помощью функций. То есть, как бы, это называется Churching Coding, то есть кодирование черча для алгебрыческих типов данных.

Что мы можем закодировать тип Doctor через такие, как бы, замоками. То есть, допустим, допустим, у нас нет директивы Data, у нас нет никакого синтеза для этого, но мы все еще можем сделать алгебрыческие типы данных просто на лямбда-исчислении, на самом деле. То есть просто на функциях. Допустим, функция fTardis это функция, которая принимает a и b, это параметры первого конструктора, и возвращает, как бы, такой continuation или замыкание, которое принимает тип... которое принимает две функции Tardis и Dalek.

И эти функции это функции, которые хотят что-то сделать с обоими вариантами. То есть это такой, как бы, кейс, какой-то такой pattern matching, который уже, как бы, вшит в конструктор. То есть конструктор уже ждет две функции и применяет только одну из них, потому что это конструктор, он знает параметры двух, и он, как бы, сохраняет их замыкание и применяет к ним левый. И при этом симметрично вторая функция, второй конструктор, он принимает один параметр, потому что конструктор имеет только один параметр, его сохраняет замыкание и в этом случае уже игнорирует, как бы, левый рекурсивный вызов и вызывает правый от этого конструктора. То есть смотрите, у нас получается, что эти две функции, если на них посмотреть, то они обе, они сначала принимают параметры своих конструкторов, потом принимают одинаковые две функции, значит, рекурсивного вызова от вариантов, но одна вызывает, значит, от одного, а другая от другого.

То есть вот этот вот хвост у них одинаковый. И вот этот хвост на самом деле является нашим типом. То есть смотрите, как это дальше использовать. Допустим, у нас есть там какая-то функция travel, которая принимает паттерн А, это было предыдем определено. Что? Это какие-то две функции, которые типа что-то делают.

Ага, смотрите, дальше у нас есть два конструктора, мы хотим сделать типа паттерн-матчинг. Паттерн-матчинг выглядит как? Мы просто передаем нашему типу две функции. Две функции, которые, собственно, левая и правая. И в зависимости от того, с помощью чего был сделан наш конструктор, с помощью функции f-targets или f-dialog, будет соответствующий результат. То есть вот, если мы передадим в f-travel, значит, наш тип сконструированный, созданный конструктором f-targets 0,0, у нас будет один результат, с помощью f-dialog будет другой результат.

И, смотрите, если мы сделаем type alias на типа вот это вот хвост, который у нас был у этих конструкторов, то на самом деле мы получим нормальную сигнатуру конструкторов. Ну, это такой стандартный способ закодировать географические типы данных с помощью просто функции. То есть это интересно теоретикам, которые показывают типа, вот сколько можно классных штук сделать с помощью простого лямбда-счисления. На курсе теории типов про это рассказывают. Под компотом оно разве точно так же не кодируется? Под компотом как оно кодируется, я не могу сказать.

То есть я не думаю, что это самый эффективный способ представления этого всего. Это не про эффективность, это про выразительность, что с помощью функции можно закодировать вот это. Потому что как будто на функции написали то же самое с точки зрения функции, потому что если все это функция, то оно как будто бы так и было закодировано, только это было скрыто с эхором. Ну, смотри, в случае более императивном мы можем сохранить объект доктор просто как тег и какие-то поля. В случае этого черчен-кодинга у нас объект это какое-то замыкание, которое на самом деле это уже не объект, который хранится в памяти, это как бы этим объектом это замыкание, то есть это функция.

Ну, как так сказать... Смотри, если у нас под капотом язык реализован императивно, то лучше все-таки первый вариант, когда мы просто храним в памяти эту гравитационную структуру, грубо говоря, с тегом, как вариант в плюсах. Если у нас под капотом есть какие-то символьные вычисления, если мы говорим, ну, мы, короче, делаем там бета-редукцию, мы, типа, упрощаем выражение просто, тем самым делаем вычисления, то, да, второй вариант лучше. Как Haskell в GHCI реально реализован, я думаю, что там как бы что-то среднее. Я не берусь говорить, как там реально это реализовано, я не копался под капотом компилятора.

Ну, короче, иногда вот такой... смотри, плюс Haskell в том, что ты можешь как бы иметь оба варианта, что у тебя есть как бы встроенная в язык такая штука эффективная, есть вот такая вот, типа, на функциях, и иногда вот эта штука на самом деле используется. Довольно редко в участии, но иногда используется. Надеюсь, я ответил на вопрос. Или просто испугал.

Нет, но мы же писали эти всякие черт-инкодинги на нот-логику. А, ну вот. Ну, типа... Да, я бы все сказал. Короче, да.

Да, и вот тут еще есть комментарий, что на самом деле вот такую штуку, типа, вот эти все определения можно с помощью метапрограммирования, короче, все это сгенерить, на самом деле. Иногда это очень удобно. Потому что потом это еще увидите. Вот. Ну, дальше какие-то слова про то, что, типа, на самом деле C++ это такие словари с методами, но я про это говорил.

Инстанции, на самом деле, это просто, типа, с объектами. Типа с реализацией методов, с функциями. Вот. В общем-то все. На этом, я думаю, что лекция закончена.

Давайте вопросы какие-то. Домашка, соответственно, будет после этой лекции? Это я, честно говоря, не знаю. Я не отвечаю за домашки. Вот. Я, возможно, отвечаю за их проверки, но не за их выкрутку.

Это скорее к Диме. Очень было бы хорошо, если бы она была. Ну да, чтобы было на чем помедитировать. Сейчас слишком много всего. Да, я понимаю вас.

Я вас понимаю. Я, честно говоря, плохо знаком с домашками в этом году. Но мне кажется, что там должно быть что-то такое, как это сказать, простое, типа написать каких-то инстансов. Потому что, понятно, да, очень много нового всего, а тут скорее проблема в том, что очень много непонятных концепций, каких-то непривычных, если вы до этого писали только на плюсах, например. Мы все писали на клажуре.

Про логию мы тоже писали. Ой, ну клажур, про лог это, да. Клажур это же инвалидная ФП. Ну как инвалидная? Оно как бы, типа это гибрид. Гибрид.

ФП и джава. Клажур. Я тоже писал карты на клажуре. Парсер. На -ок.

Все мы когда-то писали парсеры. Да. Ну, всем спасибо. Я не знаю, если еще какие-то есть вопросы, если хотите отсудить, можем отсудить. Если нет, то давайте.

Всем удачи. Спасибо, до свидания. Спасибо, до свидания. И вам спасибо, что пришли. Как слышно на языке Штукенберга.

Ладно, всем пока. 