1
00:00:06,900 --> 00:00:11,490
Рад вас видеть на третьей лекции по
функциональному программированию.

2
00:00:13,250 --> 00:00:16,390
Давайте краткий план у нас на сегодня.

3
00:00:16,950 --> 00:00:21,730
Мы научимся создавать
свои собственные типы данных,

4
00:00:23,530 --> 00:00:26,550
поговорим про алгебрические типы данных,

5
00:00:26,730 --> 00:00:32,970
про рекорды, нью-тайпы, разные
способы создать свои типы данных в Haskell.

6
00:00:35,040 --> 00:00:37,450
Поговорим про type-классы, про полиморфизм.

7
00:00:38,130 --> 00:00:39,190
Довольно интересная тема.

8
00:00:39,850 --> 00:00:43,650
И какие-то разные мелочи про модули.

9
00:00:46,230 --> 00:00:47,250
Погнали.

10
00:00:48,730 --> 00:00:52,310
Мы хотим создавать свои типы данных.

11
00:00:52,870 --> 00:00:55,710
Давайте сначала подумаем,
почему нам это нужно.

12
00:00:56,310 --> 00:01:01,770
Если нам нужен какой-то набор данных, который
как-то связан, например, какой-то юзер,

13
00:01:02,650 --> 00:01:05,950
то почему не можем
использовать просто tuple?

14
00:01:07,920 --> 00:01:08,920
Передаем tuple,

15
00:01:10,930 --> 00:01:15,750
можем написать функцию,
типа сгенерить full ID для юзера.

16
00:01:17,750 --> 00:01:19,030
Казалось бы, в чем проблема?

17
00:01:20,230 --> 00:01:24,290
Но понятно, что есть
разные неудобства с этим.

18
00:01:24,665 --> 00:01:26,710
Я забыл сказать,
если у вас есть какие-то

19
00:01:26,810 --> 00:01:28,170
вопросы, можете любое
время меня прерывать.

20
00:01:30,590 --> 00:01:32,630
Можно просто говорить,
потому что я, скорее

21
00:01:32,631 --> 00:01:35,350
всего, не буду смотреть
чат во время лекции.

22
00:01:36,130 --> 00:01:40,270
Можно просто голосом
становиться и говорить.

23
00:01:40,370 --> 00:01:44,010
Я буду стараться делать паузы
в каких-то тривиальных местах,

24
00:01:44,170 --> 00:01:46,910
чтобы вы тоже могли
немножко подумать, сознать,

25
00:01:48,010 --> 00:01:49,010
понимаете ли вы все.

26
00:01:51,750 --> 00:01:55,890
Но если вопросы возникнут после,
опять же, у нас есть чат в Телеграме,

27
00:01:56,590 --> 00:01:59,470
там можно задавать вопросы.

28
00:02:00,310 --> 00:02:02,290
Я думаю, что по этой лекции, как минимум,

29
00:02:03,570 --> 00:02:07,250
и по остальным тоже я
смогу что-нибудь ответить.

30
00:02:08,380 --> 00:02:09,380
Коллеги мне помогут.

31
00:02:10,850 --> 00:02:11,850
Продолжаем.

32
00:02:15,060 --> 00:02:16,590
Понятно, какая проблема здесь.

33
00:02:16,765 --> 00:02:20,950
Во-первых, что если мы
возьмем какой-нибудь другой

34
00:02:21,030 --> 00:02:23,490
тип данных, какой-нибудь
другой набор данных, не юзер,

35
00:02:23,550 --> 00:02:26,410
а аккаунт, у которого
такой же набор данных.

36
00:02:26,930 --> 00:02:28,150
Мы можем что-то перепутать.

37
00:02:28,350 --> 00:02:29,710
В общем, у нас никаких проверок.

38
00:02:29,930 --> 00:02:32,990
У нас такой тип питон, грубо говоря.

39
00:02:37,990 --> 00:02:38,990
Значит, первая операция.

40
00:02:39,170 --> 00:02:40,010
Что мы можем улучшить?

41
00:02:40,110 --> 00:02:42,990
Мы можем создать type
alias, то есть синоним,

42
00:02:44,890 --> 00:02:52,130
который, во-первых, у нас уже
сигнатура будет выглядеть удобно, красиво,

43
00:02:52,610 --> 00:02:55,790
но опять же, у нас есть проблема в том,

44
00:02:55,890 --> 00:03:03,670
что синоним совершенно не добавляет
никаких новых проверок в compile-time.

45
00:03:04,300 --> 00:03:08,390
То есть если у нас будет
юзер и будет аккаунт

46
00:03:08,490 --> 00:03:10,990
с одинаковым набором полей,

47
00:03:10,991 --> 00:03:14,110
то, грубо говоря, у нас они будут
совершенно взаимозаменяемы.

48
00:03:14,550 --> 00:03:16,070
То есть если мы где-то сделаем ошибку,

49
00:03:16,530 --> 00:03:19,410
все еще компилятор никак
не сможет нам помочь.

50
00:03:19,930 --> 00:03:21,730
Но, как минимум,
читаемость у нас улучшилась.

51
00:03:26,890 --> 00:03:32,370
Собственно, вот какие-то такие
распространенные type alias, их примеры.

52
00:03:33,460 --> 00:03:38,490
То есть string — это просто
лист черов, например.

53
00:03:38,990 --> 00:03:40,330
Ну, не всегда, на самом деле.

54
00:03:42,775 --> 00:03:45,816
Можно использовать разные вероятности,
которых string будет означать разная.

55
00:03:46,570 --> 00:03:49,110
В этом тоже некоторые удобства есть.

56
00:03:49,290 --> 00:03:52,050
Но, значит, что тут важно отметить,

57
00:03:52,170 --> 00:03:55,110
что type alias спокойно
могут быть параметрическими,

58
00:03:56,050 --> 00:03:58,290
то есть принимать различные аргументы,

59
00:03:58,980 --> 00:04:00,970
что довольно естественно и удобно.

60
00:04:02,910 --> 00:04:04,470
Да, тут вроде пока все понятно.

61
00:04:06,180 --> 00:04:07,770
Значит, агибарические типы данных.

62
00:04:08,210 --> 00:04:10,870
Пытаемся сделать какое-то
более правильное решение.

63
00:04:11,790 --> 00:04:14,630
И для этого немножко теории.

64
00:04:16,510 --> 00:04:21,370
Haskell-ные типы строятся на так
называемой теории агибарических типов.

65
00:04:21,810 --> 00:04:24,730
Суть в том, что у нас есть типы,

66
00:04:25,830 --> 00:04:29,150
у нас есть одними операции произведения,

67
00:04:31,120 --> 00:04:33,390
что, по сути, просто tuple.

68
00:04:36,090 --> 00:04:37,410
И почему произведение?

69
00:04:37,490 --> 00:04:41,190
Тут проводится такая
аналогия, что типы — это как бы...

70
00:04:42,130 --> 00:04:45,170
их можно, если не копать глубоко,
воспринимать как множество.

71
00:04:46,600 --> 00:04:48,150
И, в общем, когда мы хотим...

72
00:04:49,370 --> 00:04:50,890
если мы делаем пару из двух типов,

73
00:04:51,130 --> 00:04:54,190
то у нас получается количество элементов,

74
00:04:55,940 --> 00:04:58,290
которые населяют произведение типов,

75
00:04:58,440 --> 00:05:00,650
это произведение множества.

76
00:05:00,940 --> 00:05:05,050
То есть мы берем любой элемент
первый из первого множества,

77
00:05:05,510 --> 00:05:08,080
любой второй элемент из второго
множества, получается произведение.

78
00:05:11,120 --> 00:05:12,150
Ну, в общем, да.

79
00:05:12,270 --> 00:05:14,610
User — это произведение int, двух стрингов.

80
00:05:16,380 --> 00:05:17,610
Собственно, да.

81
00:05:18,370 --> 00:05:19,931
В Haskell мы это уже видели, это tuple.

82
00:05:20,590 --> 00:05:23,170
Ну и раз у нас есть произведение,
давайте введем и сумму.

83
00:05:24,430 --> 00:05:26,650
Сумма означается знаком плюс.

84
00:05:28,750 --> 00:05:32,370
Написано сложно найти какие-то
аналогии в нефункциональных языках.

85
00:05:32,890 --> 00:05:35,650
В целом, да, но сейчас во
многих современных языках

86
00:05:37,370 --> 00:05:40,930
они впитывают функциональную
парадигму и вносят ее.

87
00:05:41,550 --> 00:05:43,230
И, в общем, какие тут примеры?

88
00:05:44,440 --> 00:05:48,870
Самый оперативный — это
union, который есть еще в плюсах,

89
00:05:52,165 --> 00:05:59,490
но там далеко от того, что
воспринимается обычно под суммами типов.

90
00:05:59,710 --> 00:06:00,830
Это еще называют вариантами.

91
00:06:01,640 --> 00:06:06,250
То есть в 17-х плюсах, например,
введен стандартный вариант.

92
00:06:07,070 --> 00:06:08,690
Это, по сути, суммы типов.

93
00:06:09,470 --> 00:06:13,746
То есть у нас есть тип,
который умеет хранить

94
00:06:13,758 --> 00:06:17,570
несколько разных
вариантов других типов,

95
00:06:17,571 --> 00:06:20,266
и они помечены тегом, и
мы можем их различить,

96
00:06:20,278 --> 00:06:22,750
делать на нем
паттерн-матчинг и так далее.

97
00:06:27,730 --> 00:06:33,690
Собственно, героические типы — это,
значит, либо какой-то атомарный тип,

98
00:06:34,450 --> 00:06:39,330
int, char, double, либо сумма
типов, либо произведение типов.

99
00:06:39,430 --> 00:06:44,170
То есть мы задаем некоторую
грамматику, как могут выглядеть типы.

100
00:06:44,171 --> 00:06:49,810
Ну и, собственно, понятно, суть в том,
что это напоминает нам некоторую алгебру,

101
00:06:50,010 --> 00:06:51,983
мы можем выписать
для них какие-то правила,

102
00:06:51,995 --> 00:06:54,210
работать с ними как с
математическими объектами.

103
00:06:55,900 --> 00:07:00,176
В общем, довольно удобно, когда у
вас есть формальное определение

104
00:07:00,188 --> 00:07:03,750
того, что вы вообще можете
написать в своей программе.

105
00:07:06,250 --> 00:07:09,330
Значит, давайте посмотрим, как
это выглядит в Haskell, например.

106
00:07:09,770 --> 00:07:11,270
Самый простой пример — это enum.

107
00:07:11,970 --> 00:07:17,550
То есть есть TrafficLight, у него
есть почему-то четыре цвета.

108
00:07:18,470 --> 00:07:20,610
Я не совсем понимаю,
почему, но для прикола.

109
00:07:21,560 --> 00:07:24,588
В общем, мы можем
написать функцию для работы

110
00:07:24,600 --> 00:07:27,370
с ним, просто как бы
разобрав все случаи.

111
00:07:29,710 --> 00:07:32,410
Значит, вроде бы все понятно.

112
00:07:35,670 --> 00:07:36,710
Значит, понятно.

113
00:07:36,850 --> 00:07:39,660
Дальше мы можем эту
функцию использовать, сделать

114
00:07:39,672 --> 00:07:42,610
map по листу, каждому
применить, увидеть результат.

115
00:07:44,310 --> 00:07:47,717
Да, и тут важно то, что
компилятор может вам

116
00:07:47,729 --> 00:07:51,070
помочь проверить,
что ваш pattern matching,

117
00:07:51,750 --> 00:07:55,710
то есть сопоставление с образцом, что
вы рассматриваете все варианты в нем,

118
00:07:57,230 --> 00:08:01,390
то есть что он полный, что вы
делаете полный разбор всех случаев.

119
00:08:02,690 --> 00:08:03,690
Да.

120
00:08:05,920 --> 00:08:10,670
Для этого нужно включить нужные
флажки, и будет вам счастье.

121
00:08:11,850 --> 00:08:14,270
Значит, окей, давайте посмотрим дальше.

122
00:08:15,670 --> 00:08:17,710
У нас есть ключевое слово — data.

123
00:08:19,070 --> 00:08:23,570
По сути, мы создаем кастомный тип данных.

124
00:08:23,910 --> 00:08:29,070
Это уже не alias, это уже новый тип,
который не совпадает со всеми остальными.

125
00:08:29,670 --> 00:08:34,332
И, значит, у него есть...
Давайте разберем сигнатуру.

126
00:08:35,070 --> 00:08:39,910
У нас data, дальше идет имя,
дальше идет название конструктора.

127
00:08:40,250 --> 00:08:43,470
Оно все начинается с большой
буквы, потом идут его параметры.

128
00:08:44,290 --> 00:08:50,950
То есть, по сути, у нас тут задана...

129
00:08:51,050 --> 00:08:52,890
Давайте посмотрим, как
с этим работать дальше.

130
00:08:55,760 --> 00:08:57,190
Как получить доступ к полям?

131
00:08:57,390 --> 00:09:01,090
Мы можем просто сметчиться на конструкторе.

132
00:09:01,850 --> 00:09:04,330
То есть мы делаем паттерн-матчинг,
указываем имя конструктора,

133
00:09:05,410 --> 00:09:06,850
имя полей, на которых мы матчимся.

134
00:09:07,010 --> 00:09:09,410
Если какие-то не нужны,
заменяем их класс-холдерами,

135
00:09:09,750 --> 00:09:11,316
чтобы не было опять
варлинга, что мы не

136
00:09:11,328 --> 00:09:13,270
используем какие-то
переменные или что-то такое.

137
00:09:15,550 --> 00:09:18,510
И, в общем, вот у нас есть геттеры.

138
00:09:20,920 --> 00:09:24,550
Значит, да, конструкторы
— это просто функции.

139
00:09:26,770 --> 00:09:30,090
Просто функции, которые
принимают, по сути, инк, стринг, стринг,

140
00:09:30,290 --> 00:09:33,030
в данном случае возвращают нам
тип, который мы только что создали.

141
00:09:33,530 --> 00:09:35,270
Они ничем особо не отличаются.

142
00:09:36,750 --> 00:09:39,550
Везде, где можно использовать
функции, можно использовать конструктор.

143
00:09:40,170 --> 00:09:43,290
В общем, довольно удобно.

144
00:09:44,390 --> 00:09:47,990
Да, можно опять же в
jash-сайт посмотреть тип.

145
00:09:53,530 --> 00:10:00,410
Значит, да, можно создать список юзеров,
применить им какую-нибудь функцию.

146
00:10:06,480 --> 00:10:08,230
Например, список уникальных имен.

147
00:10:10,830 --> 00:10:13,970
Выглядит, собственно, как
какие-нибудь джаоские стримы.

148
00:10:14,220 --> 00:10:19,450
Собственно, они берут свое начало отсюда.

149
00:10:20,975 --> 00:10:27,750
Окей, значит, типы данных
могут быть параметрическими.

150
00:10:36,570 --> 00:10:37,890
Можно вопрос? Да, вопрос.

151
00:10:39,690 --> 00:10:40,690
Да, я слушаю.

152
00:10:43,620 --> 00:10:44,860


153
00:10:49,450 --> 00:10:50,680
Я не слышу, к сожалению.

154
00:10:53,300 --> 00:10:54,960
Получается это круг?

155
00:11:02,200 --> 00:11:02,680
Да.

156
00:11:03,160 --> 00:11:04,660
Давайте вы напишите вопрос в чате.

157
00:11:04,760 --> 00:11:06,820
Я не знаю, я не слышу вас.

158
00:11:08,000 --> 00:11:09,120
Вы очень сильно пропадаете.

159
00:11:15,630 --> 00:11:16,350
Что, серьезно?

160
00:11:16,430 --> 00:11:18,370
В каких-то странах есть голубой
цвет светофора? Офигеть.

161
00:11:19,750 --> 00:11:20,750
Ну, ладно.

162
00:11:21,830 --> 00:11:22,830


163
00:11:24,170 --> 00:11:25,730
Напишите, пожалуйста, вопрос в чате.

164
00:11:25,810 --> 00:11:29,210
Я его посмотрю буквально через пару минут.

165
00:11:31,020 --> 00:11:32,150
Собственно, давайте продолжим.

166
00:11:32,151 --> 00:11:33,990
У нас есть...

167
00:11:34,040 --> 00:11:38,190
Извините, у меня сейчас должно быть лучше
слышно, у меня просто был интернет выходит.

168
00:11:39,520 --> 00:11:42,850
На предыдущем слайде был мк-юзер и юзер.

169
00:11:42,970 --> 00:11:45,530
Мк-юзер – это, получается,
имя конструктора?

170
00:11:46,450 --> 00:11:50,890
Да, мк-юзер – это имя
конструктора, совершенно верно.

171
00:11:51,390 --> 00:11:53,770
А юзер – это имя? А это имя, да.

172
00:11:54,070 --> 00:11:55,070


173
00:11:56,330 --> 00:11:57,590
То есть, да, смотрите.

174
00:11:57,850 --> 00:12:01,930
Если, допустим, у вас больше
опыта работать с плюсами,

175
00:12:02,030 --> 00:12:05,550
то тут конструкторы и
имена типов – они разные.

176
00:12:09,200 --> 00:12:11,330
Это удобно, потому что, на самом деле,

177
00:12:11,640 --> 00:12:16,970
если в плюсах вы создаете разными конструкторами
тип, вы получаете один и тот же тип.

178
00:12:17,110 --> 00:12:18,470
То есть их никак нельзя различить.

179
00:12:18,750 --> 00:12:21,610
Нельзя узнать, с помощью
какого конструктора был создан тип.

180
00:12:21,670 --> 00:12:23,890
Это неинтересно в плюсах.

181
00:12:23,891 --> 00:12:25,810
Здесь немножко другая концепция.

182
00:12:26,990 --> 00:12:36,190
Тут все конструкторы помечают наш объект.

183
00:12:36,690 --> 00:12:41,910
Мы можем узнать, с помощью
какого конструктора был создан объект.

184
00:12:48,550 --> 00:12:52,990
Тут конструктор является
неотъемлемой частью представления типа.

185
00:12:53,090 --> 00:12:56,270
То есть это его как бы часть структурная.

186
00:12:57,110 --> 00:12:58,590
То есть в этом есть немножко отличие,

187
00:13:05,200 --> 00:13:09,610
более какой-то математичный подход здесь.

188
00:13:11,370 --> 00:13:12,150
Но мы это все увидим.

189
00:13:12,350 --> 00:13:16,370
Например, дальше, если
будут вопросы, я отвечу.

190
00:13:19,290 --> 00:13:20,290
Еще вопросы?

191
00:13:22,440 --> 00:13:24,050
Там вопрос в чате задали,

192
00:13:24,510 --> 00:13:28,130
можно ли создать более одного
конструктора для одного типа.

193
00:13:28,510 --> 00:13:30,430
Да, можно. Сейчас мы увидим.

194
00:13:34,140 --> 00:13:37,780
Мы пока разобрали тип
с одним конструктором.

195
00:13:38,680 --> 00:13:41,420
Когда мы пройдем дальше, мы увидим все.

196
00:13:42,920 --> 00:13:44,360
Мы не зря говорили про суммы типов.

197
00:13:44,400 --> 00:13:45,400
Сейчас все будет.

198
00:13:45,780 --> 00:13:49,320
Давайте закончим эту
часть, потом тут вопрос.

199
00:13:49,500 --> 00:13:50,500
Я спрошу.

200
00:13:53,890 --> 00:13:55,280
Типы могут быть параметрическими.

201
00:13:56,970 --> 00:13:58,860
Параметрический параметризм, как говорится.

202
00:14:02,000 --> 00:14:03,000
Понятно зачем.

203
00:14:03,220 --> 00:14:04,900
Мы хотим точку, допустим,

204
00:14:05,320 --> 00:14:07,060
написать какой-то код общий,

205
00:14:12,930 --> 00:14:14,580
без указывания конкретных типов.

206
00:14:14,581 --> 00:14:18,820
Мы хотим, чтобы и длинна
работала, и для дабла,

207
00:14:19,180 --> 00:14:21,000
и, допустим, для двухмерной точки.

208
00:14:21,740 --> 00:14:23,640
Вот простые примеры.

209
00:14:23,925 --> 00:14:27,340
Типа, точку в список превратить,

210
00:14:27,980 --> 00:14:37,540
взять точку и превратить ее в точку,

211
00:14:38,640 --> 00:14:43,720
в которой пространство, а осями
являются тоже 2D пространства, удвоить.

212
00:14:45,540 --> 00:14:46,540


213
00:14:47,200 --> 00:14:49,260
Взять максимальную координату,

214
00:14:52,075 --> 00:14:53,260
остальные от нуля посчитать.

215
00:14:56,360 --> 00:14:58,080
Такие простые, хоть понятные,

216
00:14:58,620 --> 00:15:01,540
примеры, на которых
должно быть просто видно,

217
00:15:02,540 --> 00:15:03,540
что вообще происходит.

218
00:15:07,790 --> 00:15:10,480
Создаем типы, видим результат.

219
00:15:13,020 --> 00:15:15,200
Получается конструктор
имеет такое же название,

220
00:15:15,440 --> 00:15:16,820
как и тип данных.

221
00:15:17,740 --> 00:15:18,740
Да, совершенно верно.

222
00:15:18,900 --> 00:15:21,640
Здесь у нас немножко другой пример,

223
00:15:21,835 --> 00:15:24,320
тут конструктор имеет такое
же название, как тип данных,

224
00:15:24,810 --> 00:15:30,020
и в Haskell это разные синтаксические вещи.

225
00:15:30,120 --> 00:15:34,780
Там, где предполагается тип,

226
00:15:34,940 --> 00:15:36,200
и вы пишете Point2D,

227
00:15:36,970 --> 00:15:40,060
он будет депортироваться как тип.

228
00:15:40,580 --> 00:15:42,460
Там, где предполагается какая-то функция,

229
00:15:42,920 --> 00:15:45,740
будет восприниматься как конструктор.

230
00:15:46,040 --> 00:15:47,760
То есть они вообще разнесены.

231
00:15:49,140 --> 00:15:50,140
Пока что.

232
00:15:50,835 --> 00:15:52,100
Пока у нас нет зависимых типов.

233
00:15:53,040 --> 00:15:54,380
Но, в общем, да.

234
00:15:57,055 --> 00:16:00,100
Вполне из контекста понятно, что
такое Point2D, конструктор и тип.

235
00:16:01,940 --> 00:16:02,940
В целом, довольно удобно.

236
00:16:07,440 --> 00:16:08,940
Давайте пойдем дальше.

237
00:16:10,660 --> 00:16:11,840
Суммы типов.

238
00:16:12,060 --> 00:16:14,020
Когда у нас может быть
несколько конструкторов.

239
00:16:14,520 --> 00:16:15,900
Если у нас есть intResult,

240
00:16:16,340 --> 00:16:22,560
у нас intResult воплощает в себе
либо успешное вычисление числа,

241
00:16:23,780 --> 00:16:28,740
какой-то совочисленный результат
вычислений, или это ошибка с сообщением.

242
00:16:29,560 --> 00:16:32,820
И success и failure — это две функции,

243
00:16:32,980 --> 00:16:37,740
которые принимают параметры за счет типа.

244
00:16:42,140 --> 00:16:45,420
Если проводить аналогию с
пульсами, это такой вариант,

245
00:16:45,700 --> 00:16:48,920
в котором лежат string и int.

246
00:16:50,560 --> 00:16:51,960
И как в варианте,

247
00:16:52,080 --> 00:16:53,640
мы можем по индексу спросить,

248
00:16:53,920 --> 00:16:56,260
какой из вариантов лежит.

249
00:16:57,540 --> 00:17:01,120
То есть у нас они протеганы,

250
00:17:01,560 --> 00:17:07,040
в отличие от union, у нас есть
доступ к тому, что мы можем спросить,

251
00:17:07,160 --> 00:17:09,160
какой из вариантов лежит
сделать pattern matching.

252
00:17:10,250 --> 00:17:13,360
И давайте реализуем saveDiff.

253
00:17:14,320 --> 00:17:15,420
Если у нас деление на 0,

254
00:17:15,560 --> 00:17:18,520
то мы кидаем ошибку, грубо говоря.

255
00:17:19,780 --> 00:17:21,280
Такой способ обрабатывать ошибки.

256
00:17:21,740 --> 00:17:25,200
Мы возвращаем сообщение.

257
00:17:26,160 --> 00:17:27,160
Вот.

258
00:17:29,000 --> 00:17:30,000
ShowResult.

259
00:17:32,100 --> 00:17:33,480
Собственно, да.

260
00:17:37,800 --> 00:17:38,800
Вот так вот.

261
00:17:39,240 --> 00:17:40,240
Все понятно.

262
00:17:40,880 --> 00:17:41,880
Давайте дальше.

263
00:17:42,760 --> 00:17:44,540
Параметрические суммы могут быть легко.

264
00:17:44,880 --> 00:17:46,000
Допустим, у нас есть вектор,

265
00:17:46,380 --> 00:17:53,741
и мы хотим с ним работать как с
вектором, вне зависимости от того,

266
00:17:53,880 --> 00:17:57,160
сколько там 2D это вектор или 3D.

267
00:17:59,950 --> 00:18:01,720
Ну, такие игрушечные примеры.

268
00:18:02,240 --> 00:18:04,640
Наверное, нет у них
большого смысла, но, в общем,

269
00:18:07,650 --> 00:18:11,860
можно писать функцию, которая
из обоих вариантов делает список.

270
00:18:13,920 --> 00:18:14,920
Посчитать длину.

271
00:18:17,100 --> 00:18:19,060
Собственно, да.

272
00:18:19,530 --> 00:18:20,640
Превращаем все в список.

273
00:18:20,740 --> 00:18:23,120
И дальше берем сумму квадратов,

274
00:18:23,640 --> 00:18:24,640
корень суммы квадратов,

275
00:18:24,800 --> 00:18:25,800
и, собственно,

276
00:18:30,130 --> 00:18:31,840
всякие конкретные примеры.

277
00:18:33,300 --> 00:18:34,920
Да, и при этом, понятно,

278
00:18:35,280 --> 00:18:36,640
все еще конструкты — это функции,

279
00:18:36,760 --> 00:18:40,800
просто теперь эти функции полиморфные.

280
00:18:45,160 --> 00:18:46,160
А вот вопрос.

281
00:18:46,400 --> 00:18:51,160
В самой первой строчке у нас
написано «вектор А» после даты.

282
00:18:51,560 --> 00:18:52,700
Это полностью название?

283
00:18:53,200 --> 00:18:54,820
Ну, типа, «А» — это что такое?

284
00:18:55,680 --> 00:18:56,680
«А» — это параметр.

285
00:18:56,960 --> 00:18:59,140
Это тип параметра.

286
00:19:00,970 --> 00:19:02,820
А, типа, генерик какой-то?

287
00:19:03,250 --> 00:19:04,400
Типа, type name А.

288
00:19:06,950 --> 00:19:09,300
Да, это генерик.

289
00:19:21,750 --> 00:19:27,340
Да, и вектор, собственно, «АА» —

290
00:19:28,065 --> 00:19:31,640
это немножко такой, на мой взгляд,

291
00:19:31,910 --> 00:19:33,190
немножко странноватый синтаксис.

292
00:19:36,730 --> 00:19:37,770
Довольно легко привыкнуть.

293
00:19:39,100 --> 00:19:41,400
Ну, типа, если бы мы
использовали в конструкторе

294
00:19:41,401 --> 00:19:44,080
какие-то дефолтные
типы, а не генерики,

295
00:19:44,200 --> 00:19:46,360
то нам бы не нужно
было «вектор А» указать.

296
00:19:46,440 --> 00:19:48,340
Достаточно было бы
просто написать «вектор».

297
00:19:48,341 --> 00:19:49,341
Дата, вектор равно.

298
00:19:51,060 --> 00:19:57,680
Да, если мы не используем... Если у
нас тип не параметризован никаким типом,

299
00:19:57,780 --> 00:20:00,780
то мы как бы не пишем никаких
аргументов, как это было там с юзером.

300
00:20:03,480 --> 00:20:04,480
Ну, понятно.

301
00:20:04,600 --> 00:20:05,600
Да, спасибо.

302
00:20:09,460 --> 00:20:10,460
Да.

303
00:20:14,150 --> 00:20:19,570
То есть, по факту, мы это делаем,
чтобы сузить возможный аргумент,

304
00:20:20,170 --> 00:20:21,830
типа, аргумент, который мы можем принять.

305
00:20:22,250 --> 00:20:23,890
То есть, грубо говоря, мы сузили до того,

306
00:20:24,100 --> 00:20:27,170
что у нас должны быть аргументы
в векторе 2D и в векторе 3D

307
00:20:28,090 --> 00:20:29,410
строго одного и того же типа.

308
00:20:30,610 --> 00:20:33,550
То есть, что они там не могут
быть разных типов, там, int и string.

309
00:20:36,520 --> 00:20:37,650
Да, да, да.

310
00:20:37,850 --> 00:20:42,470
То есть, это как темплейты,
грубо говоря, в плюсах.

311
00:20:43,970 --> 00:20:44,870
Да, все верно.

312
00:20:44,910 --> 00:20:46,590
Это действительно как темплейты в плюсах.

313
00:20:47,410 --> 00:20:49,130
Ну, то есть, и то, и то.

314
00:20:49,210 --> 00:20:52,470
Это способ создать генерик,

315
00:20:52,690 --> 00:20:54,610
тип проэматризованный типом.

316
00:20:58,130 --> 00:21:05,970
И да, если мы делаем более полиморфный тип,

317
00:21:06,590 --> 00:21:08,510
мы с ним меньше чего можем сделать,

318
00:21:08,690 --> 00:21:15,390
потому что у нас меньше
информации о типе и у нас

319
00:21:15,440 --> 00:21:16,350
меньше способов облажаться
в некотором смысле.

320
00:21:16,450 --> 00:21:20,670
Если мы правильно
задизайнили тип и мы все еще

321
00:21:20,730 --> 00:21:21,770
можем сделать все, что
мы хотим с ним делать,

322
00:21:21,890 --> 00:21:25,170
то да, каких-то вариантов,

323
00:21:25,310 --> 00:21:27,290
что мы можем сделать не так, меньше.

324
00:21:27,450 --> 00:21:28,450
Это правда.

325
00:21:32,190 --> 00:21:36,170
А можно несколько конструкторов с
одинаковым названием, но разными типами?

326
00:21:38,450 --> 00:21:39,450
К сожалению, нет.

327
00:21:40,970 --> 00:21:49,660
Потому что в Haskell нет такой штуки,

328
00:21:49,860 --> 00:21:50,620
как оверлоадинг.

329
00:21:50,780 --> 00:21:53,280
То есть не может быть
одной и той же функции

330
00:21:53,380 --> 00:21:58,020
с разными реализациями,
как в плюсах, например.

331
00:21:58,660 --> 00:22:03,100
Но есть способ сделать

332
00:22:04,290 --> 00:22:06,100
такой ad-hoc полиморфизм,
как он называется,

333
00:22:06,920 --> 00:22:09,000
но с конструкторами это не совсем прокатит.

334
00:22:09,200 --> 00:22:10,760
Потому что, допустим,

335
00:22:11,620 --> 00:22:12,900
мы все еще хотим их различать.

336
00:22:12,980 --> 00:22:15,040
Если мы делаем pattern
match, мы хотим знать,

337
00:22:15,200 --> 00:22:19,140
мы сматчились на, не знаю,
на что-то name конструктор

338
00:22:19,690 --> 00:22:22,120
и как понять, сколько у него параметров.

339
00:22:23,295 --> 00:22:25,095
То есть мы все еще
хотим их как-то различать.

340
00:22:27,320 --> 00:22:31,720
Да, есть некоторые неудобства, возможно,

341
00:22:32,685 --> 00:22:34,520
если мы, допустим, не знаю,

342
00:22:35,280 --> 00:22:38,620
можно представить себе ситуацию, какая-то
неудобная, но как бы это некоторые трейдов,

343
00:22:39,045 --> 00:22:43,520
что все остальное продолжает работать.

344
00:22:50,380 --> 00:22:52,020
Давайте закончим эту главу все-таки.

345
00:23:02,690 --> 00:23:04,550
Еще последний вещь,
которую я хотел сказать.

346
00:23:04,740 --> 00:23:06,670
Понятно, если мы вызовем функцию

347
00:23:11,250 --> 00:23:12,970
Vector2D242 со стрингами,

348
00:23:13,090 --> 00:23:15,630
что-нибудь вызовем,
один будет VectorInt,

349
00:23:16,750 --> 00:23:19,530
на выходе другой будет
VectorString, это будут разные типы.

350
00:23:19,690 --> 00:23:20,730
Ну, понятно.

351
00:23:24,115 --> 00:23:26,450
И мы их никак не просоцировать не сможем.

352
00:23:28,510 --> 00:23:30,930
То есть нет какого-то
общего типа у них вектор.

353
00:23:33,640 --> 00:23:34,850
Это скорее как плюсах.

354
00:23:34,851 --> 00:23:37,170
Это совершенно разные
классы, разные типы.

355
00:23:37,690 --> 00:23:38,770


356
00:23:40,330 --> 00:23:42,130
Так, окей, значит, maybe,

357
00:23:42,870 --> 00:23:44,290
значит, очень полезный тип.

358
00:23:44,450 --> 00:23:48,430
А можно еще по параметрам такой вопрос?

359
00:23:48,950 --> 00:23:53,310
Мы можем как-нибудь из вот
типа вектора, который у нас здесь,

360
00:23:53,470 --> 00:23:54,770
который параметризованный,

361
00:23:55,230 --> 00:23:56,930
можем ли мы из него сделать

362
00:23:57,205 --> 00:24:00,470
его непараметризованный аналог
для какого-то конкретного типа?

363
00:24:01,030 --> 00:24:03,330
Взять и вычли из него вектор от Int?

364
00:24:06,040 --> 00:24:07,830
Ну, ты можешь написать TypeAlias,

365
00:24:08,930 --> 00:24:09,930
IntVector,

366
00:24:10,910 --> 00:24:13,250
TypeIntVector равно VectorInt.

367
00:24:14,290 --> 00:24:18,340
То есть можешь.

368
00:24:19,000 --> 00:24:20,000
Да, все можно.

369
00:24:20,200 --> 00:24:22,120
То есть можно сделать TypeAlias,

370
00:24:22,240 --> 00:24:23,460
можно сделать NewType,

371
00:24:23,580 --> 00:24:25,000
NewType будет дальше.

372
00:24:26,160 --> 00:24:27,480
Мы как бы разберем это тоже.

373
00:24:31,820 --> 00:24:32,820
Окей, давайте дальше.

374
00:24:35,180 --> 00:24:36,420
Все можно, сейчас увидим.

375
00:24:36,620 --> 00:24:38,420
Думаю, что вопросы сами эти отпадут.

376
00:24:38,660 --> 00:24:40,400
В общем, давайте разберем maybe.

377
00:24:40,680 --> 00:24:44,840
Maybe, значит, похожая штука,
только мы, похожая штука,

378
00:24:45,000 --> 00:24:48,020
что из IntResult, только у нас
здесь как бы более общий тип.

379
00:24:49,120 --> 00:24:52,740
То есть у нас можно вспомнить,
что это некоторые вычисления,

380
00:24:53,140 --> 00:24:55,640
то есть некоторые результаты
вычисления, которые имеют тип A,

381
00:24:56,000 --> 00:24:57,220
и у него она может свейлиться,

382
00:24:57,650 --> 00:24:59,130
то есть может вернуть просто nothing.

383
00:24:59,220 --> 00:25:00,460
То есть, по сути, это optional.

384
00:25:00,520 --> 00:25:01,520
Optional в плюсах.

385
00:25:02,080 --> 00:25:06,680
Не помню, наверное, в Java
тоже есть что-то похожее.

386
00:25:07,260 --> 00:25:13,780
В общем, да, это некий подход,

387
00:25:13,940 --> 00:25:17,460
чтобы моделировать нул-пойнтеры,

388
00:25:18,350 --> 00:25:20,540
то есть либо pointer, либо null.

389
00:25:24,380 --> 00:25:25,500
С помощью этого можно писать

390
00:25:26,200 --> 00:25:28,540
некоторые такие безопасные функции,

391
00:25:28,660 --> 00:25:31,400
типа maybe second, то есть
взять второй элемент массива,

392
00:25:31,760 --> 00:25:33,760
но если как бы не получилось
его взять, то nothing.

393
00:25:33,900 --> 00:25:34,900


394
00:25:38,000 --> 00:25:38,840
Безопасные в том смысле,

395
00:25:38,940 --> 00:25:42,480
что мы можем легко
проверить результат работы.

396
00:25:44,260 --> 00:25:51,960
У нас нет какого-то ошибки,
которые мы не можем поймать.

397
00:25:52,540 --> 00:25:53,760
В общем, исключение.

398
00:25:56,755 --> 00:25:59,080
Плюс maybe, забегая вперед,
это monad, очень полезная.

399
00:26:01,310 --> 00:26:02,100


400
00:26:02,300 --> 00:26:04,960
То есть мы можем
использовать ее для вычислений,

401
00:26:07,160 --> 00:26:08,200
композировать вычисления,

402
00:26:09,030 --> 00:26:10,030
которые нам дают,

403
00:26:10,780 --> 00:26:12,040
могут вернуть ошибку или нет.

404
00:26:12,580 --> 00:26:14,400
Это все будет в следующей лекции.

405
00:26:15,240 --> 00:26:17,640
В общем, можно представить,

406
00:26:17,760 --> 00:26:20,080
что maybe это некий такой бокс,

407
00:26:20,200 --> 00:26:21,840
некая коробка, в которой
либо есть что-то, либо нет.

408
00:26:21,841 --> 00:26:22,841


409
00:26:23,520 --> 00:26:26,160
То есть это значение и некоторый контекст,

410
00:26:28,250 --> 00:26:30,260
который еще называют эффект.

411
00:26:32,390 --> 00:26:33,710
Пока это, наверное, просто слова.

412
00:26:33,860 --> 00:26:36,060
Дальше будет все более понятна аналогия.

413
00:26:37,000 --> 00:26:41,340
А можно вопрос по поводу в коде
предпоследней строчкой, тут maybe second,

414
00:26:41,640 --> 00:26:43,740
и дальше аргумент в скобках.

415
00:26:44,220 --> 00:26:45,220
Можно это расшифровать?

416
00:26:45,900 --> 00:26:48,500
Да, это происходит
pattern matching по листу.

417
00:26:51,990 --> 00:26:54,960
Значит, у листа есть конструктор,

418
00:26:55,420 --> 00:26:57,020
он принимает два аргумента.

419
00:26:57,120 --> 00:27:00,260
Он принимает элемент и список,

420
00:27:00,880 --> 00:27:02,900
то есть хвост, head и хвост.

421
00:27:05,320 --> 00:27:06,396
Ну и, понятно, возвращается список.

422
00:27:06,420 --> 00:27:07,420
То есть мы сматчились.

423
00:27:08,540 --> 00:27:09,660
По сути, что тут происходит?

424
00:27:09,700 --> 00:27:12,380
Первый underscore значит первый элемент,

425
00:27:12,860 --> 00:27:14,040
x значит второй элемент,

426
00:27:14,490 --> 00:27:20,180
а второй placeholder
значит остальной список.

427
00:27:23,640 --> 00:27:26,100
То есть мы вызвали просто
just от второго элемента списка?

428
00:27:27,340 --> 00:27:28,340
Да.

429
00:27:28,700 --> 00:27:29,700
Спасибо.

430
00:27:30,240 --> 00:27:32,020
То есть что мы сделали?

431
00:27:32,140 --> 00:27:34,880
Мы взяли x, передали в конструктор,

432
00:27:35,480 --> 00:27:36,480
и нам вернулся maybe.

433
00:27:36,620 --> 00:27:40,260
То есть мы завернули наше
значение в эту коробку maybe

434
00:27:41,040 --> 00:27:42,840
и вернули пользователю.

435
00:27:43,920 --> 00:27:45,620
А он же там сам будет проверять,

436
00:27:46,250 --> 00:27:47,480
есть что-то в коробке или нет.

437
00:27:54,445 --> 00:27:55,620
Так, ну давайте дальше.

438
00:27:57,320 --> 00:28:04,040
Azure – другой способ обрабатывать ошибки,

439
00:28:04,420 --> 00:28:07,980
когда мы хотим знать
какое-то еще сообщение.

440
00:28:08,880 --> 00:28:11,840
Ну или тег какой-то нашей ошибки,

441
00:28:13,030 --> 00:28:14,220
строковый, не строковый.

442
00:28:14,320 --> 00:28:18,100
В общем, left значит, что все, капут,

443
00:28:18,980 --> 00:28:20,760
у нас вычисление исправилось,

444
00:28:20,940 --> 00:28:24,800
right значит, что нормально вычислилось.

445
00:28:25,280 --> 00:28:26,760
И вот, например, azure second.

446
00:28:28,380 --> 00:28:29,700
Опять делаем matching,

447
00:28:33,330 --> 00:28:34,970
проверяем, какие у нас могут быть ошибки,

448
00:28:35,270 --> 00:28:37,300
разбираем случаи и возвращаем right x,

449
00:28:37,440 --> 00:28:38,440
если все хорошо.

450
00:28:39,310 --> 00:28:50,060
Да, ну и такой маленький совет, что
надо смотреть за порядком матчинга.

451
00:28:51,180 --> 00:28:52,300
Потому что в прошлой лекции,

452
00:28:53,425 --> 00:28:58,410
вы знаете, что нужно в правильном порядке

453
00:28:58,660 --> 00:28:59,710
заставлять потом матчинг,

454
00:28:59,850 --> 00:29:01,710
потому что он идет сверху вниз,

455
00:29:02,090 --> 00:29:04,250
всегда проверяется.

456
00:29:06,410 --> 00:29:09,070
Ну и вот ссылочка на какое-то обсуждение,

457
00:29:09,220 --> 00:29:12,550
у нас такое info про ошибку в
функциональном программировании.

458
00:29:13,025 --> 00:29:16,110
Интересная тема, много вариантов есть.

459
00:29:18,170 --> 00:29:19,170
С вами проблемами.

460
00:29:19,770 --> 00:29:20,770
Давайте дальше.

461
00:29:21,090 --> 00:29:22,090
Рекурсивность.

462
00:29:22,470 --> 00:29:23,470
Ну, понятно.

463
00:29:23,870 --> 00:29:25,390
Дошли наконец-то до листа.

464
00:29:25,970 --> 00:29:27,070
Типы могут быть рекурсивны.

465
00:29:27,350 --> 00:29:31,450
То есть мы можем использовать в параметре
сам тип, который мы сейчас определяем,

466
00:29:31,690 --> 00:29:33,230
тем самым получая рекурсивные типы.

467
00:29:37,490 --> 00:29:39,890
В общем, у нас есть два
конструктора, nil и cons.

468
00:29:41,110 --> 00:29:42,110


469
00:29:42,590 --> 00:29:44,490
nil – это просто пустой список,

470
00:29:44,630 --> 00:29:47,910
cons – это head, хвост.

471
00:29:49,240 --> 00:29:53,230
И мы возвращаем уже наш тип.

472
00:29:53,870 --> 00:29:56,650
Понятно, вот список из 2, 1, 3.

473
00:29:59,310 --> 00:30:00,330
Можно писать свой мэп.

474
00:30:00,730 --> 00:30:01,730
Вот, пожалуйста.

475
00:30:05,740 --> 00:30:06,740
Ну да.

476
00:30:07,200 --> 00:30:09,460
Отличие от реального листа только в том,

477
00:30:09,590 --> 00:30:14,720
что у нас конструктор
у листа – это оператор.

478
00:30:14,960 --> 00:30:17,800
То есть мы не пишем cons, мы просто
используем оператор в двоеточии.

479
00:30:19,700 --> 00:30:23,340
Ну и плюс там еще какой-то
синтаксический сахар сверху всего этого.

480
00:30:25,100 --> 00:30:26,100
Вот.

481
00:30:27,540 --> 00:30:28,540
Да.

482
00:30:33,340 --> 00:30:35,820
Ну да, собственно, вот определение,

483
00:30:36,880 --> 00:30:40,900
как оно могло бы быть в
основном в библиотеке.

484
00:30:43,850 --> 00:30:46,540
Ну да, и у нас еще есть
специальный синтез для типа,

485
00:30:46,900 --> 00:30:49,980
потому что у нас имени для листа нет.

486
00:30:51,500 --> 00:30:53,980
У нас квадратные скобки для
этого используются, для краткости.

487
00:30:57,350 --> 00:30:59,390
Не уверен, кстати, что это
можно самому определить.

488
00:30:59,810 --> 00:31:01,860
Мне кажется, это
вшито скорее в язык,

489
00:31:01,960 --> 00:31:05,800
но, в общем, потому
что здесь используется.

490
00:31:06,560 --> 00:31:07,560
Хорошо.

491
00:31:09,350 --> 00:31:11,460
Извините, а можете, пожалуйста, объяснить,

492
00:31:11,640 --> 00:31:13,560
что происходит в myList,

493
00:31:13,900 --> 00:31:18,160
когда myList равно cons 2, cons 1, cons 3.

494
00:31:19,610 --> 00:31:20,680
Да, давайте, смотрите.

495
00:31:21,780 --> 00:31:22,780
Ну еще раз.

496
00:31:22,970 --> 00:31:28,220
Мы читаем эту запись, читаем ее по порядку,

497
00:31:32,730 --> 00:31:35,020
как мы вычисляем лямбдовыражение.

498
00:31:35,350 --> 00:31:39,060
То есть в самом начале
вычисляется, грубо говоря, внутреннее.

499
00:31:39,590 --> 00:31:41,200
Мы парсим это.

500
00:31:42,160 --> 00:31:42,800
Что тут происходит?

501
00:31:42,920 --> 00:31:44,480
Функция cons, сам внутри.

502
00:31:45,720 --> 00:31:48,240
Ей передается два параметра, 3 и nil.

503
00:31:49,480 --> 00:31:53,260
То есть смотрим, совпадает
это ли с сигнатурой.

504
00:31:53,400 --> 00:31:54,020
Да, совпадает.

505
00:31:54,120 --> 00:31:57,480
То есть мы передаем 3 и nil.

506
00:31:57,840 --> 00:32:01,320
И в итоге эта скобка имеет тип list.

507
00:32:02,230 --> 00:32:04,200
Дальше следующий конс принимает 1.

508
00:32:05,600 --> 00:32:07,180
И вот эту скобку, которую мы поняли,

509
00:32:07,300 --> 00:32:10,860
что тоже возвращает list int.

510
00:32:11,830 --> 00:32:12,960
То есть опять мы возвращаем.

511
00:32:14,310 --> 00:32:19,720
Опять внешняя скобка, вот этот тоже list.

512
00:32:21,220 --> 00:32:23,860
Мы конструируем наш список.

513
00:32:25,350 --> 00:32:26,740
Получается будет длиной 3.

514
00:32:28,480 --> 00:32:29,780
Да, да.

515
00:32:31,075 --> 00:32:37,240
То есть мы сделали просто... Это
тип или что это? Это переменная.

516
00:32:37,540 --> 00:32:38,540


517
00:32:44,100 --> 00:32:45,520
Это не функция, я так понимаю.

518
00:32:45,860 --> 00:32:46,860
Константы.

519
00:32:47,280 --> 00:32:48,280
Константы, да.

520
00:32:50,080 --> 00:32:51,180
Это философский вопрос.

521
00:32:51,480 --> 00:32:52,480
Все функции.

522
00:32:55,690 --> 00:33:01,580
Сори, я до этого читал курс по теории
типов, поэтому у меня немножко сдвиг.

523
00:33:04,140 --> 00:33:06,440
Константы и функции
большой разницы не имеют.

524
00:33:07,730 --> 00:33:10,380
Функция, которая понимает
ноль аргументов, это константы.

525
00:33:17,650 --> 00:33:19,500
Ну да, это константы.

526
00:33:20,520 --> 00:33:24,260
Не переменные, потому что у
нас все немутабельное пока что.

527
00:33:25,540 --> 00:33:26,860
Потом будут переменные.

528
00:33:28,400 --> 00:33:30,000
Сразу видно, как они выглядят.

529
00:33:30,001 --> 00:33:35,760
Ну, в общем, да.

530
00:33:35,940 --> 00:33:40,690
То есть еще раз.

531
00:33:40,810 --> 00:33:42,750
Давайте такая интуиция.

532
00:33:42,850 --> 00:33:43,670
Что такое конструктор?

533
00:33:43,750 --> 00:33:44,870
Конструктор это функция.

534
00:33:44,970 --> 00:33:46,150
В целом обычная функция.

535
00:33:46,370 --> 00:33:49,410
У нее есть сигнатура,
которая принимает элемент,

536
00:33:52,460 --> 00:33:56,010
принимает хвост списка и возвращает список,
прибавляя к нему вот этот один элемент.

537
00:33:57,235 --> 00:34:00,730
Но при этом она еще и
является представлением типа.

538
00:34:00,731 --> 00:34:05,390
То есть, грубо говоря, посмотрев на то,

539
00:34:05,450 --> 00:34:10,550
как мы определили этот
список из трех элементов,

540
00:34:10,630 --> 00:34:14,190
мы можем понять, как оно
и в памяти представляется.

541
00:34:14,310 --> 00:34:15,610
Оно точно так же представляется.

542
00:34:16,050 --> 00:34:20,070
То есть у нас есть тег
конструктора, его параметры.

543
00:34:21,070 --> 00:34:25,930
И второй параметр это
тоже лист, у которого тег конс

544
00:34:27,750 --> 00:34:29,270
и два параметра и так далее.

545
00:34:30,220 --> 00:34:34,550
То есть у нас такая как
бы древовидная структура.

546
00:34:35,350 --> 00:34:38,150
В общем, если вы напишите это на вариантах,

547
00:34:38,280 --> 00:34:41,710
в плюсах, будет так же выглядеть.

548
00:34:44,460 --> 00:34:47,770
В нормальной ситуации мы здесь не
увидим скобок, а тут будут доллары.

549
00:34:49,690 --> 00:34:50,690
Что?

550
00:34:50,960 --> 00:34:53,790
Ну, где вот моя лист
равна конус 2, конус 1.

551
00:34:57,050 --> 00:35:01,180
Сейчас, не понял.

552
00:35:02,955 --> 00:35:04,120
По какую строчку вы говорите?

553
00:35:05,120 --> 00:35:07,660
Моя лист равна конус 2, конус 1.

554
00:35:09,040 --> 00:35:10,720
Там будут вместо скобок деньги.

555
00:35:13,020 --> 00:35:14,020
Ну, да.

556
00:35:15,600 --> 00:35:17,900
Можно продать скобки, получить деньги.

557
00:35:18,120 --> 00:35:21,440
Можно написать везде доллары без проблем.

558
00:35:24,260 --> 00:35:29,440
Потому что конструкторы нормальной функции,
они так же композируются без проблем.

559
00:35:33,480 --> 00:35:35,860
А вот где мы определяем...

560
00:35:36,460 --> 00:35:43,080
Я правильно понимаю, что вот этот
тип представляет просто нам список?

561
00:35:45,840 --> 00:35:47,160
Да, это просто список.

562
00:35:47,995 --> 00:35:51,560
А вот где мы определяем... Ну,
допустим, мы написали конус 1, конус 3.

563
00:35:52,420 --> 00:35:56,360
И почему оно переводится в список?

564
00:35:56,720 --> 00:35:59,300
То есть мы же потом обращаемся в MyMap

565
00:35:59,550 --> 00:36:02,400
как к первому элементу и хвосту.

566
00:36:03,540 --> 00:36:05,680
Но, допустим, не особо видно.

567
00:36:06,280 --> 00:36:11,080
То есть у нас есть у списка
конструктор с двоеточием.

568
00:36:13,190 --> 00:36:17,700
Но когда мы делаем... Мы просто определили
тут какой-то конструктор с именем конус,

569
00:36:18,450 --> 00:36:21,640
и не определили, как он
работает, или я что-то не понял?

570
00:36:22,900 --> 00:36:25,760
Вот, окей, смотри, я понял вопрос.

571
00:36:26,810 --> 00:36:29,000
Мы нигде не определяем,
как работает конструктор.

572
00:36:29,480 --> 00:36:32,100
В этом смысле разница
между конструкторами в плюсах

573
00:36:32,101 --> 00:36:37,700
и конструкторами в функциональных
языках в algebraических типах данных.

574
00:36:38,180 --> 00:36:46,000
Конструктор представляет собой
просто структуру, структуру типа.

575
00:36:46,950 --> 00:36:47,950
Он никак не работает.

576
00:36:48,280 --> 00:36:50,000
Он как бы...

577
00:36:54,400 --> 00:36:56,890
Ну, не знаю, если я
скажу... Я понял, о чем вы.

578
00:36:57,130 --> 00:36:58,730
Датакласс, ты понимаешь, о чем я говорю?

579
00:36:59,210 --> 00:37:00,410
Да, я понимаю, о чем вы.

580
00:37:00,530 --> 00:37:05,430
Я тогда не понимаю просто, почему мы
там можем обращаться как к голове и хвосту.

581
00:37:05,695 --> 00:37:07,950
Как он определяет, что есть голова,
что есть хвост? По параметрам.

582
00:37:09,150 --> 00:37:10,150


583
00:37:11,480 --> 00:37:13,190
Ты матчишься типа на...

584
00:37:14,630 --> 00:37:16,330
То есть еще раз, вот MyMap как работает.

585
00:37:16,530 --> 00:37:20,570
Мы делаем паттерн-матчинг по листу.

586
00:37:20,970 --> 00:37:22,310
Это либо nil, либо cons.

587
00:37:22,790 --> 00:37:23,890
Это switch-кейс такой.

588
00:37:25,060 --> 00:37:26,170
Мы делаем кейс.

589
00:37:26,750 --> 00:37:29,870
Мы видим, что если nil, вернем nil.

590
00:37:30,930 --> 00:37:34,470
Если cons, то мы матчимся на параметрах,

591
00:37:34,630 --> 00:37:36,930
и мы знаем, что есть x, а есть xs.

592
00:37:39,200 --> 00:37:42,470
Значит, x это первый
параметр, он имеет тип a,

593
00:37:42,690 --> 00:37:45,190
и xs это второй параметр,
он имеет тип лист a.

594
00:37:45,191 --> 00:37:47,650
Вот мы сматчились на...

595
00:37:47,900 --> 00:37:48,910
Я все понял, да, спасибо.

596
00:37:49,910 --> 00:37:52,030
То есть это такие как бы дата-классы.

597
00:37:53,650 --> 00:37:55,190
В питоне есть...

598
00:37:56,980 --> 00:37:58,661
В общем, это класс, который представлен...

599
00:37:58,970 --> 00:38:02,730
Его определение класса,
это то, какая у него структура.

600
00:38:08,360 --> 00:38:11,080
То есть в плюсах, как
ты пишешь конструкцию,

601
00:38:11,160 --> 00:38:16,520
ты можешь написать какое-то сложное
определение, как конструировать твой тип,

602
00:38:16,820 --> 00:38:18,846
сделать какие-то вычисления
перед этим, еще что-то.

603
00:38:18,870 --> 00:38:19,880
Здесь это все не нужно.

604
00:38:20,590 --> 00:38:25,160
Здесь ты сначала пишешь,
как у тебя представляется тип,

605
00:38:25,640 --> 00:38:27,596
а дальше ты можешь просто
рядом написать функцию,

606
00:38:27,620 --> 00:38:29,660
какую-то умную, которая
конструирует этот тип,

607
00:38:30,620 --> 00:38:32,460
используя меньшее
количество данных, например,

608
00:38:32,660 --> 00:38:34,760
что-то вычисляя или еще что-то.

609
00:38:34,940 --> 00:38:37,340
Она просто рядом, сбоку.

610
00:38:39,470 --> 00:38:40,500
Да, я все понял, спасибо.

611
00:38:46,390 --> 00:38:49,320
Дата от TypeAlias отличается
только конструктором?

612
00:38:52,140 --> 00:38:53,480
Она много чем отличается.

613
00:38:54,570 --> 00:38:58,180
TypeAlias это просто
синтоксический сакр, грубо говоря.

614
00:38:59,045 --> 00:39:00,880
Грубо говоря, это макрос такой.

615
00:39:01,260 --> 00:39:03,800
Везде, где мы пишем имя alias,

616
00:39:03,920 --> 00:39:05,700
мы можем подставить его определение.

617
00:39:06,660 --> 00:39:09,140
Ну, по сути, перед
определением просто

618
00:39:09,141 --> 00:39:10,141
напишешь имя конструктора
и получишь TypeAlias.

619
00:39:10,710 --> 00:39:11,740
Ну, и как там дата?

620
00:39:12,360 --> 00:39:17,000
Нет, это разные вещи, потому что, когда
мы пишем дата, мы определяем новый тип.

621
00:39:18,440 --> 00:39:22,420
Мы не можем заменить
его на какое-то определение,

622
00:39:22,580 --> 00:39:24,600
то есть мы определяем новый тип.

623
00:39:25,850 --> 00:39:29,020
Принципиальная разница, мы определяем
новый тип или мы создаем просто синоним.

624
00:39:29,340 --> 00:39:30,820
Синоним это не новый тип.

625
00:39:31,300 --> 00:39:34,440
Он совпадает совершенно с его определением.

626
00:39:43,800 --> 00:39:48,300
Ну, типа, в плюсах есть,
опять, понятные плюсы.

627
00:39:48,730 --> 00:39:50,140
Типа, using это алиас.

628
00:39:51,915 --> 00:39:53,080
Класс это новый тип.

629
00:39:53,500 --> 00:39:54,500
Это разные вещи.

630
00:39:58,350 --> 00:40:01,150
Мы дальше увидим что-то между ними,

631
00:40:01,650 --> 00:40:02,650
какую-то конструкцию.

632
00:40:03,410 --> 00:40:04,710
Думаю, что будет понятнее.

633
00:40:05,970 --> 00:40:08,830
Хорошо, значит, по героическому
типу данных есть еще вопросы?

634
00:40:11,820 --> 00:40:13,230
У нас лекция не сложная.

635
00:40:13,630 --> 00:40:14,670
Я думаю, что есть вопросы.

636
00:40:19,450 --> 00:40:20,450
Ок, давайте дальше.

637
00:40:21,310 --> 00:40:25,930
Значит, как это называется
по-русски? Записи.

638
00:40:26,570 --> 00:40:27,570
Нанозаписи.

639
00:40:29,690 --> 00:40:30,310


640
00:40:30,650 --> 00:40:34,070
В общем, я буду говорить с рекорды.

641
00:40:34,310 --> 00:40:38,710
Значит, у нас есть возможность
определить рекорды.

642
00:40:38,711 --> 00:40:45,250
Это, по сути, такие кюплы
с именованными полями.

643
00:40:47,450 --> 00:40:49,030
В общем, да.

644
00:40:49,590 --> 00:40:54,790
Можно представить, как такой синтактический
сахар, просто с такими гетерами,

645
00:40:57,420 --> 00:40:59,210
которые написаны на правом слайде.

646
00:40:59,750 --> 00:41:01,170
То есть, понятно.

647
00:41:01,430 --> 00:41:04,950
Опять же, логин, пасвод это просто функции,

648
00:41:05,400 --> 00:41:08,010
которые определяются вместе с типом.

649
00:41:10,460 --> 00:41:14,070
Есть специальный синтаксис для определения.

650
00:41:16,610 --> 00:41:18,030
Понятно.

651
00:41:18,890 --> 00:41:24,550
В общем, хотим спросить,
чему равен какое-то поле.

652
00:41:25,850 --> 00:41:35,830
Взяли сначала у юзера, примели
функцию логин к рекорду юзера,

653
00:41:36,690 --> 00:41:41,810
получили строчку, сравнили с Иваном.

654
00:41:41,965 --> 00:41:44,030
Если Иван, то вернули трубку.

655
00:41:46,010 --> 00:41:48,090
Собственно, да, хоть понятно.

656
00:41:49,150 --> 00:41:50,470
Значит, паттерн-матчинг.

657
00:41:50,720 --> 00:41:55,390
Мы можем делать паттерн-матчинг
на рекордах очень удобно.

658
00:41:55,610 --> 00:41:59,530
То есть, если мы хотим сматчить
только какой-то один элемент,

659
00:42:00,170 --> 00:42:04,690
можем сделать такой
синтаксис фигурной скобки логин

660
00:42:04,790 --> 00:42:08,270
равный юзернейм, где
логин, первое, это имя поля,

661
00:42:08,730 --> 00:42:09,810
юзернейм это переменная,

662
00:42:11,830 --> 00:42:16,430
которую мы хотим забиндить,
привязать к этому значению.

663
00:42:17,430 --> 00:42:19,990
То есть, опять, какую
проблему мы здесь решаем?

664
00:42:20,010 --> 00:42:21,370
Если у нас, допустим, есть юзер,

665
00:42:21,690 --> 00:42:27,450
как в самом начале нашей лекции,
возвращаясь к ней, у нас есть два стринга.

666
00:42:28,065 --> 00:42:32,090
Есть логин и что-то еще, пасворд.

667
00:42:32,490 --> 00:42:35,070
Чтобы их не перепутать, они оба стринг,

668
00:42:35,590 --> 00:42:38,690
мы их именуем, и теперь
мы должны все представить,

669
00:42:38,930 --> 00:42:41,710
что юзернейм это именно логин и пасворд.

670
00:42:46,580 --> 00:42:49,110
Можем делать паттерн-матчинг такой вот.

671
00:42:51,320 --> 00:42:54,550
В любом паттерн-матчинге мы
можем записать вместо переменной,

672
00:42:55,250 --> 00:42:56,910
которую мы хотим забиндить значение,

673
00:42:57,250 --> 00:42:58,670
можем писать само значение,

674
00:42:58,810 --> 00:43:01,870
тогда будет поверх то, что это равно имя.

675
00:43:03,190 --> 00:43:05,150
В общем, очень удобно.

676
00:43:06,430 --> 00:43:11,190
Есть такой специальный
синтаксис update-синтакс.

677
00:43:12,110 --> 00:43:15,470
В смысле, мы хотим взять Ivan,

678
00:43:17,040 --> 00:43:19,570
взять запись и поменять только одно поле,

679
00:43:19,790 --> 00:43:21,970
а все остальные оставить на своем месте.

680
00:43:23,025 --> 00:43:28,530
Это, кажется, называется
как-то функциональное

681
00:43:28,590 --> 00:43:33,050
обновление, что ли,
в оперативном мире.

682
00:43:34,130 --> 00:43:43,220
В общем, да, у нас все иммутабельное,
поэтому мы вынуждены скопировать весь объект,

683
00:43:43,420 --> 00:43:44,620
но поменять только одно поле.

684
00:43:45,040 --> 00:43:50,060
Чтобы не писать слишком много,
есть такой удобный синтаксис.

685
00:43:51,580 --> 00:43:52,840
Там прям все копируются, да?

686
00:43:54,740 --> 00:43:57,540
Ну как, по сути, да.

687
00:43:58,340 --> 00:44:00,160
Но как это представляется, вопрос.

688
00:44:01,900 --> 00:44:05,160
Скорее всего, копируется...

689
00:44:06,760 --> 00:44:08,480
В общем, если не лезть глубоко,

690
00:44:08,780 --> 00:44:11,880
какие-то вещи могут просто
скопироваться как ссылки, грубо говоря.

691
00:44:12,200 --> 00:44:13,320
Но копируется все, да.

692
00:44:22,060 --> 00:44:28,350
В общем, операторы...

693
00:44:29,290 --> 00:44:38,650
Да, собственно, полем
могут быть операторы тоже.

694
00:44:39,860 --> 00:44:43,250
Честно говоря, я никогда не видел
это, чтобы оно так использовалось.

695
00:44:43,450 --> 00:44:48,030
Но, в общем, может быть, это удобно.

696
00:44:48,850 --> 00:44:49,950
В общем, да.

697
00:44:50,680 --> 00:44:52,450
Понятно, операторы — это просто функции.

698
00:44:55,120 --> 00:44:59,270
И, в общем, тут получается, у
нас мы сделали такой тип данных R,

699
00:44:59,530 --> 00:45:02,750
у которого есть оператор,
который делает что-то с n,

700
00:45:02,930 --> 00:45:04,430
например, прибавляет 1.

701
00:45:04,730 --> 00:45:11,250
Это будет конкретный
какой-то... По сути, один объект

702
00:45:11,251 --> 00:45:12,530
типа R — это какой-то
оператор, который что-то делает.

703
00:45:13,110 --> 00:45:20,770
И дальше мы можем через
стрелочку его применить к числу.

704
00:45:22,780 --> 00:45:26,030
То есть можно с помощью этого
какой-то прикольный синдекс создавать.

705
00:45:28,110 --> 00:45:31,290
В общем, enjoy.

706
00:45:33,910 --> 00:45:34,910
Понятно.

707
00:45:35,930 --> 00:45:39,470
Мы можем использовать
вместе суммы типов и записи.

708
00:45:40,300 --> 00:45:43,870
Например, person — это
может быть админ или юзер.

709
00:45:44,630 --> 00:45:48,590
У них одинаковые поля, но
не совсем одинаковые поля.

710
00:45:48,850 --> 00:45:51,370
Но даже если они были одинаковые,
мы их можем всегда различить.

711
00:45:56,210 --> 00:45:59,390
Есть такой нюанс, что, допустим,
у нас есть теперь функция login.

712
00:45:59,710 --> 00:46:00,350
Что же она делает?

713
00:46:00,470 --> 00:46:07,370
Она принимает person и
возвращает поле юзера или админа.

714
00:46:07,920 --> 00:46:13,330
Но если мы вызовем UID, то
для админа она не определена,

715
00:46:13,480 --> 00:46:15,080
потому что у нее просто нет такого поля.

716
00:46:16,830 --> 00:46:21,390
То есть эта функция не полная.

717
00:46:22,550 --> 00:46:26,350
Она может упасть, что может
быть потенциально опасно.

718
00:46:27,590 --> 00:46:32,790
То есть лучше бы написать какой-нибудь
типа maybe UID или что-то такое.

719
00:46:32,791 --> 00:46:36,970
В общем, можно все безопаснее сделать.

720
00:46:38,050 --> 00:46:39,530
По дефолту оно, к сожалению, вот так.

721
00:46:41,690 --> 00:46:44,470
Да, собственно, можно писать
функцию проверки, что это админ.

722
00:46:46,570 --> 00:46:48,450
Тут такой синдекс тоже.

723
00:46:48,890 --> 00:46:55,570
Если нам неважно, какие поля находятся,
мы можем проверить, это юзер или админ,

724
00:46:56,010 --> 00:46:57,870
пишутся пустые фигурные скобки.

725
00:47:00,430 --> 00:47:01,310
Это важно.

726
00:47:01,410 --> 00:47:04,270
По-моему, нельзя просто
написать фигурные скобки.

727
00:47:06,730 --> 00:47:09,270
В смысле, опустить фигурные
скобки и просто написать админ.

728
00:47:11,470 --> 00:47:12,470
Но это не точно.

729
00:47:13,250 --> 00:47:17,770
В общем, можно написать
админ и подчеркивать.

730
00:47:20,390 --> 00:47:21,550
А не одно подчеркивание?

731
00:47:23,910 --> 00:47:24,991
Одно, по-моему, нельзя, да?

732
00:47:25,070 --> 00:47:26,070
Два надо написать.

733
00:47:26,660 --> 00:47:31,490
Да, тут есть такой прикол, что в
целом у нас все еще есть функция админ,

734
00:47:31,690 --> 00:47:35,290
которая принимает int и
string и возвращает нам person.

735
00:47:36,170 --> 00:47:39,810
То есть мы можем
использовать как рекорд синдекс,

736
00:47:40,980 --> 00:47:43,170
так и просто обычные конструкторы.

737
00:47:48,130 --> 00:47:51,130
Потому что, как мы поняли, рекорд это
тоже синдексический саппорт, по сути.

738
00:47:55,610 --> 00:47:56,610
Окей.

739
00:47:57,430 --> 00:47:59,990
Есть некоторые проблемы с этим.

740
00:48:00,640 --> 00:48:04,090
То, что, допустим, у нас есть два типа
данных, у которых одинаковые имена,

741
00:48:04,490 --> 00:48:06,110
одинаковые имена полей.

742
00:48:08,570 --> 00:48:10,190
Что такое функция name здесь?

743
00:48:12,620 --> 00:48:15,510
Она не может принимать
совершенно любой тип.

744
00:48:16,970 --> 00:48:20,090
Это другая ситуация по сравнению
с логином, который здесь был.

745
00:48:20,790 --> 00:48:24,490
Потому что тут можно
нормально выписать

746
00:48:24,590 --> 00:48:26,070
сигнатуру функции
логина, а тут уже нельзя.

747
00:48:26,520 --> 00:48:28,850
То есть это либо main, либо cat. Непонятно.

748
00:48:30,450 --> 00:48:38,170
И, в общем, одно из решений не
использовать одинаковые поля,

749
00:48:40,490 --> 00:48:43,290
что может быть как бы...

750
00:48:43,540 --> 00:48:47,330
В целом это возможно, и я думаю,
что на практике тоже многие так делают.

751
00:48:47,790 --> 00:48:52,890
То есть дальше мы посмотрим, какие
Haskell предоставляет возможности

752
00:48:52,891 --> 00:48:57,770
для сокрытия какой-то
реализации через модули.

753
00:48:58,755 --> 00:49:02,470
То есть не все совсем плохо.

754
00:49:04,940 --> 00:49:14,230
Также есть расширение, которое
пытается убрать такое неудобство.

755
00:49:14,430 --> 00:49:18,950
Мы добавляем это расширение,
пишем language duplicated record fields,

756
00:49:19,700 --> 00:49:25,990
и после этого у нас создается
некий статистический сакр,

757
00:49:26,130 --> 00:49:33,310
который при компиляции делает
эти неймы, эти функции разными.

758
00:49:34,180 --> 00:49:41,270
И пытается из контекста понять,
какая из них используется заменить.

759
00:49:41,720 --> 00:49:50,590
И, например, у нас есть какая-то
функция, которая принимает main

760
00:49:51,390 --> 00:49:55,690
и использует функцию name к
нему, но тут проблема есть некая,

761
00:49:55,840 --> 00:50:01,430
что нам приходится
указывать явно тип функции,

762
00:50:02,170 --> 00:50:06,270
потому что иначе он не может догадаться...

763
00:50:06,445 --> 00:50:10,730
Далеко не во всех случаях он может
догадаться, какая функция name используется.

764
00:50:14,120 --> 00:50:16,670
В общем, есть нюансы с этим.

765
00:50:22,170 --> 00:50:26,110
Но да, для паттерн-матчинга
это спокойно работает.

766
00:50:27,090 --> 00:50:32,210
То есть для некоторых случаев это работает
всегда, например, для паттерн-матчинга,

767
00:50:32,785 --> 00:50:36,590
а для применения функции
приходится выписывать тип.

768
00:50:37,170 --> 00:50:40,610
Ну, в общем, некоторые трейдовы опять.

769
00:50:42,550 --> 00:50:44,070
Когда-то удобно одно, когда-то другое.

770
00:50:51,850 --> 00:50:53,780
Значит, давайте дальше.

771
00:50:54,380 --> 00:50:58,200
Да, вот тут есть ссылочка, кстати,
обратите внимание, про inference.

772
00:51:00,060 --> 00:51:02,460
Собственно, как это примерно работает.

773
00:51:04,660 --> 00:51:05,860
Вот это расширение.

774
00:51:06,860 --> 00:51:13,280
Так, record wildcard,
значит, тоже удобная штука.

775
00:51:13,620 --> 00:51:17,300
Допустим, у нас есть юзер, у
него есть опять вот эти поля,

776
00:51:17,850 --> 00:51:24,300
и мы хотим сматчиться...

777
00:51:29,380 --> 00:51:34,540
Да, смотрите, тут суть в том, что мы не
хотим выписывать все поля совершенно.

778
00:51:34,740 --> 00:51:43,200
То есть мы хотим на них сматчиться, но
просто на те имена, которые у них есть.

779
00:51:43,325 --> 00:51:51,200
То есть мы просто пишем в
синдексе с UID 0, 1, 2 точки,

780
00:51:52,060 --> 00:51:56,700
и дальше мы можем использовать
как UID, так и логин, и пасворд.

781
00:52:00,040 --> 00:52:06,800
Если мы не хотим матчиться на
поля или их как-то переименовывать,

782
00:52:07,110 --> 00:52:09,800
мы просто пишем 2, 2 точки и используем их.

783
00:52:10,540 --> 00:52:12,480
Понятно, еще один синтезический сахар.

784
00:52:13,990 --> 00:52:16,580
И для этого нужно подключить
расширение record wildcard.

785
00:52:23,120 --> 00:52:28,920
Да, и это даже работает с duplicate fields,
что реально выглядит немножко как магия.

786
00:52:36,330 --> 00:52:44,110
Окей, ну, собственно, мы
переприсвоили name из man.

787
00:52:46,890 --> 00:52:49,950
Окей, new type. Очень интересная штука.

788
00:52:50,170 --> 00:52:57,070
В общем, у нас есть 2 синтаксиса,
data message и new type, имя типа.

789
00:52:58,880 --> 00:53:06,110
Сразу скажу, что у Haskell
очень странное название типов.

790
00:53:06,390 --> 00:53:11,810
Есть data, которое можно как-то
еще просоцировать с датаклассом,

791
00:53:11,910 --> 00:53:16,070
а new type это новый тип, но
как бы data это тоже новый тип.

792
00:53:16,230 --> 00:53:22,170
В общем, не обращайте внимания на
название, скорее запоминайте, в чем суть.

793
00:53:23,760 --> 00:53:26,465
То есть если data это
какой-то общий тип, то

794
00:53:26,477 --> 00:53:29,070
new type это некоторый
его частный случай,

795
00:53:29,830 --> 00:53:36,950
когда у типа всего один
конструктор и, возможно, одно поле.

796
00:53:37,310 --> 00:53:39,351
То есть оно может быть
именованное, может быть нет.

797
00:53:40,790 --> 00:53:42,470
В общем, в чем прикол?

798
00:53:42,530 --> 00:53:46,136
Прикол в том, что если у
нас всего один конструктор,

799
00:53:46,148 --> 00:53:49,070
мы можем как бы
избавиться вообще от тега.

800
00:53:49,170 --> 00:53:51,691
То есть когда мы делаем
паттерн-матч, у нас всего один вариант.

801
00:53:52,970 --> 00:53:55,810
По сути, паттерн-матч можно вообще убрать.

802
00:53:57,540 --> 00:54:01,344
И на самом деле Haskell
поступает намного умнее,

803
00:54:01,356 --> 00:54:05,410
он вообще не делает между
ними различий в рантайме.

804
00:54:06,290 --> 00:54:12,190
То есть после компиляции у нас нет
различия между месседжем и стрингом.

805
00:54:14,340 --> 00:54:19,510
То есть мы используем, как бы,
мы вводим новый тип, месседж.

806
00:54:21,510 --> 00:54:22,870
Он отличается от всех остальных.

807
00:54:23,050 --> 00:54:28,390
И в compile-time он будет проводиться
проверки, в отличие от type-alias.

808
00:54:29,050 --> 00:54:32,550
Но в рантайме это будет одно и то же.

809
00:54:34,520 --> 00:54:39,430
То есть мы получаем больше
гарантии, не платя за это реформенсом.

810
00:54:43,465 --> 00:54:46,590
Собственно, давайте посмотрим на примере.

811
00:54:49,080 --> 00:54:52,564
Значит, да, тут такой
предысторий к примеру,

812
00:54:52,576 --> 00:54:56,390
что у нас есть какая-то
функция derivePublicKey.

813
00:54:57,070 --> 00:55:01,510
Она как бы из публичного
ключа дает секретный ключ.

814
00:55:01,990 --> 00:55:04,850
Есть функция, которая
проверяет пару, что она корректная.

815
00:55:06,390 --> 00:55:10,170
И, в общем, у нас publicKey и
secretKey это один и тот же тип.

816
00:55:11,510 --> 00:55:16,330
То есть, грубо говоря, легко их
перепутать, и последствия будут страшные.

817
00:55:17,330 --> 00:55:21,950
То есть мы используем типы,
но они нам не особо помогают.

818
00:55:22,210 --> 00:55:23,650
Как сделать так, чтобы они помогали?

819
00:55:24,030 --> 00:55:27,910
Давайте просто скажем, что
publicKey и secretKey — это разные типы.

820
00:55:28,370 --> 00:55:30,910
И после этого мы никогда
не сможем их перепутать.

821
00:55:32,150 --> 00:55:34,656
То есть как мы не можем
перепутать int и bool,

822
00:55:34,668 --> 00:55:37,350
точно так же мы не можем
перепутать эти два типа.

823
00:55:40,290 --> 00:55:45,130
И теперь у нас derivePublicKey
имеет осмысленную сигнатуру.

824
00:55:45,770 --> 00:55:50,770
То есть это не просто из string в
string, так же как функция inside.

825
00:55:53,770 --> 00:55:57,430
А это конкретный тип
из secretKey в publicKey.

826
00:55:57,431 --> 00:56:01,110
И на самом деле это один из
способов прототипирования в Haskell.

827
00:56:02,030 --> 00:56:06,307
То есть ты сначала думаешь
о типах, пишешь только

828
00:56:06,319 --> 00:56:10,170
типы, а потом уже пишешь
для них реализацию.

829
00:56:11,480 --> 00:56:14,470
Причем не реализуя все
в правильном порядке.

830
00:56:16,730 --> 00:56:21,950
Да, ну и, собственно, функция checkKeyPair
тоже выглядит теперь более осмысленно.

831
00:56:25,080 --> 00:56:29,070
И мем, что если код не компилируется,
он не может работать неправильно.

832
00:56:30,850 --> 00:56:31,850
Прекрасно.

833
00:56:33,750 --> 00:56:35,470
Так, какие вопросы по
newType? Есть? Окей.

834
00:56:49,200 --> 00:56:50,200


835
00:56:51,280 --> 00:56:52,280
Меня же слышно еще?

836
00:56:53,950 --> 00:56:55,440
Да, хорошо слышно, все прекрасно.

837
00:56:55,720 --> 00:56:56,900
Хорошо, идем дальше.

838
00:56:57,460 --> 00:57:02,360
Type классы. Самое, наверное,
интересное в этой лекции, на мой вкус.

839
00:57:02,435 --> 00:57:06,440
В общем, ad-hoc полиморфизм.
Что значит ad-hoc?

840
00:57:09,540 --> 00:57:13,688
В общем, это значит,
что мы используем то, что

841
00:57:13,700 --> 00:57:17,860
мы сейчас хотим
использовать, то и используем.

842
00:57:18,160 --> 00:57:22,200
Грубо говоря, мы из контекста
использования понимаем, что нам нужно.

843
00:57:22,860 --> 00:57:27,780
Например, overloading в плюсах —
это тоже ad-hoc, типа полиморфизм.

844
00:57:28,030 --> 00:57:35,780
Мы пишем функцию плюс, и
независимо от того, что мы...

845
00:57:36,030 --> 00:57:37,898
Мы не указываем, какой
конкретный плюс мы

846
00:57:37,910 --> 00:57:40,020
используем, оно просто
выводится из контекста.

847
00:57:40,500 --> 00:57:44,240
Если рядом стоят строки, мы
складываем строки — это одна реализация.

848
00:57:44,340 --> 00:57:46,300
Если мы складываем числи
— это другая реализация.

849
00:57:47,160 --> 00:57:49,880
И, собственно, мы посмотрим,
как такие же штуки делать в Haskell.

850
00:57:52,680 --> 00:57:54,980
Значит, у нас есть type
классы, это называется.

851
00:57:55,740 --> 00:57:59,000
Мы, значит, классы типов.

852
00:57:59,360 --> 00:58:02,740
Мы объявляем это с помощью
следующего синтеза — класс printable P.

853
00:58:03,540 --> 00:58:04,720
Это интерфейс.

854
00:58:04,840 --> 00:58:08,334
То есть мы говорим, что у
нас есть некоторый интерфейс,

855
00:58:08,346 --> 00:58:11,660
которому некоторые типы
могут удовлетворять или нет.

856
00:58:12,180 --> 00:58:14,640
То есть какие-то типы могут
входить в этот класс или нет.

857
00:58:15,190 --> 00:58:21,260
Значит, этот интерфейс обязует
реализовать следующие функции.

858
00:58:21,745 --> 00:58:25,480
printme, который
принимает, собственно, тип P.

859
00:58:26,150 --> 00:58:30,360
P — это, собственно, тот класс,
который будет реализовывать.

860
00:58:30,880 --> 00:58:32,960
Это тот тип, который будет
реализовывать этот класс.

861
00:58:33,840 --> 00:58:40,100
И, собственно, простыми словами, это класс
объектов, который мы можем распечатать.

862
00:58:40,350 --> 00:58:42,320
Распечатать куда-то в
конце, в строчку, в общем.

863
00:58:44,920 --> 00:58:49,760
И, допустим, у нас есть некоторый
класс просто enum из foo и bar.

864
00:58:52,910 --> 00:58:58,720
И, значит, да, то есть тут
давайте это немножко опустим.

865
00:58:59,440 --> 00:59:02,940
Значит, дальше мы можем
написать, значит, instance.

866
00:59:03,340 --> 00:59:11,980
То есть объявить то, что наш тип
foo удовлетворяет этому интерфейсу.

867
00:59:12,220 --> 00:59:13,420
То есть его можно распечатать.

868
00:59:14,140 --> 00:59:16,020
Для этого нужно
реализовать функцию printme.

869
00:59:18,290 --> 00:59:22,240
Вот так это работает.

870
00:59:22,840 --> 00:59:29,740
Значит, понятно, у нас есть тут кейворды.

871
00:59:29,960 --> 00:59:31,580
Класс — это определение класса.

872
00:59:31,840 --> 00:59:34,000
Инстанс — это определение инстанса.

873
00:59:34,565 --> 00:59:38,960
Определение того, что мы...
Определение имплементации.

874
00:59:39,380 --> 00:59:40,820
Инстанс — это имплементация.

875
00:59:41,740 --> 00:59:43,280
Класс — это интерфейс.

876
00:59:45,940 --> 00:59:46,580
Вот.

877
00:59:46,940 --> 00:59:53,380
И теперь, допустим, мы хотим
использовать этот type class,

878
00:59:53,640 --> 00:59:57,400
чтобы написать некую
полиморфную функцию, собственно,

879
00:59:57,600 --> 00:59:59,280
которая использует этот полиморфизм.

880
00:59:59,480 --> 00:59:59,500
Как?

881
01:00:00,120 --> 01:00:02,040
Мы пишем, допустим, helloP.

882
01:00:02,330 --> 01:00:07,020
Это некая функция,
которая принимает объект

883
01:00:07,080 --> 01:00:08,080
и печатает его в консоль,
добавляя там hello.

884
01:00:08,870 --> 01:00:12,620
И мы хотим потребовать,

885
01:00:13,580 --> 01:00:16,300
что обязательно P, которое
мы хотим распечатать,

886
01:00:16,680 --> 01:00:19,300
должно удовлетворять интерфейсу printableP.

887
01:00:20,450 --> 01:00:23,960
То есть, говоря на других языках,

888
01:00:24,160 --> 01:00:29,840
это значит, что мы проверяем
из instance of P printable.

889
01:00:30,930 --> 01:00:33,440
То есть, если P удовлетворяет
этому интерфейсу,

890
01:00:34,140 --> 01:00:37,420
то тогда у нас type checking проходит.

891
01:00:37,800 --> 01:00:38,800
Иначе он не проходит.

892
01:00:39,560 --> 01:00:41,940
То есть, огромный плюс всего этого,

893
01:00:42,000 --> 01:00:45,440
что все эти проверки происходят
в compile-time, а не в run-time.

894
01:00:47,600 --> 01:00:52,160
Да, собственно, так это можно выглядеть.

895
01:00:53,080 --> 01:00:59,520
Ошибки, если мы передадим true, для
которого мы не реализовали наш интерфейс,

896
01:00:59,640 --> 01:01:02,760
то нам скажут, что sorry,
не могу найти instance.

897
01:01:03,160 --> 01:01:06,280
То есть, не могу найти
реализацию этого дела.

898
01:01:06,875 --> 01:01:14,700
В общем, давайте посмотрим
какие-то базовые примеры всего этого.

899
01:01:15,440 --> 01:01:17,060
Допустим, type class equal.

900
01:01:20,990 --> 01:01:25,020
То есть, это интерфейс объектов,
которые можно сравнивать на равно.

901
01:01:26,080 --> 01:01:28,240
Ну и соответственно, если
есть равно, есть и не равно.

902
01:01:29,275 --> 01:01:35,580
И дальше мы видим один пример
такого классного аспекта в Haskell.

903
01:01:36,010 --> 01:01:39,380
То, что можно писать интерфейсы
с дефолтными реализациями.

904
01:01:39,820 --> 01:01:41,740
Здесь мы объявили сначала типы.

905
01:01:42,800 --> 01:01:45,920
Не обязательно делать это
прям так, можно это писать рядом.

906
01:01:46,310 --> 01:01:56,440
То есть, тип, потом ниже реализация,
как это обычно пишут на топ-левеле.

907
01:01:57,870 --> 01:01:59,520
Но смотрите, в чем тут соль.

908
01:01:59,790 --> 01:02:03,580
То, что у нас есть дефолтная
реализация для обоих методов.

909
01:02:03,680 --> 01:02:05,000
И она взаимно рекурсивная.

910
01:02:05,120 --> 01:02:07,316
То есть, мы равно
можем реализовать через

911
01:02:07,328 --> 01:02:09,860
неровно, неровно можем
реализовать через равно.

912
01:02:10,300 --> 01:02:16,220
И плюс этого, что мы
даем выбор пользователю,

913
01:02:16,520 --> 01:02:20,920
точнее, пользователю нашего
интерфейса, кто будет реализовывать его.

914
01:02:21,660 --> 01:02:25,100
Если мы реализуем только равно,
то мы получим сразу оба метода.

915
01:02:25,350 --> 01:02:31,000
То есть, по сути, у нас
просто дефолтная реализация

916
01:02:31,100 --> 01:02:34,980
перекроется реализацией,
которая в инстанте написана.

917
01:02:35,840 --> 01:02:44,380
Или, допустим, для какого-то типа сложно
написать равно, удобнее написать неровно.

918
01:02:45,620 --> 01:02:47,340
Немножко игрушечный пример, но все же.

919
01:02:47,585 --> 01:02:50,200
В общем, он может реализовать
только функцию неровно,

920
01:02:50,960 --> 01:02:52,520
и у него будет автоматом функция равно.

921
01:02:53,350 --> 01:02:57,420
И дальше есть специальная
директива, которая добавляет...

922
01:02:58,620 --> 01:02:59,901
Собственно, все это проверяется.

923
01:03:00,090 --> 01:03:05,740
То есть, комператор должен удостовериться,
что ты реализовал все нужные функции.

924
01:03:06,840 --> 01:03:10,308
Но тут такая проблема,
что может быть так, что у

925
01:03:10,320 --> 01:03:13,800
тебя функции реализованы,
но взаимно рекурсивно.

926
01:03:15,180 --> 01:03:16,840
Чтобы такого не было,
есть специальная директива,

927
01:03:16,841 --> 01:03:22,320
которая указывает, какие наборы
операторов ты должен реализовать.

928
01:03:23,360 --> 01:03:25,080
Какие из них является полными, а какие нет.

929
01:03:28,450 --> 01:03:33,440
Ну и также, если мы хотим как-то
оптимизировать оба оператора,

930
01:03:33,700 --> 01:03:36,020
мы можем это сделать без проблем.

931
01:03:40,490 --> 01:03:50,820
Да, но, кажется, чтобы писать
вот эти типы, явно выписывать

932
01:03:50,920 --> 01:03:54,180
типы для операторов, нужно
instance.sig расширение.

933
01:03:57,380 --> 01:04:00,680
Это нужно, чтобы в
реализации выписывать тип.

934
01:04:01,920 --> 01:04:04,900
Чтобы явно написать тип в
реализации, нужно вот этот instance.

935
01:04:05,245 --> 01:04:08,200
В общем, можно просто
всегда использовать, и все.

936
01:04:14,520 --> 01:04:16,600
Смотрим теперь,
допустим, здесь TrafficLight.

937
01:04:17,120 --> 01:04:24,900
Мы реализуем для него интерфейс
ик таким естественным образом.

938
01:04:25,175 --> 01:04:27,440
Матчимся на всех парах, которые равны.

939
01:04:27,560 --> 01:04:29,040
Все остальные пары false.

940
01:04:29,880 --> 01:04:30,880
Все понятно.

941
01:04:30,970 --> 01:04:37,920
Теперь у нас есть instance
TrafficLight, и мы можем сравнивать.

942
01:04:40,060 --> 01:04:43,780
Ниже еще один пример, как
написать полиморфную функцию,

943
01:04:43,860 --> 01:04:48,020
которая, допустим, берет три
объекта, которые можно сравнивать,

944
01:04:48,560 --> 01:04:50,540
и проверяет, что они все три равны.

945
01:04:51,950 --> 01:04:58,680
То есть пишем полиморфный
код и радуемся жизни.

946
01:05:00,820 --> 01:05:02,680
Потому что не нужно
делать какое-то копипасту.

947
01:05:03,860 --> 01:05:05,640
Давайте посмотрим следующий пример.

948
01:05:06,920 --> 01:05:11,460
Ордеринг, когда мы хотим
проверить на равенство.

949
01:05:11,790 --> 01:05:14,751
Когда мы проверили на равенство,
теперь мы хотим проверить на неравенство.

950
01:05:14,780 --> 01:05:18,400
В общем, понятно, что если
мы проверяем на неравенство,

951
01:05:18,401 --> 01:05:24,220
то для этого нужно, чтобы
изначально интерфейс

952
01:05:24,310 --> 01:05:25,351
удовлетворял свойства,
что у него есть равенство.

953
01:05:25,735 --> 01:05:30,300
Мы расширяем наш type класс,
добавляем в него две функции,

954
01:05:30,570 --> 01:05:32,720
и с помощью этого у нас
есть специальный синтезис.

955
01:05:33,220 --> 01:05:38,720
Опять же, eq равно больше, такая стрелочка.

956
01:05:43,190 --> 01:05:47,540
Эта стрелочка обозначает, что мы
предоставляем требования к типу A.

957
01:05:48,520 --> 01:05:56,220
Справа от стрелочки обычный тип, а слева от
стрелочки constraint, то есть ограничение.

958
01:05:56,860 --> 01:06:04,780
И как это было для функции, мы объявляем,
что тип A должен удовлетворять constraint,

959
01:06:05,120 --> 01:06:10,220
это ограничение, что у
него должен быть instance eq.

960
01:06:10,560 --> 01:06:12,200
И также мы объявляем это для класса.

961
01:06:12,350 --> 01:06:17,960
То есть мы объявляем класс для
тех типов, для которых уже есть eq.

962
01:06:19,300 --> 01:06:32,220
Ну и понятно, дальше мы можем в дефолтной
реализации использовать те методы,

963
01:06:33,170 --> 01:06:36,260
которые мы потребовали,
что существуют у этих типов.

964
01:06:37,660 --> 01:06:40,620
Ну и тут видно, зачем нужна
вот эта дефолтная реализация.

965
01:06:40,621 --> 01:06:49,300
То есть можно реализовать
compare, как это, 3-way comparing,

966
01:06:49,640 --> 01:06:55,020
типа spaceship оператор в плюсах.

967
01:06:55,640 --> 01:06:58,050
В общем, одну функцию
достаточно реализовать

968
01:06:58,062 --> 01:07:00,540
и автоматно получить
все остальные операторы,

969
01:07:00,920 --> 01:07:02,480
которые несложно выражаются через него.

970
01:07:04,900 --> 01:07:07,320
В общем, да, вот такая штука.

971
01:07:08,900 --> 01:07:13,140
Да, ну и опять же какие-то
ссылочки для монетного чтения.

972
01:07:14,135 --> 01:07:19,060
Ну, значит, числа в
Haskell тоже полиморфные.

973
01:07:19,460 --> 01:07:22,637
То есть если мы пишем
семерка, это просто, на

974
01:07:22,649 --> 01:07:25,980
самом деле, как бы
семерка некоторого типа num.

975
01:07:26,340 --> 01:07:33,580
То есть она может быть и
флотовая, так и целочисленная.

976
01:07:34,420 --> 01:07:38,400
И, значит, давайте посмотрим, вот
прям так выглядит базовый тип num.

977
01:07:39,360 --> 01:07:43,040
У него есть плюс, минус, умножить.

978
01:07:43,180 --> 01:07:45,709
Прошу прощения,
а minimal.complete.

979
01:07:45,721 --> 01:07:47,640
definition в Word надо
было написать или нет?

980
01:07:52,660 --> 01:07:58,580
Нет, смотрите, у нас есть compare и...

981
01:08:03,250 --> 01:08:04,250
Ща.

982
01:08:05,130 --> 01:08:06,366
Хороший вопрос, кстати, сейчас.

983
01:08:06,390 --> 01:08:07,070
У нас получается как?

984
01:08:07,400 --> 01:08:10,150
У нас compare реализован
через меньше либо равно.

985
01:08:11,480 --> 01:08:12,480
И равно, да?

986
01:08:12,520 --> 01:08:15,870
То есть мы можем реализовать либо
compare, либо меньше, либо равно.

987
01:08:18,410 --> 01:08:19,970
Ну, учитывая, что у нас есть равно уже.

988
01:08:26,400 --> 01:08:29,430
Наверное, можно написать типа
compare или меньше, либо равно.

989
01:08:29,550 --> 01:08:31,350
Возможно, тут просто опущены для краткости.

990
01:08:32,500 --> 01:08:35,310
А может быть, какие-то вещи
компилятор сам умеет выводить.

991
01:08:37,810 --> 01:08:39,491
Может быть, я не знаю, за последнее время.

992
01:08:40,210 --> 01:08:41,950
Может выводить больше или меньше, в общем.

993
01:08:42,510 --> 01:08:45,330
Поэтому это немножко на
расширениях все еще остается,

994
01:08:45,490 --> 01:08:50,450
потому что не совсем стабильная штука.

995
01:08:50,705 --> 01:08:53,410
То есть что-то может
компилятор вывести, а что-то нет.

996
01:08:56,390 --> 01:08:59,270
А раз уж вернулись, можете,
пожалуйста, еще раз повторить.

997
01:09:00,070 --> 01:09:06,230
Где у нас написано
class ик а стрелочка орт а.

998
01:09:06,390 --> 01:09:07,390
Еще раз, что это значит?

999
01:09:11,960 --> 01:09:17,650
Это означает, что мы определяем
интерфейс орт для типа а

1000
01:09:19,380 --> 01:09:25,450
и требуем, чтобы для него уже
был реализован интерфейс ик.

1001
01:09:27,610 --> 01:09:30,390
То есть, когда мы будем
определять instance орт,

1002
01:09:31,040 --> 01:09:34,150
мы перед этим обязаны объявить instance ик.

1003
01:09:34,580 --> 01:09:35,580
Все, понял, спасибо.

1004
01:09:37,170 --> 01:09:40,130
Мы расширяем интерфейс, грубо говоря.

1005
01:09:40,770 --> 01:09:47,390
То есть это некоторый такой
способ расширения интерфейса,

1006
01:09:48,770 --> 01:09:49,770
который у нас уже есть.

1007
01:09:52,490 --> 01:09:55,250
Так, раз уж мы остановились, время 12.

1008
01:09:55,450 --> 01:09:56,790
Мы начали в 10.40.

1009
01:09:56,791 --> 01:09:57,791
Сколько?

1010
01:09:59,060 --> 01:10:00,850
Пошло почти полтора часа.

1011
01:10:01,590 --> 01:10:02,830
Хотите ли вы сделать перерыв?

1012
01:10:05,770 --> 01:10:08,490
Ну, по идее, минут 10,
если как-то вместится.

1013
01:10:13,910 --> 01:10:17,150
В целом мы больше половины
рассмотрели, мне кажется.

1014
01:10:17,430 --> 01:10:21,790
Поэтому можно сделать перерыв.

1015
01:10:21,791 --> 01:10:22,830
Вот.

1016
01:10:24,380 --> 01:10:25,890
Ну, давайте, сколько? 10, 5 минут.

1017
01:10:28,310 --> 01:10:29,310
Давайте 10.

1018
01:10:29,890 --> 01:10:31,150
10, ок.

1019
01:10:31,660 --> 01:10:34,790
12.10, тогда возвращаемся.

1020
01:10:41,870 --> 01:10:44,020
Можете какие-то вопросы задать, если есть.

1021
01:11:05,790 --> 01:11:07,830
Да, вопрос был в слайде 19.1.

1022
01:11:11,660 --> 01:11:13,050
19.1...

1023
01:11:15,090 --> 01:11:16,330
Вот этот?

1024
01:11:18,700 --> 01:11:22,070
Да, что за оператор такой,
стрелочка с двумя адефисами,

1025
01:11:22,290 --> 01:11:23,930
и не будет ли это считаться комментарием?

1026
01:11:26,130 --> 01:11:28,390
Потому что он у вас
выделил, ну, подчеркнулся.

1027
01:11:28,630 --> 01:11:29,630
Да-да-да.

1028
01:11:30,520 --> 01:11:32,230
Я, честно говоря, не уверен.

1029
01:11:39,190 --> 01:11:41,970
У меня в репле тоже не
получилось, я не особо встал.

1030
01:11:43,240 --> 01:11:45,550
Ну, да, то есть как бы это такое себе...

1031
01:11:53,660 --> 01:11:54,660
Ну...

1032
01:11:56,570 --> 01:11:57,930
Может, это пример неудачный.

1033
01:11:58,190 --> 01:12:00,010
Может, так можно сделать.

1034
01:12:12,130 --> 01:12:15,110
И на 28-ом слайде там еще
hype-классы, а не type-классы.

1035
01:12:15,270 --> 01:12:16,511
Я не знаю, может, это intended?

1036
01:12:19,660 --> 01:12:20,730
Возможно, это intended.

1037
01:12:22,410 --> 01:12:23,150
Короче, я не знаю.

1038
01:12:23,310 --> 01:12:27,170
Ну, не знаю, поменяй на
Unicode стрелочку, типа.

1039
01:12:29,150 --> 01:12:33,010
Ну, грубо говоря, типа... Сейчас, а
три тоже нельзя, да? Три адефиса.

1040
01:12:33,650 --> 01:12:34,650


1041
01:12:36,470 --> 01:12:37,010
Ну...

1042
01:12:37,310 --> 01:12:38,310
Блин, сейчас.

1043
01:12:38,430 --> 01:12:40,430
Может, надо в хугле просто забить,

1044
01:12:40,550 --> 01:12:42,030
есть там такие операторы или нет.

1045
01:12:43,750 --> 01:12:44,750
Есть, слушай.

1046
01:12:45,010 --> 01:12:46,010
Есть такие операторы.

1047
01:12:46,730 --> 01:12:47,730
Значит, как-то можно.

1048
01:12:48,170 --> 01:12:50,170
Может, это проблемы чисто репла?

1049
01:12:53,870 --> 01:12:54,870
Наверняка, спасибо.

1050
01:12:57,040 --> 01:13:01,250
А можно вот еще раз объяснить,
что значит фигурные скобочки?

1051
01:13:01,750 --> 01:13:04,670
Это, получается, мы
объявляем функции в них?

1052
01:13:06,515 --> 01:13:07,515
Что мы делаем?

1053
01:13:08,400 --> 01:13:11,270
Фигурные скобки — это синтексис рекордов,

1054
01:13:11,370 --> 01:13:12,950
синтексис записей.

1055
01:13:19,110 --> 01:13:20,110
Ну вот.

1056
01:13:21,370 --> 01:13:23,510
А запись — это сокращение от того,

1057
01:13:23,630 --> 01:13:26,290
что мы делали до
этого? Или как бы.

1058
01:13:26,770 --> 01:13:28,210
..

1059
01:13:28,360 --> 01:13:34,410
Запись — это такое понятие, как
бы это тюпл с помеченными полями.

1060
01:13:39,540 --> 01:13:41,560
То есть мы, грубо говоря, дали имя...

1061
01:13:44,920 --> 01:13:46,360
Аргументам компьютера, грубо говоря.

1062
01:13:48,360 --> 01:13:49,360
Да.

1063
01:13:51,380 --> 01:13:52,840
Это такие геттеры.

1064
01:13:55,900 --> 01:13:56,900
А?

1065
01:13:57,650 --> 01:14:00,440
Ну, учитывая то, что
все это, по сути, функции,

1066
01:14:01,465 --> 01:14:02,560
это вот такие геттеры.

1067
01:14:03,600 --> 01:14:06,220
Ну да, вот по сути, вот слайд,
собственно, который на экране,

1068
01:14:08,780 --> 01:14:10,720
мы просто, ну, как бы статистически сахар.

1069
01:14:10,910 --> 01:14:11,910
Типа мы...

1070
01:14:13,770 --> 01:14:15,800
дали имена, значит, полям.

1071
01:14:17,750 --> 01:14:21,020
То же самое, что просто объявить геттеры.

1072
01:14:29,670 --> 01:14:30,950
Вроде бы очень тихо,

1073
01:14:31,110 --> 01:14:32,390
но может быть это только у меня.

1074
01:14:32,690 --> 01:14:33,910
Нет, у меня тоже.

1075
01:14:35,070 --> 01:14:36,070
Можно вопрос?

1076
01:14:36,275 --> 01:14:38,630
Вопрос по поводу 20-теряжного слайда,

1077
01:14:40,340 --> 01:14:44,370
где мы объявляли базовый пассворд.

1078
01:14:44,970 --> 01:14:46,251
Здесь же мы, как бы, получается,

1079
01:14:46,510 --> 01:14:48,790
что объявили в борде функцию compare,

1080
01:14:50,050 --> 01:14:53,210
и операторы меньше, меньше,
равно, больше, равно, больше.

1081
01:14:53,750 --> 01:14:55,650
Но вот дальше мы ниже написали,

1082
01:14:55,990 --> 01:14:59,630
что x меньше равно y,
равно compare xy, не равно gt.

1083
01:15:00,650 --> 01:15:03,290
А можно как-то расшифровать,
что здесь происходит?

1084
01:15:05,905 --> 01:15:06,950
Ну, что происходит? Типа.

1085
01:15:07,150 --> 01:15:08,210
..

1086
01:15:09,590 --> 01:15:11,970
вспоминаем порядок, как это, операторов,

1087
01:15:12,990 --> 01:15:14,310
как называется, я не помню.

1088
01:15:15,930 --> 01:15:18,350
Ну, типа, приоритет операции,

1089
01:15:18,475 --> 01:15:22,070
что сначала применяется
функция compare к xy,

1090
01:15:23,970 --> 01:15:25,250
возвращается значение,

1091
01:15:27,570 --> 01:15:28,570
типа ordering,

1092
01:15:29,210 --> 01:15:31,050
и мы сравниваем, что оно не равно gt.

1093
01:15:36,540 --> 01:15:38,490
Вопрос, почему это
именно меньше, либо равно?

1094
01:15:41,770 --> 01:15:46,811
Вопрос, скорее, просто в синтексисе,
потому что, кажется... В синтексисе...

1095
01:15:47,250 --> 01:15:48,770
Так, какой вопрос в синтексисе?

1096
01:15:49,170 --> 01:15:52,430
Ну, просто мы не должны
нигде скобочки поставить,

1097
01:15:52,630 --> 01:15:54,490
потому что мы сначала функцию вызываем,

1098
01:15:54,610 --> 01:15:56,470
потом применяем оператор к результату.

1099
01:15:56,710 --> 01:16:01,690
Как-то не очень понятно, как это сработает.

1100
01:16:02,635 --> 01:16:03,770
Так это же прекрасно.

1101
01:16:03,910 --> 01:16:07,170
Меньше скобочек, как бы, компактный код.

1102
01:16:07,545 --> 01:16:13,550
Ну, типа, смотри, в Haskell
интересный синтексис в целом.

1103
01:16:14,020 --> 01:16:17,270
То есть, нужно запомнить
порядок операторов.

1104
01:16:17,530 --> 01:16:21,650
То есть, есть как бы всего
10, по-моему, уровней.

1105
01:16:23,500 --> 01:16:25,070
Вроде бы, да, 10.

1106
01:16:26,220 --> 01:16:30,270
Ну, это нормальный порядок операции.

1107
01:16:30,560 --> 01:16:35,180
То есть, как в математике
умножение, оно сильнее, чем сложение.

1108
01:16:35,430 --> 01:16:37,680
Поэтому сначала мы вычисляем умножение.

1109
01:16:37,800 --> 01:16:38,800
И тут то же самое.

1110
01:16:38,970 --> 01:16:41,480
Самое сильное – это применение функции.

1111
01:16:43,150 --> 01:16:45,300
Функция – это compare функция.

1112
01:16:45,500 --> 01:16:47,320
Значит, мы ее применяем к x и y.

1113
01:16:48,310 --> 01:16:49,380
Дальше идет оператор.

1114
01:16:49,660 --> 01:16:52,400
Типа, он слабее, чем применение функции.

1115
01:16:52,520 --> 01:16:55,460
Поэтому сначала мы вычисляем его операнды.

1116
01:16:56,305 --> 01:16:58,040
Все, я понял, я распортил.

1117
01:16:58,940 --> 01:17:04,560
То есть, если хочешь, можешь
выделить скобочки compare и x и y.

1118
01:17:05,820 --> 01:17:10,540
Но тебе compare расскажет,
что можно убрать, если хочешь.

1119
01:21:11,420 --> 01:21:17,890
Что из этого нам дает ику, которую
мы просим от класса? Еще раз.

1120
01:21:25,780 --> 01:21:26,900


1121
01:21:27,900 --> 01:21:32,180
Мы пишем класс ико а.

1122
01:21:34,940 --> 01:21:38,060
Что он нам дает, этот ико?

1123
01:21:46,010 --> 01:21:48,840
Допустим, мы уберем эту ико-стрелочку.

1124
01:21:49,480 --> 01:21:50,480
В чем получим?

1125
01:21:52,030 --> 01:21:53,030
Сейчас, секунду.

1126
01:22:00,530 --> 01:22:05,230
Смотри, допустим, мы
уберем ико, что сломается?

1127
01:22:06,980 --> 01:22:13,490
Он нам в моменте использования x
равно y скажет, что это за функция.

1128
01:22:18,500 --> 01:22:19,990
А остальное при этом не сломается.

1129
01:22:20,150 --> 01:22:23,690
То есть, если мы уберем это
равно-равно, у нас все сработает.

1130
01:22:25,980 --> 01:22:29,517
Ну как, если ты уберешь
равно-равно, то у тебя

1131
01:22:29,529 --> 01:22:32,770
в целом попадет смысл
этого класса, но да.

1132
01:22:34,450 --> 01:22:36,070
Там же еще останется lt, gt.

1133
01:22:40,130 --> 01:22:42,657
Представь, что у тебя
элементы можно сравнивать

1134
01:22:42,669 --> 01:22:45,370
на меньше, но нельзя
сравнивать на равно.

1135
01:22:53,180 --> 01:22:54,470
Это как? Я не понимаю,
как такое может быть.

1136
01:22:54,471 --> 01:22:56,570
Ну это когда не меньше и не больше.

1137
01:22:57,630 --> 01:22:59,750
Да, можно же выразить
равно-через меньше-больше.

1138
01:23:01,660 --> 01:23:02,660
Ну можно, да.

1139
01:23:02,910 --> 01:23:06,190
Это правда.

1140
01:23:09,880 --> 01:23:12,808
То есть, можно написать
какой-то другой класс,

1141
01:23:12,820 --> 01:23:15,440
орд, который не
требует этого constraint,

1142
01:23:16,360 --> 01:23:18,480
который не требует равно-равно.

1143
01:23:21,380 --> 01:23:23,300
Это вопрос дизайна, наверное.

1144
01:23:23,450 --> 01:23:34,070
Я думаю, что есть какие-то
математические вариации,

1145
01:23:35,750 --> 01:23:41,930
когда другая иерархия классов строится,
но тут вот так, в стандартной библиотеке.

1146
01:23:42,050 --> 01:23:44,190
В целом, довольно разумно.

1147
01:23:44,580 --> 01:23:50,030
Но существует такой вопрос, что
если мы используем равно-равно,

1148
01:23:50,180 --> 01:23:54,330
то мы должны в сигнатуре
функции или класса указать,

1149
01:23:54,570 --> 01:24:02,810
что мы требуем выполнения этого constraint,

1150
01:24:03,550 --> 01:24:06,310
что действительно эти элементы
можно сравнить на равно.

1151
01:24:12,380 --> 01:24:16,360
Для compare x, y, первая
строчка это x равно-равно y.

1152
01:24:16,780 --> 01:24:18,720
Понятно, мы ее просим у ICO.

1153
01:24:19,280 --> 01:24:21,900
А вторая, x меньше-равно
y, она откуда берется?

1154
01:24:22,850 --> 01:24:26,900
А это мы вызываем recursive на функцию,
которую в этом же классе определяем.

1155
01:24:29,920 --> 01:24:34,240
Так, а у нас очередь
происходит через compare.

1156
01:24:34,540 --> 01:24:36,460
Да, это взаимная рекурсия опять.

1157
01:24:38,630 --> 01:24:42,020
То есть до этого класса нам
нужно где-то instance написать,

1158
01:24:43,060 --> 01:24:44,420
и в этом instance что должно быть?

1159
01:24:46,030 --> 01:24:47,880
После этого класса мы напишем instance,

1160
01:24:47,980 --> 01:24:54,240
и там минимально мы должны определить
либо compare, либо меньше-равно.

1161
01:24:58,460 --> 01:24:59,600
Ага, класс, супер.

1162
01:25:00,290 --> 01:25:04,060
И еще должен быть ICO, который
бы определил нам равно-равно.

1163
01:25:04,590 --> 01:25:08,040
Да, он просто должен
быть виден в этом месте.

1164
01:25:08,600 --> 01:25:09,600
Там не надо указывать.

1165
01:25:10,980 --> 01:25:13,760
Так, но если все равно нужно
определять меньше-равно,

1166
01:25:14,160 --> 01:25:17,780
то ICO ни через что не
выражается в определении,

1167
01:25:17,781 --> 01:25:20,160
то, в принципе, он нам
не особо нужен здесь.

1168
01:25:26,100 --> 01:25:27,100
Сейчас, не понял.

1169
01:25:28,220 --> 01:25:31,080
Ну вот, кроме строчки, где
x равно-равно y равно ICO,

1170
01:25:32,640 --> 01:25:34,740
он нигде ни через что не выражается.

1171
01:25:35,060 --> 01:25:36,060
Ну да.

1172
01:25:36,690 --> 01:25:41,680
Тогда, по сути, можно убрать
ICO, вообще не просить больше.

1173
01:25:43,900 --> 01:25:52,620
И, например, внизу добавить x равно-равно
y, а compare x, y не равно gt и lt.

1174
01:25:54,120 --> 01:25:55,160
Да, так можно.

1175
01:25:55,300 --> 01:25:57,260
Но, по сути, ты что сделаешь тем самым?

1176
01:25:57,340 --> 01:26:01,200
Ты просто одну из функций
ICO перенесешь в ORD.

1177
01:26:03,120 --> 01:26:07,160
Ну да, зато нам теперь не нужно будет
требовать от A, чтобы был реализован ICO.

1178
01:26:09,180 --> 01:26:10,180
Окей, согласен.

1179
01:26:11,660 --> 01:26:13,660
Но выиграли ли мы от этого что-нибудь?

1180
01:26:13,661 --> 01:26:17,160
То есть сейчас мы хотим, чтобы у
нас до этого был какой-то instance,

1181
01:26:17,340 --> 01:26:19,980
который реализует меньше
либо равно знак, и плюс еще ICO.

1182
01:26:20,080 --> 01:26:21,720
А так нам на одно требование меньше.

1183
01:26:21,960 --> 01:26:25,820
Это просто интерфейс
ICO понадобится кому-то

1184
01:26:25,920 --> 01:26:27,580
другому, кто хочет
именно ICO, а не ORD.

1185
01:26:27,880 --> 01:26:31,080
И ты его не будешь реализовывать,
и будет грустно в такой ситуации.

1186
01:26:31,640 --> 01:26:32,640
То есть, да, вопрос.

1187
01:26:33,760 --> 01:26:35,580
Во-первых, декомпозиция — это хорошо.

1188
01:26:37,400 --> 01:26:42,080
Во-вторых, допустим, у тебя есть
тип, у которого ты требуешь ORD.

1189
01:26:43,060 --> 01:26:45,420
Для него количество
constraint не изменилось.

1190
01:26:45,820 --> 01:26:50,180
Ему как нужно было определить
равно-равно, так и остается.

1191
01:26:50,700 --> 01:26:51,700
Ничего не меняется.

1192
01:26:57,810 --> 01:27:01,684
Убрав constraint у
класса, по сути оставив

1193
01:27:01,696 --> 01:27:05,860
все равно то, что нужно
определить равенство,

1194
01:27:07,040 --> 01:27:08,040
ничего не меняется.

1195
01:27:09,710 --> 01:27:13,700
То есть, смотри, ты
не упрощаешь constraint

1196
01:27:13,780 --> 01:27:15,320
какой-то функции, ты
упрощаешь constraint класса.

1197
01:27:15,835 --> 01:27:18,720
Constraint всех функций остаются такие же.

1198
01:27:24,805 --> 01:27:26,010
Может, я запутал? Нет?

1199
01:27:28,890 --> 01:27:29,890
Понятно?

1200
01:27:33,125 --> 01:27:38,090
Так, значит, давайте вернемся.

1201
01:27:38,970 --> 01:27:41,210
Сейчас, а можно еще один
небольшой вопрос здесь?

1202
01:27:41,310 --> 01:27:45,370
Мы там внизу, вот, compareXY
не равно GT, так легко используем,

1203
01:27:45,450 --> 01:27:50,230
а мы же нигде не писали
реализацию equal для ordering.

1204
01:27:50,550 --> 01:27:53,151
Она автоматически где-то
згенерировалась или ее надо тоже писать?

1205
01:27:54,810 --> 01:27:56,590
Да, хорошее замечание, его тут нет.

1206
01:27:56,890 --> 01:28:02,710
Его нужно, ну, надо либо его
определить, instance, либо задеравить.

1207
01:28:04,330 --> 01:28:09,090
То есть, deriving значит, что он
автоматически может быть сгенерен.

1208
01:28:09,165 --> 01:28:12,870
Инстанцы могут автоматически
генериться, мы тоже сейчас увидим.

1209
01:28:15,330 --> 01:28:17,590
Не всегда нужно все это определять руками.

1210
01:28:19,730 --> 01:28:20,730
Спасибо.

1211
01:28:22,990 --> 01:28:26,350
В этом смысле Haskell прекрасен
в том, что он, как сказать,

1212
01:28:31,620 --> 01:28:35,870
мотивирует тебя создавать новые типы.

1213
01:28:37,240 --> 01:28:40,030
То есть, на любой чих новый
тип, без проблем вообще.

1214
01:28:46,940 --> 01:28:50,990
Мы хотим сделать новый
тип, я не знаю, для security.

1215
01:28:51,490 --> 01:28:52,490
Без проблем, создавай.

1216
01:28:54,250 --> 01:28:56,270
Равенство для этого нужно переопределять.

1217
01:28:58,270 --> 01:29:00,150
Равенство, типа, орд, еще что-то.

1218
01:29:00,490 --> 01:29:01,490
Все это можно сгенерить.

1219
01:29:04,355 --> 01:29:06,450
То есть, это как бы прекрасно.

1220
01:29:06,910 --> 01:29:10,290
Да, еще я хотел, это один момент, а
второй момент, который я хотел сказать,

1221
01:29:10,810 --> 01:29:13,254
в целом, чтобы было
понимание общее, почему

1222
01:29:13,266 --> 01:29:15,950
вообще вот то, что я
сейчас рассказываю, важно.

1223
01:29:16,800 --> 01:29:19,020
Даже если вы не будете
писать на Haskell, вообще

1224
01:29:19,032 --> 01:29:21,310
сама концепция тип-классов,
она очень интересная.

1225
01:29:23,070 --> 01:29:25,120
Потому что, во-первых,
она теоретически

1226
01:29:25,132 --> 01:29:27,670
интересная, то есть, там
можно посчитать статью,

1227
01:29:28,510 --> 01:29:36,090
она будет либо где-то в конце слайдов,
либо я так могу скинуть про тип-классы.

1228
01:29:37,670 --> 01:29:39,751
То есть, она с точки зрения
теории типов интересная.

1229
01:29:40,590 --> 01:29:44,790
Плюс еще тип-классы,
например, есть язык Rust.

1230
01:29:46,250 --> 01:29:49,590
У него тоже такая же система тип-классов.

1231
01:29:49,690 --> 01:29:53,950
Ну, она не такая же, она похожая, но
они как бы вдохновлялись тем же самым.

1232
01:29:54,820 --> 01:29:56,590
Там это называется Type Traces.

1233
01:29:59,270 --> 01:30:01,950
Плюсы, по-моему, тоже в
какую-то эту же сторону двигаются.

1234
01:30:02,310 --> 01:30:11,790
Если раньше там было вот
эти enable-if-t или что-то такое,

1235
01:30:11,850 --> 01:30:16,065
то есть, это компиляторная
магия, то в целом,

1236
01:30:16,077 --> 01:30:23,210
по-моему, они двигаются в сторону концептов,
которые, если я не ошибаюсь, они тоже...

1237
01:30:24,055 --> 01:30:26,857
Суть в том, что ты
декларативно указываешь

1238
01:30:26,869 --> 01:30:29,950
какие-то constraints на
классы, на реализацию.

1239
01:30:30,360 --> 01:30:32,970
В общем, идея очень классная, прикольная.

1240
01:30:33,070 --> 01:30:34,970
И при этом в Haskell она реализована.

1241
01:30:35,050 --> 01:30:39,770
Это, наверное, одна из
лучших реализаций тип-классов,

1242
01:30:39,850 --> 01:30:44,670
потому что они довольно
мощные в Haskell.

1243
01:30:44,990 --> 01:30:48,490
То есть, мы там дальше
увидим, они могут быть

1244
01:30:48,491 --> 01:30:53,330
и параметрические, и,
в смысле, полиморфные,

1245
01:30:53,750 --> 01:30:55,490
и можно писать инстансы полиморфные,

1246
01:30:56,810 --> 01:30:59,450
и, в общем, там есть какие-то
функциональные зависимости.

1247
01:30:59,570 --> 01:31:00,570
В общем, куча разных фич.

1248
01:31:01,210 --> 01:31:04,687
Я даже видел какой-то
чувак, типа, зависимые

1249
01:31:04,699 --> 01:31:08,030
типы кодировал с
помощью этих тип-классов.

1250
01:31:08,750 --> 01:31:13,290
Там можно вараги делать,
вараг-функцию с помощью тип-класса.

1251
01:31:13,370 --> 01:31:15,890
В общем, прикольная штука.

1252
01:31:18,490 --> 01:31:19,490
Вот.

1253
01:31:20,550 --> 01:31:22,690
Собственно, давайте дальше ее взбирать.

1254
01:31:23,730 --> 01:31:26,110
А как работает тип, который внизу написан?

1255
01:31:26,470 --> 01:31:28,790
Который от Summa, от
Moe University и Sirocco.

1256
01:31:33,370 --> 01:31:34,370
Хорошая шутка.

1257
01:31:36,050 --> 01:31:37,050
Или нет, подожди.

1258
01:31:41,030 --> 01:31:43,470
Ты шутишь или, типа, я реально вопрос?

1259
01:31:45,690 --> 01:31:47,150
Ну, вообще шучу.

1260
01:31:47,610 --> 01:31:48,610
Окей, все.

1261
01:31:48,990 --> 01:31:50,270
Ну, на всякий случай, типа.

1262
01:31:50,890 --> 01:31:51,890
Мало ли.

1263
01:31:53,870 --> 01:31:58,010
Может, у нас такой уровень
понимания не терялось сейчас, я не знаю.

1264
01:31:58,830 --> 01:32:03,010
Вы говорите, мне тоже сложно
понимать, что понятно, что нет.

1265
01:32:07,250 --> 01:32:08,250
Вот.

1266
01:32:09,150 --> 01:32:10,150
Да, тип.

1267
01:32:12,360 --> 01:32:14,470
В общем, давайте дальше.

1268
01:32:15,240 --> 01:32:17,390
Ну, мы смотрели уже.

1269
01:32:17,670 --> 01:32:21,750
У нас есть класс, есть у
него куча всяких методов.

1270
01:32:22,550 --> 01:32:26,210
Типа, плюс, негейт, апс, ну и так далее.

1271
01:32:27,970 --> 01:32:28,570
Вот.

1272
01:32:28,690 --> 01:32:31,030
Интересный у него метод,
наверное, fromInteger.

1273
01:32:31,310 --> 01:32:36,750
То есть это, типа, из любого
интеджера можно сконвертировать в...

1274
01:32:38,330 --> 01:32:39,530
То есть...

1275
01:32:41,370 --> 01:32:46,950
Как из интеджера, типа, можно сделать
int, можно сделать double и так далее.

1276
01:32:46,951 --> 01:32:47,951
То есть...

1277
01:32:50,270 --> 01:32:55,390
Это полезно для как раз вот этих
вот литералов, которые полиморфные.

1278
01:32:55,470 --> 01:32:59,970
То есть когда мы пишем,
если мы в Haskell напишем...

1279
01:33:00,395 --> 01:33:03,630
Спросим у GHCI, типа, тип.

1280
01:33:03,910 --> 01:33:04,910
Спросим тип.

1281
01:33:06,520 --> 01:33:07,770
В чиселке у нас будет 0p.

1282
01:33:08,370 --> 01:33:14,130
То есть это, на самом деле,
синтаксический сахар для fromInteger 5.

1283
01:33:16,070 --> 01:33:17,070
FromInteger 5.

1284
01:33:20,590 --> 01:33:21,430
Значит, и...

1285
01:33:21,530 --> 01:33:25,910
В зависимости от того, в каком контексте
будет использоваться это выражение,

1286
01:33:26,010 --> 01:33:29,550
там уже будет вывозиться,
типа, это double, int.

1287
01:33:30,370 --> 01:33:32,370
В общем, очень удобно.

1288
01:33:34,050 --> 01:33:35,050
Да.

1289
01:33:39,530 --> 01:33:41,520
Ну и мы видим, что у
нас, типа, у нас тут...

1290
01:33:41,521 --> 01:33:44,020
Вот тут класс, типа,
тоже не сильно дробится.

1291
01:33:44,021 --> 01:33:49,140
То есть его, наверное, можно было разбить,
типа, вот это вот на кольцо, на что-то еще.

1292
01:33:49,650 --> 01:33:52,940
В общем, можно было так сделать.

1293
01:33:53,250 --> 01:33:56,000
В стандартной библиотеке
вот такое принято решение.

1294
01:33:56,740 --> 01:33:58,980
Ну, это вот набор вот таких классов.

1295
01:34:00,200 --> 01:34:05,000
Значит, дальше у нас есть
type класс, height класс show.

1296
01:34:06,520 --> 01:34:08,840
Ну, это, типа, printable,
который у нас до этого был.

1297
01:34:09,380 --> 01:34:11,900
Так он называется в стандартной
библиотеке, он называется show.

1298
01:34:17,030 --> 01:34:21,260
Значит, он должен быть...
Он всегда используется в JSCI.

1299
01:34:21,680 --> 01:34:22,680
Всегда мы пишем...

1300
01:34:23,600 --> 01:34:30,080
Когда мы пишем, типа, 5, он
показывает это с помощью show.

1301
01:34:34,260 --> 01:34:36,350
Значит... Ну, вот.

1302
01:34:36,860 --> 01:34:37,860
Да.

1303
01:34:38,220 --> 01:34:39,220
В общем, как-то так.

1304
01:34:45,210 --> 01:34:46,210
Ну да.

1305
01:34:46,310 --> 01:34:51,070
Есть разные num типы, которые
творятся в интерфейсе num.

1306
01:34:51,860 --> 01:34:53,290
Это int, double, rational.

1307
01:34:54,190 --> 01:34:56,010
У них там тоже есть какая-то иерархия.

1308
01:34:58,760 --> 01:35:02,770
Есть fractional, который,
по-моему, включает в себя num.

1309
01:35:04,710 --> 01:35:05,010
Вот.

1310
01:35:05,390 --> 01:35:07,230
Ну, это можете в
стандартной библиотеке там...

1311
01:35:07,810 --> 01:35:09,770
В этом...

1312
01:35:11,800 --> 01:35:12,870
В кугле поискать.

1313
01:35:13,350 --> 01:35:13,510
Вот.

1314
01:35:13,810 --> 01:35:14,810
В общем, да.

1315
01:35:15,410 --> 01:35:16,410
Read.

1316
01:35:17,420 --> 01:35:18,910
Тоже важный тип.

1317
01:35:19,715 --> 01:35:24,030
Потому что... Важный type класс,
потому что он на самом деле...

1318
01:35:26,940 --> 01:35:28,190
Нужен для парсинга.

1319
01:35:30,070 --> 01:35:30,350
Да.

1320
01:35:30,450 --> 01:35:31,450
Вот.

1321
01:35:32,630 --> 01:35:34,311
Короче... Понятно.

1322
01:35:34,570 --> 01:35:35,570
Чтение...

1323
01:35:37,610 --> 01:35:38,610
Чтение строки.

1324
01:35:41,320 --> 01:35:43,030
Ну, понятно, что это не полная функция.

1325
01:35:43,450 --> 01:35:45,550
Да, и тут есть такой момент, что...

1326
01:35:47,880 --> 01:35:50,350
Когда мы пишем read, мы не можем...

1327
01:35:52,760 --> 01:35:58,970
Из строчки понять, что нам
нужно... Какую функцию вызывать.

1328
01:36:03,115 --> 01:36:04,650
Допустим, double или int.

1329
01:36:04,790 --> 01:36:05,790
Непонятно.

1330
01:36:06,450 --> 01:36:10,590
То есть для этого нужно явно указывать
тип, который возвращаем, и мы хотим.

1331
01:36:10,770 --> 01:36:12,350
Потому что иначе...

1332
01:36:16,340 --> 01:36:19,010
Есть какая-то неоднозначность.

1333
01:36:20,850 --> 01:36:20,970
Вот.

1334
01:36:21,190 --> 01:36:25,630
Ну, и по дефолту, возможно, это
может как-то вам выстрелиться в ногу.

1335
01:36:25,860 --> 01:36:27,770
То, что, допустим, если
мы напишем read true,

1336
01:36:28,370 --> 01:36:31,870
там вывезется какой-то непонятный тип.

1337
01:36:34,990 --> 01:36:36,030
Возможно, случайный.

1338
01:36:36,110 --> 01:36:38,470
Возможно, он вывезется
как-то из вашего использования.

1339
01:36:39,275 --> 01:36:40,510
И read просто упадет.

1340
01:36:41,330 --> 01:36:42,330
Потому что...

1341
01:36:43,750 --> 01:36:45,830
Вот как-то вывелось,
что там должен быть такой

1342
01:36:45,870 --> 01:36:47,630
тип, а вы думаете, что
там должен быть bool.

1343
01:36:48,510 --> 01:36:48,630
Вот.

1344
01:36:48,690 --> 01:36:55,130
Поэтому, в общем, в таких случаях лучше
всегда указывать, что вы ожидаете типом.

1345
01:36:55,131 --> 01:36:55,970
Вот.

1346
01:36:56,110 --> 01:37:03,090
Но это прекрасно, что не нужно
называть функцию по-разному как-то.

1347
01:37:03,410 --> 01:37:04,910
Типа read bool, read true.

1348
01:37:05,050 --> 01:37:06,210
Это все одна и та же функция.

1349
01:37:06,430 --> 01:37:07,630
Она полиморфная.

1350
01:37:08,550 --> 01:37:10,230
И если из контекста реально понятно,

1351
01:37:10,450 --> 01:37:15,670
если вы сразу после read композируете из
какой-то функции, которая принимает bool,

1352
01:37:16,370 --> 01:37:18,930
оно вывезется, что там должен быть bool.

1353
01:37:22,420 --> 01:37:24,060
Просто не всегда это может быть очевидно.

1354
01:37:24,560 --> 01:37:24,820
Да.

1355
01:37:24,821 --> 01:37:28,080
И есть функции readMaybe, readEither,

1356
01:37:28,420 --> 01:37:35,320
которые позволяют чекнуть,
проверить, что результат правильный.

1357
01:37:37,550 --> 01:37:39,071
Вот, собственно, пример использования.

1358
01:37:43,490 --> 01:37:44,740
Такие вот типы у них.

1359
01:37:46,380 --> 01:37:50,100
То есть по типу, наверное, должно быть
уже понятно, что readA стрелочка значит,

1360
01:37:50,680 --> 01:37:54,700
что мы требуем, что тип
A должен быть читаемый.

1361
01:37:54,701 --> 01:37:56,541
И у него должна быть
реализована функция read.

1362
01:37:58,780 --> 01:38:01,800
Ну, в общем, вот все понятно должно быть.

1363
01:38:06,000 --> 01:38:07,000
Полиморфные примеры.

1364
01:38:07,420 --> 01:38:08,540
Допустим, вычитание.

1365
01:38:12,390 --> 01:38:17,280
Собственно, мы требуем,
чтобы был тип num у A.

1366
01:38:17,750 --> 01:38:23,640
После этого мы можем
вычитать, использовать минус.

1367
01:38:24,550 --> 01:38:26,860
И как бы неважно, какой это конкретный тип.

1368
01:38:27,600 --> 01:38:29,440
Да, вот я, кстати,
говорил уже про fractional.

1369
01:38:29,590 --> 01:38:32,580
Есть fractional, который
расширяет класс num,

1370
01:38:33,120 --> 01:38:34,180
добавляет деления.

1371
01:38:46,960 --> 01:38:48,500
Есть инстансы такие.

1372
01:38:50,740 --> 01:38:53,641
Если мы хотим посчитать, например,
среднее, то нам нужно деление.

1373
01:38:53,920 --> 01:38:55,180
Нам уже num не достаточно.

1374
01:38:56,180 --> 01:38:57,180
Нужно fractional.

1375
01:39:01,190 --> 01:39:03,231
Но давайте посмотрим,
например, у нас есть функция.

1376
01:39:04,540 --> 01:39:08,120
Какой у нас наиболее
общий тип этой функции?

1377
01:39:08,300 --> 01:39:11,500
Причем этот тип сам выведется
компилятором, если вы его спросите.

1378
01:39:15,350 --> 01:39:19,380
Причем прелесть type-классов, что
у них есть какая-то под ними теория,

1379
01:39:20,540 --> 01:39:22,440
есть алгоритм вывода и все такое.

1380
01:39:22,441 --> 01:39:24,060
В общем, они могут вводиться.

1381
01:39:26,140 --> 01:39:30,040
Смотрим, у нас используется
меньше оператор.

1382
01:39:30,310 --> 01:39:33,100
Значит, мы идем туда, где он определен.

1383
01:39:33,180 --> 01:39:35,360
Он определен в классе орд.

1384
01:39:35,480 --> 01:39:39,320
Значит, у нас x и y должны быть орд.

1385
01:39:40,280 --> 01:39:41,880
Иметь тип какой-то орд а.

1386
01:39:43,930 --> 01:39:45,500
Плюс, значит, нам нужен num.

1387
01:39:45,920 --> 01:39:46,920
Умножить тоже num.

1388
01:39:48,670 --> 01:39:54,300
Можем проверить себя, спросить
GHCI, он скажет, орд и num должны быть.

1389
01:39:54,740 --> 01:39:56,176
То есть, да, если не
оставлять комплиментов,

1390
01:39:56,200 --> 01:39:58,720
они указываются просто в
скобочках через запятую.

1391
01:40:02,380 --> 01:40:09,480
На самом деле, никакой
магии нет под type-классами.

1392
01:40:10,520 --> 01:40:11,240
Это работает как?

1393
01:40:11,380 --> 01:40:14,720
У нас нет каких-то виртуальных
таблиц или чего-то такого.

1394
01:40:15,280 --> 01:40:20,700
На самом деле, вот эти орд а и num а это
можно воспринимать как неявные аргументы.

1395
01:40:21,705 --> 01:40:27,780
То есть, функция cmp
сам принимает instance,

1396
01:40:30,965 --> 01:40:35,820
который определяет для а функцию орд,

1397
01:40:37,120 --> 01:40:38,380
интерфейс орд,

1398
01:40:39,190 --> 01:40:41,220
и использует их внутри своего тела,

1399
01:40:41,440 --> 01:40:43,100
внутри, значит, определения.

1400
01:40:45,000 --> 01:40:47,300
А почему недостаточно только одного num?

1401
01:40:47,920 --> 01:40:52,800
Мы и так можем число сравнивать, зачем
num явно указывает, что мы еще орд требуем?

1402
01:40:54,370 --> 01:40:55,880
Давайте посмотрим определение num.

1403
01:40:57,430 --> 01:40:58,760
Num не требует орда.

1404
01:41:04,280 --> 01:41:07,410
То есть, по дефолту num не может
сравниваться друг с другом? Да, да, да.

1405
01:41:08,510 --> 01:41:10,210


1406
01:41:13,290 --> 01:41:20,080
Это специально сделано или
просто для непонятной магии?

1407
01:41:21,140 --> 01:41:22,820
Нет, я думаю, что это специально сделано.

1408
01:41:23,540 --> 01:41:26,620
То есть, к чему обязательно
числа должны сравниваться?

1409
01:41:28,790 --> 01:41:30,840
Какие числа буквально сравниваются?

1410
01:41:32,440 --> 01:41:34,640
Ну, допустим, это...

1411
01:41:35,320 --> 01:41:37,000
Ладно, мы не говорим про комплексные числа.

1412
01:41:37,001 --> 01:41:40,760
Нет, ну, допустим, комплексные, я не знаю.

1413
01:41:41,100 --> 01:41:46,160
Допустим, это, я не знаю, какие-то кольца,

1414
01:41:46,640 --> 01:41:49,060
я не знаю, в кольце у тебя есть сравнение?

1415
01:41:49,160 --> 01:41:51,340
Ну, оно как бы есть, но там толку от него.

1416
01:41:53,680 --> 01:41:55,880
Если все равно все операции замкнуты.

1417
01:41:56,540 --> 01:41:59,140
Ну, там типа не выполняется
какое-нибудь правило треугольника,

1418
01:41:59,820 --> 01:42:01,100
или что-нибудь такое, я не знаю.

1419
01:42:03,960 --> 01:42:04,960
Ну, короче...

1420
01:42:08,940 --> 01:42:10,350
Ну, вот так сделано, я не знаю.

1421
01:42:11,215 --> 01:42:13,610
Мне кажется, что можно пойти в Google.

1422
01:42:16,590 --> 01:42:17,590
Давайте сходим.

1423
01:42:18,130 --> 01:42:19,750
Есть Num, да?

1424
01:42:20,580 --> 01:42:21,770
Класс Num в Prelude.

1425
01:42:25,050 --> 01:42:27,170
Да, и вот мы видим его определение.

1426
01:42:28,480 --> 01:42:29,670
Видно, да, что я показываю?

1427
01:42:33,350 --> 01:42:34,350
Да, да, да, видно.

1428
01:42:34,590 --> 01:42:37,850
Вот определение, написаны
какие-то его законы,

1429
01:42:37,851 --> 01:42:39,710
к которым должны
удовлетворяться инстансы.

1430
01:42:40,370 --> 01:42:41,710
Ну, это они неформальные,

1431
01:42:41,850 --> 01:42:43,610
они не могут быть проверены компилятором,

1432
01:42:46,530 --> 01:42:48,410
но их часто указывают в документации,

1433
01:42:48,850 --> 01:42:50,530
какие свойства должны выполняться.

1434
01:42:53,820 --> 01:42:55,886
Значит, да, вот мы видим,
значит, все это определение.

1435
01:42:55,910 --> 01:42:58,670
Вот есть инстансы, по крайней
мере, которые есть в Prelude.

1436
01:42:59,630 --> 01:43:01,490
И вот что тут
есть? bool float int.

1437
01:43:01,850 --> 01:43:03,130


1438
01:43:04,700 --> 01:43:06,010
Вот строки, например, есть.

1439
01:43:07,560 --> 01:43:08,690
Строки как сравниваются?

1440
01:43:08,810 --> 01:43:11,570
Ну, окей, строки можно
литерографически сравнивать,

1441
01:43:12,490 --> 01:43:13,490
в целом,

1442
01:43:14,390 --> 01:43:17,250
но можно притвориться,
что есть несколько способов,

1443
01:43:17,390 --> 01:43:19,430
как сравнивать строки, поэтому непонятно.

1444
01:43:19,570 --> 01:43:20,810
Не обязательно, чтобы они были.

1445
01:43:25,545 --> 01:43:36,690
Ну, не знаю.

1446
01:43:36,910 --> 01:43:41,810
Короче, в целом тут как раз это про то,

1447
01:43:42,065 --> 01:43:45,470
про что говорил ваш коллега,

1448
01:43:46,120 --> 01:43:48,970
что зачем нам требовать больше, чем нужно?

1449
01:43:49,410 --> 01:43:50,690
Мы нигде не используем ORD.

1450
01:43:50,750 --> 01:43:51,790
Зачем нам его требовать?

1451
01:43:54,210 --> 01:43:55,810
Если бы мы его использовали, то да.

1452
01:43:56,050 --> 01:43:57,050
Типа, окей.

1453
01:43:57,390 --> 01:43:58,430
А так зачем? Так, спойлеры.

1454
01:44:08,510 --> 01:44:10,090


1455
01:44:10,450 --> 01:44:12,130
Ага, вот, мы здесь остановились.

1456
01:44:15,390 --> 01:44:16,991
Да, я сказал про то, что, на самом деле,

1457
01:44:17,360 --> 01:44:22,360
type classes — это просто как бы некоторые
такие неявные параметры у функций.

1458
01:44:22,361 --> 01:44:23,780


1459
01:44:25,430 --> 01:44:27,260
Которые компилятор может выводить

1460
01:44:27,610 --> 01:44:29,180
и подставлять вместо нас.

1461
01:44:30,260 --> 01:44:33,280
То есть, поэтому можно...
Зачем я это говорю?

1462
01:44:33,380 --> 01:44:38,000
Потому что дает такую некоторую интуицию,
почему вот пишется вот так вот, типа там,

1463
01:44:39,160 --> 01:44:40,740
круглые скобочки, запятая.

1464
01:44:40,900 --> 01:44:42,740
Потому что это, на самом деле, реально

1465
01:44:45,340 --> 01:44:47,020
typo из instances.

1466
01:44:49,900 --> 01:44:50,900
Вот.

1467
01:44:51,160 --> 01:44:52,820
У нас вот этот вывод типов,

1468
01:44:52,970 --> 01:44:54,931
ну вот из значка плюс мы,
например, выводили num.

1469
01:44:55,020 --> 01:44:57,520
А если я заведу свой type
класс со значком плюс,

1470
01:44:57,900 --> 01:44:58,960
то будет ambiguous?

1471
01:45:00,420 --> 01:45:01,420
Да.

1472
01:45:03,330 --> 01:45:05,100
А в цупле у нас есть порядок?

1473
01:45:15,290 --> 01:45:16,940
В цупле есть ли порядок?

1474
01:45:17,880 --> 01:45:18,880
В смысле?

1475
01:45:19,060 --> 01:45:21,160
Ну, ort a и num a,

1476
01:45:21,500 --> 01:45:24,360
и num a, ort a — это не одно и то же?

1477
01:45:26,120 --> 01:45:27,940
А, нет, это одно и то же.

1478
01:45:28,460 --> 01:45:29,520
Нет, нет порядка.

1479
01:45:30,080 --> 01:45:31,540
В смысле, да, я понял.

1480
01:45:33,260 --> 01:45:35,940
Нет, констрейты
указываются в любом порядке.

1481
01:45:36,940 --> 01:45:39,540
Констрейты в любом, а вот если
бы у нас был нормальный tuple,

1482
01:45:40,180 --> 01:45:41,180
то там уже не в любом.

1483
01:45:42,590 --> 01:45:45,220
Ну, типа два стринга, наверное,
перепутать не очень хочется.

1484
01:45:49,510 --> 01:45:51,711
В смысле, у тебя же у конструктора
есть первый, второй? Да, конечно.

1485
01:45:52,190 --> 01:45:52,510


1486
01:45:53,050 --> 01:45:54,830
Ну, типа да, обычно у tuple есть.

1487
01:45:58,665 --> 01:46:00,940
Нет, конечно, haskell — это
странный немножко язык,

1488
01:46:00,941 --> 01:46:03,021
когда ты первый раз на
него пишешь, но не настолько.

1489
01:46:07,210 --> 01:46:11,210
Так, а tuple у нас встречаются вообще
вне контекста этих констрейнтов?

1490
01:46:13,450 --> 01:46:14,450
В смысле?

1491
01:46:14,490 --> 01:46:17,130
Ну, там, типа, первые слайды там были.

1492
01:46:19,510 --> 01:46:20,510
Вот tuple.

1493
01:46:23,500 --> 01:46:25,570
А, так, ну вот type alias как раз.

1494
01:46:25,710 --> 01:46:27,270
Ну, вот здесь уже порядок важен.

1495
01:46:29,530 --> 01:46:30,530
Да.

1496
01:46:30,630 --> 01:46:32,230
Ага, в порядках есть, прикольно.

1497
01:46:35,910 --> 01:46:38,101
Ну, синтактически, как
бы, и круглые скобочки

1498
01:46:38,113 --> 01:46:40,170
не всегда одно и то
же получаются сначала.

1499
01:46:42,170 --> 01:46:43,170
Ну, да.

1500
01:46:45,210 --> 01:46:46,690
Так и почти во всех языках.

1501
01:46:47,130 --> 01:46:49,850
Ну, блин, нет, в смысле,
короче, есть tuples, да?

1502
01:46:53,500 --> 01:46:55,110
Типа, вот внизу написано, типа,

1503
01:46:55,590 --> 01:46:59,330
uid.login.name — это tuple выражение, да?

1504
01:46:59,930 --> 01:47:04,130
Оно имеет тип tuple int string string.

1505
01:47:05,550 --> 01:47:06,550
Окей.

1506
01:47:07,950 --> 01:47:11,450
То, что я сказал про
констрейнты, это как бы интуиция.

1507
01:47:11,750 --> 01:47:13,190
Это не обязательно, типа, так.

1508
01:47:14,790 --> 01:47:16,410
Это тоже просто синтаксис.

1509
01:47:17,390 --> 01:47:21,540
Ну, да, короче, порядок
констрейнтов неважен.

1510
01:47:26,840 --> 01:47:28,660
Скобочки, значит, разные, да.

1511
01:47:28,760 --> 01:47:30,480
Например, можно выражение в скобочке взять.

1512
01:47:30,510 --> 01:47:31,780
Это не значит, что это tuple.

1513
01:47:34,120 --> 01:47:37,640
Ну, понятно, что в контексте, когда
там у нас в скобочках типы записаны.

1514
01:47:38,880 --> 01:47:39,880
Да, да, да.

1515
01:47:40,150 --> 01:47:47,260
То есть порядок как бы в типе важен,
порядок в констрейнтах не важен.

1516
01:47:47,660 --> 01:47:49,280
Да, да, все верно.

1517
01:47:51,080 --> 01:47:52,080
Окей.

1518
01:47:54,380 --> 01:47:55,380
Окей.

1519
01:47:57,640 --> 01:47:58,640
Так.

1520
01:48:01,140 --> 01:48:02,200
Полиморфные штуки.

1521
01:48:02,480 --> 01:48:03,980
Короче, да, это мы все посмотрели.

1522
01:48:05,040 --> 01:48:06,040
Что дальше?

1523
01:48:07,960 --> 01:48:09,800
Ну, это маленькое такое отступление.

1524
01:48:10,200 --> 01:48:11,360
То, что есть...

1525
01:48:13,470 --> 01:48:15,140
Есть такие функции, как undefined,

1526
01:48:16,180 --> 01:48:17,460
которые означают как бы...

1527
01:48:19,170 --> 01:48:25,240
Ну, это типа bottom в теории
типов, если кто ходил, слышал.

1528
01:48:25,700 --> 01:48:29,720
Короче, это вычисление
некоторое, которое не завершается.

1529
01:48:31,280 --> 01:48:32,920
В бесконечной циклице, грубо говоря.

1530
01:48:34,890 --> 01:48:37,840
И теоретически это
значит, что оно имеет false.

1531
01:48:38,400 --> 01:48:40,380
Типа ложь.

1532
01:48:40,540 --> 01:48:41,760
Оно совершенно любого типа.

1533
01:48:45,640 --> 01:48:47,721
То есть если мы спросим
тип undefined, у него тип A.

1534
01:48:48,120 --> 01:48:51,160
То есть его можно подставить совершенно
вместо любого выражения в коде,

1535
01:48:51,400 --> 01:48:55,680
чтобы как бы заткнуть любую дырку им можно.

1536
01:48:57,640 --> 01:48:58,900
Например, у нас есть тип fu.

1537
01:48:59,950 --> 01:49:02,660
У него какой-то сложный тип.

1538
01:49:04,560 --> 01:49:05,700
Он принимает string.

1539
01:49:06,040 --> 01:49:08,100
Там A, 2B, возвращает string.

1540
01:49:08,700 --> 01:49:10,280
Есть какие-то constraints на A и B.

1541
01:49:11,380 --> 01:49:14,620
Но, допустим, мы пока
что только прототипируем.

1542
01:49:15,520 --> 01:49:17,280
И мы пока придумывали только тип.

1543
01:49:18,500 --> 01:49:21,240
Мы можем просто воткнуть undefined и все.

1544
01:49:22,970 --> 01:49:25,500
И потом это реализовать когда-нибудь потом.

1545
01:49:26,270 --> 01:49:30,960
То есть мы завтра это реализуем,
а сегодня оно уже будет отчекаться.

1546
01:49:31,860 --> 01:49:34,300
То есть в этом примере
понятно, немножко непонятно,

1547
01:49:34,445 --> 01:49:36,240
что такое A, что такое B, что такое fu.

1548
01:49:36,880 --> 01:49:39,000
Но если как-то ее нормально назвать,

1549
01:49:39,260 --> 01:49:42,260
то это очень удобно.

1550
01:49:44,040 --> 01:49:45,240
Можно определить функцию.

1551
01:49:46,940 --> 01:49:48,100
Я не знаю, вы пишете код.

1552
01:49:48,580 --> 01:49:51,400
Не обязательно все
писать с начала до конца.

1553
01:49:51,460 --> 01:49:52,940
Вы пишете код, вам нужна какая-то функция.

1554
01:49:52,941 --> 01:49:55,660
Вы выше определили ее
тип, который вам нужен.

1555
01:49:59,460 --> 01:50:00,820
Дописываете интересную часть.

1556
01:50:00,940 --> 01:50:02,540
Потом реализуются всякие скучные вещи.

1557
01:50:04,840 --> 01:50:05,840
Понятно.

1558
01:50:06,220 --> 01:50:08,500
Я просто объясняю, наверное,
что такое прототипирование.

1559
01:50:08,660 --> 01:50:09,700
Это, я думаю, вам понятно.

1560
01:50:11,040 --> 01:50:15,300
Есть еще функция error, которая такая
же, только она еще принимает строчку.

1561
01:50:15,580 --> 01:50:19,740
То есть она умеет кидать
какое-то сообщение об ошибке.

1562
01:50:19,900 --> 01:50:25,060
То есть если мы попытаемся
вычислить undefined, это будет exception.

1563
01:50:27,590 --> 01:50:30,180
А если мы пытаемся вычислить error,

1564
01:50:30,300 --> 01:50:37,240
это будет exception, но
с каким-то сообщением.

1565
01:50:37,830 --> 01:50:41,080
То есть если у нас есть в
нескольких местах эти error,

1566
01:50:41,260 --> 01:50:42,960
можем их различить. Понятно.

1567
01:50:50,960 --> 01:50:51,800
Понятно.

1568
01:50:51,801 --> 01:50:54,700
Варнинг все выполнен профессионалами.

1569
01:50:56,060 --> 01:50:58,060
В реальном коде не надо использовать.

1570
01:50:58,580 --> 01:51:01,360
То есть код, который вы уже
не прототипируете, запускаете,

1571
01:51:01,480 --> 01:51:05,420
там оставлять error и
undefined – плохая идея.

1572
01:51:07,480 --> 01:51:09,920
Ну а если мы хотим
обработать какой-то кейс,

1573
01:51:10,000 --> 01:51:12,760
когда у нас какая-то
невыполнимая ситуация,

1574
01:51:13,530 --> 01:51:15,660
то есть какая-то ошибка,
которая не должна случиться?

1575
01:51:17,895 --> 01:51:21,460
В этом случае тут разговор
про обработку ошибок.

1576
01:51:21,560 --> 01:51:24,200
Чего мы хотим?
Чего мы хотим, зависит от ситуации.

1577
01:51:24,320 --> 01:51:27,120
Если это ошибка, которая типа паник, error,

1578
01:51:27,785 --> 01:51:30,940
все, мы никогда не хотим
восстанавливаться после нее,

1579
01:51:31,620 --> 01:51:35,060
да, можно, наверное, написать error и все.

1580
01:51:35,650 --> 01:51:38,560
Но мы хотим как-то на
уровне типов нам себя

1581
01:51:38,620 --> 01:51:39,940
гарантировать, что
этой ошибке не случится.

1582
01:51:43,710 --> 01:51:46,350
Если мы хотим на уровне типов

1583
01:51:48,770 --> 01:51:50,650
обеспечить себе, чтобы
эта ошибка не случалась,

1584
01:51:50,675 --> 01:51:52,630
то error нам никак не
поможет, понятно, да?

1585
01:51:53,610 --> 01:51:56,870
Ну, в итоге были
прикольные всякие штуки по

1586
01:51:56,871 --> 01:52:01,030
типу вывода отрицаний
в функциях в этих типах.

1587
01:52:02,750 --> 01:52:04,750
Ну и вот можно что-то
там придумать, например.

1588
01:52:09,770 --> 01:52:10,810
Вывод отрицания...

1589
01:52:12,990 --> 01:52:13,990
Короче,

1590
01:52:16,400 --> 01:52:18,201
все еще мое утверждение,
мне кажется, верным,

1591
01:52:18,450 --> 01:52:19,850
что error никак не поможет.

1592
01:52:22,130 --> 01:52:23,570
Или подождите, что ты имеешь в виду?

1593
01:52:23,910 --> 01:52:26,230
Типа отрицание через ложь выразить?

1594
01:52:29,940 --> 01:52:31,570
Короче, я не очень понял тебя.

1595
01:52:35,300 --> 01:52:40,160
Ну да, можно некоторые
ошибки избегать с помощью типов.

1596
01:52:40,240 --> 01:52:41,680
Haskell в целом про это.

1597
01:52:43,200 --> 01:52:45,820
Но тут вопрос, по какие
конкретно ошибки мы

1598
01:52:45,920 --> 01:52:47,940
говорим, не все можно
избежать с помощью типов,

1599
01:52:49,580 --> 01:52:50,700
по крайней мере, haskellных.

1600
01:52:51,940 --> 01:52:53,240
И это зависит от ошибки.

1601
01:52:53,360 --> 01:52:57,020
То есть даже если мы
просто заведем new type

1602
01:52:57,470 --> 01:52:59,960
для secret и public key,

1603
01:53:00,340 --> 01:53:03,580
мы уже избежим от этого... С
помощью этого куча ошибок, правильно?

1604
01:53:03,880 --> 01:53:07,920
У нас будет тапчекаться, что они
разные, что мы никуда не передадим.

1605
01:53:08,960 --> 01:53:10,580
Secret, там должен быть public.

1606
01:53:12,800 --> 01:53:13,800
Ну да,

1607
01:53:14,360 --> 01:53:17,120
ты правильно говоришь.

1608
01:53:21,315 --> 01:53:23,660
Но в целом... Окей,
у нас есть тип еще,

1609
01:53:24,600 --> 01:53:25,900
этот void, который data void.

1610
01:53:28,580 --> 01:53:29,580
Так.

1611
01:53:30,830 --> 01:53:32,320
Какое это имеет отношение
к MDF? Типа абсурд.

1612
01:53:36,980 --> 01:53:37,980


1613
01:53:39,185 --> 01:53:41,160
Ну, я вообще имел в виду
именно функцию absurd,

1614
01:53:42,720 --> 01:53:43,720
когда говорил про Matlab.

1615
01:53:44,990 --> 01:53:46,760
Абсурд. Из индреса, что ли?

1616
01:53:51,260 --> 01:53:52,700
Которая используется...

1617
01:53:53,740 --> 01:53:55,320
Я понял тебя.

1618
01:53:55,940 --> 01:53:57,760
Это немножко не то.

1619
01:53:59,180 --> 01:54:00,180
Это, короче...

1620
01:54:00,560 --> 01:54:03,860
Окей, void это такая штука...

1621
01:54:04,010 --> 01:54:05,010
Сейчас.

1622
01:54:10,180 --> 01:54:10,900
Немножко...

1623
01:54:11,050 --> 01:54:12,171
Время у нас, наверное, есть?

1624
01:54:12,240 --> 01:54:13,240
Можно немножко отвлечься.

1625
01:54:13,340 --> 01:54:14,340
Короче, void...

1626
01:54:15,050 --> 01:54:20,100
Если мы откроем data void, то это немножко...
Это тип, у которого нет конструкторов.

1627
01:54:22,980 --> 01:54:24,440
Это не то же самое, что undefined.

1628
01:54:24,600 --> 01:54:27,120
Undefined, как бы, это
любой тип, а void это.

1629
01:54:27,200 --> 01:54:28,600
..

1630
01:54:29,460 --> 01:54:31,640
Это как бы тоже ложь.

1631
01:54:31,700 --> 01:54:33,440
Немножко по-другому закодированная.

1632
01:54:34,460 --> 01:54:35,720
С точки зрения теоретиков.

1633
01:54:35,960 --> 01:54:37,120
Он буквально возвращает a,

1634
01:54:38,045 --> 01:54:39,660
что по сути собой является undefined.

1635
01:54:42,220 --> 01:54:43,840
Потому что тип undefined a.

1636
01:54:47,225 --> 01:54:48,640
Абсурд возвращает a.

1637
01:54:49,340 --> 01:54:50,340
Ты имеешь в виду? Да, да.

1638
01:54:51,580 --> 01:54:52,580


1639
01:54:52,985 --> 01:54:56,740
Да, но ты не можешь передать
абсурду никакое реальное значение,

1640
01:54:57,120 --> 01:54:58,240
потому что он не существует.

1641
01:55:02,680 --> 01:55:03,680
Да, все верно.

1642
01:55:03,900 --> 01:55:07,540
Знаешь, вся эта логическая суть прекрасна,

1643
01:55:07,640 --> 01:55:11,200
но она вся ломается,
когда появляется undefined.

1644
01:55:11,500 --> 01:55:14,300
Потому что ты можешь сломать...

1645
01:55:16,470 --> 01:55:17,340
Ты можешь в месте,

1646
01:55:17,480 --> 01:55:19,440
где у тебя предполагалось доказательство,

1647
01:55:21,140 --> 01:55:22,140
подсунуть undefined.

1648
01:55:27,030 --> 01:55:28,710
И ты уже не можешь гарантировать,

1649
01:55:28,915 --> 01:55:30,610
что если ты что-то доказал,

1650
01:55:30,990 --> 01:55:32,311
если у тебя все скомпилировалось,

1651
01:55:32,430 --> 01:55:34,230
то нет никаких ошибок.

1652
01:55:34,750 --> 01:55:37,030
Потому что, возможно, ты просто
это сделал с помощью undefined.

1653
01:55:40,510 --> 01:55:43,810
Я думаю, что void немножко
для этих целей существует.

1654
01:55:44,680 --> 01:55:45,490
Если мы притворимся,

1655
01:55:45,670 --> 01:55:46,670
что у нас нет undefined,

1656
01:55:47,340 --> 01:55:50,170
то что-то можно, наверное, доказывать.

1657
01:55:51,650 --> 01:55:56,750
Какие-то constraints на уровне типов.

1658
01:56:03,350 --> 01:56:04,510
Это немножко другая тема.

1659
01:56:04,760 --> 01:56:10,070
Это тема формального
доказательства и теорем прулеров.

1660
01:56:14,880 --> 01:56:15,880
Пока не про это.

1661
01:56:17,210 --> 01:56:18,210
Deriving.

1662
01:56:19,050 --> 01:56:20,670
Что такое deriving?

1663
01:56:21,700 --> 01:56:23,270
Допустим, у нас есть traffic.

1664
01:56:23,550 --> 01:56:26,530
light, и мы не хотим для
него определять все инстансы.

1665
01:56:26,650 --> 01:56:27,950
Можем писать просто deriving,

1666
01:56:31,680 --> 01:56:33,710
специальный кейворд deriving,

1667
01:56:33,850 --> 01:56:36,490
и он выведет нам все инстансы.

1668
01:56:36,710 --> 01:56:39,290
Если мы хотим,
можем написать их кучу.

1669
01:56:40,120 --> 01:56:42,730
Янум, орд, шоу.

1670
01:56:43,510 --> 01:56:44,510
И он все это выведет.

1671
01:56:45,490 --> 01:56:46,290
Компилятор за нас.

1672
01:56:46,370 --> 01:56:48,430
Нам ничего не нужно делать.

1673
01:56:49,150 --> 01:56:50,150
Это пожалуйста.

1674
01:56:50,770 --> 01:56:51,770
Очень удобно.

1675
01:56:52,470 --> 01:56:54,590
Все автоматизировано за вас.

1676
01:56:57,240 --> 01:56:58,810
Можно сравнивать,

1677
01:56:59,090 --> 01:57:01,790
можно проверять неравенство.

1678
01:57:04,050 --> 01:57:06,510
Есть всякие toYanum, fromYanum.

1679
01:57:09,365 --> 01:57:10,630
У нас есть bound,

1680
01:57:10,770 --> 01:57:14,340
поэтому мы можем создавать

1681
01:57:15,450 --> 01:57:17,090
list comprehensions.

1682
01:57:19,630 --> 01:57:20,790
Сравнение лексикографическое,

1683
01:57:21,250 --> 01:57:22,250
или что это вообще?

1684
01:57:24,110 --> 01:57:26,410
Сравнение работает просто по номеру.

1685
01:57:26,890 --> 01:57:30,770
Red меньше, чем green.

1686
01:57:40,000 --> 01:57:42,160
Red меньше, чем yellow.

1687
01:57:46,260 --> 01:57:46,700
Янумы.

1688
01:57:47,170 --> 01:57:49,240
Если ты определяешь какие-то янумы,

1689
01:57:49,545 --> 01:57:51,560
обычно оно работает в плюсах каких-то.

1690
01:57:56,620 --> 01:57:58,360
Есть у этого некоторое неудобство.

1691
01:58:00,700 --> 01:58:02,540
Если я хочу что-то умное,

1692
01:58:02,660 --> 01:58:08,420
хочу, чтобы у меня орд
как-то по-другому работал,

1693
01:58:08,500 --> 01:58:10,000
но я все равно не
хочу его писать руками.

1694
01:58:10,001 --> 01:58:13,660
Тут уже все становится сложнее.

1695
01:58:15,330 --> 01:58:17,360
Иногда приходится писать много руками.

1696
01:58:18,360 --> 01:58:21,040
А что это i.x.

1697
01:58:22,180 --> 01:58:23,180
сверху? i.x.

1698
01:58:24,860 --> 01:58:26,940
ShowRead и i.x.

1699
01:58:31,080 --> 01:58:33,140
Это в блоке deriving на первой строчке.

1700
01:58:35,360 --> 01:58:36,600
Все, я вижу.

1701
01:58:37,160 --> 01:58:39,920
x это индекс.

1702
01:58:40,480 --> 01:58:42,240
Он является индексом, что ли.

1703
01:58:45,120 --> 01:58:48,760
Ну, в общем, посмотри в кугле.

1704
01:59:04,050 --> 01:59:06,310
Тут такой слайд вопрос.

1705
01:59:07,070 --> 01:59:10,830
Что если у нас есть какой-то дататайп,

1706
01:59:10,970 --> 01:59:13,310
который хранит функцию?

1707
01:59:14,520 --> 01:59:16,050
Что если мы для него попросим вывести?

1708
01:59:16,930 --> 01:59:22,970
Суть в том, что мы не можем
гарантировать, что во всех

1709
01:59:22,971 --> 01:59:27,190
случаях мы можем вывести хотя
бы какой-то тривиальный инстанс.

1710
01:59:27,810 --> 01:59:29,510
То есть есть функции, которые непонятно,

1711
01:59:29,715 --> 01:59:33,130
как печатать, например,
или читать из строки.

1712
01:59:33,250 --> 01:59:36,850
Поэтому нужно понимать, что
все это некоторые эвристики,

1713
01:59:38,210 --> 01:59:39,710
которые не всегда работают.

1714
01:59:50,200 --> 01:59:51,200
Причем...

1715
01:59:57,820 --> 01:59:59,010
Сейчас я немножко забыл.

1716
01:59:59,420 --> 02:00:00,650
Короче, надо уточнить.

1717
02:00:01,240 --> 02:00:03,770
Бывает так, что он сгенерит тебе что-то,

1718
02:00:04,310 --> 02:00:07,230
но для функции она не работает совсем.

1719
02:00:07,800 --> 02:00:09,930
Или она сгенерит тебе какой-нибудь инстанс,

1720
02:00:10,280 --> 02:00:13,690
в котором будут взаимно рекурсивные

1721
02:00:14,140 --> 02:00:16,070
просто дефолтные реализации.

1722
02:00:20,440 --> 02:00:21,510
Это надо уточнить.

1723
02:00:23,120 --> 02:00:27,470
А правила для дерайвинга, они вообще
зашиты в компилятор для контрактных типов?

1724
02:00:27,710 --> 02:00:29,030
Или они где-то в исходниках есть?

1725
02:00:29,890 --> 02:00:32,430
Это не зашиты в компилятор.

1726
02:00:34,830 --> 02:00:38,750
Вот эти все дерайвинги, они
предоставляются компилятором,

1727
02:00:38,950 --> 02:00:42,330
но есть способы писать свои дерайвинги.

1728
02:00:46,320 --> 02:00:47,390
Там, мне кажется,

1729
02:00:47,570 --> 02:00:49,550
подключается немножко метапрограммирование,

1730
02:00:51,150 --> 02:00:56,130
когда тебе хочется потраверсить тип,

1731
02:00:56,570 --> 02:00:57,830
взять все его конструкторы.

1732
02:00:58,190 --> 02:01:00,130
Короче, какие-то рефлекшены там есть,

1733
02:01:00,830 --> 02:01:02,130
говоря языком Java,

1734
02:01:03,130 --> 02:01:05,210
для которых ты можешь
генерить эти все дерайвинги.

1735
02:01:05,260 --> 02:01:06,450
Поэтому, в общем,

1736
02:01:09,900 --> 02:01:13,620
это не first class сущность в языке,

1737
02:01:13,880 --> 02:01:15,620
но есть поддержка.

1738
02:01:17,210 --> 02:01:18,800
В общем, например,

1739
02:01:19,020 --> 02:01:21,960
есть NewType, любимый.

1740
02:01:25,500 --> 02:01:26,740
Давайте посмотрим,

1741
02:01:26,880 --> 02:01:28,980
какие есть проблемы с NewType, например.

1742
02:01:31,540 --> 02:01:34,560
Нам, допустим, нужно
реализовать метод show.

1743
02:01:34,710 --> 02:01:37,600
Для этого нужно сделать
паттерн-матчинг по этому элементу.

1744
02:01:38,520 --> 02:01:40,140
Если мы делаем, допустим, ик,

1745
02:01:41,460 --> 02:01:44,980
мы должны сделать паттерн-матчинг
на левом и правом операнде,

1746
02:01:45,100 --> 02:01:47,740
взять инты оттуда и сравнить их.

1747
02:01:49,240 --> 02:01:49,980
То есть мы предполагаем,

1748
02:01:50,100 --> 02:01:52,520
что NewType — это некоторый синоним инта,

1749
02:01:52,720 --> 02:01:55,180
но не совсем,

1750
02:01:55,720 --> 02:01:57,440
которые отличаются от него по тигму.

1751
02:01:59,020 --> 02:02:00,020
И у нас проблема.

1752
02:02:00,180 --> 02:02:02,600
У нас уже нет реальный какой-то код.

1753
02:02:02,601 --> 02:02:06,060
У нас не просто enum и сравниваются,
а надо какой-то паттерн-матчинг делать,

1754
02:02:06,120 --> 02:02:08,180
еще что-то, потом
обратно это заворачивать,

1755
02:02:08,360 --> 02:02:10,560
наверное, где-то там в плюсе.

1756
02:02:10,860 --> 02:02:12,820
В общем, с этим есть проблема.

1757
02:02:13,340 --> 02:02:15,580
Это уже не включено в язык стандартный,

1758
02:02:15,800 --> 02:02:16,440
но есть расширение,

1759
02:02:16,720 --> 02:02:18,440
называется generalized NewType deriving,

1760
02:02:19,070 --> 02:02:20,580
который это все делает.

1761
02:02:21,560 --> 02:02:24,140
Ну и вот deriving может
быть довольно большим

1762
02:02:24,890 --> 02:02:25,890
для NewType,

1763
02:02:27,680 --> 02:02:28,680
потому что,

1764
02:02:31,540 --> 02:02:33,140
смотрите, тут как это работает.

1765
02:02:33,260 --> 02:02:34,260
Например, функтор.

1766
02:02:35,160 --> 02:02:37,040
Он не генерирует с нуля функтор,

1767
02:02:37,240 --> 02:02:39,320
но если у типа, который внутри,

1768
02:02:39,500 --> 02:02:40,380
уже есть функтор,

1769
02:02:40,500 --> 02:02:41,500
например, у инта,

1770
02:02:41,700 --> 02:02:42,480
но у инта нет,

1771
02:02:42,660 --> 02:02:43,800
допустим, NewType,

1772
02:02:44,045 --> 02:02:45,326
какой-нибудь параметр list есть,

1773
02:02:46,600 --> 02:02:46,900
аргумент,

1774
02:02:47,600 --> 02:02:49,900
то для него уже есть функтор.

1775
02:02:50,880 --> 02:02:52,040
Ему нужно просто, по сути,

1776
02:02:52,530 --> 02:02:53,530
написать определение,

1777
02:02:53,680 --> 02:02:57,940
которое делает паттерн-матчинг

1778
02:02:58,290 --> 02:03:01,860
на одном, единственном
существующем конструкторе,

1779
02:03:02,540 --> 02:03:03,260
применяет функцию,

1780
02:03:03,360 --> 02:03:04,520
потом опять это
заворачивает, если нужно.

1781
02:03:04,560 --> 02:03:05,560


1782
02:03:08,240 --> 02:03:09,780
И в антайме вообще-то вот эти вот

1783
02:03:09,980 --> 02:03:11,100
боксинги, анбоксинги,

1784
02:03:11,640 --> 02:03:12,220
они будут вообще,

1785
02:03:12,580 --> 02:03:14,160
типа, они будут уничтожены,

1786
02:03:14,350 --> 02:03:16,000
их не будет в антайме.

1787
02:03:16,500 --> 02:03:17,500
Поэтому

1788
02:03:19,960 --> 02:03:21,680
для NewType все проще,

1789
02:03:21,900 --> 02:03:25,580
и существуют эти директивы, которые
почти все можно для него вывести вообще.

1790
02:03:26,280 --> 02:03:27,280
То есть там никаких

1791
02:03:28,400 --> 02:03:30,100
ручных действий не нужно.

1792
02:03:32,040 --> 02:03:32,660
Причем тут, видите,

1793
02:03:32,780 --> 02:03:35,040
даже какие-то есть
параметры у deriving, типа.

1794
02:03:39,050 --> 02:03:40,050
В общем, да.

1795
02:03:44,080 --> 02:03:46,040
Довольно удобно на практике.

1796
02:03:49,630 --> 02:03:50,800
Да, и там вот ссылочки есть,

1797
02:03:50,960 --> 02:03:53,700
какой-то комментарий про то,

1798
02:03:54,570 --> 02:03:57,980
что делать, если вот
этот список deriving

1799
02:03:57,981 --> 02:03:59,320
слишком длинный, и
хочется у каждого повторять.

1800
02:04:00,980 --> 02:04:01,380
Хорошо.

1801
02:04:01,780 --> 02:04:03,720
Теперь давайте посмотрим модули.

1802
02:04:04,500 --> 02:04:06,020
Значит, смотрите,

1803
02:04:06,140 --> 02:04:10,960
какая есть проблема вот с type-классами,
которые мы до этого смотрели.

1804
02:04:11,080 --> 02:04:12,680
Чем они отличаются от классов

1805
02:04:12,780 --> 02:04:14,060
в плюсах, например.

1806
02:04:14,355 --> 02:04:15,740
У нас нет области видимости,

1807
02:04:16,640 --> 02:04:17,640
у нас нет вот этого вот

1808
02:04:18,410 --> 02:04:21,720
public полей, private
полей, вот этого всего нет.

1809
02:04:22,320 --> 02:04:23,500
У нас все public всегда.

1810
02:04:26,035 --> 02:04:28,101
Что как бы на самом
деле не очень хорошо.

1811
02:04:29,100 --> 02:04:31,320
Оно как бы упрощает жизнь

1812
02:04:31,545 --> 02:04:33,320
и позволяет реализовать

1813
02:04:33,495 --> 02:04:34,220
какие-то механизмы,

1814
02:04:34,340 --> 02:04:35,596
какой-то type-checking,
наверное, упрощает.

1815
02:04:35,620 --> 02:04:36,160


1816
02:04:36,460 --> 02:04:38,620
Но вообще это не очень удобно в жизни.

1817
02:04:39,560 --> 02:04:40,560
Но это можно

1818
02:04:41,310 --> 02:04:44,100
похожую функциональность
реализовать с помощью модулей.

1819
02:04:44,960 --> 02:04:46,460
То есть, смотрите,

1820
02:04:46,640 --> 02:04:47,360
у нас, допустим,

1821
02:04:47,550 --> 02:04:50,200
смотрим с первой строчки.

1822
02:04:50,860 --> 02:04:53,060
У нас есть модуль lib,

1823
02:04:54,630 --> 02:04:58,280
то, что в начале каждого
файла мы пишем модуль lib.

1824
02:04:58,740 --> 02:04:59,960
Это модуль, который
определяется в этом файле.

1825
02:04:59,961 --> 02:05:00,961
Ну, понятно.

1826
02:05:01,860 --> 02:05:02,320


1827
02:05:02,520 --> 02:05:04,340
Модуль — это набор кода,

1828
02:05:05,220 --> 02:05:06,560
который мы можем

1829
02:05:07,620 --> 02:05:08,820
отдельно скомпилировать,

1830
02:05:09,420 --> 02:05:10,460
потом куда-то заимпортить.

1831
02:05:12,400 --> 02:05:14,520
И мы указываем после lib в скобочках

1832
02:05:15,120 --> 02:05:16,280
те функции,

1833
02:05:17,020 --> 02:05:18,020
те модули,

1834
02:05:18,300 --> 02:05:20,100
те типы,

1835
02:05:20,350 --> 02:05:22,681
которые мы
экспозируем, которые мы

1836
02:05:24,020 --> 02:05:25,140
делаем открытыми для импорта.

1837
02:05:27,180 --> 02:05:28,180


1838
02:05:30,155 --> 02:05:32,781
То есть, если есть
какие-то детали реализации,

1839
02:05:33,020 --> 02:05:34,820
мы просто их не добавляем в этот список,

1840
02:05:34,940 --> 02:05:36,200
и они остаются закрытыми.

1841
02:05:37,540 --> 02:05:38,620
Понятно, зачем это нужно.

1842
02:05:40,720 --> 02:05:43,500
Если мы захотим поменять
реализацию, мы это можем сделать.

1843
02:05:43,980 --> 02:05:45,120
И будем уверены, что никто,

1844
02:05:46,940 --> 02:05:49,860
ни пользователя, никого
пользователя мы не сломаем

1845
02:05:50,560 --> 02:05:51,560
в нашей библиотеке,

1846
02:05:51,820 --> 02:05:53,980
потому что он не мог

1847
02:05:54,130 --> 02:05:55,780
использовать эти
детали реализации.

1848
02:05:55,781 --> 02:05:56,781


1849
02:05:58,120 --> 02:05:59,700
Посмотрим, как мы делаем импорт.

1850
02:06:00,340 --> 02:06:01,900
Мы пишем

1851
02:06:04,575 --> 02:06:05,640
foo.a, например.

1852
02:06:06,185 --> 02:06:08,940
То есть, у нас модули
имеют иерархию какую-то.

1853
02:06:10,720 --> 02:06:11,720
Иерархия строится,

1854
02:06:11,840 --> 02:06:12,840
по-моему, как в Java,

1855
02:06:14,180 --> 02:06:15,180
значит, по

1856
02:06:15,850 --> 02:06:18,800
файловой системе.
То есть, есть папка foo,

1857
02:06:19,550 --> 02:06:21,440
в ней есть файл a, файл b,

1858
02:06:23,450 --> 02:06:25,160
в нем определяются модули a и b,

1859
02:06:25,550 --> 02:06:31,260
поэтому мы определяем еще рядом
файл foo, в котором описывается модуль

1860
02:06:34,220 --> 02:06:35,220
foo.

1861
02:06:35,580 --> 02:06:37,080
Причем модуль foo может

1862
02:06:37,880 --> 02:06:39,020
импортить, значит,

1863
02:06:40,080 --> 02:06:41,260
какие-то,

1864
02:06:42,220 --> 02:06:44,460
грубо говоря, protected
вещи, какие-то детали

1865
02:06:45,180 --> 02:06:46,680
реализации, которые доступны

1866
02:06:47,380 --> 02:06:50,540
всему модулю foo, но не
выдавать их туда наверх.

1867
02:06:50,541 --> 02:06:51,541
То есть,

1868
02:06:55,190 --> 02:06:57,800
не делать их видимыми для

1869
02:06:58,750 --> 02:07:00,200
всего модуля foo.

1870
02:07:00,820 --> 02:07:02,340
Для всей библиотеки,
грубо говоря.

1871
02:07:02,540 --> 02:07:03,540


1872
02:07:05,800 --> 02:07:07,980
Давайте пробежимся
еще раз по синтаксису.

1873
02:07:08,220 --> 02:07:10,240
Значит, у нас есть импорт,

1874
02:07:10,380 --> 02:07:12,300
мы можем дальше в скобочках написать,

1875
02:07:12,675 --> 02:07:13,780
что мы конкретно
хотим заимпортить.

1876
02:07:15,020 --> 02:07:16,020


1877
02:07:16,660 --> 02:07:17,660
Вот, например, мы здесь,

1878
02:07:17,880 --> 02:07:20,300
посчитаю, что здесь написано, мы импортим

1879
02:07:21,140 --> 02:07:21,660
тип

1880
02:07:21,910 --> 02:07:23,720
foo b2 и

1881
02:07:24,180 --> 02:07:26,420
один его конструктор mkb1.

1882
02:07:27,200 --> 02:07:29,620
Возможно, это не один
конструктор, а их несколько.

1883
02:07:30,325 --> 02:07:31,860
Мы только этот хотим заимпортить.

1884
02:07:34,520 --> 02:07:39,180
Ну, собственно, справа у нас
есть определение, foo b2 у него два

1885
02:07:40,600 --> 02:07:41,160
конструктора,

1886
02:07:41,560 --> 02:07:43,100
мы только один из них импортим.

1887
02:07:45,420 --> 02:07:46,420
Ну, то есть,

1888
02:07:50,430 --> 02:07:51,220
когда-нибудь,
наверное, это нужно.

1889
02:07:51,280 --> 02:07:54,720
То есть, наверное, уже потомачить
мы уже не сможем сделать, но

1890
02:07:55,790 --> 02:07:57,180
пока немного создать

1891
02:07:59,660 --> 02:08:00,660
элемент мы сможем.

1892
02:08:01,800 --> 02:08:03,120
Вот, foo b3

1893
02:08:03,320 --> 02:08:04,320
значит,

1894
02:08:06,190 --> 02:08:09,300
с этим типом мы импортим
все его конструкторы.

1895
02:08:10,940 --> 02:08:13,360
Да, если мы не напишем
вот эти скобочки с двумя

1896
02:08:13,361 --> 02:08:15,140
точками, мы вообще не
будем импортить конструкторы.

1897
02:08:15,141 --> 02:08:17,300
Это тоже нужно учитывать.

1898
02:08:17,400 --> 02:08:19,340
Мы можем импортить
тип, но не его конструкторы.

1899
02:08:19,341 --> 02:08:21,580
Это разные вещи.

1900
02:08:22,160 --> 02:08:23,460
Ну, мы помним, что
конструкторы просто функции.

1901
02:08:23,461 --> 02:08:24,461


1902
02:08:25,840 --> 02:08:26,840
Вот, значит,

1903
02:08:28,640 --> 02:08:31,140
дальше мы можем сделать
хайдинг. То есть, мы можем

1904
02:08:32,080 --> 02:08:33,280
заимпортить все, кроме.

1905
02:08:34,140 --> 02:08:35,280
Например, это удобно для

1906
02:08:35,760 --> 02:08:37,160
прелюда, когда мы хотим...

1907
02:08:37,310 --> 02:08:40,980
Есть какая-то функция,
которая называется print, но

1908
02:08:40,981 --> 02:08:42,240
нам она не нравится, мы
хотим ее по-своему реализовать.

1909
02:08:43,790 --> 02:08:46,081
Мы ее не импортим,
чтобы у нас не было

1910
02:08:48,380 --> 02:08:48,820
переопределения,

1911
02:08:49,040 --> 02:08:50,080
не было одинаковых имен.

1912
02:08:53,440 --> 02:08:57,180
Дальше у нас пример, как можно импортить
операторы. Они в скобочках указываются.

1913
02:08:57,181 --> 02:08:58,181


1914
02:08:59,180 --> 02:09:00,840
Отдельных обязательно.

1915
02:09:00,841 --> 02:09:02,860
Потом мы можем
заимпортить пустые скобочки.

1916
02:09:02,861 --> 02:09:03,861


1917
02:09:04,700 --> 02:09:06,700
Смотрите, какой смысл пустых скобочек.

1918
02:09:09,580 --> 02:09:12,760
Казалось бы, мы делаем
импорт, но ничего не импортим.

1919
02:09:13,135 --> 02:09:14,896
То есть, как будто бы ничего.
На самом деле,

1920
02:09:15,555 --> 02:09:19,200
тут важный вопрос, а как происходит
импорт инстансов и классов?

1921
02:09:20,020 --> 02:09:22,676
Потому что для них на самом деле
нет никакого отдельного синдекса.

1922
02:09:22,700 --> 02:09:24,676
Например, я хочу
заимпортить только вот этот

1923
02:09:24,700 --> 02:09:26,300
класс, и вот этот класс,
и вот этот инстанс.

1924
02:09:30,060 --> 02:09:34,360
Для этого работает правило,
что если мы импортим модуль,

1925
02:09:34,460 --> 02:09:36,440
то мы импортим все его
инстансы и все классы.

1926
02:09:36,441 --> 02:09:37,680
То есть,

1927
02:09:38,455 --> 02:09:39,920
принято такое решение в Хаскере.

1928
02:09:40,560 --> 02:09:42,720
То есть, понятно, у него
есть свои плюсы и минусы,

1929
02:09:43,260 --> 02:09:44,260
но, в общем,

1930
02:09:46,260 --> 02:09:47,700
инстансы должны быть видны,

1931
02:09:48,300 --> 02:09:52,360
если мы импортим какой-то модуль,
все его инстансы видны и все классы.

1932
02:09:52,510 --> 02:09:54,000
Да, еще раз повторюсь.

1933
02:09:54,820 --> 02:09:55,820
И

1934
02:09:56,600 --> 02:09:59,340
такой синдекс позволяет
заимпортить только

1935
02:09:59,565 --> 02:10:01,260
инстансы и классы, если мы не указываем

1936
02:10:01,360 --> 02:10:02,440
в скобках ничего.

1937
02:10:04,480 --> 02:10:05,480
Мы все еще

1938
02:10:06,460 --> 02:10:07,460
импортим так классы.

1939
02:10:08,840 --> 02:10:10,520


1940
02:10:13,820 --> 02:10:15,300
Давайте дальше разберем.

1941
02:10:15,440 --> 02:10:16,440
Импорт.

1942
02:10:17,140 --> 02:10:18,140
База.

1943
02:10:18,640 --> 02:10:21,000
Мы можем как-то
по-другому назвать модуль.

1944
02:10:21,001 --> 02:10:22,920
Например,

1945
02:10:23,760 --> 02:10:27,520
x, y, z у нас какое-то длинное
название, мы не хотим

1946
02:10:27,580 --> 02:10:29,120
постоянно его писать, мы
можем переназвать как-нибудь,

1947
02:10:30,920 --> 02:10:32,100
дать короткое имя.

1948
02:10:32,800 --> 02:10:33,340
Потом есть

1949
02:10:33,540 --> 02:10:34,740
специальное слово qualified,

1950
02:10:35,360 --> 02:10:36,520
которое означает, что

1951
02:10:40,445 --> 02:10:41,140
любой символ,

1952
02:10:41,280 --> 02:10:43,600
который мы заимпортили,

1953
02:10:45,120 --> 02:10:46,120
который мы импортировали

1954
02:10:46,480 --> 02:10:49,560
из этого модуля, мы
обязаны указывать его

1955
02:10:51,270 --> 02:10:52,040
квалификатора,

1956
02:10:52,180 --> 02:10:53,260
то есть указывать
его полное имя.

1957
02:10:53,261 --> 02:10:54,340


1958
02:10:54,880 --> 02:10:56,500
Допустим, есть какая-нибудь
функция fold из data.

1959
02:10:57,300 --> 02:10:58,300


1960
02:10:59,200 --> 02:11:02,361
list модуля,

1961
02:11:02,970 --> 02:11:05,240
мы обязаны везде писать data.

1962
02:11:06,565 --> 02:11:08,040
list data.list.

1963
02:11:09,440 --> 02:11:10,440
fold fold fold в общем.

1964
02:11:10,560 --> 02:11:12,361



1965
02:11:15,640 --> 02:11:19,220
Это удобно, потому что
опять же, если у нас есть

1966
02:11:19,670 --> 02:11:21,120
своя функция fold,

1967
02:11:21,440 --> 02:11:23,060
и она совпадает с тем, что мы

1968
02:11:26,700 --> 02:11:27,700
импортировали,

1969
02:11:27,900 --> 02:11:28,920
мы указываем qualified,

1970
02:11:29,140 --> 02:11:30,140
и у нас

1971
02:11:32,120 --> 02:11:34,420
неоднозначность пропадает,
потому что мы знаем, что один из них

1972
02:11:34,421 --> 02:11:37,260
обязан быть указан с
полным путем модуля.

1973
02:11:38,480 --> 02:11:39,480


1974
02:11:40,300 --> 02:11:43,300
Но, понятно, полный путь
указать постоянно неудобно,

1975
02:11:43,380 --> 02:11:46,301
поэтому мы можем
комбинировать это с

1976
02:11:48,180 --> 02:11:49,360
синонимом, допустим,

1977
02:11:49,500 --> 02:11:50,500
c,

1978
02:11:51,920 --> 02:11:52,940
опять же, можно

1979
02:11:53,515 --> 02:11:56,520
спрятать какие-то
вещи и не импортить их.

1980
02:11:57,280 --> 02:11:59,500
Можно заимпортировать
только что-то, что мы хотим.

1981
02:12:00,240 --> 02:12:01,240
В общем, понятно.

1982
02:12:01,950 --> 02:12:06,580
Причем, да, смотрите, в
последнем примере у нас есть,

1983
02:12:07,380 --> 02:12:09,240
мы импортируем

1984
02:12:09,790 --> 02:12:10,920
модуль x и y,

1985
02:12:11,320 --> 02:12:13,180
и оба из них называем export,

1986
02:12:13,530 --> 02:12:16,960
тем самым мы их как бы собираем в
один модуль, мы их как бы объединяем.

1987
02:12:19,540 --> 02:12:20,680
Тоже может быть удобно.

1988
02:12:23,460 --> 02:12:25,100
Вот, вроде бы все разобрал.

1989
02:12:26,680 --> 02:12:27,040
Давайте,

1990
02:12:27,180 --> 02:12:28,180
какие есть вопросы?

1991
02:12:38,440 --> 02:12:40,140
А если мы заимпортировали

1992
02:12:40,340 --> 02:12:41,460
fu.x и fu.

1993
02:12:41,461 --> 02:12:43,740
y одним и тем же
именем, как мы сможем

1994
02:12:44,390 --> 02:12:45,390
к ним обращаться?

1995
02:12:47,825 --> 02:12:49,800
Смотри, они оба обозначены

1996
02:12:49,950 --> 02:12:54,020
как qualified, поэтому мы
обращаемся как export.что-то.

1997
02:12:56,940 --> 02:12:57,640
Если они оба

1998
02:12:57,940 --> 02:12:59,640
импортируют одинаковое
имя, я думаю, что очень жаль.

1999
02:12:59,760 --> 02:13:00,760
Ага, хорошо.

2000
02:13:02,180 --> 02:13:03,320


2001
02:13:10,100 --> 02:13:13,500
А чем отличается
просто import fu.

2002
02:13:13,800 --> 02:13:15,040
y s-export

2003
02:13:15,190 --> 02:13:17,060
от import qualified fu.

2004
02:13:17,061 --> 02:13:18,061
y s-export?

2005
02:13:19,060 --> 02:13:20,360
Смотрите, повторяю,

2006
02:13:20,460 --> 02:13:23,400
qualified значит, что
ко всем символам из

2007
02:13:23,500 --> 02:13:28,060
этого модуля ты обязан
обращаться с квалификатором.

2008
02:13:29,560 --> 02:13:30,140


2009
02:13:30,260 --> 02:13:31,800
То есть ты обязан писать

2010
02:13:31,900 --> 02:13:34,120
fu.x.имя.

2011
02:13:34,700 --> 02:13:35,740
Ну а если не qualified,

2012
02:13:36,020 --> 02:13:38,240
то я тоже могу так
сделать, но не обязательно.

2013
02:13:38,900 --> 02:13:39,900
Да.

2014
02:13:54,145 --> 02:13:57,040
Ну то есть слайд выглядит
на самом деле сложно,

2015
02:13:57,041 --> 02:13:59,520
но на самом деле тут как
бы все довольно понятно,

2016
02:13:59,920 --> 02:14:03,980
и все что хотелось бы иметь

2017
02:14:04,480 --> 02:14:05,480
от модулей, оно есть.

2018
02:14:05,720 --> 02:14:06,720


2019
02:14:07,580 --> 02:14:10,620
Изначально в Haskell нельзя два модуля
в одном файле объявлять, это неудобно.

2020
02:14:10,660 --> 02:14:11,660


2021
02:14:12,820 --> 02:14:13,820
Ну,

2022
02:14:15,450 --> 02:14:16,640
какие-то трейд-оффы.

2023
02:14:24,640 --> 02:14:29,280
Но при этом, при том, что нельзя объявлять
два модуля в одном файле, модуль может

2024
02:14:30,500 --> 02:14:31,780
экспортировать модуль,

2025
02:14:32,280 --> 02:14:34,260
потому что он может его
перед этим заимпортить.

2026
02:14:34,760 --> 02:14:36,800
То есть, видите, модуль lib

2027
02:14:40,680 --> 02:14:41,220
импортит

2028
02:14:41,470 --> 02:14:43,960
fu.x и fu.y как экспорт,

2029
02:14:44,260 --> 02:14:45,260
и потом экспорт

2030
02:14:46,040 --> 02:14:47,040
экспортирует дальше.

2031
02:14:52,860 --> 02:14:58,340
То есть, как бы, lib, он немножко
пересобирает область видимости библиотеки

2032
02:15:00,520 --> 02:15:02,180
и создает такой интерфейс.

2033
02:15:06,960 --> 02:15:07,960
Вот.

2034
02:15:09,810 --> 02:15:11,636
Ну ладно, если понятно,
давайте пойдем дальше.

2035
02:15:11,660 --> 02:15:12,760
Там осталось вроде немного.

2036
02:15:14,100 --> 02:15:15,100
Значит,

2037
02:15:16,380 --> 02:15:17,420
extra knowledges.

2038
02:15:19,440 --> 02:15:22,180
Тут, короче, какие-то интересные ссылочки.

2039
02:15:22,770 --> 02:15:24,800
Вот последняя-то статья,
про которую я говорил.

2040
02:15:25,280 --> 02:15:27,700
How to make ad-hoc
polymorphism less ad-hoc.

2041
02:15:30,360 --> 02:15:31,500
Кому интересно, почитайте.

2042
02:15:31,640 --> 02:15:32,540
Прикольно должно быть.

2043
02:15:32,541 --> 02:15:33,541
Вот.

2044
02:15:33,660 --> 02:15:36,660
И какие-то еще фичи
тэп-классов мы еще будем говорить

2045
02:15:37,910 --> 02:15:38,660
в следующих лекциях.

2046
02:15:38,661 --> 02:15:39,880


2047
02:15:41,680 --> 02:15:43,180
Что тут осталось?

2048
02:15:44,500 --> 02:15:45,780
Нерекурсивные ADT.

2049
02:15:47,460 --> 02:15:49,520
А, ну, такой

2050
02:15:52,740 --> 02:15:53,740
теоретический

2051
02:15:54,220 --> 02:15:55,220
пассаж, наверное.

2052
02:15:58,700 --> 02:16:00,760
Сейчас я попытаюсь сказать
более простыми словами,

2053
02:16:01,185 --> 02:16:03,780
что, допустим, у нас
есть вот такой тип

2054
02:16:05,015 --> 02:16:06,620
DoctorWho, это Tardis

2055
02:16:06,770 --> 02:16:09,661
или Dalek, в общем, какая-то
сумма типов у нас есть.

2056
02:16:11,300 --> 02:16:16,000
И, на самом деле, можно
закодировать с помощью функций.

2057
02:16:16,180 --> 02:16:17,180
То есть, как бы,

2058
02:16:18,670 --> 02:16:20,060
это называется Churching Coding,

2059
02:16:20,220 --> 02:16:23,561
то есть кодирование черча для

2060
02:16:25,940 --> 02:16:27,060
алгебрыческих типов данных.

2061
02:16:27,300 --> 02:16:28,300
Что

2062
02:16:30,860 --> 02:16:32,020
мы можем закодировать

2063
02:16:32,370 --> 02:16:34,460
тип Doctor

2064
02:16:34,585 --> 02:16:36,120
через такие, как бы, замоками.

2065
02:16:36,340 --> 02:16:37,340
То есть, допустим,

2066
02:16:41,180 --> 02:16:42,180
допустим, у нас нет

2067
02:16:42,740 --> 02:16:43,740
директивы Data,

2068
02:16:45,580 --> 02:16:46,200
у нас нет

2069
02:16:46,580 --> 02:16:50,660
никакого синтеза для этого, но мы
все еще можем сделать алгебрыческие

2070
02:16:50,661 --> 02:16:52,440
типы данных просто на
лямбда-исчислении, на самом деле.

2071
02:16:52,620 --> 02:16:54,880
То есть просто на функциях.

2072
02:16:55,280 --> 02:17:00,520
Допустим, функция fTardis это функция,
которая принимает a и b, это параметры

2073
02:17:00,720 --> 02:17:01,840
первого конструктора,

2074
02:17:02,460 --> 02:17:03,820
и возвращает, как бы,

2075
02:17:04,400 --> 02:17:05,400
такой

2076
02:17:07,020 --> 02:17:09,820
continuation или замыкание,

2077
02:17:10,560 --> 02:17:11,940
которое принимает

2078
02:17:18,820 --> 02:17:19,880
тип...

2079
02:17:20,440 --> 02:17:21,920
которое принимает две
функции Tardis и Dalek.

2080
02:17:23,380 --> 02:17:28,900
И эти функции это функции,
которые хотят что-то сделать

2081
02:17:29,150 --> 02:17:30,720
с обоими вариантами.

2082
02:17:30,721 --> 02:17:31,800
То есть это такой, как бы, кейс,

2083
02:17:32,200 --> 02:17:34,140
какой-то такой pattern matching,

2084
02:17:34,620 --> 02:17:37,160
который уже, как бы, вшит в конструктор.

2085
02:17:37,340 --> 02:17:40,180
То есть конструктор
уже ждет две функции

2086
02:17:42,700 --> 02:17:46,620
и применяет только
одну из них, потому что это

2087
02:17:46,621 --> 02:17:48,400
конструктор, он знает
параметры двух, и он, как бы,

2088
02:17:49,780 --> 02:17:50,300
сохраняет

2089
02:17:50,640 --> 02:17:52,520
их замыкание и
применяет к ним левый.

2090
02:17:52,521 --> 02:17:53,521


2091
02:17:55,520 --> 02:18:00,400
И при этом симметрично
вторая функция, второй

2092
02:18:00,401 --> 02:18:01,700
конструктор, он принимает
один параметр, потому что

2093
02:18:02,740 --> 02:18:04,320
конструктор имеет только один параметр,

2094
02:18:04,920 --> 02:18:06,240
его сохраняет замыкание

2095
02:18:06,465 --> 02:18:09,920
и в этом случае уже
игнорирует, как бы,

2096
02:18:12,620 --> 02:18:15,900
левый рекурсивный вызов и
вызывает правый от этого конструктора.

2097
02:18:16,290 --> 02:18:18,530
То есть смотрите, у нас
получается, что эти две функции,

2098
02:18:20,300 --> 02:18:23,960
если на них посмотреть, то они обе,
они сначала принимают параметры

2099
02:18:24,360 --> 02:18:25,360
своих конструкторов,

2100
02:18:26,380 --> 02:18:27,580
потом принимают

2101
02:18:29,200 --> 02:18:31,940
одинаковые две функции, значит,

2102
02:18:34,260 --> 02:18:36,340
рекурсивного вызова от вариантов,

2103
02:18:36,600 --> 02:18:38,160
но одна вызывает, значит, от одного,

2104
02:18:38,300 --> 02:18:40,260
а другая от другого.
То есть вот этот вот хвост

2105
02:18:40,560 --> 02:18:41,640
у них одинаковый.

2106
02:18:42,200 --> 02:18:43,200
И вот этот хвост

2107
02:18:44,250 --> 02:18:45,420
на самом деле

2108
02:18:46,160 --> 02:18:47,920
является нашим типом. То есть смотрите,

2109
02:18:48,040 --> 02:18:51,920
как это дальше использовать. Допустим,
у нас есть там какая-то функция travel,

2110
02:18:54,400 --> 02:18:55,560
которая принимает

2111
02:19:00,040 --> 02:19:01,040
паттерн

2112
02:19:06,250 --> 02:19:11,010
А, это было предыдем определено.

2113
02:19:15,200 --> 02:19:16,200
Что?

2114
02:19:16,275 --> 02:19:20,000
Это какие-то две функции, которые
типа что-то делают. Ага, смотрите,

2115
02:19:20,280 --> 02:19:22,580
дальше у нас есть два
конструктора, мы хотим сделать

2116
02:19:22,630 --> 02:19:26,680
типа паттерн-матчинг. Паттерн-матчинг
выглядит как? Мы просто передаем

2117
02:19:27,695 --> 02:19:28,740
нашему типу две функции.

2118
02:19:28,741 --> 02:19:29,741


2119
02:19:30,500 --> 02:19:32,380
Две функции, которые,
собственно, левая и правая.

2120
02:19:32,480 --> 02:19:34,480
И в зависимости от
того, с помощью чего

2121
02:19:34,481 --> 02:19:39,661
был сделан наш конструктор, с
помощью функции f-targets или f-dialog,

2122
02:19:40,380 --> 02:19:41,660
будет соответствующий результат.

2123
02:19:42,640 --> 02:19:44,440
То есть вот, если мы передадим

2124
02:19:44,640 --> 02:19:46,100
в f-travel, значит, наш тип

2125
02:19:47,640 --> 02:19:48,640
сконструированный,

2126
02:19:49,860 --> 02:19:52,340
созданный
конструктором f-targets 0,0,

2127
02:19:52,610 --> 02:19:55,700
у нас будет один результат, с
помощью f-dialog будет другой результат.

2128
02:19:56,900 --> 02:19:58,080
И, смотрите, если мы сделаем

2129
02:19:58,330 --> 02:20:00,360
type alias на

2130
02:20:00,560 --> 02:20:04,260
типа вот это вот хвост, который
у нас был у этих конструкторов,

2131
02:20:04,420 --> 02:20:05,600
то на самом деле мы

2132
02:20:07,420 --> 02:20:08,300
получим нормальную
сигнатуру конструкторов.

2133
02:20:08,301 --> 02:20:09,301


2134
02:20:12,490 --> 02:20:15,111
Ну, это такой стандартный
способ закодировать

2135
02:20:16,330 --> 02:20:17,770
географические типы данных
с помощью просто функции.

2136
02:20:17,820 --> 02:20:18,820


2137
02:20:19,100 --> 02:20:20,100
То есть

2138
02:20:21,700 --> 02:20:23,451
это интересно теоретикам,

2139
02:20:25,650 --> 02:20:30,350
которые показывают типа,
вот сколько можно классных

2140
02:20:30,351 --> 02:20:31,351
штук сделать с помощью
простого лямбда-счисления.

2141
02:20:31,630 --> 02:20:34,630
На курсе теории типов про это рассказывают.

2142
02:20:36,230 --> 02:20:38,331
Под компотом оно разве

2143
02:20:38,650 --> 02:20:39,870
точно так же не кодируется?

2144
02:20:41,750 --> 02:20:44,650
Под компотом как оно
кодируется, я не могу сказать.

2145
02:20:44,651 --> 02:20:46,131
То есть

2146
02:20:47,530 --> 02:20:49,410
я не думаю, что это самый эффективный

2147
02:20:50,110 --> 02:20:51,110
способ

2148
02:20:51,325 --> 02:20:52,365
представления этого всего.

2149
02:20:53,750 --> 02:20:55,270
Это не про эффективность,

2150
02:20:55,370 --> 02:20:58,810
это про выразительность, что с помощью
функции можно закодировать вот это.

2151
02:21:00,670 --> 02:21:02,890
Потому что как будто на
функции написали то же самое

2152
02:21:03,500 --> 02:21:07,110
с точки зрения функции, потому что
если все это функция, то оно как будто бы

2153
02:21:07,111 --> 02:21:09,851
так и было закодировано,
только это было скрыто с эхором.

2154
02:21:11,080 --> 02:21:13,550
Ну, смотри, в случае

2155
02:21:14,810 --> 02:21:17,690
более императивном мы
можем сохранить объект

2156
02:21:18,230 --> 02:21:22,510
доктор просто как
тег и какие-то поля.

2157
02:21:23,550 --> 02:21:26,210
В случае этого
черчен-кодинга у нас

2158
02:21:26,360 --> 02:21:30,050
объект это какое-то замыкание,

2159
02:21:30,390 --> 02:21:34,450
которое на самом деле это уже не
объект, который хранится в памяти,

2160
02:21:34,690 --> 02:21:35,690
это как бы

2161
02:21:36,400 --> 02:21:38,530
этим объектом это
замыкание, то есть это функция.

2162
02:21:42,250 --> 02:21:44,250
Ну, как так сказать...

2163
02:21:45,240 --> 02:21:46,290
Смотри, если у нас

2164
02:21:46,490 --> 02:21:48,690
под капотом язык реализован императивно,

2165
02:21:50,090 --> 02:21:50,290
то

2166
02:21:50,790 --> 02:21:52,270
лучше все-таки первый вариант,

2167
02:21:52,410 --> 02:21:55,410
когда мы просто храним в памяти
эту гравитационную структуру,

2168
02:21:55,990 --> 02:21:56,990
грубо говоря,

2169
02:21:58,330 --> 02:21:59,330
с тегом,

2170
02:22:00,480 --> 02:22:01,790
как вариант в плюсах.

2171
02:22:02,830 --> 02:22:06,130
Если у нас под капотом есть какие-то
символьные вычисления, если мы

2172
02:22:06,131 --> 02:22:09,970
говорим, ну, мы, короче,
делаем там бета-редукцию,

2173
02:22:09,971 --> 02:22:11,910
мы, типа, упрощаем
выражение просто,

2174
02:22:12,490 --> 02:22:13,710
тем самым делаем вычисления,

2175
02:22:14,890 --> 02:22:15,910
то, да,

2176
02:22:16,810 --> 02:22:18,150
второй вариант лучше.

2177
02:22:20,050 --> 02:22:21,251
Как Haskell

2178
02:22:21,530 --> 02:22:23,970
в GHCI реально реализован,

2179
02:22:24,600 --> 02:22:26,070
я думаю, что там
как бы что-то среднее.

2180
02:22:26,220 --> 02:22:27,220


2181
02:22:29,150 --> 02:22:31,806
Я не берусь говорить,
как там реально это

2182
02:22:31,830 --> 02:22:34,190
реализовано, я не копался
под капотом компилятора.

2183
02:22:41,370 --> 02:22:44,371
Ну, короче, иногда
вот такой... смотри,

2184
02:22:44,810 --> 02:22:48,970
плюс Haskell в том, что ты
можешь как бы иметь оба

2185
02:22:48,971 --> 02:22:51,030
варианта, что у тебя есть
как бы встроенная в язык

2186
02:22:51,630 --> 02:22:53,070
такая штука эффективная,

2187
02:22:53,870 --> 02:22:56,910
есть вот такая вот, типа,
на функциях, и иногда

2188
02:22:57,010 --> 02:22:58,750
вот эта штука на самом
деле используется.

2189
02:23:00,410 --> 02:23:01,450
Довольно редко

2190
02:23:01,900 --> 02:23:03,070
в участии, но

2191
02:23:03,850 --> 02:23:04,890
иногда используется.

2192
02:23:14,360 --> 02:23:15,580
Надеюсь, я ответил на вопрос.

2193
02:23:18,860 --> 02:23:19,860
Или просто испугал.

2194
02:23:20,700 --> 02:23:21,700


2195
02:23:23,180 --> 02:23:24,380
Нет, но мы же писали

2196
02:23:24,580 --> 02:23:26,860
эти всякие черт-инкодинги на нот-логику.

2197
02:23:27,760 --> 02:23:28,760
А, ну вот.

2198
02:23:38,100 --> 02:23:39,100
Ну, типа...

2199
02:23:39,540 --> 02:23:41,660
Да, я бы все сказал.

2200
02:23:45,580 --> 02:23:46,580
Короче, да.

2201
02:23:50,430 --> 02:23:53,480
Да, и вот тут еще есть комментарий,
что на самом деле вот такую штуку,

2202
02:23:53,760 --> 02:23:57,200
типа, вот эти все
определения можно с помощью

2203
02:23:57,880 --> 02:23:59,360
метапрограммирования, короче, все это

2204
02:23:59,720 --> 02:24:01,320
сгенерить, на самом деле.

2205
02:24:02,260 --> 02:24:03,860
Иногда это очень удобно.

2206
02:24:04,820 --> 02:24:06,520
Потому что потом
это еще увидите.

2207
02:24:07,700 --> 02:24:08,700
Вот.

2208
02:24:09,100 --> 02:24:13,260
Ну, дальше какие-то слова про
то, что, типа, на самом деле C++ это

2209
02:24:14,180 --> 02:24:15,180
такие

2210
02:24:16,200 --> 02:24:17,200
словари

2211
02:24:18,280 --> 02:24:19,280
с методами,

2212
02:24:19,440 --> 02:24:20,440
но я про это говорил.

2213
02:24:22,680 --> 02:24:24,641
Инстанции, на самом деле,
это просто, типа, с объектами.

2214
02:24:25,270 --> 02:24:26,270


2215
02:24:28,300 --> 02:24:31,560
Типа с реализацией
методов, с функциями.

2216
02:24:32,640 --> 02:24:33,060
Вот.

2217
02:24:33,340 --> 02:24:34,340
В общем-то все.

2218
02:24:35,100 --> 02:24:37,320
На этом, я думаю, что лекция закончена.

2219
02:24:37,400 --> 02:24:38,860
Давайте вопросы какие-то.

2220
02:24:40,480 --> 02:24:42,900
Домашка, соответственно,
будет после этой лекции?

2221
02:24:46,280 --> 02:24:47,800
Это я, честно говоря, не знаю.

2222
02:24:48,480 --> 02:24:49,820
Я не отвечаю за домашки.

2223
02:24:51,020 --> 02:24:51,220
Вот.

2224
02:24:51,320 --> 02:24:55,240
Я, возможно, отвечаю за их
проверки, но не за их выкрутку.

2225
02:24:56,500 --> 02:24:56,780
Это скорее к Диме.

2226
02:24:56,781 --> 02:24:58,060


2227
02:24:58,620 --> 02:25:00,480
Очень было бы хорошо, если бы она была.

2228
02:25:01,990 --> 02:25:02,960
Ну да, чтобы было на
чем помедитировать.

2229
02:25:02,961 --> 02:25:03,961


2230
02:25:05,320 --> 02:25:06,840
Сейчас слишком много всего.

2231
02:25:07,640 --> 02:25:08,640


2232
02:25:08,920 --> 02:25:10,620
Да, я понимаю вас.

2233
02:25:10,720 --> 02:25:11,720
Я вас понимаю.

2234
02:25:19,360 --> 02:25:20,360
Я, честно говоря,

2235
02:25:20,890 --> 02:25:23,230
плохо знаком с
домашками в этом году.

2236
02:25:23,950 --> 02:25:24,950
Но

2237
02:25:25,530 --> 02:25:27,130
мне кажется, что там должно быть что-то

2238
02:25:27,940 --> 02:25:28,940
такое, как это сказать,

2239
02:25:29,410 --> 02:25:31,030
простое, типа написать
каких-то инстансов.

2240
02:25:31,570 --> 02:25:32,570


2241
02:25:35,410 --> 02:25:38,890
Потому что, понятно, да,
очень много нового всего, а тут

2242
02:25:38,891 --> 02:25:40,690
скорее проблема в том, что
очень много непонятных концепций,

2243
02:25:41,055 --> 02:25:43,110
каких-то непривычных, если вы до этого

2244
02:25:43,235 --> 02:25:44,790
писали только на плюсах, например.

2245
02:25:46,430 --> 02:25:47,250
Мы все писали на клажуре.

2246
02:25:47,251 --> 02:25:48,251


2247
02:25:49,970 --> 02:25:51,510
Про логию мы тоже писали.

2248
02:25:52,310 --> 02:25:53,610
Ой, ну клажур,

2249
02:25:53,750 --> 02:25:54,870
про лог это, да.

2250
02:25:55,430 --> 02:25:56,990
Клажур это же инвалидная ФП.

2251
02:25:59,900 --> 02:26:00,930
Ну как инвалидная?

2252
02:26:01,390 --> 02:26:03,310
Оно как бы, типа это гибрид.

2253
02:26:03,690 --> 02:26:04,690
Гибрид.

2254
02:26:05,795 --> 02:26:07,390
ФП и джава.

2255
02:26:11,590 --> 02:26:12,590
Клажур.

2256
02:26:12,710 --> 02:26:14,530
Я тоже писал карты на клажуре.

2257
02:26:14,630 --> 02:26:15,630
Парсер.

2258
02:26:16,820 --> 02:26:17,820
На 70-ок.

2259
02:26:25,550 --> 02:26:27,200
Все мы когда-то писали парсеры.

2260
02:26:29,720 --> 02:26:30,720
Да.

2261
02:26:37,770 --> 02:26:38,880
Ну, всем спасибо.

2262
02:26:39,780 --> 02:26:40,560
Я не знаю,

2263
02:26:40,780 --> 02:26:42,160
если еще какие-то есть вопросы,

2264
02:26:42,670 --> 02:26:43,670
если хотите отсудить,
можем отсудить.

2265
02:26:45,280 --> 02:26:46,280


2266
02:26:46,620 --> 02:26:47,780
Если нет, то давайте.

2267
02:26:49,320 --> 02:26:50,320
Всем удачи.

2268
02:26:51,680 --> 02:26:52,680
Спасибо, до свидания.

2269
02:26:54,780 --> 02:26:55,780
Спасибо, до свидания.

2270
02:26:59,740 --> 02:27:01,100
И вам спасибо, что пришли.

2271
02:27:06,960 --> 02:27:08,700
Как слышно на языке Штукенберга.

2272
02:27:13,940 --> 02:27:15,140
Ладно, всем пока.

