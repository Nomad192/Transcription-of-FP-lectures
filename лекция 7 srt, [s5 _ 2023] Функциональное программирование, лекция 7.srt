1
00:00:02,380 --> 00:00:07,343
Итак, сегодня мы будем проходить
что такое монадные трансформеры, и это

2
00:00:07,386 --> 00:00:12,461
одна из самых основных техник Хаскеля,
которая используется повсеместно.

3
00:00:13,340 --> 00:00:17,117
В чем, собственно, проблема,
которую мы сегодня будем

4
00:00:17,159 --> 00:00:20,761
проходить? Давайте начнем
с повторения небольшого.

5
00:00:21,600 --> 00:00:27,685
Что такое монада? Вы должны были
изучать на прошлом занятии, что монада это

6
00:00:27,728 --> 00:00:34,181
некоторый способ показать, что определенный
код использует определенный эффект.

7
00:00:35,545 --> 00:00:41,787
То есть, что, например, если вы пишете в шапке функции,
что у вас действие происходит в монаде райтера, вы как

8
00:00:41,829 --> 00:00:47,998
бы добавляете к тому, что вы можете делать здесь, запись
в какой-то моноидальный аккумулятор или просто лоб.

9
00:00:48,080 --> 00:00:50,487
Ридер, соответственно,
добавляет вам какой-то

10
00:00:50,530 --> 00:00:52,598
неизменяемый контекст, ну и так далее.

11
00:00:52,680 --> 00:00:58,659
То есть, забавно, но если вы посмотрите
на любой язык программирования

12
00:00:58,702 --> 00:01:04,981
OOP, то вы увидите, что там тоже
самое есть, просто оно включено по базе.

13
00:01:05,400 --> 00:01:08,487
То есть, вы, находясь в любом
месте, можете делать какой-нибудь

14
00:01:08,529 --> 00:01:11,558
лог, какой-нибудь стейт хранить,
еще какой-нибудь его писать.

15
00:01:11,640 --> 00:01:17,253
В Haskell'е эти все эффекты нужно подключать по
отдельности. Почему? Потому что, во-первых, чтобы избавиться

16
00:01:17,296 --> 00:01:22,898
от мусора, во-вторых, потому что можно построить
оптимизацию на том, что у вас не все эффекты используются.

17
00:01:22,980 --> 00:01:26,679
Самый банальный пример – это
чистые функции, которые без I.O.

18
00:01:26,722 --> 00:01:30,161
, соответственно, можно
оптимизировать на этапе компиляции.

19
00:01:35,640 --> 00:01:39,878
А теперь задача. Мы хотим применить
несколько эффектов к нашей функции.

20
00:01:39,921 --> 00:01:44,201
То есть, грубо говоря,
стимулировать несколько монад.

21
00:01:50,180 --> 00:01:55,933
Значит, вот то, что вы проходили на предыдущих
лекциях, вот у вас есть Reader. То есть, у вас есть

22
00:01:55,976 --> 00:02:01,770
какой-то environment, который вы не хотите передавать
переменно, вы передаете его в монаде Reader.

23
00:02:03,240 --> 00:02:07,022
А теперь я хочу, чтобы у меня был
эффект ридера и стейта. Самый банальный

24
00:02:07,065 --> 00:02:11,203
пример, который здесь можно привести,
например, вы пишите какую-нибудь игрушку.

25
00:02:11,285 --> 00:02:15,448
И вот в этой игрушке у вас есть
какой-нибудь, не знаю, давайте возьмем,

26
00:02:15,491 --> 00:02:19,992
например, шахматы. И вот у вас есть
стейт в виде положения ее фигур на поле.

27
00:02:20,780 --> 00:02:26,073
То есть, сам стейт игры. И Reader, который
отвечает, например, за какую-нибудь

28
00:02:26,116 --> 00:02:31,861
отрисовку, за параметры поля. Не знаю,
выходите вы доску на 64 клетки, а там на 128.

29
00:02:33,410 --> 00:02:37,634
Я хочу скомбинировать, соответственно,
эффекты неизменяемого окружения и

30
00:02:37,676 --> 00:02:41,941
изменяемого стейта. Как я могу что-то
подобное сделать? Какие есть идеи? Тапл.

31
00:02:53,070 --> 00:02:56,230
Сделать тапл из двух вещей, из двух монад.

32
00:02:56,231 --> 00:03:01,689
Это плохая идея. Почему? Потому что
вы тогда теряете преимущество обоих.

33
00:03:01,732 --> 00:03:07,231
То есть, вы теряете возможность
оперировать внутри монады.

34
00:03:07,930 --> 00:03:12,708
В этом случае вы теряете
преимущество обоих. Вы не получаете

35
00:03:12,751 --> 00:03:17,811
преимущество двух, вы теряете
преимущество обеих. Еще варианты?

36
00:03:19,025 --> 00:03:21,630
Извините, но можно сделать полный экран?

37
00:03:21,880 --> 00:03:27,990
Можно, но тогда я не смогу переключаться.
А, нет, смогу, все хорошо.

38
00:03:29,130 --> 00:03:29,963
Спасибо.

39
00:03:30,690 --> 00:03:34,710
Еще идея? Есть у кого-нибудь?

40
00:03:42,230 --> 00:03:43,450
Монады над монадой.

41
00:03:45,010 --> 00:03:51,390
Это финальное решение, не совсем в
таком виде, и мы пройдем его чуть дальше.

42
00:03:51,391 --> 00:03:55,299
Если вы попробуете просто
использовать монаду в качестве… то есть,

43
00:03:55,342 --> 00:03:59,471
написать условно там «reader
environment» в скобочках «state» от «a»,

44
00:03:59,595 --> 00:04:01,577
вы получите преимущество «reader», вы все

45
00:04:01,619 --> 00:04:03,791
еще не получите
преимущество «state» от «a».

46
00:04:03,840 --> 00:04:08,390
У вас будет «state», который нужно будет
как-то разворачивать, что, честно, будет…

47
00:04:08,440 --> 00:04:10,800
То есть, грубо говоря, каждый
раз, когда вы хотите дернуть

48
00:04:10,842 --> 00:04:13,368
что-то «state»овое, вам нужно
будет «run state» использовать.

49
00:04:13,450 --> 00:04:15,906
Передавать ему «state», но это не позволит

50
00:04:15,949 --> 00:04:18,863
сохранить «state» на
протяжении всего вычисления.

51
00:04:20,310 --> 00:04:21,143
Еще варианты?

52
00:04:25,865 --> 00:04:27,297
Хорошо, давайте немножко упростим задачу.

53
00:04:27,380 --> 00:04:34,480
Хотим чисто «reader», хотим просто,
чтобы у нас был «environment» и «state».

54
00:04:34,580 --> 00:04:36,992
Неважно, там мутабельное, не мутабельное.

55
00:04:38,960 --> 00:04:40,080
Ну ладно, черт.

56
00:04:40,820 --> 00:04:45,097
Да, значит, хотим что-то
вот такое, чтобы у нас

57
00:04:45,139 --> 00:04:49,641
был здесь вот «ask»,
чтобы у нас был здесь «put».

58
00:04:49,690 --> 00:04:54,044
То есть, «ask» идет у нас от,
соответственно, «reader» и «put» от «state».

59
00:04:54,375 --> 00:04:56,980
Вариант, который никто не предложил.

60
00:04:57,380 --> 00:05:00,020
Ну, первое — это использовать «rvs».

61
00:05:00,470 --> 00:05:02,746
Я понимаю, что есть такая
манатка «rvs», которая

62
00:05:02,789 --> 00:05:05,348
совершает себе внезапно
«reader», «writer» и «state».

63
00:05:05,430 --> 00:05:09,019
Вы должны были, вроде, проходить
на предыдущих лекциях, была?

64
00:05:12,640 --> 00:05:13,582
Да нет, кажется.

65
00:05:14,440 --> 00:05:15,500
Серьезно? Окей.

66
00:05:15,825 --> 00:05:21,640
Ну, знаете тогда, что
есть такая манатка «rvs»,

67
00:05:21,890 --> 00:05:26,100
которая — это буквально тупо
комбинация «reader», «writer» и «state».

68
00:05:26,101 --> 00:05:30,060
То есть, она обладает неизменяемым
«environment», изменяемым «state»,

69
00:05:30,061 --> 00:05:33,650
и еще какой-то аккумулятор
есть, в который можно писать логи.

70
00:05:34,700 --> 00:05:37,791
Второй вариант, который
хорошо, наверное, что никто

71
00:05:37,834 --> 00:05:40,721
не предложил — это
использовать чистый «state».

72
00:05:40,820 --> 00:05:43,917
То есть, мы просто храним и
«environment», и «state» внутри «state».

73
00:05:44,000 --> 00:05:47,940
Возможно, можно
расширить варианцию с тупом.

74
00:05:47,941 --> 00:05:49,059
Да не тупо, а тупо.

75
00:05:49,780 --> 00:05:52,200
До вот этого состояния.

76
00:05:53,665 --> 00:05:55,260
Почему эти варианты плохие?

77
00:05:55,380 --> 00:06:00,340
В «rvs» оно работает
нормально, но появляется какой-то

78
00:06:00,341 --> 00:06:01,777
лишний «writer», который
вообще-то непонятно кому нужен.

79
00:06:01,860 --> 00:06:04,549
Главное, что там может
очутиться в какой-то момент,

80
00:06:04,592 --> 00:06:06,948
что-то совершенно не
должно там оказываться.

81
00:06:07,030 --> 00:06:14,220
В случае же «state» мы теряем, собственно,
доступ к неизменяемому «environment».

82
00:06:14,221 --> 00:06:16,737
Ну и вам, наверное, не хочется, чтобы ваша

83
00:06:16,779 --> 00:06:19,641
шахматная доска в какой-то
момент сказала «оп»,

84
00:06:19,665 --> 00:06:22,520
и посреди партии
расширилась до 128 клеток.

85
00:06:23,020 --> 00:06:23,900
Будет весело.

86
00:06:28,360 --> 00:06:32,140
И, да, собственно, вот
решение, которое является

87
00:06:32,160 --> 00:06:33,680
комбинацией двух модат, так
называемые «трансформеры».

88
00:06:33,681 --> 00:06:38,900
Можете заметить, что они
используют имена стандартных модат,

89
00:06:39,530 --> 00:06:41,825
только приписывается буква «т» в конце.

90
00:06:41,920 --> 00:06:45,920
Ну, так, во всяком случае, по код-стайлу.

91
00:06:46,960 --> 00:06:48,843
А теперь вопрос, что изменилось.

92
00:06:49,260 --> 00:06:52,790
Посмотрите на ассигнатуру
функции и скажите, что изменилось.

93
00:07:10,690 --> 00:07:11,632
Тяжелая публика.

94
00:07:13,470 --> 00:07:16,987
Можете заметить, что у вас изменилось
количество аргументов в «reader».

95
00:07:17,070 --> 00:07:19,590
В «reader» изначально было два аргумента.

96
00:07:19,591 --> 00:07:21,747
Это «environment» и тип
возвращаемого значения.

97
00:07:21,830 --> 00:07:23,190
Сейчас у вас появилось третье.

98
00:07:23,210 --> 00:07:24,590
Это «state int».

99
00:07:24,591 --> 00:07:25,927
То есть, третий аргумент.

100
00:07:26,010 --> 00:07:29,363
Замечу, что вот здесь написано
через «state» то же самое.

101
00:07:29,590 --> 00:07:32,247
То есть, эти две штуки,
по факту, равносильны.

102
00:07:32,330 --> 00:07:32,850
И здесь тоже.

103
00:07:32,910 --> 00:07:34,230
Если вы посмотрите на «state», там тоже.

104
00:07:34,310 --> 00:07:35,810
Значит, у вас был один «state».

105
00:07:35,811 --> 00:07:38,070
Одна типовая перемена означала «state».

106
00:07:38,071 --> 00:07:39,647
И одна означала возвращаемое значение.

107
00:07:39,730 --> 00:07:43,290
Сейчас у вас появилось
еще промежуточный аргумент.

108
00:07:44,270 --> 00:07:46,050
Понятно пока, что происходит?

109
00:07:56,290 --> 00:07:58,010
Сейчас у нас еще равный оружий.

110
00:07:58,011 --> 00:07:58,110
Здесь есть не равный оружий.

111
00:07:58,111 --> 00:07:59,050
Там есть отрицательное
оружие, а здесь нет.

112
00:07:59,070 --> 00:08:05,190
Поэтому, вы видите, что в нашей
локации пока нет вашего оружия.

113
00:08:05,191 --> 00:08:06,127
равно на два из таких уровня наше оружие.

114
00:08:06,210 --> 00:08:06,290
Только то, что у нас
есть не в таким уровне.

115
00:08:06,291 --> 00:08:08,291
И то, что вы видите здесь или ещё.

116
00:08:11,730 --> 00:08:12,563
Повторяем.

117
00:08:14,570 --> 00:08:15,190
Вот здесь, например, у нас ровно на тремя

118
00:08:15,191 --> 00:08:15,310
уровнях растута
переверенная аргументность.

119
00:08:15,311 --> 00:08:19,570
Если вы не понимаете монады к
сегодняшней лекции, то это очень плохо.

120
00:08:19,770 --> 00:08:22,594
И давайте вы мне лучше
по ним задавайте вопросы.

121
00:08:27,960 --> 00:08:32,740
Риберт, он же тоже возвращает
монаду или какой-то другой объект?

122
00:08:35,370 --> 00:08:38,380
Смотрите, формально он возвращает монаду.

123
00:08:39,320 --> 00:08:41,732
То есть из него мы сейчас увидим его тип.

124
00:08:44,805 --> 00:08:48,800
Проблема одна из этого принципа
монадных трансформеров заключается в том,

125
00:08:48,801 --> 00:08:51,557
что вам потом в конце концов
придется все это дело развернуть.

126
00:08:51,640 --> 00:08:56,288
То есть сначала передать environment,
применить reader, развернуть это в state,

127
00:08:56,480 --> 00:09:00,840
и потом передать один раз state
и получить там уже результат.

128
00:09:01,580 --> 00:09:04,837
Отличие от того, что предлагалось
с использованием обычного reader,

129
00:09:04,920 --> 00:09:08,577
когда у вас просто reader и в него вы
возвращаемое значение передаете,

130
00:09:08,660 --> 00:09:11,857
заключается в том, что вам там
нужно было передавать всегда,

131
00:09:11,940 --> 00:09:13,997
когда вы что-то стейтовое
хотите использовать.

132
00:09:14,080 --> 00:09:15,845
Здесь вам так не нужно делать.

133
00:09:16,850 --> 00:09:18,697
Здесь вам нужно это все сделать один раз,

134
00:09:18,780 --> 00:09:23,560
но если это нужно развернуть,
оно получается достаточно большим.

135
00:09:24,080 --> 00:09:25,400
С правильной версией радио стоит заметить,

136
00:09:25,460 --> 00:09:28,057
что разворачивается это обычно
только один раз в каком-нибудь мейне,

137
00:09:28,140 --> 00:09:30,620
потому что обычно вот таким
гигантским трансформером

138
00:09:30,621 --> 00:09:33,220
обвешивают почти все вычисления в проекте.

139
00:09:34,120 --> 00:09:36,944
За исключением, очевидно,
чистых каких-то вещей.

140
00:09:38,820 --> 00:09:42,060
Сейчас, если этот трансформер разрешает

141
00:09:42,120 --> 00:09:44,980
монаду, при этом сам
комбинирует две монады,

142
00:09:45,295 --> 00:09:48,420
как для него реализованы
стрелочки и его return?

143
00:09:48,680 --> 00:09:49,677
Это мы сейчас увидим.

144
00:09:49,760 --> 00:09:52,400
Дальше будет и типы, и, соответственно,

145
00:09:54,020 --> 00:09:56,537
там, по-моему, даже
будет instance написано.

146
00:09:56,620 --> 00:09:58,117
Да, там точно будет пара инстансов.

147
00:09:58,200 --> 00:09:59,259
Можете посмотреть.

148
00:09:59,820 --> 00:10:00,653
Хорошо.

149
00:10:01,020 --> 00:10:01,880
Еще вопросы?

150
00:10:05,390 --> 00:10:08,350
По монадам, по синтаксису, по чему угодно.

151
00:10:09,010 --> 00:10:11,481
Просто чтобы все понимали, что происходит.

152
00:10:16,530 --> 00:10:18,001
Ну ладно, поехали дальше.

153
00:10:20,110 --> 00:10:22,228
Окей, значит, у вас, соответственно,

154
00:10:22,570 --> 00:10:24,394
вот такая конструкция позволяет

155
00:10:24,910 --> 00:10:26,675
использовать комбинацию монад.

156
00:10:28,100 --> 00:10:30,689
Почему вообще нам
нужно так разворачиваться?

157
00:10:30,780 --> 00:10:32,207
Потому что есть одна проблемка.

158
00:10:32,290 --> 00:10:35,710
Если вы возьмете функторы,
аппликативы, альтернативы,

159
00:10:35,711 --> 00:10:38,888
все вот эти вещи, которые
проходили на третьей лекции,

160
00:10:39,010 --> 00:10:40,290
то у них есть одна особенность.

161
00:10:40,370 --> 00:10:41,450
Они композируемы.

162
00:10:41,690 --> 00:10:44,347
То есть, грубо говоря, если
у вас есть, представьте, вот

163
00:10:44,430 --> 00:10:47,990
этот new type, он абсолютно
фикшен, но идея вот в чем.

164
00:10:48,130 --> 00:10:50,187
Представьте, что у вас есть
какая-то некая композиция.

165
00:10:50,270 --> 00:10:54,990
То есть вы делаете композицию,
там, функтор от чего-то.

166
00:10:55,510 --> 00:10:59,570
Так вот, если f это
функтор и g это функтор,

167
00:10:59,840 --> 00:11:01,488
то композиция f и g функтор.

168
00:11:02,120 --> 00:11:06,810
Или это можно прописать так, что у
вас буквально сразу получаете правило,

169
00:11:06,930 --> 00:11:09,578
то, как вы должны
действовать для композиции,

170
00:11:09,950 --> 00:11:11,167
чтобы получился функтор.

171
00:11:11,250 --> 00:11:14,172
То есть из того, что f функтор и
g функтор, вы сразу получаете то,

172
00:11:14,255 --> 00:11:16,927
как instance функтора
выглядит для их композиции.

173
00:11:17,010 --> 00:11:18,787
То же самое, верно,
для foldable, traversable,

174
00:11:18,870 --> 00:11:21,347
аппликативы, альтернативы,
для всего, кроме монад.

175
00:11:21,430 --> 00:11:24,078
Для монад такой фигни
нет, и оно не работает.

176
00:11:24,230 --> 00:11:26,760
Почему?
Ну, упарывайтесь в категории типов.

177
00:11:27,910 --> 00:11:30,087
Почему композиция монад, а не монада?

178
00:11:30,320 --> 00:11:31,379
Типов в категории.

179
00:11:33,650 --> 00:11:36,492
Поэтому вы формально можете
сделать такую композицию,

180
00:11:36,575 --> 00:11:39,756
просто в каждом отдельном случае
ее нужно определять отдельно.

181
00:11:39,950 --> 00:11:43,187
Часто может показаться
страшным, что мы сейчас, если хотим

182
00:11:43,270 --> 00:11:44,847
выкомпозировать больше, чем
две монады, то это надо умереть.

183
00:11:44,930 --> 00:11:46,107
Это не так работает.

184
00:11:46,570 --> 00:11:47,830
Это гораздо проще.

185
00:11:50,430 --> 00:11:54,750
Поэтому все монады, все
трансформеры мы должны описать

186
00:11:54,810 --> 00:11:56,516
ручками самостоятельно,
как у них выглядят instances.

187
00:11:56,690 --> 00:11:58,808
Вот давайте приведем пример с мэйби.

188
00:11:59,530 --> 00:12:02,236
Хотим что?
Хотим ио-действие и какой-то мэйби.

189
00:12:02,770 --> 00:12:05,090
Вот это тоже вполне себе продакшн вещь.

190
00:12:05,250 --> 00:12:08,550
То есть мы хотим иметь возможность
сделать какое-то ио-действие,

191
00:12:08,630 --> 00:12:10,847
которое непонятно, оно
дойдет вообще или нет.

192
00:12:10,930 --> 00:12:14,605
Подключимся мы к базе, подключимся
к серверам, не подключимся.

193
00:12:14,930 --> 00:12:18,187
Обычно это как раз таки обозначается тем,
что у вас возвращается какой-то натрин.

194
00:12:18,270 --> 00:12:22,247
Ну, ладно, в рул обычно это обозначается
тем, что какой-то экрепшн возвращается,

195
00:12:22,330 --> 00:12:25,166
так что там, скорее всего, не
мэйби, а какой-нибудь эксерт.

196
00:12:25,750 --> 00:12:28,398
Но, тем не менее, вполне
себе рабочий пример.

197
00:12:30,370 --> 00:12:33,253
Да, и, соответственно,
написать мы хотим вот так.

198
00:12:33,430 --> 00:12:35,750
Замечу, что вот это как
раз таки реализация того

199
00:12:35,810 --> 00:12:38,027
подхода, который предлагался
как в качестве ридера,

200
00:12:38,110 --> 00:12:40,647
в качестве возвращаемого
значения использовать стейт.

201
00:12:40,730 --> 00:12:44,170
Вот заметите, что вы здесь
каждый раз, пополняя какое-нибудь

202
00:12:44,230 --> 00:12:47,290
ио-действие, получаете в
результате какой-то мэйби,

203
00:12:47,600 --> 00:12:49,187
который вы должны разворачивать.

204
00:12:49,270 --> 00:12:50,907
Ну, мэйби разворачивать достаточно просто,

205
00:12:50,990 --> 00:12:52,610
а в случае стейта вы
должны были сюда, там,

206
00:12:52,611 --> 00:12:55,410
run стейт, передать
стейт и так далее делать.

207
00:12:56,155 --> 00:12:59,030
Вот, и если у нас, соответственно,
нужно законнектиться к нескольким хостам,

208
00:12:59,110 --> 00:13:00,650
или у нас несколько операций,
которые различают мэйби,

209
00:13:00,730 --> 00:13:03,378
нужно творить всю вот
эту громадю каждый раз.

210
00:13:04,710 --> 00:13:05,543
Понятно?

211
00:13:08,930 --> 00:13:09,763
Да.

212
00:13:10,330 --> 00:13:11,163
Окей.

213
00:13:12,660 --> 00:13:15,467
Значит, хотим это
скомбинировать, получаем мэйби-ио.

214
00:13:15,550 --> 00:13:17,492
Это вот некий абстрактный пример.

215
00:13:18,270 --> 00:13:19,212
Что у нас здесь?

216
00:13:19,430 --> 00:13:23,870
Заметьте, что вот у нас
тип стал чуть-чуть похуже,

217
00:13:25,070 --> 00:13:28,365
но вот видим, что у нас мы
запихнули вот этот ио.мэйби.

218
00:13:30,010 --> 00:13:31,187
а внутрь конструктора.

219
00:13:31,890 --> 00:13:34,387
И давайте теперь определим
для него инстанс монады.

220
00:13:34,470 --> 00:13:34,910
В чем и дело?

221
00:13:35,010 --> 00:13:36,867
Ну, ретурн, понятно, да, то
есть это всегда это мэйби.

222
00:13:36,950 --> 00:13:39,330
ио, сначала завернуть в мэйби,

223
00:13:39,970 --> 00:13:41,410
потом завернуть в ио,

224
00:13:41,810 --> 00:13:45,270
потом завернуть в мэйби.ио.

225
00:13:45,710 --> 00:13:47,027
Понятно? То есть от обратного идем.

226
00:13:47,110 --> 00:13:49,869
Сначала вот это значение, потом
вот это значение, потом вот это все.

227
00:13:51,410 --> 00:13:52,881
Вот, с экшеном повеселее.

228
00:13:53,430 --> 00:13:54,489
На самом деле нет.

229
00:13:55,030 --> 00:13:58,147
Результат у нас все еще
должен быть завернут в мэйби.

230
00:13:58,230 --> 00:14:01,172
ио, в нем должно быть ио
действие, так что вот это ио.

231
00:14:01,605 --> 00:14:03,990
В ио мы выполняем результат экшена.

232
00:14:04,170 --> 00:14:06,523
Экшен, напоминаю, у нас,
соответственно, экшен это ио.

233
00:14:08,950 --> 00:14:11,090
мэйби.

234
00:14:12,110 --> 00:14:15,747
а действие, то есть вот у нас вот это ио,
результат получается типа имеет мэйби.а.

235
00:14:15,830 --> 00:14:20,170
Дальше проверяем результат и
заворачиваем все это дело в результат.

236
00:14:21,370 --> 00:14:24,253
Понятно, как устроен
инстанс монады для мэйби.

237
00:14:28,530 --> 00:14:29,363
ио? Да.

238
00:14:30,650 --> 00:14:32,650
То есть здесь все достаточно тупо.

239
00:14:34,770 --> 00:14:36,888
Заперформили экшен внутри ио монады,

240
00:14:37,370 --> 00:14:40,747
получили результат, который мэйби,
проверили, чему он этот мэйби равен,

241
00:14:40,830 --> 00:14:43,419
и завернули все это
дело в мэйби.ио обратно.

242
00:14:45,780 --> 00:14:47,075
Вот, теперь у вас все.

243
00:14:47,540 --> 00:14:50,640
Теперь у вас все довольно таки тупо.

244
00:14:51,520 --> 00:14:55,462
Более того, на самом деле вот этот
мэйби.ио можно вынести вот сюда.

245
00:14:57,840 --> 00:14:58,723
Проблема в чем?

246
00:14:58,860 --> 00:15:01,096
Теперь я хочу посреди всего этого дела

247
00:15:01,680 --> 00:15:03,517
использовать просто тупо ио действие.

248
00:15:03,600 --> 00:15:08,269
То есть вот этот printHello, он чистый
ио, он не возвращает мне мэйби.

249
00:15:08,820 --> 00:15:09,653
Понятно?

250
00:15:11,170 --> 00:15:12,876
И вот так мы делать не можем.

251
00:15:15,060 --> 00:15:16,840
Ну, потому что они по
типам не сходятся, да?

252
00:15:16,900 --> 00:15:20,222
Здесь у нас runMaybe.io
применяется к мэйби.ио, очевидно.

253
00:15:20,305 --> 00:15:23,140
Это у нас чистый ио,
потому что там результатом

254
00:15:23,141 --> 00:15:26,020
не является мэйби, там
является пустой тупо.

255
00:15:26,800 --> 00:15:27,960
Что мы делаем?

256
00:15:28,000 --> 00:15:29,648
Мы делаем простой трансформ.

257
00:15:29,780 --> 00:15:33,800
Мы perform результат и
оборачиваем его в мэйби.

258
00:15:34,360 --> 00:15:36,184
То есть оборачиваем его в just.

259
00:15:36,620 --> 00:15:37,697
Получаем некоторую функцию,

260
00:15:37,780 --> 00:15:42,428
которая любое действие иошное позволяет
трансформировать мэйби иошное действие.

261
00:15:43,960 --> 00:15:47,140
И теперь это все выглядит
достаточно травоядно.

262
00:15:49,000 --> 00:15:51,080
Опять же, это все еще
можно сократить немножечко.

263
00:15:51,081 --> 00:15:54,552
Нужно каждый раз применять
конструктор мэйби.ио к действию.

264
00:15:57,060 --> 00:16:00,701
Собственно, на самом деле мы сейчас получили
просто define под мэйби.т трансформер,

265
00:16:00,780 --> 00:16:04,075
потому что вы заменяете его
на любую произвольную монаду

266
00:16:05,460 --> 00:16:08,560
и получаете вот таким же
образом буквально дефайните

267
00:16:10,620 --> 00:16:13,720
типа инстанции монады для этого мэйби.т.

268
00:16:15,240 --> 00:16:16,073
Понятно?

269
00:16:20,845 --> 00:16:23,316
Инстанция, например, будет точно такой же.

270
00:16:24,710 --> 00:16:26,946
Собственно, вот это вы можете увидеть.

271
00:16:31,530 --> 00:16:33,883
Вопросы по мэйби.т, как мы его получили?

272
00:16:39,120 --> 00:16:40,680
Вопросы по вот этой штуке.

273
00:16:44,850 --> 00:16:46,321
Тут-то все вроде понятно,

274
00:16:46,690 --> 00:16:51,250
а вот все-таки последний
переход к мэйби.т был не до конца.

275
00:16:51,870 --> 00:16:52,190
Вот тут?

276
00:16:52,780 --> 00:16:54,010
Ну, пожалуй, да.

277
00:16:55,580 --> 00:17:00,570
В двух словах, мэйби.т, для чего они
нужны, трансформеры, если подвести?

278
00:17:01,210 --> 00:17:03,858
Смотрите, для чего вообще
нужны трансформеры?

279
00:17:04,480 --> 00:17:06,010
Для того, чтобы я мог применить...

280
00:17:06,011 --> 00:17:09,450
Смотрите, еще раз, пытайтесь
узнать следующую вещь.

281
00:17:10,330 --> 00:17:13,267
В ООПшке, там, допустим,
возьмем какой-нибудь

282
00:17:13,350 --> 00:17:15,810
питон, у вас все эффекты
включены по умолчанию.

283
00:17:16,370 --> 00:17:18,450
То есть у вас включено ИО-действие,

284
00:17:18,570 --> 00:17:20,430
у вас включены всякие логи,

285
00:17:21,580 --> 00:17:24,030
стейты, инвайрмент какой-нибудь включен.

286
00:17:24,300 --> 00:17:26,550
Это все у вас есть по умолчанию.

287
00:17:27,020 --> 00:17:30,867
В Хаскеле у вас по умолчанию буквально
нет ничего, кроме чистой функции.

288
00:17:30,950 --> 00:17:32,150
Чистая функция не имеет ничего.

289
00:17:32,151 --> 00:17:35,370
На самом деле, да,
если кто-то сомневается,

290
00:17:36,950 --> 00:17:40,186
монологические действия,
кроме ИОшных, они тоже чистые.

291
00:17:41,350 --> 00:17:44,527
Соответственно, у вас по умолчанию
в Хаскеле все эффекты выключены.

292
00:17:44,610 --> 00:17:49,710
И вам нужно добавлять их,
чтобы вы могли ими пользоваться.

293
00:17:50,300 --> 00:17:52,790
В предыдущих главах, в предыдущих лекциях,

294
00:17:52,850 --> 00:17:56,427
вы использовались либо никакими
эффектами, либо всегда одним эффектом.

295
00:17:56,510 --> 00:18:00,470
То есть у вас есть всегда ридер, у вас
есть какой-нибудь мэйби, у вас есть райтер.

296
00:18:00,630 --> 00:18:03,847
Вот он в шапке функции написан,
вот у вас один эффект подключен.

297
00:18:03,930 --> 00:18:06,127
Теперь я хочу подключить
несколько эффектов.

298
00:18:06,210 --> 00:18:09,093
То есть я хочу несколько
каких-то фич подключить.

299
00:18:09,290 --> 00:18:12,207
То есть у меня по умолчанию
нет записи ввода-вывода.

300
00:18:12,290 --> 00:18:14,667
Я не могу писать ввод-вывод,
потому что его нет по умолчанию.

301
00:18:14,750 --> 00:18:16,045
Я хочу его подключить.

302
00:18:16,550 --> 00:18:21,096
Дальше у меня есть... На самом
деле, на примере сейчас на этом будет.

303
00:18:27,975 --> 00:18:29,937
На самом деле, вот это
самый хороший пример.

304
00:18:30,020 --> 00:18:31,937
Вот, например, использование ридера и.о.

305
00:18:32,020 --> 00:18:35,079
То есть я хочу иметь доступ
к невменяемому окружению

306
00:18:35,380 --> 00:18:37,550
и иметь возможность писать какой-то и.о.
экшен.

307
00:18:37,630 --> 00:18:39,787
Сейчас не смотрите на
код, мы к нему придем.

308
00:18:39,870 --> 00:18:42,870
То есть, смотрите, вот вы, допустим,

309
00:18:42,890 --> 00:18:45,837
описываете подключение к базе
данных из какого-нибудь кода.

310
00:18:45,920 --> 00:18:47,987
У вас есть креденшел,
так сказать, база данных,

311
00:18:48,070 --> 00:18:50,627
там логин, пароль,
название АБД, что-то такое.

312
00:18:50,710 --> 00:18:51,890
И вы хотите делать и.о.

313
00:18:51,891 --> 00:18:55,027
, потому что доступ в сторонние
сервисы – это всегда и.о.

314
00:18:55,110 --> 00:18:56,590
Бегать на сервер – это и.о.

315
00:18:56,650 --> 00:18:59,310
Бегать в базу – это и.о.

316
00:18:59,470 --> 00:19:00,303
Вот.

317
00:19:00,640 --> 00:19:01,987
Соответственно, вы хотите иметь конфликт,

318
00:19:02,070 --> 00:19:04,776
с которым вы всегда
можете креденшел почитать.

319
00:19:04,870 --> 00:19:06,927
И вы хотите иметь возможность писать и.о.
экшен.

320
00:19:07,010 --> 00:19:09,647
Для этого вы не могли так сделать,
потому что у вас всегда был один эффект.

321
00:19:09,730 --> 00:19:12,789
То есть вы либо пишете,
либо у вас есть environment.

322
00:19:14,060 --> 00:19:17,150
Теперь вы можете их комбинировать, с помощью
трансформеров вы можете комбинировать

323
00:19:17,151 --> 00:19:18,927
различные эффекты,
причем до бесконечности.

324
00:19:19,010 --> 00:19:20,830
То есть не только два
эффекта можно комбинировать,

325
00:19:20,890 --> 00:19:22,807
можно комбинировать
бесконечное количество эффектов.

326
00:19:22,890 --> 00:19:25,370
У меня может быть ридер
от фрайтера, от стейта, от и.о.

327
00:19:25,371 --> 00:19:27,430
, от айзера, там черт знает чего еще.

328
00:19:28,090 --> 00:19:30,987
То есть вы можете создать
комбинацию только тех

329
00:19:31,070 --> 00:19:35,310
эффектов, которые вам
нужны для выполнения задач.

330
00:19:36,350 --> 00:19:37,183
Понятно?

331
00:19:39,250 --> 00:19:40,083
Да.

332
00:19:40,360 --> 00:19:42,947
Maybe.t в этом вопросе
мне не очень нравится.

333
00:19:43,030 --> 00:19:43,350
Почему?

334
00:19:43,490 --> 00:19:46,247
Потому что, на самом деле, я,
по-моему, один раз в жизни видел,

335
00:19:46,330 --> 00:19:49,095
как кто-то применяет
maybe в количестве монады,

336
00:19:50,300 --> 00:19:52,536
и код от этого выглядит очень хреново.

337
00:19:55,030 --> 00:19:55,230
Вот.

338
00:19:55,350 --> 00:19:57,977
Поэтому дальше будет,
наверное, не очень понятно.

339
00:19:58,060 --> 00:19:59,050
Но идея в чем?

340
00:19:59,150 --> 00:20:02,730
Вот у вас есть эффект монады
maybe, который означает, что у

341
00:20:02,731 --> 00:20:04,827
вас в какой-то момент веществения
могут завершиться с ошибкой.

342
00:20:04,910 --> 00:20:06,587
Плевать какой, просто они упали с ошибкой.

343
00:20:06,670 --> 00:20:08,907
Может не привести к
результату, который вы хотите.

344
00:20:08,990 --> 00:20:10,427
И у вас есть при этом и.о.

345
00:20:10,510 --> 00:20:11,747
То есть можете читать
это как, у вас есть и.

346
00:20:11,830 --> 00:20:15,488
о. действия, которые могут
завершиться с ошибкой.

347
00:20:15,810 --> 00:20:16,643
Понятно?

348
00:20:19,630 --> 00:20:20,463
Угу.

349
00:20:21,950 --> 00:20:22,950
Так, еще вопросы.

350
00:20:26,730 --> 00:20:28,554
У нас тут целых девять человек.

351
00:20:30,670 --> 00:20:34,450
В примере с maybe.t и
try-connect сделать print,

352
00:20:34,890 --> 00:20:37,410
нам пришлось написать transformed.

353
00:20:37,960 --> 00:20:40,170
io и потом его доставать.

354
00:20:40,530 --> 00:20:44,503
Вот если мы скомбинируем
больше монад, чем две,

355
00:20:44,650 --> 00:20:46,467
нам для того, чтобы добраться до и.о.

356
00:20:46,550 --> 00:20:49,070
придется еще много букв писать.

357
00:20:50,130 --> 00:20:51,510
Плохая новость – да.

358
00:20:53,300 --> 00:20:56,947
Хорошая новость – очевидно,
это проблемы, которые решили.

359
00:20:57,030 --> 00:20:57,913


360
00:20:59,500 --> 00:21:00,500
Мы потом покажем,

361
00:21:00,650 --> 00:21:02,239
потом подальше покажем как.

362
00:21:02,350 --> 00:21:05,315
Но сейчас считайте, да,
если у вас много эффектов,

363
00:21:05,510 --> 00:21:08,608
это вот, собственно, называется, да,
давайте покажем следующий слайд,

364
00:21:08,790 --> 00:21:10,438
это называется функция lift.

365
00:21:11,685 --> 00:21:14,910
Да, если вот видели слоган Серокина –

366
00:21:14,911 --> 00:21:18,046
your expectations lifted, так
вот lifted – это вот отсюда lifted.

367
00:21:19,710 --> 00:21:23,107
Да, у него есть некоторые законы о том,
что lift и return – это просто return,

368
00:21:23,190 --> 00:21:25,950
и lift байнда – это lift
сначала одной монады,

369
00:21:26,230 --> 00:21:28,650
bind в lift функцию.

370
00:21:31,390 --> 00:21:34,750
Лифт позволяет вам поднять
одну монаду в другую монаду.

371
00:21:35,790 --> 00:21:36,623
Понятно?

372
00:21:41,720 --> 00:21:42,600
Посмотрите на тип.

373
00:21:42,680 --> 00:21:45,717
То есть у вас была какая-то обертка
над возвращаемым значением,

374
00:21:45,800 --> 00:21:49,220
теперь вы завернули это
все дело в еще одну обертку,

375
00:21:49,440 --> 00:21:51,277
теперь над двумя типовыми переменными.

376
00:21:51,360 --> 00:21:54,619
Заметьте, что скобок здесь нет,
то есть это t принимает на вход две

377
00:21:55,900 --> 00:21:57,018
типовые переменные.

378
00:21:58,660 --> 00:21:59,597
Эта штука называется kind, by the way.

379
00:21:59,680 --> 00:22:00,513


380
00:22:03,170 --> 00:22:04,003
Окей? Так, хорошо.

381
00:22:11,180 --> 00:22:12,013


382
00:22:12,140 --> 00:22:14,199
Кроме Романа, еще все
все понимают? Так, да.

383
00:22:18,600 --> 00:22:19,433


384
00:22:20,700 --> 00:22:23,749
Сейчас сдерну рандомного
кого-нибудь, спрошу вопросы.

385
00:22:24,080 --> 00:22:24,913
Ладно.

386
00:22:27,400 --> 00:22:30,420
Да, соответственно, вот у
вас, да, эта штука называется

387
00:22:30,421 --> 00:22:33,480
monotrans, ну и, соответственно,
для трансформеров нужно определить

388
00:22:33,481 --> 00:22:38,620
внезапный instance monotrans,
который позволяет делать lift.

389
00:22:39,130 --> 00:22:41,435
Там еще пара функций
есть, но главное – это lift.

390
00:22:43,440 --> 00:22:45,088
Да, ну вот на тему написания

391
00:22:47,660 --> 00:22:49,480
кода в адекватном виде,

392
00:22:51,720 --> 00:22:57,360
вот у вас, соответственно, то, что я
говорил, вот у вас вы лифтите putString,

393
00:22:58,960 --> 00:23:02,340
потому что он в IO чисто,

394
00:23:03,010 --> 00:23:04,128
вы лифтите getLine,

395
00:23:04,260 --> 00:23:08,520
потому что getLine тоже IOC,

396
00:23:10,060 --> 00:23:21,800
Вы не лифтите email as valid, потому
что у вас нет здесь монада, логично.

397
00:23:23,070 --> 00:23:26,914
Вот, и все. А дальше
здесь, соответственно,

398
00:23:26,956 --> 00:23:30,661
в майне вы делаете просто run mybt и все.

399
00:23:31,520 --> 00:23:35,792
Да, until success функция здесь,
если что, она просто повторяет

400
00:23:35,835 --> 00:23:39,601
действие, пока оно не
завершится чем-то, кроме nothing.

401
00:23:44,150 --> 00:23:48,857
Да, у mybt, соответственно, есть альтернативы,
которые позволяют делать вот так.

402
00:23:55,540 --> 00:23:59,749
Ну, то есть, еще раз, фиговый пример,
потому что mybt не очень хорошо, не

403
00:23:59,791 --> 00:24:04,158
очень красиво выглядит в реальной
жизни, если использовать какую-то монаду.

404
00:24:04,240 --> 00:24:08,535
Вот, вот это повеселее
пример. Вот environment.

405
00:24:08,577 --> 00:24:13,501
io, то есть, reader.io, это, короче, самый
часто используемый паттерн в Haskell.

406
00:24:13,940 --> 00:24:16,514
Ну, то есть, буквально почти
все, что вы увидите, на самом деле,

407
00:24:16,557 --> 00:24:18,968
под капотом это какой-нибудь
ридер с каким-нибудь state.io.

408
00:24:19,050 --> 00:24:23,777
Там еще иногда except замешивают, чтобы у
вас еще ошибки правильно разрабатывались.

409
00:24:23,860 --> 00:24:25,680
Но почти все это, на
самом деле, environment.io.

410
00:24:25,681 --> 00:24:29,021
Любая коннекция к базе
данных – это environment.

411
00:24:29,063 --> 00:24:32,682
io, любой сервер – это environment.io,
любое логирование – то же самое.

412
00:24:35,960 --> 00:24:39,737
Вот. Ну, да, соответственно, что мы имеем?
Вот у нас есть раньше, чем было.

413
00:24:39,820 --> 00:24:42,024
Вот мы хотим записать
какой-то лог, вот у нас логер.

414
00:24:42,066 --> 00:24:44,461
name, файл.path, мы его должны передавать.

415
00:24:44,540 --> 00:24:48,257
Почему? Потому что мы здесь не можем
использовать ридер, у нас здесь уже его.

416
00:24:48,340 --> 00:24:49,173
Окей.

417
00:24:53,180 --> 00:24:56,720
Хотя они передаются вот
через все вот эти функции.

418
00:24:59,490 --> 00:25:01,138
Тянем за собой хвост.

419
00:25:02,740 --> 00:25:05,457
Зачем? Вот. Идем в ридер,
и вот, кстати, вопрос о типе.

420
00:25:05,540 --> 00:25:09,580
Весь у ридера, если помните, типа
r-стрелка a, теперь r-стрелка m-a.

421
00:25:09,680 --> 00:25:12,461
То есть, действительно, когда
вы применяете run ридера и

422
00:25:12,503 --> 00:25:15,678
передаете ему environment, он
возвращает вам внутреннюю монаду.

423
00:25:15,760 --> 00:25:19,197
И к ней уже надо будет свой
run применить, чтобы ее достать.

424
00:25:19,280 --> 00:25:21,796
Но это применяется
еще раз только, когда вы

425
00:25:21,839 --> 00:25:24,634
хотите вернуть деятельность
в какой-нибудь I.O.

426
00:25:26,480 --> 00:25:28,517
Вот. И вот здесь, смотрите,
вот мы создаем логер I.O.

427
00:25:28,600 --> 00:25:32,900
То есть вот у вас ридер t, логер.name I.O.

428
00:25:33,620 --> 00:25:36,973
Замечу, смотрите, здесь мы просто...
это тупо type alias.

429
00:25:37,270 --> 00:25:40,120
Это тоже часто применяемая
техника, когда вот в этом

430
00:25:40,163 --> 00:25:46,380
type alias у вас определены параметры
внутренней монады и определенный environment.

431
00:25:46,800 --> 00:25:50,389
По сути, мы здесь передаем просто...
мы создаем новую монаду.

432
00:25:50,560 --> 00:25:54,090
По факту это просто ридер с
определенными двумя параметрами.

433
00:25:54,320 --> 00:25:55,153
Понятно?

434
00:25:59,590 --> 00:26:00,423
Да.

435
00:26:03,220 --> 00:26:04,053
Окей.

436
00:26:04,180 --> 00:26:06,298
Ну и, соответственно, что мы делаем?

437
00:26:07,280 --> 00:26:11,780
Теперь у нас все просто, тупо мы логируем,
если нам нужен доступ к этому самому,

438
00:26:11,781 --> 00:26:18,660
то мы можем всегда из этого environment
получить данные по файлу, например.

439
00:26:26,520 --> 00:26:27,377
Не вижу ни одного примера.

440
00:26:27,460 --> 00:26:30,872
На самом деле, тем мы что-то
из environment достаем здесь.

441
00:26:33,900 --> 00:26:34,440
А, ну окей.

442
00:26:34,560 --> 00:26:38,090
Видимо, у нас есть log message,
который там из него достает.

443
00:26:38,860 --> 00:26:39,693
Вот.

444
00:26:40,060 --> 00:26:40,893
И все.

445
00:26:41,920 --> 00:26:45,397
И вот runRider вы применяете
здесь только в одном месте, в main.

446
00:26:45,480 --> 00:26:47,560
Единственное, что здесь не
приходится разворачивать I.O.

447
00:26:47,561 --> 00:26:50,580
Потому что main тоже в I.O.

448
00:26:52,620 --> 00:26:53,453
Пока понятно?

449
00:27:01,580 --> 00:27:02,522
Гробовая тишина.

450
00:27:03,000 --> 00:27:03,942
А что непонятно?

451
00:27:07,240 --> 00:27:11,250
Ну, лично я пытаюсь вчитаться
в код, поэтому и молчу.

452
00:27:12,150 --> 00:27:12,983
Хорошо.

453
00:27:21,130 --> 00:27:23,601
Можете подробнее что-то поделиться на что?

454
00:27:26,370 --> 00:27:28,547
Можно как-то объяснить код чуть-чуть?

455
00:27:29,460 --> 00:27:34,343
Ну, смотрите, у вас есть просто несколько
функций, которые умеют что-то логировать.

456
00:27:35,130 --> 00:27:41,910
Условно, у вас есть функции записи, чтения
файла, какой-то prettify файл content,

457
00:27:42,330 --> 00:27:45,448
который как-то меняет то,
что у вас в файле написано.

458
00:27:45,830 --> 00:27:48,407
И на каждое ваше действие
вы хотите логировать это дело.

459
00:27:48,490 --> 00:27:57,130
На каждое ваше действие вы хотите в данном
случае в stdout писать какой-то лог.

460
00:27:58,070 --> 00:27:58,903
Вот.

461
00:28:01,000 --> 00:28:03,450
Соответственно, каждое ваше
действие readfile.withlog это просто что?

462
00:28:03,510 --> 00:28:06,863
Это readfile, и до этого вы
делаете какой-то log message.

463
00:28:08,910 --> 00:28:13,230
Предположим, что функция log message,
она умеет доставать из environment,

464
00:28:14,110 --> 00:28:15,667
надо бы ее написать, кстати,

465
00:28:15,750 --> 00:28:18,590
она умеет доставать из вот
этого environment, из logger name,

466
00:28:18,630 --> 00:28:21,219
она умеет доставать куда
писать, что писать, ну там, в std.

467
00:28:21,790 --> 00:28:27,197
in или в какой-нибудь отдельный файл,
и она как-то этим environment пользуется.

468
00:28:27,280 --> 00:28:30,170
Чтобы не передавать этот
environment везде, вот здесь

469
00:28:30,210 --> 00:28:32,170
во всех этих функциях, вы
используете MonadoReader,

470
00:28:32,890 --> 00:28:36,970
так же, как вы это использовали
во всех предыдущих занятиях.

471
00:28:38,510 --> 00:28:41,767
Но поскольку, помимо
того, чтобы использовать

472
00:28:41,850 --> 00:28:43,850
неизменяемое окружение, вам
нужно еще делать его действие,

473
00:28:44,035 --> 00:28:46,330
то есть писать в какой-то output канал,

474
00:28:47,690 --> 00:28:49,279
вы используете трансформер.

475
00:28:50,110 --> 00:28:50,943
Понятно?

476
00:28:53,820 --> 00:28:58,067
То есть, еще раз, функция log message
умеет получать доступ к environment.

477
00:28:58,150 --> 00:29:00,770
Чтобы не передавать этот environment
через каждую отдельную функцию,

478
00:29:00,830 --> 00:29:05,850
при каждом вызове этих функций,
вы передаете его один раз в меню,

479
00:29:06,770 --> 00:29:12,690
а потом, соответственно, претифия файл
content, он читает с логом, читает с логом,

480
00:29:12,950 --> 00:29:17,187
делает запись в лог, записывает
с логом, делает запись в лог.

481
00:29:20,670 --> 00:29:21,503
Понятно?

482
00:29:23,370 --> 00:29:26,470
Можно задать вопрос по поводу read file?

483
00:29:28,780 --> 00:29:33,430
Как я понимаю, log message
возвращает нам нечто в логер.

484
00:29:35,450 --> 00:29:41,630
io, а lift в следующей строчке
возьмет и текст приведет к логер.io.

485
00:29:43,140 --> 00:29:46,964
Ну, read file возвращает его,
так что он его приведет к логер.io.

486
00:29:48,450 --> 00:29:50,270
Кстати, тут баг, похоже, да.

487
00:29:52,270 --> 00:29:53,565
Смотрите, давайте так.

488
00:29:54,530 --> 00:29:55,942
Окей, это не совсем баг.

489
00:29:57,090 --> 00:30:00,170
Тип read file with log
– это логер.io текст.

490
00:30:03,550 --> 00:30:04,767
Аналогично, да, собственно.

491
00:30:04,850 --> 00:30:06,145
Нет, совсем нормально.

492
00:30:08,110 --> 00:30:09,930
Read file имеет тип .io текст.

493
00:30:14,000 --> 00:30:16,236
И lift поднимает его в логер.io текст.

494
00:30:19,025 --> 00:30:20,287
Поэтому, собственно, и lift.

495
00:30:20,370 --> 00:30:22,470
Ну, то есть, и lift...

496
00:30:23,670 --> 00:30:25,310
Что это за лифт, откуда он?

497
00:30:26,470 --> 00:30:33,450
Ведь, получается, лифт должен знать,
как это... Вот, лифт – это из monad.trans.

498
00:30:35,330 --> 00:30:36,050
Давайте так.

499
00:30:36,190 --> 00:30:40,073
Здесь не написано, что read.t –
это monad, хотя всем это очевидно.

500
00:30:40,430 --> 00:30:42,394
Но у него также должен быть
очевидный instance monad.

501
00:30:42,437 --> 00:30:44,768
trans, если это трансформер.

502
00:30:44,850 --> 00:30:49,674
Если у него есть instance monad.trans, то
там лифт, очевидно, берется из instance.

503
00:30:53,610 --> 00:30:54,443
Еще вопросы?

504
00:31:00,860 --> 00:31:02,508
Ну, давайте, поехали дальше.

505
00:31:03,200 --> 00:31:04,033
Да.

506
00:31:06,600 --> 00:31:09,877
Замечу, что вообще все ваши
стандартные монады, которые проходили,

507
00:31:09,960 --> 00:31:13,843
типа reader, writer, state – это все,
на самом деле, трансформеры.

508
00:31:15,100 --> 00:31:19,701
Просто они являются алиасом на трансформере,
где определена монада identity.

509
00:31:20,180 --> 00:31:22,122
Монада identity не делает ничего.

510
00:31:22,820 --> 00:31:26,580
Она как раз нужна как такая заглушка,
когда нужно передать какую-то монаду,

511
00:31:26,620 --> 00:31:29,620
но не нужно передать
монаду, которая что-то делает.

512
00:31:37,820 --> 00:31:41,879
Да, кто хотел увидеть instance
монада для reader.t, вот он вот такой.

513
00:31:42,300 --> 00:31:44,595
Monad.trans, соответственно, вот такой.

514
00:31:48,550 --> 00:31:52,950
А почему у нас reader является
трансформером, который принимает identity?

515
00:31:53,090 --> 00:31:54,326
Зачем нам это делать?

516
00:31:54,890 --> 00:31:57,067
Почему не достаточно отдельно монады?

517
00:31:57,590 --> 00:31:58,423
А зачем?

518
00:32:01,330 --> 00:32:03,267
Грубо говоря, если вы делаете
отдельно монады reader,

519
00:32:03,350 --> 00:32:06,350
вам нужно определять
заново монад instance для нее,

520
00:32:09,950 --> 00:32:13,847
или всякие там аппликативы, альтернативы,
что там еще у reader определено.

521
00:32:13,930 --> 00:32:15,590
Если вам нужно определить…

522
00:32:15,591 --> 00:32:19,003
Более того, у вас бывает такое,
что вот у вас есть reader, да, reader.

523
00:32:19,410 --> 00:32:22,610
t, и у него какие-то полиморфные монады.

524
00:32:22,770 --> 00:32:26,307
И вот в одних случаях вы хотите
какую-нибудь action туда передать,

525
00:32:26,390 --> 00:32:28,907
ну там, только логирование
какого-нибудь левого.

526
00:32:28,990 --> 00:32:30,507
А вот в другом случае вы не хотите.

527
00:32:30,590 --> 00:32:33,179
Вы хотите, чтобы у вас
был четыридер, и все.

528
00:32:34,030 --> 00:32:37,716
Ну, из самого тупого, наверное,
смотрите, пусть у вас есть какая-нибудь…

529
00:32:38,290 --> 00:32:41,761
пусть у вас выпишите код,
который входит в базу данных, да.

530
00:32:42,960 --> 00:32:48,830
Вот для того, чтобы протестировать
функционал, вы хотите написать, во-первых, да,

531
00:32:48,910 --> 00:32:51,667
чтобы вы могли ходить,
собственно, непосредственно в базу,

532
00:32:51,750 --> 00:32:53,847
но также вы хотите написать какой-нибудь

533
00:32:53,930 --> 00:32:55,807
тестик, где вы ходите,
на самом деле, не в базу,

534
00:32:55,890 --> 00:32:59,507
а просто там, типа, какую-нибудь
константу возвращаете на запрос.

535
00:32:59,590 --> 00:33:01,708
И вот в первом случае его вам нужно,

536
00:33:02,150 --> 00:33:04,150
во втором случае его вам не нужно.

537
00:33:06,490 --> 00:33:08,079
Вот, если вам его не нужно,

538
00:33:09,550 --> 00:33:12,430
вам не нужно тогда писать
несколько различных функций.

539
00:33:12,510 --> 00:33:14,397
Одну с reader.t, другую просто с reader.

540
00:33:14,480 --> 00:33:15,707
Вы просто передаете identity,

541
00:33:15,790 --> 00:33:18,587
когда вам не нужен другой
какой-то эффект, кроме reader.

542
00:33:18,670 --> 00:33:19,503
Понятно?

543
00:33:25,860 --> 00:33:26,860
Ну, вроде бы, да.

544
00:33:30,040 --> 00:33:32,817
Да, значит, на то, что справа,
пока не обращайте внимания,

545
00:33:32,900 --> 00:33:35,548
он тут преждевременно,
тут какая-то картинка.

546
00:33:39,930 --> 00:33:40,763
Вот.

547
00:33:41,110 --> 00:33:44,487
Так, если здесь все понятно,
давайте посмотрим на табличку.

548
00:33:44,570 --> 00:33:47,570
Вот у вас типы,
соответственно, базовых монад,

549
00:33:47,690 --> 00:33:50,102
типы трансформеров, вот как они меняются.

550
00:33:53,480 --> 00:33:56,186
Да, вот, соответственно,
то, что у вас было...

551
00:33:56,400 --> 00:34:00,400
Грубо говоря, у вас результат всегда
теперь заворачивается в монаду.

552
00:34:01,040 --> 00:34:02,982
Я не знаю, проходили конт-монаду?

553
00:34:04,920 --> 00:34:06,215
Знаете, что это такое? И я не помню.

554
00:34:07,880 --> 00:34:08,713


555
00:34:09,900 --> 00:34:12,062
Поэтому тогда я не буду
мешать на ваше внимание.

556
00:34:12,145 --> 00:34:14,040
Но вот state, writer, reader...

557
00:34:14,710 --> 00:34:16,377
Господи, writer, reader, state.

558
00:34:16,460 --> 00:34:17,293
Вот запомните.

559
00:34:19,540 --> 00:34:20,776
Вот так вот работают.

560
00:34:21,060 --> 00:34:28,560
Да, на всякий случай, если вдруг
у вас возникнет такая ситуация,

561
00:34:28,640 --> 00:34:32,375
что вам нужно комбинировать reader,
writer и state, используйте тогда RWS.

562
00:34:32,780 --> 00:34:35,310
Это просто проще с
точки зрения синтексиса.

563
00:34:36,580 --> 00:34:39,720
Да, и у RWS все еще есть
трансформеры, так что есть RWST.

564
00:34:39,721 --> 00:34:41,545
И у RWS тоже есть трансформеры.

565
00:34:43,270 --> 00:34:44,103
Окей.

566
00:34:44,590 --> 00:34:45,450
Идем дальше.

567
00:34:46,510 --> 00:34:49,452
Да, можно заметить, что
в этой табличке нет иошки.

568
00:34:49,930 --> 00:34:51,730
Иошка не трансформируется.

569
00:34:54,130 --> 00:34:57,072
Почему его не трансформируется,
вопрос интересный.

570
00:34:57,210 --> 00:35:00,610
Если вкратце, то потому что,
если его трансформируется,

571
00:35:00,730 --> 00:35:05,210
вам в какой-то момент можно
будет захотеть сделать какие-то очень,

572
00:35:06,560 --> 00:35:08,457
скажем так, пагубные вещи с иошкой.

573
00:35:08,540 --> 00:35:13,030
В том смысле, что вы не сможете
написать монадный инстанс для нее.

574
00:35:13,830 --> 00:35:16,050
Например, вы не сможете написать,

575
00:35:16,370 --> 00:35:19,723
как будет выглядеть монадный
инстанс в случае ио и мэйби.

576
00:35:19,990 --> 00:35:23,190
То есть, если у вас не ио, а мэйби,

577
00:35:30,380 --> 00:35:34,660
в мэйби ио было можно
использовать комбинацию ио и мэйби.

578
00:35:34,885 --> 00:35:37,356
В обратном порядке ее использовать нельзя.

579
00:35:39,030 --> 00:35:42,300
То есть, ио не трансформируется.

580
00:35:43,820 --> 00:35:45,800
Есть только такой монад ио,

581
00:35:47,960 --> 00:35:52,440
который позволяет вам лифтить
специально ио действие в другую монаду.

582
00:35:56,390 --> 00:36:01,039
Может показаться, что эта штука стирает
нечистоту иошки, на самом деле нет.

583
00:36:03,620 --> 00:36:07,740
Эта штука нужна исключительно
потому, что ио у вас всегда в самом конце.

584
00:36:07,790 --> 00:36:11,920
В самом конце цепочки трансформеров.

585
00:36:13,400 --> 00:36:17,048
Поэтому его надо всегда поднимать
с самого низа на самый верх.

586
00:36:17,400 --> 00:36:19,857
Да, потому что нужно
делать эту операцию поднятия.

587
00:36:19,940 --> 00:36:21,882
Вот это последовательность монад,

588
00:36:22,420 --> 00:36:25,773
трансформеров и их аргументов
называется монадным стэгом.

589
00:36:26,040 --> 00:36:29,520
То есть, то, что у вас был
reader t от state t от writer t,

590
00:36:29,740 --> 00:36:31,446
это называется монадный стэг.

591
00:36:34,220 --> 00:36:35,053
Понятно?

592
00:36:56,310 --> 00:37:03,170
Внезапно вы увидите, что то же самое
происходит с инстанцией monad.trans.

593
00:37:03,495 --> 00:37:06,437
У вас достаточно тривиальные
инстанции получаются,

594
00:37:07,050 --> 00:37:08,950
но их просто много.

595
00:37:11,335 --> 00:37:13,990
Монадный стэг называется монадным стэгом.

596
00:37:14,310 --> 00:37:16,075
То есть у вас state от reader.

597
00:37:17,450 --> 00:37:20,230
Мы вернулись к оригинальной задаче.

598
00:37:20,231 --> 00:37:24,208
Мы действительно теперь можем скомпозировать
state и reader, или reader и state,

599
00:37:24,800 --> 00:37:29,110
и получить то, что мы хотели.

600
00:37:29,210 --> 00:37:32,050
То есть мы получаем доступ к environment,

601
00:37:33,850 --> 00:37:36,262
и мы получаем возможность записать state.

602
00:37:37,450 --> 00:37:38,921
Пока мы не перешли к MTL,

603
00:37:40,055 --> 00:37:42,232
здесь понятно все, что до этого было?

604
00:37:45,920 --> 00:37:50,240
Получается, порядок трансформирования
монад важен или не очень?

605
00:37:50,241 --> 00:37:54,241
То есть в чем разница между
state t от reader или reader t от state?

606
00:37:55,040 --> 00:37:57,217
Смотрите, конкретно в
этом случае вообще не важно.

607
00:37:57,300 --> 00:38:01,362
Здесь мы могли написать reader t от
state, это было бы совершенно легитимно.

608
00:38:03,160 --> 00:38:05,380
Важен он становится,

609
00:38:06,020 --> 00:38:08,891
когда у вас появляются штуки,
которые могут ломать вам,

610
00:38:11,150 --> 00:38:12,915
когда могут ломать вычисления.

611
00:38:13,210 --> 00:38:16,200
Это, соответственно,
ситуация либо с иоркой, но с

612
00:38:16,280 --> 00:38:18,339
иоркой все просто, она
всегда должна быть внизу стэга,

613
00:38:21,470 --> 00:38:24,480
либо еще там появляются
веселости, мы сейчас чуть

614
00:38:24,560 --> 00:38:26,325
позже их увидим, когда
у вас появляется accept.

615
00:38:28,480 --> 00:38:32,440
Ломать вычисления, это в
плане, как у нас в случае с maybe,

616
00:38:32,640 --> 00:38:35,540
там по nothing было
замыкание, вот это вот?

617
00:38:36,600 --> 00:38:37,597
Ну, типа того, да.

618
00:38:37,680 --> 00:38:38,440
То есть у вас, например,

619
00:38:38,540 --> 00:38:41,060
при определенных
комбинациях accept и state,

620
00:38:41,140 --> 00:38:45,020
да, если что, accept это
просто трансформер either.

621
00:38:45,540 --> 00:38:51,100
Единственное, почему-то, что у вас,
у всех трансформеров называется,

622
00:38:51,220 --> 00:38:53,757
точнее у всех моделей трансформеров
называется буквка t в конце,

623
00:38:53,840 --> 00:38:57,260
а вот у either почему-то
он не either t, а accept t.

624
00:38:59,100 --> 00:39:00,395
Честно не знаю почему.

625
00:39:00,640 --> 00:39:01,935
Суть в том, что у вас,

626
00:39:02,200 --> 00:39:05,720
в зависимости от того, в какой
момент вы прокинете вот это исключение

627
00:39:05,721 --> 00:39:09,810
через accept, у вас может
стоить либо сохраниться, либо нет.

628
00:39:11,960 --> 00:39:13,260
Оно как бы там,

629
00:39:13,500 --> 00:39:15,936
это логически понятно,
почему так происходит,

630
00:39:17,460 --> 00:39:19,160
да и по смыслу тоже понятно.

631
00:39:19,360 --> 00:39:20,140
Но вот сам факт того,

632
00:39:20,260 --> 00:39:22,917
что если вы просто бездумно влепите,
вы можете в какой-то момент получить,

633
00:39:23,000 --> 00:39:26,432
что у вас вылетает ошибка, и
из-за этого у вас state не сохраняется.

634
00:39:34,560 --> 00:39:35,619
Окей, еще вопросы?

635
00:39:42,280 --> 00:39:43,575
Тогда переходим к MTL.

636
00:39:44,105 --> 00:39:46,341
Да, собственно, как бы кто-то заметил,

637
00:39:46,700 --> 00:39:50,540
у вас есть как минимум одна
сейчас проблема, у вас куча лифтов.

638
00:39:52,140 --> 00:39:52,973
Вот.

639
00:39:53,080 --> 00:39:53,913
Более того,

640
00:39:56,095 --> 00:39:57,919
мы хотим делать еще одну штуку.

641
00:39:59,000 --> 00:40:00,353
Мы не хотим каждый раз,

642
00:40:00,980 --> 00:40:03,451
мы хотим добавить еще больше полиморфизма.

643
00:40:03,660 --> 00:40:07,340
Мы не хотим каждый раз
указывать конкретную монаду, а

644
00:40:07,341 --> 00:40:08,880
вместо этого мы хотим
указать как бы эффект, который,

645
00:40:09,040 --> 00:40:10,740
который какая-то,

646
00:40:12,520 --> 00:40:13,353
господи,

647
00:40:14,390 --> 00:40:16,273
мы хотим указать набор эффектов,

648
00:40:16,380 --> 00:40:20,115
который монада должна обладать,
чтобы мы могли в этой функции работать.

649
00:40:20,760 --> 00:40:21,593
Понятно?

650
00:40:21,820 --> 00:40:23,560
То есть не всегда писать,
что вот у вас state reader,

651
00:40:23,561 --> 00:40:26,480
что вы можете передать
абсолютно любую монаду,

652
00:40:26,760 --> 00:40:29,197
главное, чтобы она
умела делать вот эти вещи.

653
00:40:29,280 --> 00:40:30,197
Для чего это нужно?

654
00:40:30,280 --> 00:40:34,200
Потому что мы хотим,

655
00:40:34,800 --> 00:40:36,857
чтобы у нас было чуть-чуть
больше полиморфизма.

656
00:40:36,940 --> 00:40:38,411
Смотрите, например, у нас

657
00:40:38,560 --> 00:40:40,980
некоторые функции хотят ЙО и Ридер,

658
00:40:43,145 --> 00:40:45,720
некоторые функции хотят Ридер и Стейт,

659
00:40:45,970 --> 00:40:48,080
некоторые хотят ЙО и Стейт.

660
00:40:49,440 --> 00:40:50,273
Так что,

661
00:40:50,700 --> 00:40:53,053
и, соответственно, чтобы этими функциями

662
00:40:54,655 --> 00:40:57,196
Мы хотим сделать следующее.
Мы хотим, чтобы каждая

663
00:40:57,239 --> 00:40:59,718
из этих функций просто
указывала, что она хочет.

664
00:40:59,800 --> 00:41:01,698
Что она хочет, чтобы мы могли получать

665
00:41:01,741 --> 00:41:04,038
доступ к environment и
получать доступ к его.

666
00:41:04,120 --> 00:41:06,351
Что она еще умеет,
какие еще эффекты есть у

667
00:41:06,393 --> 00:41:08,718
polymorph на этой
монаде, нас не интересует.

668
00:41:08,800 --> 00:41:13,090
Поэтому мы один раз загоняем
какую-то большущую монаду, большущего

669
00:41:13,132 --> 00:41:17,201
стека, вида reader, writer,
state, except, черт еще что знает.

670
00:41:17,875 --> 00:41:20,959
А потом, соответственно,
каждая из этих функций будет

671
00:41:21,001 --> 00:41:24,598
использовать только определенные
эффекты, которые в ней есть.

672
00:41:24,680 --> 00:41:28,708
Для этого мы вводим специальный пакет mtl.

673
00:41:28,750 --> 00:41:33,401
Пакет называется mtl,
так же и метод называется.

674
00:41:36,820 --> 00:41:39,585
MonadTemplateLibrary,
но сейчас я уже не помню.

675
00:41:39,780 --> 00:41:43,780
Суть в чем. Мы вводим некоторый класс.
Класс, например, MonadReader.

676
00:41:45,240 --> 00:41:48,696
MonadReader, который
означает, что мы умеем

677
00:41:48,739 --> 00:41:52,481
читать какой-то
environment, и что это монада.

678
00:41:55,180 --> 00:41:58,080
И таким образом у вас
получается следующее.

679
00:42:03,310 --> 00:42:07,150
Вы, соответственно, можете
передать сюда любую монаду, в которой

680
00:42:07,193 --> 00:42:10,711
где-то там в стеке есть reader,
и мы умеем из него читать.

681
00:42:12,040 --> 00:42:14,784
Меное определенное
производство для нее является

682
00:42:14,826 --> 00:42:17,728
монад reader, определяется
достаточно превиальным.

683
00:42:17,810 --> 00:42:22,590
Здесь есть один элемент, который
вы не знаете до сих пор, кто его видит?

684
00:42:25,170 --> 00:42:28,030
По-хорошему должен быть
тот вопрос, а что вот это за код?

685
00:42:28,031 --> 00:42:30,770
Вертикальная черта меня напрягает.

686
00:42:31,470 --> 00:42:32,823
Вот, правильный пример.

687
00:42:33,210 --> 00:42:36,070
Это немножко легоси, называется фундепа,

688
00:42:36,330 --> 00:42:37,801
рациональная зависимость.

689
00:42:38,390 --> 00:42:40,850
Эта штука как бы гарантирует компилятору,

690
00:42:41,470 --> 00:42:46,310
что если у вас есть определен
инстанс MonadReader

691
00:42:47,110 --> 00:42:48,350
для какой-то Monad M,

692
00:42:49,370 --> 00:42:51,927
то вы всегда знаете, для
какого environment он определен.

693
00:42:52,010 --> 00:42:53,305
То есть, грубо говоря,

694
00:42:53,930 --> 00:42:56,890
данное M сразу определяет вам environment.

695
00:42:59,090 --> 00:43:00,190
Что это означает на практике?

696
00:43:00,250 --> 00:43:06,890
На практике это означает, что
вы определили MonadReader R1M,

697
00:43:07,680 --> 00:43:10,490
вы не можете определить MonadReader R2M.

698
00:43:13,250 --> 00:43:16,507
Компилятор скажет, ребята,
у вас там фундеп, не надо так.

699
00:43:16,590 --> 00:43:17,649
И не скомпилирует.

700
00:43:21,230 --> 00:43:22,466
Для чего это сделано?

701
00:43:22,900 --> 00:43:24,900
Это сознательная лимитация.

702
00:43:26,080 --> 00:43:26,680
Почему?

703
00:43:26,681 --> 00:43:29,093
Потому что, смотрите, вот у вас есть ASK.

704
00:43:29,460 --> 00:43:32,637
ASK M R, то есть он просто
возвращает вам environment.

705
00:43:33,730 --> 00:43:35,697
Вот у вас есть, допустим, MonadReader,

706
00:43:35,780 --> 00:43:39,016
определен для двух разных
environment, для одной Monad.

707
00:43:41,080 --> 00:43:42,300
Вот вы делаете ASK.

708
00:43:42,380 --> 00:43:44,720
Вопрос, какой environment вы получите?

709
00:43:47,990 --> 00:43:51,461
Тут по-хорошему бы надо
что-нибудь нарисовать или написать.

710
00:43:53,750 --> 00:43:56,398
Давайте я попробую в
комменты тогда написать.

711
00:44:02,970 --> 00:44:05,912
Что я имею в виду, потому
что важно для понимания.

712
00:44:06,450 --> 00:44:08,410
Предположим, что у меня есть...

713
00:44:20,740 --> 00:44:24,799
Ладно, сейчас не буду писать, а
потом скину флешку, чтобы все видели.

714
00:44:27,180 --> 00:44:28,520
Еще раз, идея в чем.

715
00:44:29,070 --> 00:44:33,060
Вы не можете определить два
инстанса MonadReader к одной Monad,

716
00:44:33,425 --> 00:44:36,249
так, чтобы из них получались
разные environment.

717
00:44:36,820 --> 00:44:37,653
Понятно?

718
00:44:40,540 --> 00:44:41,373
Ага.

719
00:44:44,940 --> 00:44:47,780
Кому-то кроме Романа и Федора понятно?

720
00:44:51,860 --> 00:44:54,780
Анастасия, Кристина, Юрий.

721
00:44:56,360 --> 00:44:58,947
Остальных я, к сожалению,
имена не выговорю.

722
00:44:59,030 --> 00:45:02,960
Можно ли это трактовать как интерфейс?

723
00:45:06,360 --> 00:45:08,660
Накладывание каких-то ограничений?

724
00:45:09,160 --> 00:45:10,840
Как накладывание ограничений, да.

725
00:45:10,900 --> 00:45:12,820
Интерфейс это немножко другое.

726
00:45:13,760 --> 00:45:16,395
Интерфейс это про то,
что вы делать можете, а

727
00:45:16,438 --> 00:45:19,114
здесь скорее про то,
что вы делать не можете.

728
00:45:23,640 --> 00:45:24,380
Двигаемся дальше.

729
00:45:24,381 --> 00:45:30,360
Все MTL классы, они так или иначе с
фундеповскими констрейтами сидят.

730
00:45:38,040 --> 00:45:41,280
У вас для всех их комбинаций
есть какие-то инстансы.

731
00:45:41,660 --> 00:45:48,300
То есть для MonadReader, инстанс
MonadReader для ридера банальный,

732
00:45:48,980 --> 00:45:55,360
а инстанс MonadReader для
райтера, он определяется как.

733
00:45:55,361 --> 00:45:57,637
Вам нужно, чтобы MonadReader
был в внутренней монаде.

734
00:45:57,720 --> 00:45:58,640
То есть что это означает?

735
00:45:58,720 --> 00:46:02,191
Означает, что где-то там по
стэку должен быть где-то ридер.

736
00:46:03,340 --> 00:46:04,173
Понятно?

737
00:46:08,040 --> 00:46:10,077
То есть видите вот этот констрейнт.

738
00:46:10,160 --> 00:46:15,010
Этот констрейнт гарантирует вам,
что у вас определен MonadReader для M.

739
00:46:17,170 --> 00:46:20,730
Лезем в M, а там скорее всего
какой-нибудь такой же констрейнт,

740
00:46:20,731 --> 00:46:24,950
что MonadReader уже внутренней
монады у M должно существовать.

741
00:46:25,225 --> 00:46:28,167
И так далее, пока мы не
натыкаемся на MonadReader,

742
00:46:28,880 --> 00:46:32,810
в котором у вас требуется только,
чтобы у вас была внутри монада.

743
00:46:33,290 --> 00:46:34,123
Понятно?

744
00:46:37,050 --> 00:46:38,957
Соответственно, если
у вас ридеров стэки нет,

745
00:46:39,040 --> 00:46:43,276
вы не можете выполнить это условие,
у вас не будет инстанса MonadReader.

746
00:46:45,870 --> 00:46:47,567
То же самое для стэйта и райтера.

747
00:46:47,650 --> 00:46:48,483
Понятно?

748
00:46:51,820 --> 00:46:52,653
Да.

749
00:46:54,070 --> 00:46:55,894
И так мы можем получать стэйты.

750
00:46:57,700 --> 00:46:58,533
Понятно.

751
00:47:00,210 --> 00:47:01,957
Ладно, возможно я не так понял.

752
00:47:02,040 --> 00:47:04,800
Ну просто вот MonadReader, да, стэйт.

753
00:47:10,010 --> 00:47:12,100
Вот, что происходит в этом случае.

754
00:47:12,200 --> 00:47:12,460
Еще раз.

755
00:47:12,980 --> 00:47:15,060
Вот смотрите, мы определяем
MonadReader для стэйта.

756
00:47:15,140 --> 00:47:15,973
Что за фигня?

757
00:47:16,660 --> 00:47:19,867
То есть какой ридер, какой environment
мы можем из стэйта прочитать.

758
00:47:19,950 --> 00:47:22,127
А мы читаем environment не из стэйта.

759
00:47:22,900 --> 00:47:26,430
Представьте, что здесь у стэйта
в монаде M там еще 20 монад.

760
00:47:27,090 --> 00:47:29,737
Там какой-нибудь ридер,
райтер, там еще что-нибудь.

761
00:47:29,820 --> 00:47:31,938
Где-то среди этого стэка есть ридер.

762
00:47:32,400 --> 00:47:33,320
Или ридер T.

763
00:47:36,710 --> 00:47:41,420
Вот, и вы говорите, я хочу сделать
доступ к environment, хочу сделать ask.

764
00:47:42,400 --> 00:47:45,377
Чтобы не делать лифт,
лифт, лифт, лифт, лифт, лифт,

765
00:47:45,460 --> 00:47:48,225
вы запаковываете его
внутри вот этого инстанса.

766
00:47:49,370 --> 00:47:54,060
Инстанс при этом имеет
constraint, что я не применяю ask,

767
00:47:54,920 --> 00:47:58,557
я не достаю environment из вот этой монады
стэйт, которая у меня сейчас написана.

768
00:47:58,640 --> 00:48:01,560
Я достаю ее откуда-то дальше по стэку.

769
00:48:02,320 --> 00:48:05,871
У меня гарантированно, что дальше
по стэку, вот этим вот MonadReader,

770
00:48:06,530 --> 00:48:09,997
у меня гарантированно, что
дальше по стэку где-то монада есть.

771
00:48:10,080 --> 00:48:11,316
MonadReader в смысле.

772
00:48:13,930 --> 00:48:18,030
Как достать environment из той монады,
которая где-то внутри далеко по стэку?

773
00:48:18,070 --> 00:48:18,903
Ну очевидно,

774
00:48:20,350 --> 00:48:23,667
ask для данной монады это
запросить ask во внутренней монаде,

775
00:48:23,750 --> 00:48:26,190
которая в свою очередь
запросит ask во внутренней монаде,

776
00:48:26,270 --> 00:48:28,267
и так далее, и так далее, и так
далее, пока не дает до ридера,

777
00:48:28,350 --> 00:48:31,115
у которого вот эта штука
определена тривиально.

778
00:48:33,030 --> 00:48:33,863
Понятно?

779
00:48:34,870 --> 00:48:35,703
Да.

780
00:48:37,230 --> 00:48:40,890
Верно ли, что тогда нужно
прописывать еще и для

781
00:48:40,970 --> 00:48:42,382
всех других комбинаций,
где не только стэйт, тэ?

782
00:48:44,010 --> 00:48:44,843
Да.

783
00:48:45,160 --> 00:48:46,749
Это называется NxM problem,

784
00:48:47,130 --> 00:48:50,170
но опять же очевидно,
что никто так не делает,

785
00:48:50,270 --> 00:48:51,970
оно достаточно тривиально
решаемое, потому что смотрите,

786
00:48:52,320 --> 00:48:55,144
замечу, что этот инстанс
достаточно тривиальный.

787
00:48:55,350 --> 00:48:57,586
Ну то есть буквально ask это lift ask,

788
00:48:58,170 --> 00:48:58,270
там,

789
00:48:58,990 --> 00:49:00,343
reader это lift reader,

790
00:49:00,650 --> 00:49:04,858
local это какая-то ересь, но насколько
я помню, там не нужно определять для,

791
00:49:06,310 --> 00:49:09,010
не помню какого у
него minimal definition, но

792
00:49:09,090 --> 00:49:11,470
даже так, все равно он
достаточно тривиальный.

793
00:49:12,250 --> 00:49:13,270
Вот, поэтому да,

794
00:49:13,470 --> 00:49:14,353
соответственно,

795
00:49:16,390 --> 00:49:19,770
короче, решение у этой штуки
есть, сейчас через пару слайдов.

796
00:49:21,530 --> 00:49:24,707
Вот, да, значит как-то связано
с парсер-комбинаторами.

797
00:49:27,360 --> 00:49:30,435
Сейчас, у вас какая сейчас доза,
там есть какие-нибудь парсеры?

798
00:49:31,515 --> 00:49:33,633
Или бывали у вас лекции про парсеры?

799
00:49:34,730 --> 00:49:35,930
Нет, парсеров нет.

800
00:49:37,390 --> 00:49:38,223
Окей, хорошо.

801
00:49:38,370 --> 00:49:39,959
А никаких парсеров не было.

802
00:49:40,960 --> 00:49:42,843
Хорошо, странно, что их не было,

803
00:49:42,950 --> 00:49:43,790
но суть в чем,

804
00:49:43,890 --> 00:49:46,750
смотрите, вот у вас
есть парсер-комбинатор,

805
00:49:46,751 --> 00:49:47,634
да, это какая-то такая
вот, какой-то класс,

806
00:49:47,780 --> 00:49:51,090
как Monado на самом деле
работает, который позволяет

807
00:49:51,170 --> 00:49:52,523
вам парсить выражение,
то есть он берет строку

808
00:49:52,890 --> 00:49:55,970
и возвращает, может быть,
распарщенный результат и остаток строки.

809
00:49:58,080 --> 00:49:59,527
Для чего нужно именно вот так вот делать?

810
00:49:59,610 --> 00:50:02,850
Для того, чтобы вы сразу могли
вот к этому результату, вот к этой вот

811
00:50:03,100 --> 00:50:05,107
оставшей части применить другой парсер.

812
00:50:05,190 --> 00:50:07,047
Поэтому они называются
парсер-комбинаторами.

813
00:50:07,130 --> 00:50:10,827
Вы берете несколько парсеров, каждый
из которых умеет парсить какую-то часть,

814
00:50:10,910 --> 00:50:13,527
применяете их все
последовательно друг за другом,

815
00:50:13,610 --> 00:50:17,372
и у вас каждый из них выдает какой-то
результат, плюс то, что осталось распарсить.

816
00:50:17,910 --> 00:50:18,743
Вот.

817
00:50:18,980 --> 00:50:21,410
К этой фигне можно добавить,

818
00:50:22,470 --> 00:50:25,427
да, по сути, во-первых, эта
штука превращается в некий стейт,

819
00:50:25,970 --> 00:50:28,690
во-вторых, к этой фигне можно добавить
трансформеров, то есть, например,

820
00:50:28,810 --> 00:50:31,846
если вам парсер нужно логировать
ошибку, раз вы ее обнаружили,

821
00:50:32,110 --> 00:50:33,827
вы можете добавить сюда PointXL.

822
00:50:33,910 --> 00:50:37,487
Если вам для того, чтобы
распарсить значение, нужно

823
00:50:37,570 --> 00:50:39,050
PointEnvironment почитать,
ну, например, самое

824
00:50:39,051 --> 00:50:40,650
банальное – это переменная,
замена переменных,

825
00:50:40,770 --> 00:50:41,330
там PointMaps,

826
00:50:41,470 --> 00:50:42,707
замена переменных лежит.

827
00:50:42,790 --> 00:50:44,849
Вот вы можете Reader сюда добавить.

828
00:50:46,760 --> 00:50:49,167
Давайте не будем на этом
долго останавливаться.

829
00:50:49,250 --> 00:50:50,083
Да.

830
00:50:50,700 --> 00:50:52,627
Значит, теперь обработка исключений.

831
00:50:52,710 --> 00:50:55,062
У вас, по-моему, было что-то
про обработку исключений.

832
00:50:55,930 --> 00:50:56,763
Правильно? Правильно было.

833
00:50:58,830 --> 00:50:59,810
Отлично.

834
00:51:01,050 --> 00:51:01,570


835
00:51:01,830 --> 00:51:04,769
Кому-нибудь скажет, в Хакере можно
кидать исключения из чьих-то функций?

836
00:51:09,620 --> 00:51:12,470
Ну, вообще, здесь функция
Error, которая прервает...

837
00:51:12,870 --> 00:51:14,812
Хорошо, а проверяемые исключения?

838
00:51:15,610 --> 00:51:17,347
Error – непроверяемые исключения.

839
00:51:17,430 --> 00:51:18,263
Это правда.

840
00:51:23,240 --> 00:51:24,770
Проверяемые только из его.

841
00:51:26,660 --> 00:51:30,686
Вот этим ответом люди
себя убивают на экзамене.

842
00:51:31,760 --> 00:51:32,740
Первое, значит,

843
00:51:32,960 --> 00:51:36,297
даже без каких-либо монад вы
все равно можете сделать просто

844
00:51:36,380 --> 00:51:37,360
функцию Throw, если
посмотрите на ее тип, ее тип E, A.

845
00:51:37,380 --> 00:51:38,260


846
00:51:38,980 --> 00:51:40,804
И потом ее можно Catch сделать.

847
00:51:41,280 --> 00:51:44,140
Замечу, что Throw...

848
00:51:44,490 --> 00:51:46,920
Короче, вы можете делать
Throw из чьих-то функций,

849
00:51:46,921 --> 00:51:48,392
вы не можете делать
из чьих-то функций Catch.

850
00:51:48,960 --> 00:51:51,763
Вот ловить исключения можно
действительно только в ООО.

851
00:51:52,880 --> 00:51:54,757
А вот Throw делать можно откуда угодно.

852
00:51:54,840 --> 00:51:57,600
Но вот там как раз такие
проблемы, что Throw на самом

853
00:51:57,601 --> 00:51:58,778
деле пробрасывает
исключения все равно через ООО.

854
00:51:58,950 --> 00:52:00,362
Он ломает вам вычисление

855
00:52:02,580 --> 00:52:04,780
и, ну, не есть хорошо.

856
00:52:05,140 --> 00:52:05,680
Это можно,

857
00:52:05,800 --> 00:52:07,095
но это не есть хорошо.

858
00:52:07,290 --> 00:52:09,220
Чтобы вот такой фигни
не было, есть два варианта.

859
00:52:09,320 --> 00:52:09,620
Первый –

860
00:52:09,621 --> 00:52:11,504
у вас все крутится в ООО хорошо.

861
00:52:12,100 --> 00:52:20,780
В таком случае у вас, соответственно,
в таком случае вы можете

862
00:52:22,145 --> 00:52:24,137
просто делать Throw и Catch в ООО.

863
00:52:24,220 --> 00:52:25,809
Или как они так называются?

864
00:52:25,920 --> 00:52:27,332
Throw и Catch, по-моему.

865
00:52:28,880 --> 00:52:32,120
Которые работают через ООО
и так, поэтому им не страшно.

866
00:52:32,200 --> 00:52:34,479
И ООО само там пофиксит
порядок вычислений.

867
00:52:34,920 --> 00:52:38,600
А если вам хочется кинуть вычисление
внутри какой-нибудь чистой функции,

868
00:52:40,020 --> 00:52:40,853
тем не менее,

869
00:52:41,120 --> 00:52:42,177
то вы можете все это сделать.

870
00:52:42,260 --> 00:52:45,756
Просто он лучше будет, если вы начнете
вычислять на это дело монадический контекст.

871
00:52:46,320 --> 00:52:49,065
Но самое банальное,
опять же, это except какой-то.

872
00:52:49,280 --> 00:52:51,760
Except, на самом деле, в монадическом
контексте он просто заменяет

873
00:52:51,761 --> 00:52:54,467
каждую последующую операцию
после того, как случилась

874
00:52:54,550 --> 00:52:56,970
ошибка на возвращение
за результат ошибки, и все.

875
00:52:57,600 --> 00:52:58,433


876
00:53:00,110 --> 00:53:02,800
То есть он как бы продолжает
вычисления дальше.

877
00:53:03,060 --> 00:53:04,740
Просто каждую операцию, вместо этого,

878
00:53:05,015 --> 00:53:06,397
тупо не будет ее выполнять.

879
00:53:06,480 --> 00:53:07,920
Вместо этого просто результатом
этой операции будет ошибка.

880
00:53:07,921 --> 00:53:08,754


881
00:53:09,000 --> 00:53:09,540
И вот тогда и тогда,

882
00:53:09,720 --> 00:53:10,460
и так далее, пока она не вернется

883
00:53:10,461 --> 00:53:25,993
в виде результата. Вот. И, соответственно, чтобы таким образом выкидывать ошибки или их ловить, есть
две монатки. Монат throw и монат fetch. Точнее, не монатки, а классы. То есть для его этого throw и all

884
00:53:26,035 --> 00:53:41,761
просто тупо, а для, соответственно, maybe, она просто заменяет классы на nothing. Всё. Вот. Соответственно,
есть монат throw для того, чтобы выкидать ошибки. Как вы можете видеть, у него он же определяется,

885
00:53:42,690 --> 00:53:46,854
через лифты для внутренних
монат поставку. Вот.

886
00:53:46,896 --> 00:53:50,821
Это, кстати, важно. Почему? Потому
что, соответственно, это означает,

887
00:53:50,940 --> 00:53:53,077
что вы из какой-то
внутренней монады можете

888
00:53:53,119 --> 00:53:55,041
бросить исключение, и мы здесь это знаем.

889
00:53:55,041 --> 00:53:58,031
Но мы можем пробросить
дальше. Вот. Соответственно, монат

890
00:53:58,073 --> 00:54:01,441
catch, который парен монат
throw, потому что нужен

891
00:54:01,441 --> 00:54:05,568
инстанс монат throw, чтобы
был монат catch, он позволяет это

892
00:54:05,611 --> 00:54:09,641
исключение в монаде
ловить и как-то обрабатывать.

893
00:54:38,660 --> 00:54:42,056
Понятно? Непонятно. Зачем нам
для того, чтобы определить монат

894
00:54:42,098 --> 00:54:45,341
catch, требуется, чтобы
был определен монат throw,

895
00:54:46,330 --> 00:54:53,361
если мы можем бросать это всюду, а
не только из... Нет, это не совсем так.

896
00:54:53,361 --> 00:54:55,851
Смотрите, констрентами монат
throw и монат catch вы описываете,

897
00:54:55,893 --> 00:54:58,281
как вы пробрасываете
исключение. Потому что соч.

898
00:54:58,281 --> 00:55:01,382
io это вот та самая ломающая
последовательность вычислений выброс.

899
00:55:01,424 --> 00:55:04,338
То есть, и.о. это как
бы такая дубинка, да?

900
00:55:04,420 --> 00:55:07,017
Она просто говорит, все, у меня
случилось исключение, мне пофиг на

901
00:55:07,060 --> 00:55:09,818
то, что там должно в программе
твориться дальше, я вот полетела туда.

902
00:55:09,900 --> 00:55:13,541
Как бы вы ее так и ловите,
как что-то, что летит откуда-то

903
00:55:13,583 --> 00:55:16,821
непонятно откуда, как
бы, и приходит к вам.

904
00:55:16,821 --> 00:55:20,327
С точки зрения maybe, ошибка
гораздо более такая мягкая.

905
00:55:20,369 --> 00:55:23,798
Это просто, типа, вы заменяете
последовательность операции на nothing.

906
00:55:23,880 --> 00:55:26,304
Соответственно, как вам
поймать то, что у вас случилась

907
00:55:26,346 --> 00:55:28,901
таки ошибка? Ну вот ровно
так же. Вы определяете instance

908
00:55:28,901 --> 00:55:31,630
монат catch, который умеет
понимать, что ага, вот этот

909
00:55:31,673 --> 00:55:34,238
nothing, которым пришел,
это на самом деле ошибка,

910
00:55:34,320 --> 00:55:40,921
которая вылетела, и
мы ее можем обработать.

911
00:55:40,964 --> 00:55:47,351
Понятно? Да. Замечу, что
instance монат throw и монат catch

912
00:55:47,351 --> 00:55:49,965
определяются для одной и
той же монады. То есть, если

913
00:55:50,008 --> 00:55:52,663
вы определили монат throw
для maybe каким-то образом,

914
00:55:52,745 --> 00:55:56,856
вы определяете монат catch
для maybe таким же образом.

915
00:55:56,899 --> 00:56:01,051
Ну, в плане, типа, как-то
парно к нему. Чтобы вы умели

916
00:56:01,051 --> 00:56:04,745
обрабатывать тот тип
ошибок, который там вылетает.

917
00:56:04,787 --> 00:56:08,641
Для его это, соответственно, простой
catch, для maybe там что-то другое будет.

918
00:56:09,910 --> 00:56:13,027
Да, для его это просто catch.
Как catch и throw работают

919
00:56:13,069 --> 00:56:16,171
под капотом, мы вам, вроде
так, должны были рассказать,

920
00:56:16,171 --> 00:56:19,502
если не представляли,
лучше не смотрите туда,

921
00:56:19,544 --> 00:56:22,991
там мощная магия. Вот.
Да, еще есть mtl'евский

922
00:56:22,991 --> 00:56:27,199
монат error, который на
самом деле то же самое, что

923
00:56:27,242 --> 00:56:31,491
эти два комбинированные,
просто он, типа, позволяет

924
00:56:31,491 --> 00:56:33,942
одновременно определять,
позволяет одновременно

925
00:56:33,985 --> 00:56:36,531
кидать ошибку и ловить
ошибку. Замечу, что здесь

926
00:56:36,531 --> 00:56:38,513
опять есть фунт деп на
то, что у вас так же как и с

927
00:56:38,555 --> 00:56:40,578
ридером, только здесь у вас
определяется тип ошибки для монады.

928
00:56:40,660 --> 00:56:44,907
То есть, одна монада может кидать только

929
00:56:44,950 --> 00:56:48,991
одну ошибку по этому
инстанцу. Зачем так сделано,

930
00:56:49,130 --> 00:56:52,825
честно говоря, не знаю,
просто design limitation.

931
00:56:52,867 --> 00:56:56,811
Вот, ну и да, то, что я говорил,
что у вас accept transformer,

932
00:56:57,230 --> 00:57:03,946
это какого-то черта
трансформер для either.

933
00:57:03,989 --> 00:57:11,061
Вот. Ну и какой-то пример
того, как это можно использовать.

934
00:57:11,210 --> 00:57:14,965
То есть, фу кидает монад error, фу

935
00:57:15,007 --> 00:57:19,041
error, бар кидает монад
error, бар error, баз монад

936
00:57:19,041 --> 00:57:25,651
error, баз error. Где баз
эррор, это комбинация.

937
00:57:25,693 --> 00:57:31,861
Теперь вы можете применить
их оба, просто в базе вы должны

938
00:57:31,861 --> 00:57:34,533
без accept, то есть вы
здесь с каждым конкретным

939
00:57:34,575 --> 00:57:37,458
этим случаем ловите ошибку,
которая здесь вылетает,

940
00:57:37,540 --> 00:57:45,421
комбинируете их как-то,
справляетесь с ними, как-то и

941
00:57:45,464 --> 00:57:54,881
передаете дальше. Окей, значит,
да. Собственно к вопросу о том,

942
00:57:55,600 --> 00:57:58,681
что зачем нужны MTL,
MTL вот эти монад что-то

943
00:57:58,723 --> 00:58:02,401
позволяют обходить вот эту вот
проблему множественных лифтов.

944
00:58:02,600 --> 00:58:05,825
Это, кстати, реальный production code.

945
00:58:05,868 --> 00:58:08,778
Когда-то у Серокеля было вот
такое. Да, мы им не гордимся,

946
00:58:11,760 --> 00:58:14,041
но когда нужно было что-то
быстро написать, ребята

947
00:58:14,084 --> 00:58:16,221
написали это вот так
вот. Здесь сколько? Самое

948
00:58:16,221 --> 00:58:20,248
большое я здесь вижу,
сколько здесь? Восемь лифтов.

949
00:58:20,290 --> 00:58:25,021
Ну типа не надо так использовать MTL и она

950
00:58:25,021 --> 00:58:30,233
позволяет вот это все дело
сократить. Единственное,

951
00:58:30,275 --> 00:58:34,601
что возникает, собственно,
проблема n на m инстансов.

952
00:58:34,601 --> 00:58:37,584
Что если у вас есть n монад и m type

953
00:58:37,626 --> 00:58:41,101
классов, вам нужно написать
n на m монадных инстансов.

954
00:58:41,440 --> 00:58:44,887
Хотя, как мы уже заметили,
большинство из этих

955
00:58:44,930 --> 00:58:49,101
инстансов они совершенно
тривиальны. Поэтому MTL есть с

956
00:58:49,101 --> 00:58:52,990
помощью вот этих вот
экстеншенов. Вы можете задеривить

957
00:58:53,033 --> 00:58:56,381
просто монад что-то,
если инстанс тривиальный.

958
00:58:57,620 --> 00:59:00,140
То есть у вас условно
ридер внутри есть, можете

959
00:59:00,182 --> 00:59:02,961
задерить монад ридер по
environment. State my state

960
00:59:03,010 --> 00:59:09,827
есть, монад стоит за деревелью,
есть монад за деревелью.

961
00:59:09,870 --> 00:59:15,871
Понятно? Да. Замечу, что
вот это тоже очень часто

962
00:59:15,871 --> 00:59:20,437
техника, чтобы не
таскать за собой гигантские

963
00:59:20,480 --> 00:59:24,371
трансформеры, вот такие вот. Обычно их

964
00:59:24,371 --> 00:59:29,490
либо оборачивают в new type. Почему в new
type? Потому что есть экстеншен New Type

965
00:59:29,491 --> 00:59:34,890
деревень, который позволяет New
Type деревень делать очень просто.

966
00:59:36,270 --> 00:59:38,688
Он, по сути, разворачивает
New Type и говорит, что я

967
00:59:38,730 --> 00:59:41,631
определяю инстанс вот этой штуки для New

968
00:59:41,730 --> 00:59:45,247
Type, так же как для
того, что внутри него.

969
00:59:45,289 --> 00:59:49,271
И по этой причине у вас эта
штука вообще будет очень

970
00:59:49,271 --> 00:59:51,023
легко работать, потому
что у вас деревень в этом

971
00:59:51,065 --> 00:59:52,971
случае просто развернет
эмку, посмотрит, ага, у вас

972
00:59:52,971 --> 00:59:55,029
ридер, ну как определенно
монад ридер для ридера, ну вот так.

973
00:59:55,071 --> 00:59:57,128
Как монад стей для ридера
определен, ну вот так.

974
00:59:57,210 --> 00:59:59,903
Как монад эо для ридера
определен, ну вот так.

975
00:59:59,946 --> 01:00:02,859
И все. И определить их автоматически.

976
01:00:03,865 --> 01:00:09,140
Вот. Либо еще, ну тогда
можно совсем тупо, если

977
01:00:09,183 --> 01:00:15,291
typewise просто использовать.
Вот. Да. Соответственно,

978
01:00:15,430 --> 01:00:19,665
теперь у вас, может, такие вот вещи можно

979
01:00:19,708 --> 01:00:23,491
превратить вообще вот в
это. Можно еще круче пойти.

980
01:00:23,491 --> 01:00:27,098
Можно сказать, что у нас
здесь вообще-то не environment

981
01:00:27,140 --> 01:00:30,491
просто, да, а у меня
какой-то has environment

982
01:00:32,410 --> 01:00:35,891
класс переменная. Вот. То
есть, что мы не обязательно

983
01:00:35,933 --> 01:00:38,791
должны чистый environment
всегда доставать.

984
01:00:38,810 --> 01:00:43,151
Мы можем доставать больше, просто мы должны
уметь из-за этого получать environment.

985
01:00:43,151 --> 01:00:45,963
Тогда вообще становится
все полиморфно, даже утер.

986
01:00:46,006 --> 01:00:48,741
То есть мы буквально всегда
можем кидать любые аргументы,

987
01:00:49,110 --> 01:00:51,205
любые, делать эти
вычисления в любой монаде, и

988
01:00:51,248 --> 01:00:53,431
он все равно будет
работать. Главное, чтобы

989
01:00:53,431 --> 01:00:56,265
вот это вот констринты были удовлетворены.

990
01:00:56,308 --> 01:00:59,011
И эта штука может реально
разрастаться. То есть у меня было

991
01:00:59,011 --> 01:01:01,529
такое, что у меня там
штук 40 констринтов в

992
01:01:01,571 --> 01:01:04,130
один момент получилось,
там бага, это почти

993
01:01:05,030 --> 01:01:09,756
апогенережка была. Вот.
Можно еще раз? Зачем

994
01:01:09,798 --> 01:01:14,891
нам здесь has environment
делать? Почему это не

995
01:01:14,891 --> 01:01:18,356
оборачивается в monadreader?
Почему-то не сделать его

996
01:01:18,398 --> 01:01:21,971
частью ответственности?
Смотрите, объясняю.

997
01:01:21,971 --> 01:01:25,004
Что делает monadreader?
Monadreader позволяет вам получить

998
01:01:25,047 --> 01:01:27,991
какой-то environment,
так? Но мы здесь жестко

999
01:01:27,991 --> 01:01:30,505
прописываем, что
monadreader должен получить

1000
01:01:30,547 --> 01:01:33,451
именно environment значение.
Вместо этого, если мы

1001
01:01:33,451 --> 01:01:35,721
хотим сделать это еще
более полиморфным, мы

1002
01:01:35,764 --> 01:01:38,291
можем прописать, что у
нас monadreader на самом

1003
01:01:38,291 --> 01:01:40,831
деле здесь не environment
возвращает, а какую-то переменную k.

1004
01:01:40,874 --> 01:01:46,303
Типовую, да? И вот для этой переменной k
мы умеем делать какой-то has environment.

1005
01:01:46,346 --> 01:01:48,771
То есть environment может быть каким-то

1006
01:01:48,771 --> 01:01:54,570
подмножеством k. Просто мы
гарантируем, что мы умеем из

1007
01:01:54,571 --> 01:01:59,064
этого множества k получить вот
это подмножество environment.

1008
01:01:59,106 --> 01:02:04,331
Понятно? Это просто может быть
нужно иногда для того, чтобы вообще

1009
01:02:04,331 --> 01:02:09,233
все заполиморфить. То есть
мы еще environment могли

1010
01:02:09,275 --> 01:02:13,831
бы различные передать
в эту monad. Более-менее.

1011
01:02:17,070 --> 01:02:22,305
Так лучше на самом деле не делать.

1012
01:02:22,347 --> 01:02:27,511
То есть если вы пишете
какую-то lib, тогда да, тогда можно,

1013
01:02:27,730 --> 01:02:30,572
потому что непонятно,
кто и в каком контексте

1014
01:02:30,615 --> 01:02:33,691
будет юзать вашу
библиотечку. И там можно делать

1015
01:02:33,790 --> 01:02:35,964
все полиморфным до жути.
Вот если вы посмотрите

1016
01:02:36,006 --> 01:02:38,551
какие-нибудь хаскинговые
большие библиотеки для работы

1017
01:02:38,551 --> 01:02:44,245
с базами, с вебом, с телегой,
с андроидом, с чем угодно.

1018
01:02:44,288 --> 01:02:49,511
Вы увидите, что на самом деле большинство

1019
01:02:49,511 --> 01:02:53,667
библиотек действительно
вот так вот определено.

1020
01:02:53,710 --> 01:02:57,991
Самому такие вещи лучше не
писать. Если вы не пишете библиотеку,

1021
01:02:58,570 --> 01:03:02,390
а пишете какую-то просто функцию, то лучше
прописывайте четко monad, которые должны

1022
01:03:02,391 --> 01:03:04,859
использоваться, потому
что вы точно знаете, что вы

1023
01:03:04,901 --> 01:03:07,511
будете использовать.
И это позволит читателю

1024
01:03:07,511 --> 01:03:12,869
гораздо проще понять, что
вообще здесь вы делаете.

1025
01:03:12,912 --> 01:03:18,311
Вот это то, что мы пытались
достичь. Мы просто перечислили

1026
01:03:18,311 --> 01:03:22,149
список эффектов, которые
мы должны и хотим здесь

1027
01:03:22,192 --> 01:03:25,991
применить, и тип. Примерно
такой же у нас здесь и получилось.

1028
01:03:25,991 --> 01:03:28,204
То есть у нас перечислены все

1029
01:03:28,246 --> 01:03:30,658
эти monad что-то. Это эффект,
который мы хотим использовать.

1030
01:03:30,740 --> 01:03:36,886
А в типе она осталась
простенькой параметром.

1031
01:03:36,928 --> 01:03:46,507
Да, значит, какие паттерны стоит использовать?
Ну, Reader.io это просто классика.

1032
01:03:46,550 --> 01:03:50,301
Я об этом много рассказал.
TaglessFinal это вот

1033
01:03:50,301 --> 01:03:56,893
то, что на самом деле
это продолжение вот этой

1034
01:03:56,936 --> 01:04:04,201
вот MTL практики. Что
такое MTL? Оно позволяет

1035
01:04:04,201 --> 01:04:07,013
задавать вам эффект, который вы делаете.

1036
01:04:07,056 --> 01:04:09,850
То есть monadReader это
доступ к изменяемому окружению.

1037
01:04:10,000 --> 01:04:12,389
Давайте теперь введем
собственную monad, например

1038
01:04:12,431 --> 01:04:14,961
monadDatabase, которая
под капотом будет там тем же

1039
01:04:14,961 --> 01:04:17,595
MonadReader с иошкой,
но зато мы теперь у нее

1040
01:04:17,637 --> 01:04:20,610
определяем, что у нас есть
какой-то monadDatabase,

1041
01:04:20,705 --> 01:04:23,224
который позволяет вам
получить юзера или дайвить

1042
01:04:23,267 --> 01:04:26,041
юзера, например. Или
сделать запрос с connection там

1043
01:04:26,041 --> 01:04:29,405
или еще что-нибудь такое.
Это нужно, чтобы достать

1044
01:04:29,447 --> 01:04:32,921
детали реализации того, как вы
там в базу ходите на самом деле.

1045
01:04:32,921 --> 01:04:36,488
И при этом, соответственно, использовать

1046
01:04:36,530 --> 01:04:39,861
этот monadDatabase в
любом контексте, независимо

1047
01:04:39,960 --> 01:04:47,641
от того, как мы реально
хотим в эту базу ходить.

1048
01:04:47,683 --> 01:04:56,371
Понятно? То есть, вот
смотрите, у вас здесь есть AppM,

1049
01:04:58,390 --> 01:05:01,450
который ходит, видимо, в реальную
базу, потому что у него есть TO.

1050
01:05:01,492 --> 01:05:04,531
Есть TestM, который на самом деле

1051
01:05:04,805 --> 01:05:07,735
просто хранит каких-то
юзеров, но их как-то меняет

1052
01:05:07,778 --> 01:05:10,512
в зависимости от действия,
которое вы делаете.

1053
01:05:13,210 --> 01:05:16,191
И, соответственно, в
зависимости от того, что

1054
01:05:16,234 --> 01:05:19,391
вы хотите использовать
функцию в реальности или

1055
01:05:19,690 --> 01:05:22,379
в тестовом окружении, вы
подменяете монаду внутреннюю.

1056
01:05:22,421 --> 01:05:25,931
Ну и, соответственно, в одной из них у вас

1057
01:05:25,931 --> 01:05:29,505
идет вычисление. Как-то.
Я об этом, кстати, говорил

1058
01:05:29,548 --> 01:05:32,951
на самом начале. У нас
было в Sirocco, например,

1059
01:05:33,500 --> 01:05:37,983
там другая ситуация. У нас
была библиотечка для работы

1060
01:05:38,025 --> 01:05:42,131
с блокчейн-сетью, и вот
мы хотим, соответственно,

1061
01:05:44,565 --> 01:05:46,916
мы хотим какие-то вещи
протестить, но проблема, что

1062
01:05:46,959 --> 01:05:49,351
протестить их на реальной
блокчейн-сети, там каждая

1063
01:05:49,351 --> 01:05:51,683
операция выполняется 30
секунд реального времени.

1064
01:05:51,726 --> 01:05:54,148
Вот просто constraint
такой стоит. Соответственно,

1065
01:05:54,230 --> 01:05:56,175
любой тест у вас будет
выполняться 30 умножить

1066
01:05:56,218 --> 01:05:58,291
на количество операций, которые
вы хотите в этом тесте сделать.

1067
01:05:58,291 --> 01:06:01,345
Что мы сделали? Мы ввели два environment.

1068
01:06:01,388 --> 01:06:05,131
Один для продуктовой сети, в которой мы

1069
01:06:05,131 --> 01:06:07,369
можем, соответственно, использовать эти же

1070
01:06:07,412 --> 01:06:09,691
функции, но, блин, да, они
будут требовать времени.

1071
01:06:09,691 --> 01:06:12,923
И другой для тестовой сети,
в которой каждая операция

1072
01:06:12,966 --> 01:06:16,611
выполняется одну секунду.
И чтобы не переписывать

1073
01:06:16,611 --> 01:06:20,069
каждую функцию под
разные контексты, мы просто

1074
01:06:20,112 --> 01:06:23,231
написали функции один раз, функции такие,

1075
01:06:23,231 --> 01:06:27,471
к которым мы можем
передавать вот этот вот паттерн

1076
01:06:27,513 --> 01:06:32,051
того, где мы хотим
использовать эту функцию.

1077
01:06:38,670 --> 01:06:44,276
Понятно? Да. То есть, грубо
говоря, если в Java мы создаем

1078
01:06:44,318 --> 01:06:50,081
интерфейс блокчейн и две
реализации. Это интерфейс

1079
01:06:50,081 --> 01:06:54,081
аквас реализации, и передаем
в приложение объекты,

1080
01:06:54,124 --> 01:06:57,761
которые реализуют
интерфейс тестовой блокчейн

1081
01:06:57,785 --> 01:07:01,881
и приложение веб-блокчейн.
Здесь мы определяем

1082
01:07:01,924 --> 01:07:06,601
сразу типы тестовой блокчейн
и нормальный блокчейн и

1083
01:07:06,720 --> 01:07:16,894
передаем типы, не экземпляры. Да. Хорошо.

1084
01:07:16,936 --> 01:07:27,741
Экземпляры вы создаете,
соответственно, потом, когда хотите что-то

1085
01:07:27,741 --> 01:07:31,016
в этом типе, оно будет
эти операции выполнять

1086
01:07:31,058 --> 01:07:34,301
следующим образом. А
интерфейс в этом случае

1087
01:07:34,301 --> 01:07:37,604
создает то, что вы, в принципе,
можете выполнять эти операции.

1088
01:07:37,646 --> 01:07:41,441
То есть, в данном случае,
вот этот monad-датабейс

1089
01:07:41,441 --> 01:07:44,979
это интерфейс, apm и tstem
это конкретная реализация

1090
01:07:45,021 --> 01:07:47,981
этого интерфейса, а
вот когда вы запустите,

1091
01:07:47,981 --> 01:07:55,465
вы уже передаете конкретный экземпляр.
Хорошо. Вот, что делать не стоит.

1092
01:07:55,508 --> 01:08:02,791
Трансформер с PLUS.io,
не совсем правильно назвал,

1093
01:08:02,850 --> 01:08:08,748
трансформер, очевидно,
можно использовать с

1094
01:08:08,790 --> 01:08:14,591
EO, потому что вы не можете выбирать того,

1095
01:08:14,690 --> 01:08:17,205
чтобы использовать трансформер
с EO. Однако, чего делать не стоит.

1096
01:08:17,248 --> 01:08:19,531
Значит, по-самому не стоит комбинировать

1097
01:08:19,531 --> 01:08:24,059
EXCEPT с EO и STATE с EO,
можно комбинировать, просто

1098
01:08:24,102 --> 01:08:28,671
очень аккуратно. Почему?
Потому что в этом случае EO,

1099
01:08:28,690 --> 01:08:31,108
как я уже говорил, имеет очень
забавное и неприятное свойство,

1100
01:08:31,151 --> 01:08:33,531
оно вообще ломает нафиг все
вычисления и говорит, что, типа,

1101
01:08:33,570 --> 01:08:37,206
я вот выбросил ошибку, иди ее
там где-то лови. Все, что должно

1102
01:08:37,249 --> 01:08:40,630
произойти дальше по вычислениям,
у меня не особо волнует.

1103
01:08:40,930 --> 01:08:43,827
Вот. По этой причине, во-первых,
то, что у вас должно вылететь

1104
01:08:43,869 --> 01:08:46,571
как EXCEPT, вылетает
как EO, ну, соответственно,

1105
01:08:46,571 --> 01:08:49,749
понятно, что смысла в
этом вообще не много.

1106
01:08:49,791 --> 01:08:53,511
Потому что EXCEPT нужно для
того, чтобы мягко схендлить ошибку,

1107
01:08:54,370 --> 01:08:58,266
EO выкидывает ошибки жестко. Их
комбинация, ну, очевидно, будет кидать

1108
01:08:58,308 --> 01:09:01,908
ошибки жестко, и больше ничего
вам для этого вычисления не дает.

1109
01:09:01,990 --> 01:09:05,860
Используйте либо одно из них,
либо другое. STATE T плюс EO, тут та

1110
01:09:05,903 --> 01:09:09,874
же проблема, что с EXCEPT и STATE,
на самом деле, мы сейчас увидим,

1111
01:09:09,960 --> 01:09:18,084
что STATE в этом случае может
сломаться. В плане не сам STATE, а в плане

1112
01:09:18,126 --> 01:09:26,291
STATE, который вы передаете, он
может откатиться к начальному состоянию,

1113
01:09:27,370 --> 01:09:29,884
а может не откатиться.
То есть вы не можете

1114
01:09:29,927 --> 01:09:33,136
зафиксировать STATE на том
месте, где вылетела ошибка.

1115
01:09:34,340 --> 01:09:39,990
Потому что она вылетевшая ошибка не
дает правильно этот STATE похендлить.

1116
01:09:47,170 --> 01:09:52,630
Ну, собственно, то, что там кто-то из вас
говорил на тему порядка комбинации монад.

1117
01:09:55,645 --> 01:10:01,806
Вот у нас, допустим, есть
READER T, EXCEPT T, STATE T.

1118
01:10:01,849 --> 01:10:08,051
Это все нормально работает, это
тоже работает, но немножко по-другому.

1119
01:10:08,230 --> 01:10:13,114
Почему? Потому что... А,
сейчас, в обоих случаях EXCEPT

1120
01:10:13,157 --> 01:10:18,351
над STATE, предположим, что у
нас был бы STATE над EXCEPT.

1121
01:10:18,550 --> 01:10:24,900
То есть поменяем местами EXCEPT и STATE. В
этом случае, в одном из этих случаев, у вас

1122
01:10:24,942 --> 01:10:31,631
произойдет то, что я описывал только, что
вылетевшая ошибка, она прервет вычисление STATE,

1123
01:10:32,960 --> 01:10:41,171
и вы в результате получите начальный STATE,
который вы передавали, и ошибку саму.

1124
01:10:42,380 --> 01:10:45,224
В другом случае, я сейчас
не помню, какой из них

1125
01:10:45,266 --> 01:10:48,091
какой, скину вам потом
в чат конкретный пример.

1126
01:10:49,795 --> 01:10:56,012
В другом случае, у вас вылетевшая ошибка не прервет
вычисление, и вы в результате все равно берете

1127
01:10:56,054 --> 01:11:02,951
результат, который ошибка, плюс какой-то STATE, который
посчитался до того момента, пока ошибка не вылетела.

1128
01:11:04,700 --> 01:11:07,810
То есть, если у вас...

1129
01:11:09,940 --> 01:11:12,327
Сейчас, ладно, я не беру
стражащихся, потому что, по-моему,

1130
01:11:12,370 --> 01:11:14,428
в каком-то из них порядка
не должна при этом быть.

1131
01:11:14,510 --> 01:11:15,510
Понятно примерно?

1132
01:11:18,045 --> 01:11:20,952
Можно задать вопрос, может, глупый.

1133
01:11:20,995 --> 01:11:24,231
Зачем UNIT на конце
объявления, на конце сигнатуры?

1134
01:11:24,231 --> 01:11:27,101
В смысле, у вас же в каждой
сигнатуре должно быть

1135
01:11:27,144 --> 01:11:30,115
возвращаемое значение,
тип возвращаемого значения.

1136
01:11:30,555 --> 01:11:32,290
То есть, в этом случае у вас что?

1137
01:11:32,350 --> 01:11:35,990
EXCEPT принимает на вход A
ошибку, которую она может кидать.

1138
01:11:36,710 --> 01:11:45,130
B это монада, которая будет
внутренняя монада трансформера.

1139
01:11:45,710 --> 01:11:48,547
А последний аргумент всегда
это возвращаемое значение.

1140
01:11:48,630 --> 01:11:53,454
Но у вас это возвращаемое значение, но в
данном случае, видимо, никого не волнует.

1141
01:11:53,550 --> 01:11:54,910
Но его же надо перечислить в какой-то тип.

1142
01:11:54,911 --> 01:12:00,830
Обычно возвращают той
тип, который вводит в плюсах.

1143
01:12:02,630 --> 01:12:04,637
Или в джави, или где-то в этом типе.

1144
01:12:04,720 --> 01:12:06,270
Да, много где.

1145
01:12:09,095 --> 01:12:10,860
Не совсем, на самом
деле, потому что с вайдом

1146
01:12:10,902 --> 01:12:12,708
можно, кажется, жуткие
вещи творить в плюсах,

1147
01:12:12,790 --> 01:12:17,320
а вот в хаскере это просто обозначает
того, что функции ничего не возвращают.

1148
01:12:18,880 --> 01:12:21,882
Если EXCEPT принимает
три аргумента, то там в

1149
01:12:21,925 --> 01:12:25,171
определении FULL, похоже,
скобочки не там стоят.

1150
01:12:27,930 --> 01:12:29,090
Сейчас, вот тут?

1151
01:12:30,430 --> 01:12:31,263
Да.

1152
01:12:31,910 --> 01:12:34,030
Нет, здесь все правильно.

1153
01:12:36,010 --> 01:12:36,843
Смотрите.

1154
01:12:43,290 --> 01:12:49,790
Можно в гугл-презентации уже прикрутить
джамборд, чтобы мог показывать это дело.

1155
01:12:58,665 --> 01:13:00,867
И нам все еще только презентацию видно.

1156
01:13:00,950 --> 01:13:04,027
Да, сейчас, подождите, у
меня просто компьютер тупит.

1157
01:13:04,110 --> 01:13:19,050
О! Видно? Отлично.

1158
01:13:21,550 --> 01:13:23,270


1159
01:13:24,170 --> 01:13:26,053
Можно описывать, какая прелесть.

1160
01:13:37,680 --> 01:13:42,220
В чем-то был вопрос о скобках EXCEPT.

1161
01:13:43,550 --> 01:13:44,903
Значит, что происходит?

1162
01:13:58,540 --> 01:13:59,423
Что происходит?

1163
01:13:59,970 --> 01:14:06,290
У вас тип большинства трансформеров
выглядит следующим образом.

1164
01:14:07,110 --> 01:14:09,630
Это типа NAME.

1165
01:14:13,710 --> 01:14:16,350
Значит, давайте-ка я...

1166
01:14:16,450 --> 01:14:18,509
Ой, какое жуть, какое запаздывание.

1167
01:14:22,340 --> 01:14:23,760
Типы большинства
трансформеров выглядят так.

1168
01:14:23,840 --> 01:14:26,460
NAME, R, M, A.

1169
01:14:28,280 --> 01:14:31,680
R где-то какое-нибудь state,
environment или exception.

1170
01:14:32,240 --> 01:14:35,299
M это внутренняя монада, а
A возвращаемого значения.

1171
01:14:40,560 --> 01:14:41,393
Смотрите.

1172
01:14:43,300 --> 01:14:44,830
Внутри должна быть монада.

1173
01:14:45,160 --> 01:14:46,320
Что такое монада?

1174
01:14:47,895 --> 01:14:49,337
Что такое монада, понятно.

1175
01:14:49,420 --> 01:14:54,304
Но самое главное, монада это класс, который
получает на вход один типовой аргумент.

1176
01:14:56,260 --> 01:14:59,517
Забегая вперед, у этой штуки
есть такая штука как COUNT.

1177
01:14:59,600 --> 01:15:00,700
И у него следующее.

1178
01:15:00,760 --> 01:15:03,860
Звездочка, стрелка,
звездочка, стрелка, звездочка,

1179
01:15:06,740 --> 01:15:07,573
звездочка,

1180
01:15:09,620 --> 01:15:10,453
звездочка, звездочка.

1181
01:15:11,600 --> 01:15:12,433
Мак rated 2.

1182
01:15:20,090 --> 01:15:20,923


1183
01:15:21,025 --> 01:15:26,010
То есть, есть эта монада, она
получает на вход типовой параметр,

1184
01:15:26,130 --> 01:15:28,425
который не принимает других аргументов,

1185
01:15:28,670 --> 01:15:31,427
типовой параметр, который
принимает один аргумент,

1186
01:15:31,510 --> 01:15:33,527
типовой параметр, который
не принимает аргументов.

1187
01:15:33,610 --> 01:15:35,350
И она получает собственно...

1188
01:15:37,110 --> 01:15:41,855
Поэтому M в этом случае должно быть что-то,
что еще должно принимать один аргумент.

1189
01:15:42,220 --> 01:15:44,573
Теперь посмотрим обратно на презентацию.

1190
01:15:45,720 --> 01:15:50,505
У вас ридер t с первым аргументом, с
третьим аргументом, с вторым аргументом

1191
01:15:50,548 --> 01:15:55,311
и с третьим аргументом не принимает
больше никаких типовых аргументов, так?

1192
01:15:56,490 --> 01:15:57,323
Вот.

1193
01:15:57,570 --> 01:16:01,547
Эксцепт работает точно так же. Эксцепт
с тремя аргументами не принимает других

1194
01:16:01,590 --> 01:16:05,608
аргументов, а нам нужно что-то, что еще
один типовой аргумент будет принимать.

1195
01:16:05,690 --> 01:16:08,912
Поэтому здесь эксцепт t, r,
у него два только аргумента

1196
01:16:08,955 --> 01:16:12,397
определены, а третий, он на
самом деле вот отсюда берется.

1197
01:16:12,790 --> 01:16:13,730
Понял. Спасибо.

1198
01:16:14,080 --> 01:16:17,990
Это на самом деле причина,
почему у вас монада она в центре.

1199
01:16:19,970 --> 01:16:22,648
Ну то есть она в центральном
аргументе. Чтобы вы могли

1200
01:16:22,690 --> 01:16:25,208
их вот так вот комбинировать,
было удобнее просто.

1201
01:16:25,290 --> 01:16:27,232
Короче, это частичное применение.

1202
01:16:27,470 --> 01:16:28,550
Да, буквально.

1203
01:16:29,470 --> 01:16:32,694
Я еще буду вам читать одну
лекцию, вот где мы подробнее

1204
01:16:32,737 --> 01:16:35,824
рассмотрим, как это
происходит с точки зрения типов.

1205
01:16:36,050 --> 01:16:40,698
Мне интересно, сколько туда придет людей,
потому что рекорд пока шесть человек.

1206
01:16:43,770 --> 01:16:49,651
Да, то есть это частичное применение,
поэтому здесь отсутствует последний аргумент.

1207
01:16:49,890 --> 01:16:50,723
Еще вопросы? Пока вроде нет.

1208
01:16:56,110 --> 01:16:57,130
Окей.

1209
01:16:58,030 --> 01:16:58,863


1210
01:17:00,210 --> 01:17:01,446
Да, соответственно...

1211
01:17:02,060 --> 01:17:03,413
Неужели кто-то решил...

1212
01:17:04,070 --> 01:17:04,903
А, все, окей.

1213
01:17:06,250 --> 01:17:09,133
Это сколько?
Я буду сам в себе читать лекцию, да?

1214
01:17:11,050 --> 01:17:11,883
Да.

1215
01:17:12,710 --> 01:17:13,828
Соответственно, да.

1216
01:17:19,370 --> 01:17:20,723
Не думаю, что это ваше.

1217
01:17:21,690 --> 01:17:22,607
А получается, да?

1218
01:17:22,690 --> 01:17:26,455
А вы знаете, как мы можем правильно
использовать эту информацию?

1219
01:17:28,150 --> 01:17:37,370
Да, хорошо, ну вы понимаете.

1220
01:17:37,371 --> 01:17:38,970
Значит, если вы не
знаете, то лучше почитать.

1221
01:17:38,971 --> 01:17:39,030
Да, ну можно, конечно.

1222
01:17:39,031 --> 01:17:39,476
То, что я показывал, вот, я прям, ну сюда

1223
01:17:39,518 --> 01:17:40,028
стремился, пока я не
мог на них расстаться.

1224
01:17:40,110 --> 01:17:43,490
Это, можно сказать, та как я и делал... Я!

1225
01:17:43,491 --> 01:17:48,074
вот это вот добавление нескольких различных
эффектов к вашим вычислениям, к вашей

1226
01:17:48,116 --> 01:17:52,683
функции. Есть еще несколько способов
справиться с этой проблемой, на самом деле,

1227
01:17:52,765 --> 01:17:57,990
и, признаюсь честно, с того, что я слышал на
докладах, на самом деле, Monad Transformers,

1228
01:17:58,033 --> 01:18:02,708
их очень тяжело на продакшен применить
эффективно. Есть более эффективные вещи.

1229
01:18:04,310 --> 01:18:07,533
Но, однако, они самые простые
для понимания, потому что

1230
01:18:07,576 --> 01:18:10,900
все, что остальное, это Free
Monads, они сложнее сильно.

1231
01:18:13,510 --> 01:18:17,148
Вот, собственно, Free Monads позволяют вам,
на самом деле, делать вот что-то такое.

1232
01:18:17,230 --> 01:18:21,767
То есть вы просто перечисляете вычисления,
а потом просто перечисляете эффекты.

1233
01:18:21,850 --> 01:18:24,850
Да, и это мема из 2000,
я даже не знаю какого.

1234
01:18:25,690 --> 01:18:27,747
Не знаю, кто-нибудь
шарит за этот мем или нет.

1235
01:18:27,830 --> 01:18:30,242
Мне просто интересно, насколько я старый.

1236
01:18:33,320 --> 01:18:34,153
Капец.

1237
01:18:37,820 --> 01:18:38,653
Господи.

1238
01:18:39,430 --> 01:18:41,900
Так, ладно, презентацию нужно обновлять.

1239
01:18:43,700 --> 01:18:44,533
Молодые.

1240
01:18:47,260 --> 01:18:48,093
Вот.

1241
01:18:50,470 --> 01:18:52,740
Соответственно, что у вас получается?

1242
01:18:53,180 --> 01:18:56,973
Это выглядит, как реально
может хаскельный код выглядеть,

1243
01:18:57,016 --> 01:19:00,581
когда у вас здесь вот эти
эффекты просто перечислены.

1244
01:19:01,130 --> 01:19:04,306
Это вот то самое Free
Monads, еще куча всего, что

1245
01:19:04,349 --> 01:19:07,501
мы будем изучать на той
лекции, которая жесткая.

1246
01:19:09,540 --> 01:19:10,373
Вот.

1247
01:19:10,600 --> 01:19:11,433
Да.

1248
01:19:11,650 --> 01:19:13,827
Собственно, это все по трансформерам.

1249
01:19:14,890 --> 01:19:18,011
На следующей лекции у вас, по-моему,
лекций не будет, по-моему, у вас

1250
01:19:18,053 --> 01:19:21,261
будет практика, где вы просто можете
посидеть и разбирать эти задачки.

1251
01:19:21,261 --> 01:19:25,020
На следующей трансформере
я очень советую понять.

1252
01:19:25,360 --> 01:19:30,503
Потому что, блин, это настолько основа, что
любой код, который хотите записать более-менее,

1253
01:19:30,546 --> 01:19:35,218
чем однострочный, он, скорее всего, будет
трансформером в том или ином виде юзать.

1254
01:19:35,300 --> 01:19:37,712
И сейчас у вас есть время задать вопросы.

1255
01:19:42,420 --> 01:19:43,832
Вы шарите из-за домашки?

1256
01:19:45,500 --> 01:19:49,620
В каком-то смысле да, я
же отвечаю за их проверку.

1257
01:19:51,880 --> 01:19:55,879
Ну просто, я думаю, я уже
начал писать домашку без

1258
01:19:55,921 --> 01:19:59,961
использования монад. А
какая у вас домашка сейчас,

1259
01:20:00,510 --> 01:20:03,131
давайте посмотрим. Там просто
порядок немножко изменили.

1260
01:20:03,173 --> 01:20:06,241
Вот вы спрашивали про
парсер, и на самом-то

1261
01:20:06,241 --> 01:20:09,925
деле домашка-то про
парсер, на самом-то деле,

1262
01:20:09,967 --> 01:20:13,941
потому что у нас клипон,
что и является отчасти,

1263
01:20:15,610 --> 01:20:19,082
если так, в упрощенном
формате. А, нет, сейчас,

1264
01:20:19,124 --> 01:20:23,161
подождите, у вас сейчас задачка
нет. Про деревья у вас уже была? Была.

1265
01:20:23,161 --> 01:20:34,621
У нас сейчас одна из задач — это сделать
рисинг по строке, по символу. Ну, хорошо.

1266
01:20:35,220 --> 01:20:40,662
Вот, думаю, как бы прикрутить
сюда парсер. Ну, смотрите,

1267
01:20:40,704 --> 01:20:46,481
нет, подождите, в этой задаче...
Это какой, таск-3? Таск-2.

1268
01:20:49,490 --> 01:20:53,025
Homework-2, таск-2, да?
Да. Ну, окей, здесь вам

1269
01:20:53,068 --> 01:20:56,721
не нужно никаких монад
использовать, более того,

1270
01:20:56,845 --> 01:20:58,631
домашке вообще вам не
нужно использовать никаких

1271
01:20:58,674 --> 01:21:00,578
монад, здесь можно
справиться только исключительно

1272
01:21:00,660 --> 01:21:04,972
всякими фолдами, траверсалами и так далее.

1273
01:21:05,015 --> 01:21:09,281
Хорошо, да, ну, то есть,
высший порядок функция.

1274
01:21:09,360 --> 01:21:13,280
Надеюсь, будет сказано, когда надо
применять монады, чтобы можно было.

1275
01:21:13,322 --> 01:21:17,041
Я вам так скажу, там по монадам...

1276
01:21:18,060 --> 01:21:20,941
Короче, смотрите, когда у
вас будет задание на конкретно

1277
01:21:20,984 --> 01:21:23,698
гигантский парсер, а оно
будет, мы его, к сожалению,

1278
01:21:23,780 --> 01:21:26,169
так и не распилили, вот там
прям можете использовать

1279
01:21:26,211 --> 01:21:28,361
вообще, бомбардировать
всем, чем только можно,

1280
01:21:28,361 --> 01:21:31,250
там и gdt можно использовать,
и надо даже использовать, но

1281
01:21:31,292 --> 01:21:34,121
мы их еще не проходили, там
монады можно поиспользовать,

1282
01:21:34,200 --> 01:21:37,759
какие-нибудь всякие стейты и так
далее, вот, там уже на свое усмотрение.

1283
01:21:37,801 --> 01:21:41,221
Здесь пока что вам
хватает всякой банальщины.

1284
01:21:43,140 --> 01:21:48,846
Трансформеры, тем более,
точно нужно применять.

1285
01:21:48,888 --> 01:21:54,861
Еще вопросы? В этом плане
волнует ситуация, когда кажется

1286
01:21:55,010 --> 01:21:57,586
хватает всякой банальщины,
пишешь банальщину, и

1287
01:21:57,628 --> 01:22:00,301
потом боюсь на ревью
получить вердикт, что здесь

1288
01:22:00,301 --> 01:22:04,925
можно было проще, а потом куча
непонятных букв, символов и подобных

1289
01:22:04,967 --> 01:22:09,841
монописных штук. Давайте так, к
моменту, когда вы уже на эту домашнюю,

1290
01:22:10,020 --> 01:22:14,257
насколько я помню, вы еще
монады не прошли. Или прошли.

1291
01:22:14,300 --> 01:22:18,361
Да, не суть. Суть в том, что,
типа, здесь раньше эта домашня

1292
01:22:18,361 --> 01:22:21,743
давалась еще до того, как
люди проходили монады, поэтому

1293
01:22:21,785 --> 01:22:24,781
будьте спокойны, вам
никто не скажет на вердикте,

1294
01:22:24,781 --> 01:22:30,078
что все хреново, потому
что вы можете сделать проще.

1295
01:22:30,120 --> 01:22:36,221
Пишите код нормально, красиво и правильно
в плане. И вам никто ни за что не снизит.

1296
01:22:36,480 --> 01:22:38,728
То есть у меня были просто
люди, которые написали

1297
01:22:38,771 --> 01:22:41,201
откровенно так, что у них
там отступ улетает по всей

1298
01:22:41,201 --> 01:22:44,302
странице, и получается
не весь что. Ну, так не надо

1299
01:22:44,345 --> 01:22:47,241
делать, потому что за
такое точно снижать буду.

1300
01:22:47,690 --> 01:22:51,902
За более-менее красивый код,
да пожалуйста. Единственное, что,

1301
01:22:51,945 --> 01:22:56,061
пожалуйста, я не знаю, вы уже
умеете компилировать с опциями

1302
01:22:56,061 --> 01:23:02,594
VOL и VR? Полагаю, что это
не то чтобы Rocket Science.

1303
01:23:02,637 --> 01:23:09,211
Ну вот да, типа, я просто к тому, что,
короче, мне очень сильно не нравится,

1304
01:23:09,470 --> 01:23:11,454
если есть там мое мнение по
домашкам, мне очень сильно

1305
01:23:11,496 --> 01:23:13,371
не нравится, когда люди
оставляют ворнинги в коде,

1306
01:23:13,390 --> 01:23:15,418
потому что у них есть
ворнинги по типу, например,

1307
01:23:15,461 --> 01:23:17,911
non-executive pattern matching.
Это самое страшное, что вы

1308
01:23:17,911 --> 01:23:20,545
можете оставить в коде,
который вы задаете на

1309
01:23:20,588 --> 01:23:23,501
проверку, потому что за
такое бить по рукам надо.

1310
01:23:23,730 --> 01:23:27,071
Non-executive pattern
matching – это когда вы делаете

1311
01:23:27,113 --> 01:23:30,751
pattern matching, но не
определили все возможные исходы в

1312
01:23:32,290 --> 01:23:34,903
pattern matching. В этом
случае, если у вас прилетит

1313
01:23:34,945 --> 01:23:37,651
исход, который вы не обрабатываете,
у вас на рантайме все сломается.

1314
01:23:37,651 --> 01:23:44,071
Это такая проблемка, которая, к сожалению,
типа, warning, а не вообще-то error.

1315
01:23:45,120 --> 01:23:48,335
Например, в том же
росте она error вполне себе.

1316
01:23:48,377 --> 01:23:51,951
Вот, поэтому, если вы такое оставляете,

1317
01:23:52,070 --> 01:23:55,109
такое будет бить по
рукам, а за все остальное

1318
01:23:55,151 --> 01:23:58,231
– да нет, все должно быть нормально.

1319
01:24:02,700 --> 01:24:06,313
Еще вопросы? Ну, мне выдавал,
выдает ворнинг non-executive, а,

1320
01:24:06,356 --> 01:24:09,861
incomplete patterns,
тоже про pattern matching,

1321
01:24:10,040 --> 01:24:13,016
но я смотрю, что он
выдает и что не матчится,

1322
01:24:13,059 --> 01:24:15,741
и я считаю, что он категорически неправ,

1323
01:24:15,741 --> 01:24:20,889
и матчи все правят.
Ну, либо вы открыли багу

1324
01:24:20,932 --> 01:24:26,121
в компиляторе GHC,
либо вы все-таки неправы.

1325
01:24:27,340 --> 01:24:33,582
Ставлю, скорее, на второй
вариант. Вот, поэтому...

1326
01:24:33,624 --> 01:24:38,651
Ну, просто проблема, скорее, в том, что,

1327
01:24:39,370 --> 01:24:43,773
говоря про AVL-дерево,
ты же разбираешь логику и,

1328
01:24:43,816 --> 01:24:48,351
в целом, понимаешь, что какие-то
варианты не могут наступить.

1329
01:24:48,351 --> 01:24:51,305
Нет, то, что вы с точки зрения логики

1330
01:24:51,348 --> 01:24:54,031
понимаете, что варианты могут
не наступить, это похвально.

1331
01:24:54,750 --> 01:25:02,111
Но все равно, и я более вам так скажу,
скорее всего, даже наши тесты пройдут.

1332
01:25:02,111 --> 01:25:03,609
Даже наши тесты, которые
должны проверять такую штуку, они,

1333
01:25:03,652 --> 01:25:05,191
скорее всего, пройдут,
потому что, действительно,

1334
01:25:05,191 --> 01:25:08,170
с точки зрения логики такое невозможно.

1335
01:25:08,213 --> 01:25:10,871
Компилятор об этом не знает.
Поэтому рекомендую просто,

1336
01:25:11,160 --> 01:25:13,281
вот в крайнем случае,
если вам не получается

1337
01:25:13,324 --> 01:25:15,831
сделать так, чтобы вы
матчингами покрыли вообще все

1338
01:25:15,831 --> 01:25:21,879
варианты, потому что
обычно так можно сделать,

1339
01:25:21,922 --> 01:25:28,541
добавляйте в конце вот такую
штуку. Вот буквально, вообще везде.

1340
01:25:28,760 --> 01:25:40,300
Это позволяет вам ворнинг,
соответственно, нейтрализовать.

1341
01:25:40,301 --> 01:25:42,651
При этом, если вы с
помощью вашего третьего глаза

1342
01:25:42,694 --> 01:25:45,821
гарантируете, что этот
вариант никогда не наступит,

1343
01:25:45,860 --> 01:25:51,296
он никогда не вылетит. А если
вылетит, значит, вы были неправы.

1344
01:25:51,338 --> 01:25:56,511
И ворнинг там был не с краса. Такая штука,

1345
01:25:56,570 --> 01:26:01,350
если что, существует даже в продакшн-коде,
когда точно можно доказать, что не вылетит

1346
01:26:01,351 --> 01:26:05,169
здесь такого варианта.
Вообще, по-хорошему, либо

1347
01:26:05,212 --> 01:26:08,911
покрывать все, либо не
делать по-другому, чем.

1348
01:26:11,000 --> 01:26:19,174
Еще вопросы? Тогда останавливаю запись.

1349
01:26:19,216 --> 01:26:26,281
На сегодня все. Или так,
например. Месседж любой какой

1350
01:26:26,281 --> 01:26:28,259
хотите, который означает,
что какого-то черта оно

1351
01:26:28,302 --> 01:26:30,321
дошло до части, до которой
оно вообще доходить не должно.

1352
01:26:30,321 --> 01:26:44,770
Все. На сегодня тогда все.
Спасибо. Всего доброго. До свидания.

