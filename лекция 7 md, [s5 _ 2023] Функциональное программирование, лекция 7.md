# Text

Итак, сегодня мы будем проходить что такое монадные трансформеры, и это одна из самых основных техник Хаскеля, которая используется повсеместно. В чем, собственно, проблема, которую мы сегодня будем проходить? Давайте начнем с повторения небольшого. Что такое монада? Вы должны были изучать на прошлом занятии, что монада это некоторый способ показать, что определенный код использует определенный эффект. То есть, что, например, если вы пишете в шапке функции, что у вас действие происходит в монаде райтера, вы как бы добавляете к тому, что вы можете делать здесь, запись в какой-то моноидальный аккумулятор или просто лоб. Ридер, соответственно, добавляет вам какой-то неизменяемый контекст, ну и так далее.

То есть, забавно, но если вы посмотрите на любой язык программирования OOP, то вы увидите, что там тоже самое есть, просто оно включено по базе. То есть, вы, находясь в любом месте, можете делать какой-нибудь лог, какой-нибудь стейт хранить, еще какой-нибудь его писать. В Haskell'е эти все эффекты нужно подключать по отдельности. Почему? Потому что, во-первых, чтобы избавиться от мусора, во-вторых, потому что можно построить оптимизацию на том, что у вас не все эффекты используются. Самый банальный пример – это чистые функции, которые без I.O.

, соответственно, можно оптимизировать на этапе компиляции. А теперь задача. Мы хотим применить несколько эффектов к нашей функции. То есть, грубо говоря, стимулировать несколько монад. Значит, вот то, что вы проходили на предыдущих лекциях, вот у вас есть Reader.

То есть, у вас есть какой-то environment, который вы не хотите передавать переменно, вы передаете его в монаде Reader. А теперь я хочу, чтобы у меня был эффект ридера и стейта. Самый банальный пример, который здесь можно привести, например, вы пишите какую-нибудь игрушку. И вот в этой игрушке у вас есть какой-нибудь, не знаю, давайте возьмем, например, шахматы. И вот у вас есть стейт в виде положения ее фигур на поле.

То есть, сам стейт игры. И Reader, который отвечает, например, за какую-нибудь отрисовку, за параметры поля. Не знаю, выходите вы доску на клетки, а там на 128. Я хочу скомбинировать, соответственно, эффекты неизменяемого окружения и изменяемого стейта. Как я могу что-то подобное сделать? Какие есть идеи? Тапл.

Сделать тапл из двух вещей, из двух монад. Это плохая идея. Почему? Потому что вы тогда теряете преимущество обоих. То есть, вы теряете возможность оперировать внутри монады. В этом случае вы теряете преимущество обоих.

Вы не получаете преимущество двух, вы теряете преимущество обеих. Еще варианты? Извините, но можно сделать полный экран? Можно, но тогда я не смогу переключаться. А, нет, смогу, все хорошо. Спасибо. Еще идея? Есть у кого-нибудь? Монады над монадой.

Это финальное решение, не совсем в таком виде, и мы пройдем его чуть дальше. Если вы попробуете просто использовать монаду в качестве… то есть, написать условно там «reader environment» в скобочках «state» от «a», вы получите преимущество «reader», вы все еще не получите преимущество «state» от «a». У вас будет «state», который нужно будет как-то разворачивать, что, честно, будет… То есть, грубо говоря, каждый раз, когда вы хотите дернуть что-то «state»овое, вам нужно будет «run state» использовать. Передавать ему «state», но это не позволит сохранить «state» на протяжении всего вычисления. Еще варианты? Хорошо, давайте немножко упростим задачу.

Хотим чисто «reader», хотим просто, чтобы у нас был «environment» и «state». Неважно, там мутабельное, не мутабельное. Ну ладно, черт. Да, значит, хотим что-то вот такое, чтобы у нас был здесь вот «ask», чтобы у нас был здесь «put». То есть, «ask» идет у нас от, соответственно, «reader» и «put» от «state».

Вариант, который никто не предложил. Ну, первое — это использовать «rvs». Я понимаю, что есть такая манатка «rvs», которая совершает себе внезапно «reader», «writer» и «state». Вы должны были, вроде, проходить на предыдущих лекциях, была? Да нет, кажется. Серьезно? Окей.

Ну, знаете тогда, что есть такая манатка «rvs», которая — это буквально тупо комбинация «reader», «writer» и «state». То есть, она обладает неизменяемым «environment», изменяемым «state», и еще какой-то аккумулятор есть, в который можно писать логи. Второй вариант, который хорошо, наверное, что никто не предложил — это использовать чистый «state». То есть, мы просто храним и «environment», и «state» внутри «state». Возможно, можно расширить варианцию с тупом.

Да не тупо, а тупо. До вот этого состояния. Почему эти варианты плохие? В «rvs» оно работает нормально, но появляется какой-то лишний «writer», который вообще-то непонятно кому нужен. Главное, что там может очутиться в какой-то момент, что-то совершенно не должно там оказываться. В случае же «state» мы теряем, собственно, доступ к неизменяемому «environment».

Ну и вам, наверное, не хочется, чтобы ваша шахматная доска в какой-то момент сказала «оп», и посреди партии расширилась до 128 клеток. Будет весело. И, да, собственно, вот решение, которое является комбинацией двух модат, так называемые «трансформеры». Можете заметить, что они используют имена стандартных модат, только приписывается буква «т» в конце. Ну, так, во всяком случае, по код-стайлу.

А теперь вопрос, что изменилось. Посмотрите на ассигнатуру функции и скажите, что изменилось. Тяжелая публика. Можете заметить, что у вас изменилось количество аргументов в «reader». В «reader» изначально было два аргумента.

Это «environment» и тип возвращаемого значения. Сейчас у вас появилось третье. Это «state int». То есть, третий аргумент. Замечу, что вот здесь написано через «state» то же самое.

То есть, эти две штуки, по факту, равносильны. И здесь тоже. Если вы посмотрите на «state», там тоже. Значит, у вас был один «state». Одна типовая перемена означала «state».

И одна означала возвращаемое значение. Сейчас у вас появилось еще промежуточный аргумент. Понятно пока, что происходит? Сейчас у нас еще равный оружий. Здесь есть не равный оружий. Там есть отрицательное оружие, а здесь нет.

Поэтому, вы видите, что в нашей локации пока нет вашего оружия. равно на два из таких уровня наше оружие. Только то, что у нас есть не в таким уровне. И то, что вы видите здесь или ещё. Повторяем.

Вот здесь, например, у нас ровно на тремя уровнях растута переверенная аргументность. Если вы не понимаете монады к сегодняшней лекции, то это очень плохо. И давайте вы мне лучше по ним задавайте вопросы. Риберт, он же тоже возвращает монаду или какой-то другой объект? Смотрите, формально он возвращает монаду. То есть из него мы сейчас увидим его тип.

Проблема одна из этого принципа монадных трансформеров заключается в том, что вам потом в конце концов придется все это дело развернуть. То есть сначала передать environment, применить reader, развернуть это в state, и потом передать один раз state и получить там уже результат. Отличие от того, что предлагалось с использованием обычного reader, когда у вас просто reader и в него вы возвращаемое значение передаете, заключается в том, что вам там нужно было передавать всегда, когда вы что-то стейтовое хотите использовать. Здесь вам так не нужно делать. Здесь вам нужно это все сделать один раз, но если это нужно развернуть, оно получается достаточно большим.

С правильной версией радио стоит заметить, что разворачивается это обычно только один раз в каком-нибудь мейне, потому что обычно вот таким гигантским трансформером обвешивают почти все вычисления в проекте. За исключением, очевидно, чистых каких-то вещей. Сейчас, если этот трансформер разрешает монаду, при этом сам комбинирует две монады, как для него реализованы стрелочки и его return? Это мы сейчас увидим. Дальше будет и типы, и, соответственно, там, по-моему, даже будет instance написано. Да, там точно будет пара инстансов.

Можете посмотреть. Хорошо. Еще вопросы? По монадам, по синтаксису, по чему угодно. Просто чтобы все понимали, что происходит. Ну ладно, поехали дальше.

Окей, значит, у вас, соответственно, вот такая конструкция позволяет использовать комбинацию монад. Почему вообще нам нужно так разворачиваться? Потому что есть одна проблемка. Если вы возьмете функторы, аппликативы, альтернативы, все вот эти вещи, которые проходили на третьей лекции, то у них есть одна особенность. Они композируемы. То есть, грубо говоря, если у вас есть, представьте, вот этот new type, он абсолютно фикшен, но идея вот в чем.

Представьте, что у вас есть какая-то некая композиция. То есть вы делаете композицию, там, функтор от чего-то. Так вот, если f это функтор и g это функтор, то композиция f и g функтор. Или это можно прописать так, что у вас буквально сразу получаете правило, то, как вы должны действовать для композиции, чтобы получился функтор. То есть из того, что f функтор и g функтор, вы сразу получаете то, как instance функтора выглядит для их композиции.

То же самое, верно, для foldable, traversable, аппликативы, альтернативы, для всего, кроме монад. Для монад такой фигни нет, и оно не работает. Почему? Ну, упарывайтесь в категории типов. Почему композиция монад, а не монада? Типов в категории. Поэтому вы формально можете сделать такую композицию, просто в каждом отдельном случае ее нужно определять отдельно.

Часто может показаться страшным, что мы сейчас, если хотим выкомпозировать больше, чем две монады, то это надо умереть. Это не так работает. Это гораздо проще. Поэтому все монады, все трансформеры мы должны описать ручками самостоятельно, как у них выглядят instances. Вот давайте приведем пример с мэйби.

Хотим что? Хотим ио-действие и какой-то мэйби. Вот это тоже вполне себе продакшн вещь. То есть мы хотим иметь возможность сделать какое-то ио-действие, которое непонятно, оно дойдет вообще или нет. Подключимся мы к базе, подключимся к серверам, не подключимся. Обычно это как раз таки обозначается тем, что у вас возвращается какой-то натрин.

Ну, ладно, в рул обычно это обозначается тем, что какой-то экрепшн возвращается, так что там, скорее всего, не мэйби, а какой-нибудь эксерт. Но, тем не менее, вполне себе рабочий пример. Да, и, соответственно, написать мы хотим вот так. Замечу, что вот это как раз таки реализация того подхода, который предлагался как в качестве ридера, в качестве возвращаемого значения использовать стейт. Вот заметите, что вы здесь каждый раз, пополняя какое-нибудь ио-действие, получаете в результате какой-то мэйби, который вы должны разворачивать.

Ну, мэйби разворачивать достаточно просто, а в случае стейта вы должны были сюда, там, run стейт, передать стейт и так далее делать. Вот, и если у нас, соответственно, нужно законнектиться к нескольким хостам, или у нас несколько операций, которые различают мэйби, нужно творить всю вот эту громадю каждый раз. Понятно? Да. Окей. Значит, хотим это скомбинировать, получаем мэйби-ио.

Это вот некий абстрактный пример. Что у нас здесь? Заметьте, что вот у нас тип стал чуть-чуть похуже, но вот видим, что у нас мы запихнули вот этот ио.мэйби. а внутрь конструктора. И давайте теперь определим для него инстанс монады. В чем и дело? Ну, ретурн, понятно, да, то есть это всегда это мэйби.

ио, сначала завернуть в мэйби, потом завернуть в ио, потом завернуть в мэйби.ио. Понятно? То есть от обратного идем. Сначала вот это значение, потом вот это значение, потом вот это все. Вот, с экшеном повеселее. На самом деле нет.

Результат у нас все еще должен быть завернут в мэйби. ио, в нем должно быть ио действие, так что вот это ио. В ио мы выполняем результат экшена. Экшен, напоминаю, у нас, соответственно, экшен это ио. мэйби.

а действие, то есть вот у нас вот это ио, результат получается типа имеет мэйби.а. Дальше проверяем результат и заворачиваем все это дело в результат. Понятно, как устроен инстанс монады для мэйби. ио? Да. То есть здесь все достаточно тупо.

Заперформили экшен внутри ио монады, получили результат, который мэйби, проверили, чему он этот мэйби равен, и завернули все это дело в мэйби.ио обратно. Вот, теперь у вас все. Теперь у вас все довольно таки тупо. Более того, на самом деле вот этот мэйби.ио можно вынести вот сюда. Проблема в чем? Теперь я хочу посреди всего этого дела использовать просто тупо ио действие.

То есть вот этот printHello, он чистый ио, он не возвращает мне мэйби. Понятно? И вот так мы делать не можем. Ну, потому что они по типам не сходятся, да? Здесь у нас runMaybe.io применяется к мэйби.ио, очевидно. Это у нас чистый ио, потому что там результатом не является мэйби, там является пустой тупо. Что мы делаем? Мы делаем простой трансформ.

Мы perform результат и оборачиваем его в мэйби. То есть оборачиваем его в just. Получаем некоторую функцию, которая любое действие иошное позволяет трансформировать мэйби иошное действие. И теперь это все выглядит достаточно травоядно. Опять же, это все еще можно сократить немножечко.

Нужно каждый раз применять конструктор мэйби.ио к действию. Собственно, на самом деле мы сейчас получили просто define под мэйби.т трансформер, потому что вы заменяете его на любую произвольную монаду и получаете вот таким же образом буквально дефайните типа инстанции монады для этого мэйби.т. Понятно? Инстанция, например, будет точно такой же. Собственно, вот это вы можете увидеть. Вопросы по мэйби.т, как мы его получили? Вопросы по вот этой штуке.

Тут-то все вроде понятно, а вот все-таки последний переход к мэйби.т был не до конца. Вот тут? Ну, пожалуй, да. В двух словах, мэйби.т, для чего они нужны, трансформеры, если подвести? Смотрите, для чего вообще нужны трансформеры? Для того, чтобы я мог применить... Смотрите, еще раз, пытайтесь узнать следующую вещь. В ООПшке, там, допустим, возьмем какой-нибудь питон, у вас все эффекты включены по умолчанию.

То есть у вас включено ИО-действие, у вас включены всякие логи, стейты, инвайрмент какой-нибудь включен. Это все у вас есть по умолчанию. В Хаскеле у вас по умолчанию буквально нет ничего, кроме чистой функции. Чистая функция не имеет ничего. На самом деле, да, если кто-то сомневается, монологические действия, кроме ИОшных, они тоже чистые.

Соответственно, у вас по умолчанию в Хаскеле все эффекты выключены. И вам нужно добавлять их, чтобы вы могли ими пользоваться. В предыдущих главах, в предыдущих лекциях, вы использовались либо никакими эффектами, либо всегда одним эффектом. То есть у вас есть всегда ридер, у вас есть какой-нибудь мэйби, у вас есть райтер. Вот он в шапке функции написан, вот у вас один эффект подключен.

Теперь я хочу подключить несколько эффектов. То есть я хочу несколько каких-то фич подключить. То есть у меня по умолчанию нет записи ввода-вывода. Я не могу писать ввод-вывод, потому что его нет по умолчанию. Я хочу его подключить.

Дальше у меня есть... На самом деле, на примере сейчас на этом будет. На самом деле, вот это самый хороший пример. Вот, например, использование ридера и.о. То есть я хочу иметь доступ к невменяемому окружению и иметь возможность писать какой-то и.о.

экшен. Сейчас не смотрите на код, мы к нему придем. То есть, смотрите, вот вы, допустим, описываете подключение к базе данных из какого-нибудь кода. У вас есть креденшел, так сказать, база данных, там логин, пароль, название АБД, что-то такое. И вы хотите делать и.о.

, потому что доступ в сторонние сервисы – это всегда и.о. Бегать на сервер – это и.о. Бегать в базу – это и.о. Вот. Соответственно, вы хотите иметь конфликт, с которым вы всегда можете креденшел почитать.

И вы хотите иметь возможность писать и.о. экшен. Для этого вы не могли так сделать, потому что у вас всегда был один эффект. То есть вы либо пишете, либо у вас есть environment. Теперь вы можете их комбинировать, с помощью трансформеров вы можете комбинировать различные эффекты, причем до бесконечности.

То есть не только два эффекта можно комбинировать, можно комбинировать бесконечное количество эффектов. У меня может быть ридер от фрайтера, от стейта, от и.о. , от айзера, там черт знает чего еще. То есть вы можете создать комбинацию только тех эффектов, которые вам нужны для выполнения задач. Понятно? Да.

Maybe.t в этом вопросе мне не очень нравится. Почему? Потому что, на самом деле, я, по-моему, один раз в жизни видел, как кто-то применяет maybe в количестве монады, и код от этого выглядит очень хреново. Вот. Поэтому дальше будет, наверное, не очень понятно. Но идея в чем? Вот у вас есть эффект монады maybe, который означает, что у вас в какой-то момент веществения могут завершиться с ошибкой.

Плевать какой, просто они упали с ошибкой. Может не привести к результату, который вы хотите. И у вас есть при этом и.о. То есть можете читать это как, у вас есть и. о.

действия, которые могут завершиться с ошибкой. Понятно? Угу. Так, еще вопросы. У нас тут целых девять человек. В примере с maybe.t и try-connect сделать print, нам пришлось написать transformed.

io и потом его доставать. Вот если мы скомбинируем больше монад, чем две, нам для того, чтобы добраться до и.о. придется еще много букв писать. Плохая новость – да. Хорошая новость – очевидно, это проблемы, которые решили.

Мы потом покажем, потом подальше покажем как. Но сейчас считайте, да, если у вас много эффектов, это вот, собственно, называется, да, давайте покажем следующий слайд, это называется функция lift. Да, если вот видели слоган Серокина – your expectations lifted, так вот lifted – это вот отсюда lifted. Да, у него есть некоторые законы о том, что lift и return – это просто return, и lift байнда – это lift сначала одной монады, bind в lift функцию. Лифт позволяет вам поднять одну монаду в другую монаду.

Понятно? Посмотрите на тип. То есть у вас была какая-то обертка над возвращаемым значением, теперь вы завернули это все дело в еще одну обертку, теперь над двумя типовыми переменными. Заметьте, что скобок здесь нет, то есть это t принимает на вход две типовые переменные. Эта штука называется kind, by the way. Окей? Так, хорошо.

Кроме Романа, еще все все понимают? Так, да. Сейчас сдерну рандомного кого-нибудь, спрошу вопросы. Ладно. Да, соответственно, вот у вас, да, эта штука называется monotrans, ну и, соответственно, для трансформеров нужно определить внезапный instance monotrans, который позволяет делать lift. Там еще пара функций есть, но главное – это lift.

Да, ну вот на тему написания кода в адекватном виде, вот у вас, соответственно, то, что я говорил, вот у вас вы лифтите putString, потому что он в IO чисто, вы лифтите getLine, потому что getLine тоже IOC, Вы не лифтите email as valid, потому что у вас нет здесь монада, логично. Вот, и все. А дальше здесь, соответственно, в майне вы делаете просто run mybt и все. Да, until success функция здесь, если что, она просто повторяет действие, пока оно не завершится чем-то, кроме nothing. Да, у mybt, соответственно, есть альтернативы, которые позволяют делать вот так.

Ну, то есть, еще раз, фиговый пример, потому что mybt не очень хорошо, не очень красиво выглядит в реальной жизни, если использовать какую-то монаду. Вот, вот это повеселее пример. Вот environment. io, то есть, reader.io, это, короче, самый часто используемый паттерн в Haskell. Ну, то есть, буквально почти все, что вы увидите, на самом деле, под капотом это какой-нибудь ридер с каким-нибудь state.io.

Там еще иногда except замешивают, чтобы у вас еще ошибки правильно разрабатывались. Но почти все это, на самом деле, environment.io. Любая коннекция к базе данных – это environment. io, любой сервер – это environment.io, любое логирование – то же самое. Вот.

Ну, да, соответственно, что мы имеем? Вот у нас есть раньше, чем было. Вот мы хотим записать какой-то лог, вот у нас логер. name, файл.path, мы его должны передавать. Почему? Потому что мы здесь не можем использовать ридер, у нас здесь уже его. Окей.

Хотя они передаются вот через все вот эти функции. Тянем за собой хвост. Зачем? Вот. Идем в ридер, и вот, кстати, вопрос о типе. Весь у ридера, если помните, типа r-стрелка a, теперь r-стрелка m-a.

То есть, действительно, когда вы применяете run ридера и передаете ему environment, он возвращает вам внутреннюю монаду. И к ней уже надо будет свой run применить, чтобы ее достать. Но это применяется еще раз только, когда вы хотите вернуть деятельность в какой-нибудь I.O. Вот. И вот здесь, смотрите, вот мы создаем логер I.O.

То есть вот у вас ридер t, логер.name I.O. Замечу, смотрите, здесь мы просто... это тупо type alias. Это тоже часто применяемая техника, когда вот в этом type alias у вас определены параметры внутренней монады и определенный environment. По сути, мы здесь передаем просто...

мы создаем новую монаду. По факту это просто ридер с определенными двумя параметрами. Понятно? Да. Окей. Ну и, соответственно, что мы делаем? Теперь у нас все просто, тупо мы логируем, если нам нужен доступ к этому самому, то мы можем всегда из этого environment получить данные по файлу, например.

Не вижу ни одного примера. На самом деле, тем мы что-то из environment достаем здесь. А, ну окей. Видимо, у нас есть log message, который там из него достает. Вот.

И все. И вот runRider вы применяете здесь только в одном месте, в main. Единственное, что здесь не приходится разворачивать I.O. Потому что main тоже в I.O. Пока понятно? Гробовая тишина.

А что непонятно? Ну, лично я пытаюсь вчитаться в код, поэтому и молчу. Хорошо. Можете подробнее что-то поделиться на что? Можно как-то объяснить код чуть-чуть? Ну, смотрите, у вас есть просто несколько функций, которые умеют что-то логировать. Условно, у вас есть функции записи, чтения файла, какой-то prettify файл content, который как-то меняет то, что у вас в файле написано. И на каждое ваше действие вы хотите логировать это дело.

На каждое ваше действие вы хотите в данном случае в stdout писать какой-то лог. Вот. Соответственно, каждое ваше действие readfile.withlog это просто что? Это readfile, и до этого вы делаете какой-то log message. Предположим, что функция log message, она умеет доставать из environment, надо бы ее написать, кстати, она умеет доставать из вот этого environment, из logger name, она умеет доставать куда писать, что писать, ну там, в std. in или в какой-нибудь отдельный файл, и она как-то этим environment пользуется.

Чтобы не передавать этот environment везде, вот здесь во всех этих функциях, вы используете MonadoReader, так же, как вы это использовали во всех предыдущих занятиях. Но поскольку, помимо того, чтобы использовать неизменяемое окружение, вам нужно еще делать его действие, то есть писать в какой-то output канал, вы используете трансформер. Понятно? То есть, еще раз, функция log message умеет получать доступ к environment. Чтобы не передавать этот environment через каждую отдельную функцию, при каждом вызове этих функций, вы передаете его один раз в меню, а потом, соответственно, претифия файл content, он читает с логом, читает с логом, делает запись в лог, записывает с логом, делает запись в лог. Понятно? Можно задать вопрос по поводу read file? Как я понимаю, log message возвращает нам нечто в логер.

io, а lift в следующей строчке возьмет и текст приведет к логер.io. Ну, read file возвращает его, так что он его приведет к логер.io. Кстати, тут баг, похоже, да. Смотрите, давайте так. Окей, это не совсем баг.

Тип read file with log – это логер.io текст. Аналогично, да, собственно. Нет, совсем нормально. Read file имеет тип .io текст. И lift поднимает его в логер.io текст.

Поэтому, собственно, и lift. Ну, то есть, и lift... Что это за лифт, откуда он? Ведь, получается, лифт должен знать, как это... Вот, лифт – это из monad.trans. Давайте так.

Здесь не написано, что read.t – это monad, хотя всем это очевидно. Но у него также должен быть очевидный instance monad. trans, если это трансформер. Если у него есть instance monad.trans, то там лифт, очевидно, берется из instance. Еще вопросы? Ну, давайте, поехали дальше.

Да. Замечу, что вообще все ваши стандартные монады, которые проходили, типа reader, writer, state – это все, на самом деле, трансформеры. Просто они являются алиасом на трансформере, где определена монада identity. Монада identity не делает ничего. Она как раз нужна как такая заглушка, когда нужно передать какую-то монаду, но не нужно передать монаду, которая что-то делает.

Да, кто хотел увидеть instance монада для reader.t, вот он вот такой. Monad.trans, соответственно, вот такой. А почему у нас reader является трансформером, который принимает identity? Зачем нам это делать? Почему не достаточно отдельно монады? А зачем? Грубо говоря, если вы делаете отдельно монады reader, вам нужно определять заново монад instance для нее, или всякие там аппликативы, альтернативы, что там еще у reader определено. Если вам нужно определить… Более того, у вас бывает такое, что вот у вас есть reader, да, reader. t, и у него какие-то полиморфные монады.

И вот в одних случаях вы хотите какую-нибудь action туда передать, ну там, только логирование какого-нибудь левого. А вот в другом случае вы не хотите. Вы хотите, чтобы у вас был четыридер, и все. Ну, из самого тупого, наверное, смотрите, пусть у вас есть какая-нибудь… пусть у вас выпишите код, который входит в базу данных, да. Вот для того, чтобы протестировать функционал, вы хотите написать, во-первых, да, чтобы вы могли ходить, собственно, непосредственно в базу, но также вы хотите написать какой-нибудь тестик, где вы ходите, на самом деле, не в базу, а просто там, типа, какую-нибудь константу возвращаете на запрос.

И вот в первом случае его вам нужно, во втором случае его вам не нужно. Вот, если вам его не нужно, вам не нужно тогда писать несколько различных функций. Одну с reader.t, другую просто с reader. Вы просто передаете identity, когда вам не нужен другой какой-то эффект, кроме reader. Понятно? Ну, вроде бы, да.

Да, значит, на то, что справа, пока не обращайте внимания, он тут преждевременно, тут какая-то картинка. Вот. Так, если здесь все понятно, давайте посмотрим на табличку. Вот у вас типы, соответственно, базовых монад, типы трансформеров, вот как они меняются. Да, вот, соответственно, то, что у вас было...

Грубо говоря, у вас результат всегда теперь заворачивается в монаду. Я не знаю, проходили конт-монаду? Знаете, что это такое? И я не помню. Поэтому тогда я не буду мешать на ваше внимание. Но вот state, writer, reader... Господи, writer, reader, state.

Вот запомните. Вот так вот работают. Да, на всякий случай, если вдруг у вас возникнет такая ситуация, что вам нужно комбинировать reader, writer и state, используйте тогда RWS. Это просто проще с точки зрения синтексиса. Да, и у RWS все еще есть трансформеры, так что есть RWST.

И у RWS тоже есть трансформеры. Окей. Идем дальше. Да, можно заметить, что в этой табличке нет иошки. Иошка не трансформируется.

Почему его не трансформируется, вопрос интересный. Если вкратце, то потому что, если его трансформируется, вам в какой-то момент можно будет захотеть сделать какие-то очень, скажем так, пагубные вещи с иошкой. В том смысле, что вы не сможете написать монадный инстанс для нее. Например, вы не сможете написать, как будет выглядеть монадный инстанс в случае ио и мэйби. То есть, если у вас не ио, а мэйби, в мэйби ио было можно использовать комбинацию ио и мэйби.

В обратном порядке ее использовать нельзя. То есть, ио не трансформируется. Есть только такой монад ио, который позволяет вам лифтить специально ио действие в другую монаду. Может показаться, что эта штука стирает нечистоту иошки, на самом деле нет. Эта штука нужна исключительно потому, что ио у вас всегда в самом конце.

В самом конце цепочки трансформеров. Поэтому его надо всегда поднимать с самого низа на самый верх. Да, потому что нужно делать эту операцию поднятия. Вот это последовательность монад, трансформеров и их аргументов называется монадным стэгом. То есть, то, что у вас был reader t от state t от writer t, это называется монадный стэг.

Понятно? Внезапно вы увидите, что то же самое происходит с инстанцией monad.trans. У вас достаточно тривиальные инстанции получаются, но их просто много. Монадный стэг называется монадным стэгом. То есть у вас state от reader. Мы вернулись к оригинальной задаче.

Мы действительно теперь можем скомпозировать state и reader, или reader и state, и получить то, что мы хотели. То есть мы получаем доступ к environment, и мы получаем возможность записать state. Пока мы не перешли к MTL, здесь понятно все, что до этого было? Получается, порядок трансформирования монад важен или не очень? То есть в чем разница между state t от reader или reader t от state? Смотрите, конкретно в этом случае вообще не важно. Здесь мы могли написать reader t от state, это было бы совершенно легитимно. Важен он становится, когда у вас появляются штуки, которые могут ломать вам, когда могут ломать вычисления.

Это, соответственно, ситуация либо с иоркой, но с иоркой все просто, она всегда должна быть внизу стэга, либо еще там появляются веселости, мы сейчас чуть позже их увидим, когда у вас появляется accept. Ломать вычисления, это в плане, как у нас в случае с maybe, там по nothing было замыкание, вот это вот? Ну, типа того, да. То есть у вас, например, при определенных комбинациях accept и state, да, если что, accept это просто трансформер either. Единственное, почему-то, что у вас, у всех трансформеров называется, точнее у всех моделей трансформеров называется буквка t в конце, а вот у either почему-то он не either t, а accept t. Честно не знаю почему.

Суть в том, что у вас, в зависимости от того, в какой момент вы прокинете вот это исключение через accept, у вас может стоить либо сохраниться, либо нет. Оно как бы там, это логически понятно, почему так происходит, да и по смыслу тоже понятно. Но вот сам факт того, что если вы просто бездумно влепите, вы можете в какой-то момент получить, что у вас вылетает ошибка, и из-за этого у вас state не сохраняется. Окей, еще вопросы? Тогда переходим к MTL. Да, собственно, как бы кто-то заметил, у вас есть как минимум одна сейчас проблема, у вас куча лифтов.

Вот. Более того, мы хотим делать еще одну штуку. Мы не хотим каждый раз, мы хотим добавить еще больше полиморфизма. Мы не хотим каждый раз указывать конкретную монаду, а вместо этого мы хотим указать как бы эффект, который, который какая-то, господи, мы хотим указать набор эффектов, который монада должна обладать, чтобы мы могли в этой функции работать. Понятно? То есть не всегда писать, что вот у вас state reader, что вы можете передать абсолютно любую монаду, главное, чтобы она умела делать вот эти вещи.

Для чего это нужно? Потому что мы хотим, чтобы у нас было чуть-чуть больше полиморфизма. Смотрите, например, у нас некоторые функции хотят ЙО и Ридер, некоторые функции хотят Ридер и Стейт, некоторые хотят ЙО и Стейт. Так что, и, соответственно, чтобы этими функциями Мы хотим сделать следующее. Мы хотим, чтобы каждая из этих функций просто указывала, что она хочет. Что она хочет, чтобы мы могли получать доступ к environment и получать доступ к его.

Что она еще умеет, какие еще эффекты есть у polymorph на этой монаде, нас не интересует. Поэтому мы один раз загоняем какую-то большущую монаду, большущего стека, вида reader, writer, state, except, черт еще что знает. А потом, соответственно, каждая из этих функций будет использовать только определенные эффекты, которые в ней есть. Для этого мы вводим специальный пакет mtl. Пакет называется mtl, так же и метод называется.

MonadTemplateLibrary, но сейчас я уже не помню. Суть в чем. Мы вводим некоторый класс. Класс, например, MonadReader. MonadReader, который означает, что мы умеем читать какой-то environment, и что это монада.

И таким образом у вас получается следующее. Вы, соответственно, можете передать сюда любую монаду, в которой где-то там в стеке есть reader, и мы умеем из него читать. Меное определенное производство для нее является монад reader, определяется достаточно превиальным. Здесь есть один элемент, который вы не знаете до сих пор, кто его видит? По-хорошему должен быть тот вопрос, а что вот это за код? Вертикальная черта меня напрягает. Вот, правильный пример.

Это немножко легоси, называется фундепа, рациональная зависимость. Эта штука как бы гарантирует компилятору, что если у вас есть определен инстанс MonadReader для какой-то Monad M, то вы всегда знаете, для какого environment он определен. То есть, грубо говоря, данное M сразу определяет вам environment. Что это означает на практике? На практике это означает, что вы определили MonadReader R1M, вы не можете определить MonadReader R2M. Компилятор скажет, ребята, у вас там фундеп, не надо так.

И не скомпилирует. Для чего это сделано? Это сознательная лимитация. Почему? Потому что, смотрите, вот у вас есть ASK. ASK M R, то есть он просто возвращает вам environment. Вот у вас есть, допустим, MonadReader, определен для двух разных environment, для одной Monad.

Вот вы делаете ASK. Вопрос, какой environment вы получите? Тут по-хорошему бы надо что-нибудь нарисовать или написать. Давайте я попробую в комменты тогда написать. Что я имею в виду, потому что важно для понимания. Предположим, что у меня есть...

Ладно, сейчас не буду писать, а потом скину флешку, чтобы все видели. Еще раз, идея в чем. Вы не можете определить два инстанса MonadReader к одной Monad, так, чтобы из них получались разные environment. Понятно? Ага. Кому-то кроме Романа и Федора понятно? Анастасия, Кристина, Юрий.

Остальных я, к сожалению, имена не выговорю. Можно ли это трактовать как интерфейс? Накладывание каких-то ограничений? Как накладывание ограничений, да. Интерфейс это немножко другое. Интерфейс это про то, что вы делать можете, а здесь скорее про то, что вы делать не можете. Двигаемся дальше.

Все MTL классы, они так или иначе с фундеповскими констрейтами сидят. У вас для всех их комбинаций есть какие-то инстансы. То есть для MonadReader, инстанс MonadReader для ридера банальный, а инстанс MonadReader для райтера, он определяется как. Вам нужно, чтобы MonadReader был в внутренней монаде. То есть что это означает? Означает, что где-то там по стэку должен быть где-то ридер.

Понятно? То есть видите вот этот констрейнт. Этот констрейнт гарантирует вам, что у вас определен MonadReader для M. Лезем в M, а там скорее всего какой-нибудь такой же констрейнт, что MonadReader уже внутренней монады у M должно существовать. И так далее, пока мы не натыкаемся на MonadReader, в котором у вас требуется только, чтобы у вас была внутри монада. Понятно? Соответственно, если у вас ридеров стэки нет, вы не можете выполнить это условие, у вас не будет инстанса MonadReader.

То же самое для стэйта и райтера. Понятно? Да. И так мы можем получать стэйты. Понятно. Ладно, возможно я не так понял.

Ну просто вот MonadReader, да, стэйт. Вот, что происходит в этом случае. Еще раз. Вот смотрите, мы определяем MonadReader для стэйта. Что за фигня? То есть какой ридер, какой environment мы можем из стэйта прочитать.

А мы читаем environment не из стэйта. Представьте, что здесь у стэйта в монаде M там еще монад. Там какой-нибудь ридер, райтер, там еще что-нибудь. Где-то среди этого стэка есть ридер. Или ридер T.

Вот, и вы говорите, я хочу сделать доступ к environment, хочу сделать ask. Чтобы не делать лифт, лифт, лифт, лифт, лифт, лифт, вы запаковываете его внутри вот этого инстанса. Инстанс при этом имеет constraint, что я не применяю ask, я не достаю environment из вот этой монады стэйт, которая у меня сейчас написана. Я достаю ее откуда-то дальше по стэку. У меня гарантированно, что дальше по стэку, вот этим вот MonadReader, у меня гарантированно, что дальше по стэку где-то монада есть.

MonadReader в смысле. Как достать environment из той монады, которая где-то внутри далеко по стэку? Ну очевидно, ask для данной монады это запросить ask во внутренней монаде, которая в свою очередь запросит ask во внутренней монаде, и так далее, и так далее, и так далее, пока не дает до ридера, у которого вот эта штука определена тривиально. Понятно? Да. Верно ли, что тогда нужно прописывать еще и для всех других комбинаций, где не только стэйт, тэ? Да. Это называется NxM problem, но опять же очевидно, что никто так не делает, оно достаточно тривиально решаемое, потому что смотрите, замечу, что этот инстанс достаточно тривиальный.

Ну то есть буквально ask это lift ask, там, reader это lift reader, local это какая-то ересь, но насколько я помню, там не нужно определять для, не помню какого у него minimal definition, но даже так, все равно он достаточно тривиальный. Вот, поэтому да, соответственно, короче, решение у этой штуки есть, сейчас через пару слайдов. Вот, да, значит как-то связано с парсер-комбинаторами. Сейчас, у вас какая сейчас доза, там есть какие-нибудь парсеры? Или бывали у вас лекции про парсеры? Нет, парсеров нет. Окей, хорошо.

А никаких парсеров не было. Хорошо, странно, что их не было, но суть в чем, смотрите, вот у вас есть парсер-комбинатор, да, это какая-то такая вот, какой-то класс, как Monado на самом деле работает, который позволяет вам парсить выражение, то есть он берет строку и возвращает, может быть, распарщенный результат и остаток строки. Для чего нужно именно вот так вот делать? Для того, чтобы вы сразу могли вот к этому результату, вот к этой вот оставшей части применить другой парсер. Поэтому они называются парсер-комбинаторами. Вы берете несколько парсеров, каждый из которых умеет парсить какую-то часть, применяете их все последовательно друг за другом, и у вас каждый из них выдает какой-то результат, плюс то, что осталось распарсить.

Вот. К этой фигне можно добавить, да, по сути, во-первых, эта штука превращается в некий стейт, во-вторых, к этой фигне можно добавить трансформеров, то есть, например, если вам парсер нужно логировать ошибку, раз вы ее обнаружили, вы можете добавить сюда PointXL. Если вам для того, чтобы распарсить значение, нужно PointEnvironment почитать, ну, например, самое банальное – это переменная, замена переменных, там PointMaps, замена переменных лежит. Вот вы можете Reader сюда добавить. Давайте не будем на этом долго останавливаться.

Да. Значит, теперь обработка исключений. У вас, по-моему, было что-то про обработку исключений. Правильно? Правильно было. Отлично.

Кому-нибудь скажет, в Хакере можно кидать исключения из чьих-то функций? Ну, вообще, здесь функция Error, которая прервает... Хорошо, а проверяемые исключения? Error – непроверяемые исключения. Это правда. Проверяемые только из его. Вот этим ответом люди себя убивают на экзамене.

Первое, значит, даже без каких-либо монад вы все равно можете сделать просто функцию Throw, если посмотрите на ее тип, ее тип E, A. И потом ее можно Catch сделать. Замечу, что Throw... Короче, вы можете делать Throw из чьих-то функций, вы не можете делать из чьих-то функций Catch. Вот ловить исключения можно действительно только в ООО.

А вот Throw делать можно откуда угодно. Но вот там как раз такие проблемы, что Throw на самом деле пробрасывает исключения все равно через ООО. Он ломает вам вычисление и, ну, не есть хорошо. Это можно, но это не есть хорошо. Чтобы вот такой фигни не было, есть два варианта.

Первый – у вас все крутится в ООО хорошо. В таком случае у вас, соответственно, в таком случае вы можете просто делать Throw и Catch в ООО. Или как они так называются? Throw и Catch, по-моему. Которые работают через ООО и так, поэтому им не страшно. И ООО само там пофиксит порядок вычислений.

А если вам хочется кинуть вычисление внутри какой-нибудь чистой функции, тем не менее, то вы можете все это сделать. Просто он лучше будет, если вы начнете вычислять на это дело монадический контекст. Но самое банальное, опять же, это except какой-то. Except, на самом деле, в монадическом контексте он просто заменяет каждую последующую операцию после того, как случилась ошибка на возвращение за результат ошибки, и все. То есть он как бы продолжает вычисления дальше.

Просто каждую операцию, вместо этого, тупо не будет ее выполнять. Вместо этого просто результатом этой операции будет ошибка. И вот тогда и тогда, и так далее, пока она не вернется в виде результата. Вот. И, соответственно, чтобы таким образом выкидывать ошибки или их ловить, есть две монатки.

Монат throw и монат fetch. Точнее, не монатки, а классы. То есть для его этого throw и all просто тупо, а для, соответственно, maybe, она просто заменяет классы на nothing. Всё. Вот.

Соответственно, есть монат throw для того, чтобы выкидать ошибки. Как вы можете видеть, у него он же определяется, через лифты для внутренних монат поставку. Вот. Это, кстати, важно. Почему? Потому что, соответственно, это означает, что вы из какой-то внутренней монады можете бросить исключение, и мы здесь это знаем.

Но мы можем пробросить дальше. Вот. Соответственно, монат catch, который парен монат throw, потому что нужен инстанс монат throw, чтобы был монат catch, он позволяет это исключение в монаде ловить и как-то обрабатывать. Понятно? Непонятно. Зачем нам для того, чтобы определить монат catch, требуется, чтобы был определен монат throw, если мы можем бросать это всюду, а не только из...

Нет, это не совсем так. Смотрите, констрентами монат throw и монат catch вы описываете, как вы пробрасываете исключение. Потому что соч. io это вот та самая ломающая последовательность вычислений выброс. То есть, и.о.

это как бы такая дубинка, да? Она просто говорит, все, у меня случилось исключение, мне пофиг на то, что там должно в программе твориться дальше, я вот полетела туда. Как бы вы ее так и ловите, как что-то, что летит откуда-то непонятно откуда, как бы, и приходит к вам. С точки зрения maybe, ошибка гораздо более такая мягкая. Это просто, типа, вы заменяете последовательность операции на nothing. Соответственно, как вам поймать то, что у вас случилась таки ошибка? Ну вот ровно так же.

Вы определяете instance монат catch, который умеет понимать, что ага, вот этот nothing, которым пришел, это на самом деле ошибка, которая вылетела, и мы ее можем обработать. Понятно? Да. Замечу, что instance монат throw и монат catch определяются для одной и той же монады. То есть, если вы определили монат throw для maybe каким-то образом, вы определяете монат catch для maybe таким же образом. Ну, в плане, типа, как-то парно к нему.

Чтобы вы умели обрабатывать тот тип ошибок, который там вылетает. Для его это, соответственно, простой catch, для maybe там что-то другое будет. Да, для его это просто catch. Как catch и throw работают под капотом, мы вам, вроде так, должны были рассказать, если не представляли, лучше не смотрите туда, там мощная магия. Вот.

Да, еще есть mtl'евский монат error, который на самом деле то же самое, что эти два комбинированные, просто он, типа, позволяет одновременно определять, позволяет одновременно кидать ошибку и ловить ошибку. Замечу, что здесь опять есть фунт деп на то, что у вас так же как и с ридером, только здесь у вас определяется тип ошибки для монады. То есть, одна монада может кидать только одну ошибку по этому инстанцу. Зачем так сделано, честно говоря, не знаю, просто design limitation. Вот, ну и да, то, что я говорил, что у вас accept transformer, это какого-то черта трансформер для either.

Вот. Ну и какой-то пример того, как это можно использовать. То есть, фу кидает монад error, фу error, бар кидает монад error, бар error, баз монад error, баз error. Где баз эррор, это комбинация. Теперь вы можете применить их оба, просто в базе вы должны без accept, то есть вы здесь с каждым конкретным этим случаем ловите ошибку, которая здесь вылетает, комбинируете их как-то, справляетесь с ними, как-то и передаете дальше.

Окей, значит, да. Собственно к вопросу о том, что зачем нужны MTL, MTL вот эти монад что-то позволяют обходить вот эту вот проблему множественных лифтов. Это, кстати, реальный production code. Когда-то у Серокеля было вот такое. Да, мы им не гордимся, но когда нужно было что-то быстро написать, ребята написали это вот так вот.

Здесь сколько? Самое большое я здесь вижу, сколько здесь? Восемь лифтов. Ну типа не надо так использовать MTL и она позволяет вот это все дело сократить. Единственное, что возникает, собственно, проблема n на m инстансов. Что если у вас есть n монад и m type классов, вам нужно написать n на m монадных инстансов. Хотя, как мы уже заметили, большинство из этих инстансов они совершенно тривиальны.

Поэтому MTL есть с помощью вот этих вот экстеншенов. Вы можете задеривить просто монад что-то, если инстанс тривиальный. То есть у вас условно ридер внутри есть, можете задерить монад ридер по environment. State my state есть, монад стоит за деревелью, есть монад за деревелью. Понятно? Да.

Замечу, что вот это тоже очень часто техника, чтобы не таскать за собой гигантские трансформеры, вот такие вот. Обычно их либо оборачивают в new type. Почему в new type? Потому что есть экстеншен New Type деревень, который позволяет New Type деревень делать очень просто. Он, по сути, разворачивает New Type и говорит, что я определяю инстанс вот этой штуки для New Type, так же как для того, что внутри него. И по этой причине у вас эта штука вообще будет очень легко работать, потому что у вас деревень в этом случае просто развернет эмку, посмотрит, ага, у вас ридер, ну как определенно монад ридер для ридера, ну вот так.

Как монад стей для ридера определен, ну вот так. Как монад эо для ридера определен, ну вот так. И все. И определить их автоматически. Вот.

Либо еще, ну тогда можно совсем тупо, если typewise просто использовать. Вот. Да. Соответственно, теперь у вас, может, такие вот вещи можно превратить вообще вот в это. Можно еще круче пойти.

Можно сказать, что у нас здесь вообще-то не environment просто, да, а у меня какой-то has environment класс переменная. Вот. То есть, что мы не обязательно должны чистый environment всегда доставать. Мы можем доставать больше, просто мы должны уметь из-за этого получать environment. Тогда вообще становится все полиморфно, даже утер.

То есть мы буквально всегда можем кидать любые аргументы, любые, делать эти вычисления в любой монаде, и он все равно будет работать. Главное, чтобы вот это вот констринты были удовлетворены. И эта штука может реально разрастаться. То есть у меня было такое, что у меня там штук констринтов в один момент получилось, там бага, это почти апогенережка была. Вот.

Можно еще раз? Зачем нам здесь has environment делать? Почему это не оборачивается в monadreader? Почему-то не сделать его частью ответственности? Смотрите, объясняю. Что делает monadreader? Monadreader позволяет вам получить какой-то environment, так? Но мы здесь жестко прописываем, что monadreader должен получить именно environment значение. Вместо этого, если мы хотим сделать это еще более полиморфным, мы можем прописать, что у нас monadreader на самом деле здесь не environment возвращает, а какую-то переменную k. Типовую, да? И вот для этой переменной k мы умеем делать какой-то has environment. То есть environment может быть каким-то подмножеством k.

Просто мы гарантируем, что мы умеем из этого множества k получить вот это подмножество environment. Понятно? Это просто может быть нужно иногда для того, чтобы вообще все заполиморфить. То есть мы еще environment могли бы различные передать в эту monad. Более-менее. Так лучше на самом деле не делать.

То есть если вы пишете какую-то lib, тогда да, тогда можно, потому что непонятно, кто и в каком контексте будет юзать вашу библиотечку. И там можно делать все полиморфным до жути. Вот если вы посмотрите какие-нибудь хаскинговые большие библиотеки для работы с базами, с вебом, с телегой, с андроидом, с чем угодно. Вы увидите, что на самом деле большинство библиотек действительно вот так вот определено. Самому такие вещи лучше не писать.

Если вы не пишете библиотеку, а пишете какую-то просто функцию, то лучше прописывайте четко monad, которые должны использоваться, потому что вы точно знаете, что вы будете использовать. И это позволит читателю гораздо проще понять, что вообще здесь вы делаете. Вот это то, что мы пытались достичь. Мы просто перечислили список эффектов, которые мы должны и хотим здесь применить, и тип. Примерно такой же у нас здесь и получилось.

То есть у нас перечислены все эти monad что-то. Это эффект, который мы хотим использовать. А в типе она осталась простенькой параметром. Да, значит, какие паттерны стоит использовать? Ну, Reader.io это просто классика. Я об этом много рассказал.

TaglessFinal это вот то, что на самом деле это продолжение вот этой вот MTL практики. Что такое MTL? Оно позволяет задавать вам эффект, который вы делаете. То есть monadReader это доступ к изменяемому окружению. Давайте теперь введем собственную monad, например monadDatabase, которая под капотом будет там тем же MonadReader с иошкой, но зато мы теперь у нее определяем, что у нас есть какой-то monadDatabase, который позволяет вам получить юзера или дайвить юзера, например. Или сделать запрос с connection там или еще что-нибудь такое.

Это нужно, чтобы достать детали реализации того, как вы там в базу ходите на самом деле. И при этом, соответственно, использовать этот monadDatabase в любом контексте, независимо от того, как мы реально хотим в эту базу ходить. Понятно? То есть, вот смотрите, у вас здесь есть AppM, который ходит, видимо, в реальную базу, потому что у него есть TO. Есть TestM, который на самом деле просто хранит каких-то юзеров, но их как-то меняет в зависимости от действия, которое вы делаете. И, соответственно, в зависимости от того, что вы хотите использовать функцию в реальности или в тестовом окружении, вы подменяете монаду внутреннюю.

Ну и, соответственно, в одной из них у вас идет вычисление. Как-то. Я об этом, кстати, говорил на самом начале. У нас было в Sirocco, например, там другая ситуация. У нас была библиотечка для работы с блокчейн-сетью, и вот мы хотим, соответственно, мы хотим какие-то вещи протестить, но проблема, что протестить их на реальной блокчейн-сети, там каждая операция выполняется секунд реального времени.

Вот просто constraint такой стоит. Соответственно, любой тест у вас будет выполняться умножить на количество операций, которые вы хотите в этом тесте сделать. Что мы сделали? Мы ввели два environment. Один для продуктовой сети, в которой мы можем, соответственно, использовать эти же функции, но, блин, да, они будут требовать времени. И другой для тестовой сети, в которой каждая операция выполняется одну секунду.

И чтобы не переписывать каждую функцию под разные контексты, мы просто написали функции один раз, функции такие, к которым мы можем передавать вот этот вот паттерн того, где мы хотим использовать эту функцию. Понятно? Да. То есть, грубо говоря, если в Java мы создаем интерфейс блокчейн и две реализации. Это интерфейс аквас реализации, и передаем в приложение объекты, которые реализуют интерфейс тестовой блокчейн и приложение веб-блокчейн. Здесь мы определяем сразу типы тестовой блокчейн и нормальный блокчейн и передаем типы, не экземпляры.

Да. Хорошо. Экземпляры вы создаете, соответственно, потом, когда хотите что-то в этом типе, оно будет эти операции выполнять следующим образом. А интерфейс в этом случае создает то, что вы, в принципе, можете выполнять эти операции. То есть, в данном случае, вот этот monad-датабейс это интерфейс, apm и tstem это конкретная реализация этого интерфейса, а вот когда вы запустите, вы уже передаете конкретный экземпляр.

Хорошо. Вот, что делать не стоит. Трансформер с PLUS.io, не совсем правильно назвал, трансформер, очевидно, можно использовать с EO, потому что вы не можете выбирать того, чтобы использовать трансформер с EO. Однако, чего делать не стоит. Значит, по-самому не стоит комбинировать EXCEPT с EO и STATE с EO, можно комбинировать, просто очень аккуратно.

Почему? Потому что в этом случае EO, как я уже говорил, имеет очень забавное и неприятное свойство, оно вообще ломает нафиг все вычисления и говорит, что, типа, я вот выбросил ошибку, иди ее там где-то лови. Все, что должно произойти дальше по вычислениям, у меня не особо волнует. Вот. По этой причине, во-первых, то, что у вас должно вылететь как EXCEPT, вылетает как EO, ну, соответственно, понятно, что смысла в этом вообще не много. Потому что EXCEPT нужно для того, чтобы мягко схендлить ошибку, EO выкидывает ошибки жестко.

Их комбинация, ну, очевидно, будет кидать ошибки жестко, и больше ничего вам для этого вычисления не дает. Используйте либо одно из них, либо другое. STATE T плюс EO, тут та же проблема, что с EXCEPT и STATE, на самом деле, мы сейчас увидим, что STATE в этом случае может сломаться. В плане не сам STATE, а в плане STATE, который вы передаете, он может откатиться к начальному состоянию, а может не откатиться. То есть вы не можете зафиксировать STATE на том месте, где вылетела ошибка.

Потому что она вылетевшая ошибка не дает правильно этот STATE похендлить. Ну, собственно, то, что там кто-то из вас говорил на тему порядка комбинации монад. Вот у нас, допустим, есть READER T, EXCEPT T, STATE T. Это все нормально работает, это тоже работает, но немножко по-другому. Почему? Потому что...

А, сейчас, в обоих случаях EXCEPT над STATE, предположим, что у нас был бы STATE над EXCEPT. То есть поменяем местами EXCEPT и STATE. В этом случае, в одном из этих случаев, у вас произойдет то, что я описывал только, что вылетевшая ошибка, она прервет вычисление STATE, и вы в результате получите начальный STATE, который вы передавали, и ошибку саму. В другом случае, я сейчас не помню, какой из них какой, скину вам потом в чат конкретный пример. В другом случае, у вас вылетевшая ошибка не прервет вычисление, и вы в результате все равно берете результат, который ошибка, плюс какой-то STATE, который посчитался до того момента, пока ошибка не вылетела.

То есть, если у вас... Сейчас, ладно, я не беру стражащихся, потому что, по-моему, в каком-то из них порядка не должна при этом быть. Понятно примерно? Можно задать вопрос, может, глупый. Зачем UNIT на конце объявления, на конце сигнатуры? В смысле, у вас же в каждой сигнатуре должно быть возвращаемое значение, тип возвращаемого значения. То есть, в этом случае у вас что? EXCEPT принимает на вход A ошибку, которую она может кидать.

B это монада, которая будет внутренняя монада трансформера. А последний аргумент всегда это возвращаемое значение. Но у вас это возвращаемое значение, но в данном случае, видимо, никого не волнует. Но его же надо перечислить в какой-то тип. Обычно возвращают той тип, который вводит в плюсах.

Или в джави, или где-то в этом типе. Да, много где. Не совсем, на самом деле, потому что с вайдом можно, кажется, жуткие вещи творить в плюсах, а вот в хаскере это просто обозначает того, что функции ничего не возвращают. Если EXCEPT принимает три аргумента, то там в определении FULL, похоже, скобочки не там стоят. Сейчас, вот тут? Да.

Нет, здесь все правильно. Смотрите. Можно в гугл-презентации уже прикрутить джамборд, чтобы мог показывать это дело. И нам все еще только презентацию видно. Да, сейчас, подождите, у меня просто компьютер тупит.

О! Видно? Отлично. Можно описывать, какая прелесть. В чем-то был вопрос о скобках EXCEPT. Значит, что происходит? Что происходит? У вас тип большинства трансформеров выглядит следующим образом. Это типа NAME.

Значит, давайте-ка я... Ой, какое жуть, какое запаздывание. Типы большинства трансформеров выглядят так. NAME, R, M, A. R где-то какое-нибудь state, environment или exception.

M это внутренняя монада, а A возвращаемого значения. Смотрите. Внутри должна быть монада. Что такое монада? Что такое монада, понятно. Но самое главное, монада это класс, который получает на вход один типовой аргумент.

Забегая вперед, у этой штуки есть такая штука как COUNT. И у него следующее. Звездочка, стрелка, звездочка, стрелка, звездочка, звездочка, звездочка, звездочка. Мак rated 2. То есть, есть эта монада, она получает на вход типовой параметр, который не принимает других аргументов, типовой параметр, который принимает один аргумент, типовой параметр, который не принимает аргументов.

И она получает собственно... Поэтому M в этом случае должно быть что-то, что еще должно принимать один аргумент. Теперь посмотрим обратно на презентацию. У вас ридер t с первым аргументом, с третьим аргументом, с вторым аргументом и с третьим аргументом не принимает больше никаких типовых аргументов, так? Вот. Эксцепт работает точно так же.

Эксцепт с тремя аргументами не принимает других аргументов, а нам нужно что-то, что еще один типовой аргумент будет принимать. Поэтому здесь эксцепт t, r, у него два только аргумента определены, а третий, он на самом деле вот отсюда берется. Понял. Спасибо. Это на самом деле причина, почему у вас монада она в центре.

Ну то есть она в центральном аргументе. Чтобы вы могли их вот так вот комбинировать, было удобнее просто. Короче, это частичное применение. Да, буквально. Я еще буду вам читать одну лекцию, вот где мы подробнее рассмотрим, как это происходит с точки зрения типов.

Мне интересно, сколько туда придет людей, потому что рекорд пока шесть человек. Да, то есть это частичное применение, поэтому здесь отсутствует последний аргумент. Еще вопросы? Пока вроде нет. Окей. Да, соответственно...

Неужели кто-то решил... А, все, окей. Это сколько? Я буду сам в себе читать лекцию, да? Да. Соответственно, да. Не думаю, что это ваше.

А получается, да? А вы знаете, как мы можем правильно использовать эту информацию? Да, хорошо, ну вы понимаете. Значит, если вы не знаете, то лучше почитать. Да, ну можно, конечно. То, что я показывал, вот, я прям, ну сюда стремился, пока я не мог на них расстаться. Это, можно сказать, та как я и делал...

Я! вот это вот добавление нескольких различных эффектов к вашим вычислениям, к вашей функции. Есть еще несколько способов справиться с этой проблемой, на самом деле, и, признаюсь честно, с того, что я слышал на докладах, на самом деле, Monad Transformers, их очень тяжело на продакшен применить эффективно. Есть более эффективные вещи. Но, однако, они самые простые для понимания, потому что все, что остальное, это Free Monads, они сложнее сильно. Вот, собственно, Free Monads позволяют вам, на самом деле, делать вот что-то такое.

То есть вы просто перечисляете вычисления, а потом просто перечисляете эффекты. Да, и это мема из 2000, я даже не знаю какого. Не знаю, кто-нибудь шарит за этот мем или нет. Мне просто интересно, насколько я старый. Капец.

Господи. Так, ладно, презентацию нужно обновлять. Молодые. Вот. Соответственно, что у вас получается? Это выглядит, как реально может хаскельный код выглядеть, когда у вас здесь вот эти эффекты просто перечислены.

Это вот то самое Free Monads, еще куча всего, что мы будем изучать на той лекции, которая жесткая. Вот. Да. Собственно, это все по трансформерам. На следующей лекции у вас, по-моему, лекций не будет, по-моему, у вас будет практика, где вы просто можете посидеть и разбирать эти задачки.

На следующей трансформере я очень советую понять. Потому что, блин, это настолько основа, что любой код, который хотите записать более-менее, чем однострочный, он, скорее всего, будет трансформером в том или ином виде юзать. И сейчас у вас есть время задать вопросы. Вы шарите из-за домашки? В каком-то смысле да, я же отвечаю за их проверку. Ну просто, я думаю, я уже начал писать домашку без использования монад.

А какая у вас домашка сейчас, давайте посмотрим. Там просто порядок немножко изменили. Вот вы спрашивали про парсер, и на самом-то деле домашка-то про парсер, на самом-то деле, потому что у нас клипон, что и является отчасти, если так, в упрощенном формате. А, нет, сейчас, подождите, у вас сейчас задачка нет. Про деревья у вас уже была? Была.

У нас сейчас одна из задач — это сделать рисинг по строке, по символу. Ну, хорошо. Вот, думаю, как бы прикрутить сюда парсер. Ну, смотрите, нет, подождите, в этой задаче... Это какой, таск-3? Таск-2.

Homework-2, таск-2, да? Да. Ну, окей, здесь вам не нужно никаких монад использовать, более того, домашке вообще вам не нужно использовать никаких монад, здесь можно справиться только исключительно всякими фолдами, траверсалами и так далее. Хорошо, да, ну, то есть, высший порядок функция. Надеюсь, будет сказано, когда надо применять монады, чтобы можно было. Я вам так скажу, там по монадам...

Короче, смотрите, когда у вас будет задание на конкретно гигантский парсер, а оно будет, мы его, к сожалению, так и не распилили, вот там прям можете использовать вообще, бомбардировать всем, чем только можно, там и gdt можно использовать, и надо даже использовать, но мы их еще не проходили, там монады можно поиспользовать, какие-нибудь всякие стейты и так далее, вот, там уже на свое усмотрение. Здесь пока что вам хватает всякой банальщины. Трансформеры, тем более, точно нужно применять. Еще вопросы? В этом плане волнует ситуация, когда кажется хватает всякой банальщины, пишешь банальщину, и потом боюсь на ревью получить вердикт, что здесь можно было проще, а потом куча непонятных букв, символов и подобных монописных штук. Давайте так, к моменту, когда вы уже на эту домашнюю, насколько я помню, вы еще монады не прошли.

Или прошли. Да, не суть. Суть в том, что, типа, здесь раньше эта домашня давалась еще до того, как люди проходили монады, поэтому будьте спокойны, вам никто не скажет на вердикте, что все хреново, потому что вы можете сделать проще. Пишите код нормально, красиво и правильно в плане. И вам никто ни за что не снизит.

То есть у меня были просто люди, которые написали откровенно так, что у них там отступ улетает по всей странице, и получается не весь что. Ну, так не надо делать, потому что за такое точно снижать буду. За более-менее красивый код, да пожалуйста. Единственное, что, пожалуйста, я не знаю, вы уже умеете компилировать с опциями VOL и VR? Полагаю, что это не то чтобы Rocket Science. Ну вот да, типа, я просто к тому, что, короче, мне очень сильно не нравится, если есть там мое мнение по домашкам, мне очень сильно не нравится, когда люди оставляют ворнинги в коде, потому что у них есть ворнинги по типу, например, non-executive pattern matching.

Это самое страшное, что вы можете оставить в коде, который вы задаете на проверку, потому что за такое бить по рукам надо. Non-executive pattern matching – это когда вы делаете pattern matching, но не определили все возможные исходы в pattern matching. В этом случае, если у вас прилетит исход, который вы не обрабатываете, у вас на рантайме все сломается. Это такая проблемка, которая, к сожалению, типа, warning, а не вообще-то error. Например, в том же росте она error вполне себе.

Вот, поэтому, если вы такое оставляете, такое будет бить по рукам, а за все остальное – да нет, все должно быть нормально. Еще вопросы? Ну, мне выдавал, выдает ворнинг non-executive, а, incomplete patterns, тоже про pattern matching, но я смотрю, что он выдает и что не матчится, и я считаю, что он категорически неправ, и матчи все правят. Ну, либо вы открыли багу в компиляторе GHC, либо вы все-таки неправы. Ставлю, скорее, на второй вариант. Вот, поэтому...

Ну, просто проблема, скорее, в том, что, говоря про AVL-дерево, ты же разбираешь логику и, в целом, понимаешь, что какие-то варианты не могут наступить. Нет, то, что вы с точки зрения логики понимаете, что варианты могут не наступить, это похвально. Но все равно, и я более вам так скажу, скорее всего, даже наши тесты пройдут. Даже наши тесты, которые должны проверять такую штуку, они, скорее всего, пройдут, потому что, действительно, с точки зрения логики такое невозможно. Компилятор об этом не знает.

Поэтому рекомендую просто, вот в крайнем случае, если вам не получается сделать так, чтобы вы матчингами покрыли вообще все варианты, потому что обычно так можно сделать, добавляйте в конце вот такую штуку. Вот буквально, вообще везде. Это позволяет вам ворнинг, соответственно, нейтрализовать. При этом, если вы с помощью вашего третьего глаза гарантируете, что этот вариант никогда не наступит, он никогда не вылетит. А если вылетит, значит, вы были неправы.

И ворнинг там был не с краса. Такая штука, если что, существует даже в продакшн-коде, когда точно можно доказать, что не вылетит здесь такого варианта. Вообще, по-хорошему, либо покрывать все, либо не делать по-другому, чем. Еще вопросы? Тогда останавливаю запись. На сегодня все.

Или так, например. Месседж любой какой хотите, который означает, что какого-то черта оно дошло до части, до которой оно вообще доходить не должно. Все. На сегодня тогда все. Спасибо.

Всего доброго. До свидания. 