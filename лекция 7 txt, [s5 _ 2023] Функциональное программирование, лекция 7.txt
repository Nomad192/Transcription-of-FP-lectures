0:02
Итак, сегодня мы будем проходить что такое монадные трансформеры, и это
0:07
одна из самых основных техник Хаскеля, которая используется повсеместно.
0:13
В чем, собственно, проблема, которую мы сегодня будем
0:17
проходить? Давайте начнем с повторения небольшого.
0:21
Что такое монада? Вы должны были изучать на прошлом занятии, что монада это
0:27
некоторый способ показать, что определенный код использует определенный эффект.
0:35
То есть, что, например, если вы пишете в шапке функции, что у вас действие происходит в монаде райтера, вы как
0:41
бы добавляете к тому, что вы можете делать здесь, запись в какой-то моноидальный аккумулятор или просто лоб.
0:48
Ридер, соответственно, добавляет вам какой-то
0:50
неизменяемый контекст, ну и так далее.
0:52
То есть, забавно, но если вы посмотрите на любой язык программирования
0:58
OOP, то вы увидите, что там тоже самое есть, просто оно включено по базе.
1:05
То есть, вы, находясь в любом месте, можете делать какой-нибудь
1:08
лог, какой-нибудь стейт хранить, еще какой-нибудь его писать.
1:11
В Haskell'е эти все эффекты нужно подключать по отдельности. Почему? Потому что, во-первых, чтобы избавиться
1:17
от мусора, во-вторых, потому что можно построить оптимизацию на том, что у вас не все эффекты используются.
1:22
Самый банальный пример – это чистые функции, которые без I.O.
1:26
, соответственно, можно оптимизировать на этапе компиляции.
1:35
А теперь задача. Мы хотим применить несколько эффектов к нашей функции.
1:39
То есть, грубо говоря, стимулировать несколько монад.
1:50
Значит, вот то, что вы проходили на предыдущих лекциях, вот у вас есть Reader. То есть, у вас есть
1:55
какой-то environment, который вы не хотите передавать переменно, вы передаете его в монаде Reader.
2:03
А теперь я хочу, чтобы у меня был эффект ридера и стейта. Самый банальный
2:07
пример, который здесь можно привести, например, вы пишите какую-нибудь игрушку.
2:11
И вот в этой игрушке у вас есть какой-нибудь, не знаю, давайте возьмем,
2:15
например, шахматы. И вот у вас есть стейт в виде положения ее фигур на поле.
2:20
То есть, сам стейт игры. И Reader, который отвечает, например, за какую-нибудь
2:26
отрисовку, за параметры поля. Не знаю, выходите вы доску на 64 клетки, а там на 128.
2:33
Я хочу скомбинировать, соответственно, эффекты неизменяемого окружения и
2:37
изменяемого стейта. Как я могу что-то подобное сделать? Какие есть идеи? Тапл.
2:53
Сделать тапл из двух вещей, из двух монад.
2:56
Это плохая идея. Почему? Потому что вы тогда теряете преимущество обоих.
3:01
То есть, вы теряете возможность оперировать внутри монады.
3:07
В этом случае вы теряете преимущество обоих. Вы не получаете
3:12
преимущество двух, вы теряете преимущество обеих. Еще варианты?
3:19
Извините, но можно сделать полный экран?
3:21
Можно, но тогда я не смогу переключаться. А, нет, смогу, все хорошо.
3:29
Спасибо.
3:30
Еще идея? Есть у кого-нибудь?
3:42
Монады над монадой.
3:45
Это финальное решение, не совсем в таком виде, и мы пройдем его чуть дальше.
3:51
Если вы попробуете просто использовать монаду в качестве… то есть,
3:55
написать условно там «reader environment» в скобочках «state» от «a»,
3:59
вы получите преимущество «reader», вы все
4:01
еще не получите преимущество «state» от «a».
4:03
У вас будет «state», который нужно будет как-то разворачивать, что, честно, будет…
4:08
То есть, грубо говоря, каждый раз, когда вы хотите дернуть
4:10
что-то «state»овое, вам нужно будет «run state» использовать.
4:13
Передавать ему «state», но это не позволит
4:15
сохранить «state» на протяжении всего вычисления.
4:20
Еще варианты?
4:25
Хорошо, давайте немножко упростим задачу.
4:27
Хотим чисто «reader», хотим просто, чтобы у нас был «environment» и «state».
4:34
Неважно, там мутабельное, не мутабельное.
4:38
Ну ладно, черт.
4:40
Да, значит, хотим что-то вот такое, чтобы у нас
4:45
был здесь вот «ask», чтобы у нас был здесь «put».
4:49
То есть, «ask» идет у нас от, соответственно, «reader» и «put» от «state».
4:54
Вариант, который никто не предложил.
4:57
Ну, первое — это использовать «rvs».
5:00
Я понимаю, что есть такая манатка «rvs», которая
5:02
совершает себе внезапно «reader», «writer» и «state».
5:05
Вы должны были, вроде, проходить на предыдущих лекциях, была?
5:12
Да нет, кажется.
5:14
Серьезно? Окей.
5:15
Ну, знаете тогда, что есть такая манатка «rvs»,
5:21
которая — это буквально тупо комбинация «reader», «writer» и «state».
5:26
То есть, она обладает неизменяемым «environment», изменяемым «state»,
5:30
и еще какой-то аккумулятор есть, в который можно писать логи.
5:34
Второй вариант, который хорошо, наверное, что никто
5:37
не предложил — это использовать чистый «state».
5:40
То есть, мы просто храним и «environment», и «state» внутри «state».
5:44
Возможно, можно расширить варианцию с тупом.
5:47
Да не тупо, а тупо.
5:49
До вот этого состояния.
5:53
Почему эти варианты плохие?
5:55
В «rvs» оно работает нормально, но появляется какой-то
6:00
лишний «writer», который вообще-то непонятно кому нужен.
6:01
Главное, что там может очутиться в какой-то момент,
6:04
что-то совершенно не должно там оказываться.
6:07
В случае же «state» мы теряем, собственно, доступ к неизменяемому «environment».
6:14
Ну и вам, наверное, не хочется, чтобы ваша
6:16
шахматная доска в какой-то момент сказала «оп»,
6:19
и посреди партии расширилась до 128 клеток.
6:23
Будет весело.
6:28
И, да, собственно, вот решение, которое является
6:32
комбинацией двух модат, так называемые «трансформеры».
6:33
Можете заметить, что они используют имена стандартных модат,
6:39
только приписывается буква «т» в конце.
6:41
Ну, так, во всяком случае, по код-стайлу.
6:46
А теперь вопрос, что изменилось.
6:49
Посмотрите на ассигнатуру функции и скажите, что изменилось.
7:10
Тяжелая публика.
7:13
Можете заметить, что у вас изменилось количество аргументов в «reader».
7:17
В «reader» изначально было два аргумента.
7:19
Это «environment» и тип возвращаемого значения.
7:21
Сейчас у вас появилось третье.
7:23
Это «state int».
7:24
То есть, третий аргумент.
7:26
Замечу, что вот здесь написано через «state» то же самое.
7:29
То есть, эти две штуки, по факту, равносильны.
7:32
И здесь тоже.
7:32
Если вы посмотрите на «state», там тоже.
7:34
Значит, у вас был один «state».
7:35
Одна типовая перемена означала «state».
7:38
И одна означала возвращаемое значение.
7:39
Сейчас у вас появилось еще промежуточный аргумент.
7:44
Понятно пока, что происходит?
7:56
Сейчас у нас еще равный оружий.
7:58
Здесь есть не равный оружий.
7:58
Там есть отрицательное оружие, а здесь нет.
7:59
Поэтому, вы видите, что в нашей локации пока нет вашего оружия.
8:05
равно на два из таких уровня наше оружие.
8:06
Только то, что у нас есть не в таким уровне.
8:06
И то, что вы видите здесь или ещё.
8:11
Повторяем.
8:14
Вот здесь, например, у нас ровно на тремя
8:15
уровнях растута переверенная аргументность.
8:15
Если вы не понимаете монады к сегодняшней лекции, то это очень плохо.
8:19
И давайте вы мне лучше по ним задавайте вопросы.
8:27
Риберт, он же тоже возвращает монаду или какой-то другой объект?
8:35
Смотрите, формально он возвращает монаду.
8:39
То есть из него мы сейчас увидим его тип.
8:44
Проблема одна из этого принципа монадных трансформеров заключается в том,
8:48
что вам потом в конце концов придется все это дело развернуть.
8:51
То есть сначала передать environment, применить reader, развернуть это в state,
8:56
и потом передать один раз state и получить там уже результат.
9:01
Отличие от того, что предлагалось с использованием обычного reader,
9:04
когда у вас просто reader и в него вы возвращаемое значение передаете,
9:08
заключается в том, что вам там нужно было передавать всегда,
9:11
когда вы что-то стейтовое хотите использовать.
9:14
Здесь вам так не нужно делать.
9:16
Здесь вам нужно это все сделать один раз,
9:18
но если это нужно развернуть, оно получается достаточно большим.
9:24
С правильной версией радио стоит заметить,
9:25
что разворачивается это обычно только один раз в каком-нибудь мейне,
9:28
потому что обычно вот таким гигантским трансформером
9:30
обвешивают почти все вычисления в проекте.
9:34
За исключением, очевидно, чистых каких-то вещей.
9:38
Сейчас, если этот трансформер разрешает
9:42
монаду, при этом сам комбинирует две монады,
9:45
как для него реализованы стрелочки и его return?
9:48
Это мы сейчас увидим.
9:49
Дальше будет и типы, и, соответственно,
9:54
там, по-моему, даже будет instance написано.
9:56
Да, там точно будет пара инстансов.
9:58
Можете посмотреть.
9:59
Хорошо.
10:01
Еще вопросы?
10:05
По монадам, по синтаксису, по чему угодно.
10:09
Просто чтобы все понимали, что происходит.
10:16
Ну ладно, поехали дальше.
10:20
Окей, значит, у вас, соответственно,
10:22
вот такая конструкция позволяет
10:24
использовать комбинацию монад.
10:28
Почему вообще нам нужно так разворачиваться?
10:30
Потому что есть одна проблемка.
10:32
Если вы возьмете функторы, аппликативы, альтернативы,
10:35
все вот эти вещи, которые проходили на третьей лекции,
10:39
то у них есть одна особенность.
10:40
Они композируемы.
10:41
То есть, грубо говоря, если у вас есть, представьте, вот
10:44
этот new type, он абсолютно фикшен, но идея вот в чем.
10:48
Представьте, что у вас есть какая-то некая композиция.
10:50
То есть вы делаете композицию, там, функтор от чего-то.
10:55
Так вот, если f это функтор и g это функтор,
10:59
то композиция f и g функтор.
11:02
Или это можно прописать так, что у вас буквально сразу получаете правило,
11:06
то, как вы должны действовать для композиции,
11:09
чтобы получился функтор.
11:11
То есть из того, что f функтор и g функтор, вы сразу получаете то,
11:14
как instance функтора выглядит для их композиции.
11:17
То же самое, верно, для foldable, traversable,
11:18
аппликативы, альтернативы, для всего, кроме монад.
11:21
Для монад такой фигни нет, и оно не работает.
11:24
Почему? Ну, упарывайтесь в категории типов.
11:27
Почему композиция монад, а не монада?
11:30
Типов в категории.
11:33
Поэтому вы формально можете сделать такую композицию,
11:36
просто в каждом отдельном случае ее нужно определять отдельно.
11:39
Часто может показаться страшным, что мы сейчас, если хотим
11:43
выкомпозировать больше, чем две монады, то это надо умереть.
11:44
Это не так работает.
11:46
Это гораздо проще.
11:50
Поэтому все монады, все трансформеры мы должны описать
11:54
ручками самостоятельно, как у них выглядят instances.
11:56
Вот давайте приведем пример с мэйби.
11:59
Хотим что? Хотим ио-действие и какой-то мэйби.
12:02
Вот это тоже вполне себе продакшн вещь.
12:05
То есть мы хотим иметь возможность сделать какое-то ио-действие,
12:08
которое непонятно, оно дойдет вообще или нет.
12:10
Подключимся мы к базе, подключимся к серверам, не подключимся.
12:14
Обычно это как раз таки обозначается тем, что у вас возвращается какой-то натрин.
12:18
Ну, ладно, в рул обычно это обозначается тем, что какой-то экрепшн возвращается,
12:22
так что там, скорее всего, не мэйби, а какой-нибудь эксерт.
12:25
Но, тем не менее, вполне себе рабочий пример.
12:30
Да, и, соответственно, написать мы хотим вот так.
12:33
Замечу, что вот это как раз таки реализация того
12:35
подхода, который предлагался как в качестве ридера,
12:38
в качестве возвращаемого значения использовать стейт.
12:40
Вот заметите, что вы здесь каждый раз, пополняя какое-нибудь
12:44
ио-действие, получаете в результате какой-то мэйби,
12:47
который вы должны разворачивать.
12:49
Ну, мэйби разворачивать достаточно просто,
12:50
а в случае стейта вы должны были сюда, там,
12:52
run стейт, передать стейт и так далее делать.
12:56
Вот, и если у нас, соответственно, нужно законнектиться к нескольким хостам,
12:59
или у нас несколько операций, которые различают мэйби,
13:00
нужно творить всю вот эту громадю каждый раз.
13:04
Понятно?
13:08
Да.
13:10
Окей.
13:12
Значит, хотим это скомбинировать, получаем мэйби-ио.
13:15
Это вот некий абстрактный пример.
13:18
Что у нас здесь?
13:19
Заметьте, что вот у нас тип стал чуть-чуть похуже,
13:25
но вот видим, что у нас мы запихнули вот этот ио.мэйби.
13:30
а внутрь конструктора.
13:31
И давайте теперь определим для него инстанс монады.
13:34
В чем и дело?
13:35
Ну, ретурн, понятно, да, то есть это всегда это мэйби.
13:36
ио, сначала завернуть в мэйби,
13:39
потом завернуть в ио,
13:41
потом завернуть в мэйби.ио.
13:45
Понятно? То есть от обратного идем.
13:47
Сначала вот это значение, потом вот это значение, потом вот это все.
13:51
Вот, с экшеном повеселее.
13:53
На самом деле нет.
13:55
Результат у нас все еще должен быть завернут в мэйби.
13:58
ио, в нем должно быть ио действие, так что вот это ио.
14:01
В ио мы выполняем результат экшена.
14:04
Экшен, напоминаю, у нас, соответственно, экшен это ио.
14:08
мэйби.
14:12
а действие, то есть вот у нас вот это ио, результат получается типа имеет мэйби.а.
14:15
Дальше проверяем результат и заворачиваем все это дело в результат.
14:21
Понятно, как устроен инстанс монады для мэйби.
14:28
ио? Да.
14:30
То есть здесь все достаточно тупо.
14:34
Заперформили экшен внутри ио монады,
14:37
получили результат, который мэйби, проверили, чему он этот мэйби равен,
14:40
и завернули все это дело в мэйби.ио обратно.
14:45
Вот, теперь у вас все.
14:47
Теперь у вас все довольно таки тупо.
14:51
Более того, на самом деле вот этот мэйби.ио можно вынести вот сюда.
14:57
Проблема в чем?
14:58
Теперь я хочу посреди всего этого дела
15:01
использовать просто тупо ио действие.
15:03
То есть вот этот printHello, он чистый ио, он не возвращает мне мэйби.
15:08
Понятно?
15:11
И вот так мы делать не можем.
15:15
Ну, потому что они по типам не сходятся, да?
15:16
Здесь у нас runMaybe.io применяется к мэйби.ио, очевидно.
15:20
Это у нас чистый ио, потому что там результатом
15:23
не является мэйби, там является пустой тупо.
15:26
Что мы делаем?
15:28
Мы делаем простой трансформ.
15:29
Мы perform результат и оборачиваем его в мэйби.
15:34
То есть оборачиваем его в just.
15:36
Получаем некоторую функцию,
15:37
которая любое действие иошное позволяет трансформировать мэйби иошное действие.
15:43
И теперь это все выглядит достаточно травоядно.
15:49
Опять же, это все еще можно сократить немножечко.
15:51
Нужно каждый раз применять конструктор мэйби.ио к действию.
15:57
Собственно, на самом деле мы сейчас получили просто define под мэйби.т трансформер,
16:00
потому что вы заменяете его на любую произвольную монаду
16:05
и получаете вот таким же образом буквально дефайните
16:10
типа инстанции монады для этого мэйби.т.
16:15
Понятно?
16:20
Инстанция, например, будет точно такой же.
16:24
Собственно, вот это вы можете увидеть.
16:31
Вопросы по мэйби.т, как мы его получили?
16:39
Вопросы по вот этой штуке.
16:44
Тут-то все вроде понятно,
16:46
а вот все-таки последний переход к мэйби.т был не до конца.
16:51
Вот тут?
16:52
Ну, пожалуй, да.
16:55
В двух словах, мэйби.т, для чего они нужны, трансформеры, если подвести?
17:01
Смотрите, для чего вообще нужны трансформеры?
17:04
Для того, чтобы я мог применить...
17:06
Смотрите, еще раз, пытайтесь узнать следующую вещь.
17:10
В ООПшке, там, допустим, возьмем какой-нибудь
17:13
питон, у вас все эффекты включены по умолчанию.
17:16
То есть у вас включено ИО-действие,
17:18
у вас включены всякие логи,
17:21
стейты, инвайрмент какой-нибудь включен.
17:24
Это все у вас есть по умолчанию.
17:27
В Хаскеле у вас по умолчанию буквально нет ничего, кроме чистой функции.
17:30
Чистая функция не имеет ничего.
17:32
На самом деле, да, если кто-то сомневается,
17:36
монологические действия, кроме ИОшных, они тоже чистые.
17:41
Соответственно, у вас по умолчанию в Хаскеле все эффекты выключены.
17:44
И вам нужно добавлять их, чтобы вы могли ими пользоваться.
17:50
В предыдущих главах, в предыдущих лекциях,
17:52
вы использовались либо никакими эффектами, либо всегда одним эффектом.
17:56
То есть у вас есть всегда ридер, у вас есть какой-нибудь мэйби, у вас есть райтер.
18:00
Вот он в шапке функции написан, вот у вас один эффект подключен.
18:03
Теперь я хочу подключить несколько эффектов.
18:06
То есть я хочу несколько каких-то фич подключить.
18:09
То есть у меня по умолчанию нет записи ввода-вывода.
18:12
Я не могу писать ввод-вывод, потому что его нет по умолчанию.
18:14
Я хочу его подключить.
18:16
Дальше у меня есть... На самом деле, на примере сейчас на этом будет.
18:27
На самом деле, вот это самый хороший пример.
18:30
Вот, например, использование ридера и.о.
18:32
То есть я хочу иметь доступ к невменяемому окружению
18:35
и иметь возможность писать какой-то и.о. экшен.
18:37
Сейчас не смотрите на код, мы к нему придем.
18:39
То есть, смотрите, вот вы, допустим,
18:42
описываете подключение к базе данных из какого-нибудь кода.
18:45
У вас есть креденшел, так сказать, база данных,
18:48
там логин, пароль, название АБД, что-то такое.
18:50
И вы хотите делать и.о.
18:51
, потому что доступ в сторонние сервисы – это всегда и.о.
18:55
Бегать на сервер – это и.о.
18:56
Бегать в базу – это и.о.
18:59
Вот.
19:00
Соответственно, вы хотите иметь конфликт,
19:02
с которым вы всегда можете креденшел почитать.
19:04
И вы хотите иметь возможность писать и.о. экшен.
19:07
Для этого вы не могли так сделать, потому что у вас всегда был один эффект.
19:09
То есть вы либо пишете, либо у вас есть environment.
19:14
Теперь вы можете их комбинировать, с помощью трансформеров вы можете комбинировать
19:17
различные эффекты, причем до бесконечности.
19:19
То есть не только два эффекта можно комбинировать,
19:20
можно комбинировать бесконечное количество эффектов.
19:22
У меня может быть ридер от фрайтера, от стейта, от и.о.
19:25
, от айзера, там черт знает чего еще.
19:28
То есть вы можете создать комбинацию только тех
19:31
эффектов, которые вам нужны для выполнения задач.
19:36
Понятно?
19:39
Да.
19:40
Maybe.t в этом вопросе мне не очень нравится.
19:43
Почему?
19:43
Потому что, на самом деле, я, по-моему, один раз в жизни видел,
19:46
как кто-то применяет maybe в количестве монады,
19:50
и код от этого выглядит очень хреново.
19:55
Вот.
19:55
Поэтому дальше будет, наверное, не очень понятно.
19:58
Но идея в чем?
19:59
Вот у вас есть эффект монады maybe, который означает, что у
20:02
вас в какой-то момент веществения могут завершиться с ошибкой.
20:04
Плевать какой, просто они упали с ошибкой.
20:06
Может не привести к результату, который вы хотите.
20:08
И у вас есть при этом и.о.
20:10
То есть можете читать это как, у вас есть и.
20:11
о. действия, которые могут завершиться с ошибкой.
20:15
Понятно?
20:19
Угу.
20:21
Так, еще вопросы.
20:26
У нас тут целых девять человек.
20:30
В примере с maybe.t и try-connect сделать print,
20:34
нам пришлось написать transformed.
20:37
io и потом его доставать.
20:40
Вот если мы скомбинируем больше монад, чем две,
20:44
нам для того, чтобы добраться до и.о.
20:46
придется еще много букв писать.
20:50
Плохая новость – да.
20:53
Хорошая новость – очевидно, это проблемы, которые решили.
20:57

20:59
Мы потом покажем,
21:00
потом подальше покажем как.
21:02
Но сейчас считайте, да, если у вас много эффектов,
21:05
это вот, собственно, называется, да, давайте покажем следующий слайд,
21:08
это называется функция lift.
21:11
Да, если вот видели слоган Серокина –
21:14
your expectations lifted, так вот lifted – это вот отсюда lifted.
21:19
Да, у него есть некоторые законы о том, что lift и return – это просто return,
21:23
и lift байнда – это lift сначала одной монады,
21:26
bind в lift функцию.
21:31
Лифт позволяет вам поднять одну монаду в другую монаду.
21:35
Понятно?
21:41
Посмотрите на тип.
21:42
То есть у вас была какая-то обертка над возвращаемым значением,
21:45
теперь вы завернули это все дело в еще одну обертку,
21:49
теперь над двумя типовыми переменными.
21:51
Заметьте, что скобок здесь нет, то есть это t принимает на вход две
21:55
типовые переменные.
21:58
Эта штука называется kind, by the way.
21:59

22:03
Окей? Так, хорошо.
22:11

22:12
Кроме Романа, еще все все понимают? Так, да.
22:18

22:20
Сейчас сдерну рандомного кого-нибудь, спрошу вопросы.
22:24
Ладно.
22:27
Да, соответственно, вот у вас, да, эта штука называется
22:30
monotrans, ну и, соответственно, для трансформеров нужно определить
22:33
внезапный instance monotrans, который позволяет делать lift.
22:39
Там еще пара функций есть, но главное – это lift.
22:43
Да, ну вот на тему написания
22:47
кода в адекватном виде,
22:51
вот у вас, соответственно, то, что я говорил, вот у вас вы лифтите putString,
22:58
потому что он в IO чисто,
23:03
вы лифтите getLine,
23:04
потому что getLine тоже IOC,
23:10
Вы не лифтите email as valid, потому что у вас нет здесь монада, логично.
23:23
Вот, и все. А дальше здесь, соответственно,
23:26
в майне вы делаете просто run mybt и все.
23:31
Да, until success функция здесь, если что, она просто повторяет
23:35
действие, пока оно не завершится чем-то, кроме nothing.
23:44
Да, у mybt, соответственно, есть альтернативы, которые позволяют делать вот так.
23:55
Ну, то есть, еще раз, фиговый пример, потому что mybt не очень хорошо, не
23:59
очень красиво выглядит в реальной жизни, если использовать какую-то монаду.
24:04
Вот, вот это повеселее пример. Вот environment.
24:08
io, то есть, reader.io, это, короче, самый часто используемый паттерн в Haskell.
24:13
Ну, то есть, буквально почти все, что вы увидите, на самом деле,
24:16
под капотом это какой-нибудь ридер с каким-нибудь state.io.
24:19
Там еще иногда except замешивают, чтобы у вас еще ошибки правильно разрабатывались.
24:23
Но почти все это, на самом деле, environment.io.
24:25
Любая коннекция к базе данных – это environment.
24:29
io, любой сервер – это environment.io, любое логирование – то же самое.
24:35
Вот. Ну, да, соответственно, что мы имеем? Вот у нас есть раньше, чем было.
24:39
Вот мы хотим записать какой-то лог, вот у нас логер.
24:42
name, файл.path, мы его должны передавать.
24:44
Почему? Потому что мы здесь не можем использовать ридер, у нас здесь уже его.
24:48
Окей.
24:53
Хотя они передаются вот через все вот эти функции.
24:59
Тянем за собой хвост.
25:02
Зачем? Вот. Идем в ридер, и вот, кстати, вопрос о типе.
25:05
Весь у ридера, если помните, типа r-стрелка a, теперь r-стрелка m-a.
25:09
То есть, действительно, когда вы применяете run ридера и
25:12
передаете ему environment, он возвращает вам внутреннюю монаду.
25:15
И к ней уже надо будет свой run применить, чтобы ее достать.
25:19
Но это применяется еще раз только, когда вы
25:21
хотите вернуть деятельность в какой-нибудь I.O.
25:26
Вот. И вот здесь, смотрите, вот мы создаем логер I.O.
25:28
То есть вот у вас ридер t, логер.name I.O.
25:33
Замечу, смотрите, здесь мы просто... это тупо type alias.
25:37
Это тоже часто применяемая техника, когда вот в этом
25:40
type alias у вас определены параметры внутренней монады и определенный environment.
25:46
По сути, мы здесь передаем просто... мы создаем новую монаду.
25:50
По факту это просто ридер с определенными двумя параметрами.
25:54
Понятно?
25:59
Да.
26:03
Окей.
26:04
Ну и, соответственно, что мы делаем?
26:07
Теперь у нас все просто, тупо мы логируем, если нам нужен доступ к этому самому,
26:11
то мы можем всегда из этого environment получить данные по файлу, например.
26:26
Не вижу ни одного примера.
26:27
На самом деле, тем мы что-то из environment достаем здесь.
26:33
А, ну окей.
26:34
Видимо, у нас есть log message, который там из него достает.
26:38
Вот.
26:40
И все.
26:41
И вот runRider вы применяете здесь только в одном месте, в main.
26:45
Единственное, что здесь не приходится разворачивать I.O.
26:47
Потому что main тоже в I.O.
26:52
Пока понятно?
27:01
Гробовая тишина.
27:03
А что непонятно?
27:07
Ну, лично я пытаюсь вчитаться в код, поэтому и молчу.
27:12
Хорошо.
27:21
Можете подробнее что-то поделиться на что?
27:26
Можно как-то объяснить код чуть-чуть?
27:29
Ну, смотрите, у вас есть просто несколько функций, которые умеют что-то логировать.
27:35
Условно, у вас есть функции записи, чтения файла, какой-то prettify файл content,
27:42
который как-то меняет то, что у вас в файле написано.
27:45
И на каждое ваше действие вы хотите логировать это дело.
27:48
На каждое ваше действие вы хотите в данном случае в stdout писать какой-то лог.
27:58
Вот.
28:01
Соответственно, каждое ваше действие readfile.withlog это просто что?
28:03
Это readfile, и до этого вы делаете какой-то log message.
28:08
Предположим, что функция log message, она умеет доставать из environment,
28:14
надо бы ее написать, кстати,
28:15
она умеет доставать из вот этого environment, из logger name,
28:18
она умеет доставать куда писать, что писать, ну там, в std.
28:21
in или в какой-нибудь отдельный файл, и она как-то этим environment пользуется.
28:27
Чтобы не передавать этот environment везде, вот здесь
28:30
во всех этих функциях, вы используете MonadoReader,
28:32
так же, как вы это использовали во всех предыдущих занятиях.
28:38
Но поскольку, помимо того, чтобы использовать
28:41
неизменяемое окружение, вам нужно еще делать его действие,
28:44
то есть писать в какой-то output канал,
28:47
вы используете трансформер.
28:50
Понятно?
28:53
То есть, еще раз, функция log message умеет получать доступ к environment.
28:58
Чтобы не передавать этот environment через каждую отдельную функцию,
29:00
при каждом вызове этих функций, вы передаете его один раз в меню,
29:06
а потом, соответственно, претифия файл content, он читает с логом, читает с логом,
29:12
делает запись в лог, записывает с логом, делает запись в лог.
29:20
Понятно?
29:23
Можно задать вопрос по поводу read file?
29:28
Как я понимаю, log message возвращает нам нечто в логер.
29:35
io, а lift в следующей строчке возьмет и текст приведет к логер.io.
29:43
Ну, read file возвращает его, так что он его приведет к логер.io.
29:48
Кстати, тут баг, похоже, да.
29:52
Смотрите, давайте так.
29:54
Окей, это не совсем баг.
29:57
Тип read file with log – это логер.io текст.
30:03
Аналогично, да, собственно.
30:04
Нет, совсем нормально.
30:08
Read file имеет тип .io текст.
30:14
И lift поднимает его в логер.io текст.
30:19
Поэтому, собственно, и lift.
30:20
Ну, то есть, и lift...
30:23
Что это за лифт, откуда он?
30:26
Ведь, получается, лифт должен знать, как это... Вот, лифт – это из monad.trans.
30:35
Давайте так.
30:36
Здесь не написано, что read.t – это monad, хотя всем это очевидно.
30:40
Но у него также должен быть очевидный instance monad.
30:42
trans, если это трансформер.
30:44
Если у него есть instance monad.trans, то там лифт, очевидно, берется из instance.
30:53
Еще вопросы?
31:00
Ну, давайте, поехали дальше.
31:03
Да.
31:06
Замечу, что вообще все ваши стандартные монады, которые проходили,
31:09
типа reader, writer, state – это все, на самом деле, трансформеры.
31:15
Просто они являются алиасом на трансформере, где определена монада identity.
31:20
Монада identity не делает ничего.
31:22
Она как раз нужна как такая заглушка, когда нужно передать какую-то монаду,
31:26
но не нужно передать монаду, которая что-то делает.
31:37
Да, кто хотел увидеть instance монада для reader.t, вот он вот такой.
31:42
Monad.trans, соответственно, вот такой.
31:48
А почему у нас reader является трансформером, который принимает identity?
31:53
Зачем нам это делать?
31:54
Почему не достаточно отдельно монады?
31:57
А зачем?
32:01
Грубо говоря, если вы делаете отдельно монады reader,
32:03
вам нужно определять заново монад instance для нее,
32:09
или всякие там аппликативы, альтернативы, что там еще у reader определено.
32:13
Если вам нужно определить…
32:15
Более того, у вас бывает такое, что вот у вас есть reader, да, reader.
32:19
t, и у него какие-то полиморфные монады.
32:22
И вот в одних случаях вы хотите какую-нибудь action туда передать,
32:26
ну там, только логирование какого-нибудь левого.
32:28
А вот в другом случае вы не хотите.
32:30
Вы хотите, чтобы у вас был четыридер, и все.
32:34
Ну, из самого тупого, наверное, смотрите, пусть у вас есть какая-нибудь…
32:38
пусть у вас выпишите код, который входит в базу данных, да.
32:42
Вот для того, чтобы протестировать функционал, вы хотите написать, во-первых, да,
32:48
чтобы вы могли ходить, собственно, непосредственно в базу,
32:51
но также вы хотите написать какой-нибудь
32:53
тестик, где вы ходите, на самом деле, не в базу,
32:55
а просто там, типа, какую-нибудь константу возвращаете на запрос.
32:59
И вот в первом случае его вам нужно,
33:02
во втором случае его вам не нужно.
33:06
Вот, если вам его не нужно,
33:09
вам не нужно тогда писать несколько различных функций.
33:12
Одну с reader.t, другую просто с reader.
33:14
Вы просто передаете identity,
33:15
когда вам не нужен другой какой-то эффект, кроме reader.
33:18
Понятно?
33:25
Ну, вроде бы, да.
33:30
Да, значит, на то, что справа, пока не обращайте внимания,
33:32
он тут преждевременно, тут какая-то картинка.
33:39
Вот.
33:41
Так, если здесь все понятно, давайте посмотрим на табличку.
33:44
Вот у вас типы, соответственно, базовых монад,
33:47
типы трансформеров, вот как они меняются.
33:53
Да, вот, соответственно, то, что у вас было...
33:56
Грубо говоря, у вас результат всегда теперь заворачивается в монаду.
34:01
Я не знаю, проходили конт-монаду?
34:04
Знаете, что это такое? И я не помню.
34:07

34:09
Поэтому тогда я не буду мешать на ваше внимание.
34:12
Но вот state, writer, reader...
34:14
Господи, writer, reader, state.
34:16
Вот запомните.
34:19
Вот так вот работают.
34:21
Да, на всякий случай, если вдруг у вас возникнет такая ситуация,
34:28
что вам нужно комбинировать reader, writer и state, используйте тогда RWS.
34:32
Это просто проще с точки зрения синтексиса.
34:36
Да, и у RWS все еще есть трансформеры, так что есть RWST.
34:39
И у RWS тоже есть трансформеры.
34:43
Окей.
34:44
Идем дальше.
34:46
Да, можно заметить, что в этой табличке нет иошки.
34:49
Иошка не трансформируется.
34:54
Почему его не трансформируется, вопрос интересный.
34:57
Если вкратце, то потому что, если его трансформируется,
35:00
вам в какой-то момент можно будет захотеть сделать какие-то очень,
35:06
скажем так, пагубные вещи с иошкой.
35:08
В том смысле, что вы не сможете написать монадный инстанс для нее.
35:13
Например, вы не сможете написать,
35:16
как будет выглядеть монадный инстанс в случае ио и мэйби.
35:19
То есть, если у вас не ио, а мэйби,
35:30
в мэйби ио было можно использовать комбинацию ио и мэйби.
35:34
В обратном порядке ее использовать нельзя.
35:39
То есть, ио не трансформируется.
35:43
Есть только такой монад ио,
35:47
который позволяет вам лифтить специально ио действие в другую монаду.
35:56
Может показаться, что эта штука стирает нечистоту иошки, на самом деле нет.
36:03
Эта штука нужна исключительно потому, что ио у вас всегда в самом конце.
36:07
В самом конце цепочки трансформеров.
36:13
Поэтому его надо всегда поднимать с самого низа на самый верх.
36:17
Да, потому что нужно делать эту операцию поднятия.
36:19
Вот это последовательность монад,
36:22
трансформеров и их аргументов называется монадным стэгом.
36:26
То есть, то, что у вас был reader t от state t от writer t,
36:29
это называется монадный стэг.
36:34
Понятно?
36:56
Внезапно вы увидите, что то же самое происходит с инстанцией monad.trans.
37:03
У вас достаточно тривиальные инстанции получаются,
37:07
но их просто много.
37:11
Монадный стэг называется монадным стэгом.
37:14
То есть у вас state от reader.
37:17
Мы вернулись к оригинальной задаче.
37:20
Мы действительно теперь можем скомпозировать state и reader, или reader и state,
37:24
и получить то, что мы хотели.
37:29
То есть мы получаем доступ к environment,
37:33
и мы получаем возможность записать state.
37:37
Пока мы не перешли к MTL,
37:40
здесь понятно все, что до этого было?
37:45
Получается, порядок трансформирования монад важен или не очень?
37:50
То есть в чем разница между state t от reader или reader t от state?
37:55
Смотрите, конкретно в этом случае вообще не важно.
37:57
Здесь мы могли написать reader t от state, это было бы совершенно легитимно.
38:03
Важен он становится,
38:06
когда у вас появляются штуки, которые могут ломать вам,
38:11
когда могут ломать вычисления.
38:13
Это, соответственно, ситуация либо с иоркой, но с
38:16
иоркой все просто, она всегда должна быть внизу стэга,
38:21
либо еще там появляются веселости, мы сейчас чуть
38:24
позже их увидим, когда у вас появляется accept.
38:28
Ломать вычисления, это в плане, как у нас в случае с maybe,
38:32
там по nothing было замыкание, вот это вот?
38:36
Ну, типа того, да.
38:37
То есть у вас, например,
38:38
при определенных комбинациях accept и state,
38:41
да, если что, accept это просто трансформер either.
38:45
Единственное, почему-то, что у вас, у всех трансформеров называется,
38:51
точнее у всех моделей трансформеров называется буквка t в конце,
38:53
а вот у either почему-то он не either t, а accept t.
38:59
Честно не знаю почему.
39:00
Суть в том, что у вас,
39:02
в зависимости от того, в какой момент вы прокинете вот это исключение
39:05
через accept, у вас может стоить либо сохраниться, либо нет.
39:11
Оно как бы там,
39:13
это логически понятно, почему так происходит,
39:17
да и по смыслу тоже понятно.
39:19
Но вот сам факт того,
39:20
что если вы просто бездумно влепите, вы можете в какой-то момент получить,
39:23
что у вас вылетает ошибка, и из-за этого у вас state не сохраняется.
39:34
Окей, еще вопросы?
39:42
Тогда переходим к MTL.
39:44
Да, собственно, как бы кто-то заметил,
39:46
у вас есть как минимум одна сейчас проблема, у вас куча лифтов.
39:52
Вот.
39:53
Более того,
39:56
мы хотим делать еще одну штуку.
39:59
Мы не хотим каждый раз,
40:00
мы хотим добавить еще больше полиморфизма.
40:03
Мы не хотим каждый раз указывать конкретную монаду, а
40:07
вместо этого мы хотим указать как бы эффект, который,
40:09
который какая-то,
40:12
господи,
40:14
мы хотим указать набор эффектов,
40:16
который монада должна обладать, чтобы мы могли в этой функции работать.
40:20
Понятно?
40:21
То есть не всегда писать, что вот у вас state reader,
40:23
что вы можете передать абсолютно любую монаду,
40:26
главное, чтобы она умела делать вот эти вещи.
40:29
Для чего это нужно?
40:30
Потому что мы хотим,
40:34
чтобы у нас было чуть-чуть больше полиморфизма.
40:36
Смотрите, например, у нас
40:38
некоторые функции хотят ЙО и Ридер,
40:43
некоторые функции хотят Ридер и Стейт,
40:45
некоторые хотят ЙО и Стейт.
40:49
Так что,
40:50
и, соответственно, чтобы этими функциями
40:54
Мы хотим сделать следующее. Мы хотим, чтобы каждая
40:57
из этих функций просто указывала, что она хочет.
40:59
Что она хочет, чтобы мы могли получать
41:01
доступ к environment и получать доступ к его.
41:04
Что она еще умеет, какие еще эффекты есть у
41:06
polymorph на этой монаде, нас не интересует.
41:08
Поэтому мы один раз загоняем какую-то большущую монаду, большущего
41:13
стека, вида reader, writer, state, except, черт еще что знает.
41:17
А потом, соответственно, каждая из этих функций будет
41:21
использовать только определенные эффекты, которые в ней есть.
41:24
Для этого мы вводим специальный пакет mtl.
41:28
Пакет называется mtl, так же и метод называется.
41:36
MonadTemplateLibrary, но сейчас я уже не помню.
41:39
Суть в чем. Мы вводим некоторый класс. Класс, например, MonadReader.
41:45
MonadReader, который означает, что мы умеем
41:48
читать какой-то environment, и что это монада.
41:55
И таким образом у вас получается следующее.
42:03
Вы, соответственно, можете передать сюда любую монаду, в которой
42:07
где-то там в стеке есть reader, и мы умеем из него читать.
42:12
Меное определенное производство для нее является
42:14
монад reader, определяется достаточно превиальным.
42:17
Здесь есть один элемент, который вы не знаете до сих пор, кто его видит?
42:25
По-хорошему должен быть тот вопрос, а что вот это за код?
42:28
Вертикальная черта меня напрягает.
42:31
Вот, правильный пример.
42:33
Это немножко легоси, называется фундепа,
42:36
рациональная зависимость.
42:38
Эта штука как бы гарантирует компилятору,
42:41
что если у вас есть определен инстанс MonadReader
42:47
для какой-то Monad M,
42:49
то вы всегда знаете, для какого environment он определен.
42:52
То есть, грубо говоря,
42:53
данное M сразу определяет вам environment.
42:59
Что это означает на практике?
43:00
На практике это означает, что вы определили MonadReader R1M,
43:07
вы не можете определить MonadReader R2M.
43:13
Компилятор скажет, ребята, у вас там фундеп, не надо так.
43:16
И не скомпилирует.
43:21
Для чего это сделано?
43:22
Это сознательная лимитация.
43:26
Почему?
43:26
Потому что, смотрите, вот у вас есть ASK.
43:29
ASK M R, то есть он просто возвращает вам environment.
43:33
Вот у вас есть, допустим, MonadReader,
43:35
определен для двух разных environment, для одной Monad.
43:41
Вот вы делаете ASK.
43:42
Вопрос, какой environment вы получите?
43:47
Тут по-хорошему бы надо что-нибудь нарисовать или написать.
43:53
Давайте я попробую в комменты тогда написать.
44:02
Что я имею в виду, потому что важно для понимания.
44:06
Предположим, что у меня есть...
44:20
Ладно, сейчас не буду писать, а потом скину флешку, чтобы все видели.
44:27
Еще раз, идея в чем.
44:29
Вы не можете определить два инстанса MonadReader к одной Monad,
44:33
так, чтобы из них получались разные environment.
44:36
Понятно?
44:40
Ага.
44:44
Кому-то кроме Романа и Федора понятно?
44:51
Анастасия, Кристина, Юрий.
44:56
Остальных я, к сожалению, имена не выговорю.
44:59
Можно ли это трактовать как интерфейс?
45:06
Накладывание каких-то ограничений?
45:09
Как накладывание ограничений, да.
45:10
Интерфейс это немножко другое.
45:13
Интерфейс это про то, что вы делать можете, а
45:16
здесь скорее про то, что вы делать не можете.
45:23
Двигаемся дальше.
45:24
Все MTL классы, они так или иначе с фундеповскими констрейтами сидят.
45:38
У вас для всех их комбинаций есть какие-то инстансы.
45:41
То есть для MonadReader, инстанс MonadReader для ридера банальный,
45:48
а инстанс MonadReader для райтера, он определяется как.
45:55
Вам нужно, чтобы MonadReader был в внутренней монаде.
45:57
То есть что это означает?
45:58
Означает, что где-то там по стэку должен быть где-то ридер.
46:03
Понятно?
46:08
То есть видите вот этот констрейнт.
46:10
Этот констрейнт гарантирует вам, что у вас определен MonadReader для M.
46:17
Лезем в M, а там скорее всего какой-нибудь такой же констрейнт,
46:20
что MonadReader уже внутренней монады у M должно существовать.
46:25
И так далее, пока мы не натыкаемся на MonadReader,
46:28
в котором у вас требуется только, чтобы у вас была внутри монада.
46:33
Понятно?
46:37
Соответственно, если у вас ридеров стэки нет,
46:39
вы не можете выполнить это условие, у вас не будет инстанса MonadReader.
46:45
То же самое для стэйта и райтера.
46:47
Понятно?
46:51
Да.
46:54
И так мы можем получать стэйты.
46:57
Понятно.
47:00
Ладно, возможно я не так понял.
47:02
Ну просто вот MonadReader, да, стэйт.
47:10
Вот, что происходит в этом случае.
47:12
Еще раз.
47:12
Вот смотрите, мы определяем MonadReader для стэйта.
47:15
Что за фигня?
47:16
То есть какой ридер, какой environment мы можем из стэйта прочитать.
47:19
А мы читаем environment не из стэйта.
47:22
Представьте, что здесь у стэйта в монаде M там еще 20 монад.
47:27
Там какой-нибудь ридер, райтер, там еще что-нибудь.
47:29
Где-то среди этого стэка есть ридер.
47:32
Или ридер T.
47:36
Вот, и вы говорите, я хочу сделать доступ к environment, хочу сделать ask.
47:42
Чтобы не делать лифт, лифт, лифт, лифт, лифт, лифт,
47:45
вы запаковываете его внутри вот этого инстанса.
47:49
Инстанс при этом имеет constraint, что я не применяю ask,
47:54
я не достаю environment из вот этой монады стэйт, которая у меня сейчас написана.
47:58
Я достаю ее откуда-то дальше по стэку.
48:02
У меня гарантированно, что дальше по стэку, вот этим вот MonadReader,
48:06
у меня гарантированно, что дальше по стэку где-то монада есть.
48:10
MonadReader в смысле.
48:13
Как достать environment из той монады, которая где-то внутри далеко по стэку?
48:18
Ну очевидно,
48:20
ask для данной монады это запросить ask во внутренней монаде,
48:23
которая в свою очередь запросит ask во внутренней монаде,
48:26
и так далее, и так далее, и так далее, пока не дает до ридера,
48:28
у которого вот эта штука определена тривиально.
48:33
Понятно?
48:34
Да.
48:37
Верно ли, что тогда нужно прописывать еще и для
48:40
всех других комбинаций, где не только стэйт, тэ?
48:44
Да.
48:45
Это называется NxM problem,
48:47
но опять же очевидно, что никто так не делает,
48:50
оно достаточно тривиально решаемое, потому что смотрите,
48:52
замечу, что этот инстанс достаточно тривиальный.
48:55
Ну то есть буквально ask это lift ask,
48:58
там,
48:58
reader это lift reader,
49:00
local это какая-то ересь, но насколько я помню, там не нужно определять для,
49:06
не помню какого у него minimal definition, но
49:09
даже так, все равно он достаточно тривиальный.
49:12
Вот, поэтому да,
49:13
соответственно,
49:16
короче, решение у этой штуки есть, сейчас через пару слайдов.
49:21
Вот, да, значит как-то связано с парсер-комбинаторами.
49:27
Сейчас, у вас какая сейчас доза, там есть какие-нибудь парсеры?
49:31
Или бывали у вас лекции про парсеры?
49:34
Нет, парсеров нет.
49:37
Окей, хорошо.
49:38
А никаких парсеров не было.
49:40
Хорошо, странно, что их не было,
49:42
но суть в чем,
49:43
смотрите, вот у вас есть парсер-комбинатор,
49:46
да, это какая-то такая вот, какой-то класс,
49:47
как Monado на самом деле работает, который позволяет
49:51
вам парсить выражение, то есть он берет строку
49:52
и возвращает, может быть, распарщенный результат и остаток строки.
49:58
Для чего нужно именно вот так вот делать?
49:59
Для того, чтобы вы сразу могли вот к этому результату, вот к этой вот
50:03
оставшей части применить другой парсер.
50:05
Поэтому они называются парсер-комбинаторами.
50:07
Вы берете несколько парсеров, каждый из которых умеет парсить какую-то часть,
50:10
применяете их все последовательно друг за другом,
50:13
и у вас каждый из них выдает какой-то результат, плюс то, что осталось распарсить.
50:17
Вот.
50:18
К этой фигне можно добавить,
50:22
да, по сути, во-первых, эта штука превращается в некий стейт,
50:25
во-вторых, к этой фигне можно добавить трансформеров, то есть, например,
50:28
если вам парсер нужно логировать ошибку, раз вы ее обнаружили,
50:32
вы можете добавить сюда PointXL.
50:33
Если вам для того, чтобы распарсить значение, нужно
50:37
PointEnvironment почитать, ну, например, самое
50:39
банальное – это переменная, замена переменных,
50:40
там PointMaps,
50:41
замена переменных лежит.
50:42
Вот вы можете Reader сюда добавить.
50:46
Давайте не будем на этом долго останавливаться.
50:49
Да.
50:50
Значит, теперь обработка исключений.
50:52
У вас, по-моему, было что-то про обработку исключений.
50:55
Правильно? Правильно было.
50:58
Отлично.
51:01

51:01
Кому-нибудь скажет, в Хакере можно кидать исключения из чьих-то функций?
51:09
Ну, вообще, здесь функция Error, которая прервает...
51:12
Хорошо, а проверяемые исключения?
51:15
Error – непроверяемые исключения.
51:17
Это правда.
51:23
Проверяемые только из его.
51:26
Вот этим ответом люди себя убивают на экзамене.
51:31
Первое, значит,
51:32
даже без каких-либо монад вы все равно можете сделать просто
51:36
функцию Throw, если посмотрите на ее тип, ее тип E, A.
51:37

51:38
И потом ее можно Catch сделать.
51:41
Замечу, что Throw...
51:44
Короче, вы можете делать Throw из чьих-то функций,
51:46
вы не можете делать из чьих-то функций Catch.
51:48
Вот ловить исключения можно действительно только в ООО.
51:52
А вот Throw делать можно откуда угодно.
51:54
Но вот там как раз такие проблемы, что Throw на самом
51:57
деле пробрасывает исключения все равно через ООО.
51:58
Он ломает вам вычисление
52:02
и, ну, не есть хорошо.
52:05
Это можно,
52:05
но это не есть хорошо.
52:07
Чтобы вот такой фигни не было, есть два варианта.
52:09
Первый –
52:09
у вас все крутится в ООО хорошо.
52:12
В таком случае у вас, соответственно, в таком случае вы можете
52:22
просто делать Throw и Catch в ООО.
52:24
Или как они так называются?
52:25
Throw и Catch, по-моему.
52:28
Которые работают через ООО и так, поэтому им не страшно.
52:32
И ООО само там пофиксит порядок вычислений.
52:34
А если вам хочется кинуть вычисление внутри какой-нибудь чистой функции,
52:40
тем не менее,
52:41
то вы можете все это сделать.
52:42
Просто он лучше будет, если вы начнете вычислять на это дело монадический контекст.
52:46
Но самое банальное, опять же, это except какой-то.
52:49
Except, на самом деле, в монадическом контексте он просто заменяет
52:51
каждую последующую операцию после того, как случилась
52:54
ошибка на возвращение за результат ошибки, и все.
52:57

53:00
То есть он как бы продолжает вычисления дальше.
53:03
Просто каждую операцию, вместо этого,
53:05
тупо не будет ее выполнять.
53:06
Вместо этого просто результатом этой операции будет ошибка.
53:07

53:09
И вот тогда и тогда,
53:09
и так далее, пока она не вернется
53:10
в виде результата. Вот. И, соответственно, чтобы таким образом выкидывать ошибки или их ловить, есть две монатки. Монат throw и монат fetch. Точнее, не монатки, а классы. То есть для его этого throw и all
53:26
просто тупо, а для, соответственно, maybe, она просто заменяет классы на nothing. Всё. Вот. Соответственно, есть монат throw для того, чтобы выкидать ошибки. Как вы можете видеть, у него он же определяется,
53:42
через лифты для внутренних монат поставку. Вот.
53:46
Это, кстати, важно. Почему? Потому что, соответственно, это означает,
53:50
что вы из какой-то внутренней монады можете
53:53
бросить исключение, и мы здесь это знаем.
53:55
Но мы можем пробросить дальше. Вот. Соответственно, монат
53:58
catch, который парен монат throw, потому что нужен
54:01
инстанс монат throw, чтобы был монат catch, он позволяет это
54:05
исключение в монаде ловить и как-то обрабатывать.
54:38
Понятно? Непонятно. Зачем нам для того, чтобы определить монат
54:42
catch, требуется, чтобы был определен монат throw,
54:46
если мы можем бросать это всюду, а не только из... Нет, это не совсем так.
54:53
Смотрите, констрентами монат throw и монат catch вы описываете,
54:55
как вы пробрасываете исключение. Потому что соч.
54:58
io это вот та самая ломающая последовательность вычислений выброс.
55:01
То есть, и.о. это как бы такая дубинка, да?
55:04
Она просто говорит, все, у меня случилось исключение, мне пофиг на
55:07
то, что там должно в программе твориться дальше, я вот полетела туда.
55:09
Как бы вы ее так и ловите, как что-то, что летит откуда-то
55:13
непонятно откуда, как бы, и приходит к вам.
55:16
С точки зрения maybe, ошибка гораздо более такая мягкая.
55:20
Это просто, типа, вы заменяете последовательность операции на nothing.
55:23
Соответственно, как вам поймать то, что у вас случилась
55:26
таки ошибка? Ну вот ровно так же. Вы определяете instance
55:28
монат catch, который умеет понимать, что ага, вот этот
55:31
nothing, которым пришел, это на самом деле ошибка,
55:34
которая вылетела, и мы ее можем обработать.
55:40
Понятно? Да. Замечу, что instance монат throw и монат catch
55:47
определяются для одной и той же монады. То есть, если
55:50
вы определили монат throw для maybe каким-то образом,
55:52
вы определяете монат catch для maybe таким же образом.
55:56
Ну, в плане, типа, как-то парно к нему. Чтобы вы умели
56:01
обрабатывать тот тип ошибок, который там вылетает.
56:04
Для его это, соответственно, простой catch, для maybe там что-то другое будет.
56:09
Да, для его это просто catch. Как catch и throw работают
56:13
под капотом, мы вам, вроде так, должны были рассказать,
56:16
если не представляли, лучше не смотрите туда,
56:19
там мощная магия. Вот. Да, еще есть mtl'евский
56:22
монат error, который на самом деле то же самое, что
56:27
эти два комбинированные, просто он, типа, позволяет
56:31
одновременно определять, позволяет одновременно
56:33
кидать ошибку и ловить ошибку. Замечу, что здесь
56:36
опять есть фунт деп на то, что у вас так же как и с
56:38
ридером, только здесь у вас определяется тип ошибки для монады.
56:40
То есть, одна монада может кидать только
56:44
одну ошибку по этому инстанцу. Зачем так сделано,
56:49
честно говоря, не знаю, просто design limitation.
56:52
Вот, ну и да, то, что я говорил, что у вас accept transformer,
56:57
это какого-то черта трансформер для either.
57:03
Вот. Ну и какой-то пример того, как это можно использовать.
57:11
То есть, фу кидает монад error, фу
57:15
error, бар кидает монад error, бар error, баз монад
57:19
error, баз error. Где баз эррор, это комбинация.
57:25
Теперь вы можете применить их оба, просто в базе вы должны
57:31
без accept, то есть вы здесь с каждым конкретным
57:34
этим случаем ловите ошибку, которая здесь вылетает,
57:37
комбинируете их как-то, справляетесь с ними, как-то и
57:45
передаете дальше. Окей, значит, да. Собственно к вопросу о том,
57:55
что зачем нужны MTL, MTL вот эти монад что-то
57:58
позволяют обходить вот эту вот проблему множественных лифтов.
58:02
Это, кстати, реальный production code.
58:05
Когда-то у Серокеля было вот такое. Да, мы им не гордимся,
58:11
но когда нужно было что-то быстро написать, ребята
58:14
написали это вот так вот. Здесь сколько? Самое
58:16
большое я здесь вижу, сколько здесь? Восемь лифтов.
58:20
Ну типа не надо так использовать MTL и она
58:25
позволяет вот это все дело сократить. Единственное,
58:30
что возникает, собственно, проблема n на m инстансов.
58:34
Что если у вас есть n монад и m type
58:37
классов, вам нужно написать n на m монадных инстансов.
58:41
Хотя, как мы уже заметили, большинство из этих
58:44
инстансов они совершенно тривиальны. Поэтому MTL есть с
58:49
помощью вот этих вот экстеншенов. Вы можете задеривить
58:53
просто монад что-то, если инстанс тривиальный.
58:57
То есть у вас условно ридер внутри есть, можете
59:00
задерить монад ридер по environment. State my state
59:03
есть, монад стоит за деревелью, есть монад за деревелью.
59:09
Понятно? Да. Замечу, что вот это тоже очень часто
59:15
техника, чтобы не таскать за собой гигантские
59:20
трансформеры, вот такие вот. Обычно их
59:24
либо оборачивают в new type. Почему в new type? Потому что есть экстеншен New Type
59:29
деревень, который позволяет New Type деревень делать очень просто.
59:36
Он, по сути, разворачивает New Type и говорит, что я
59:38
определяю инстанс вот этой штуки для New
59:41
Type, так же как для того, что внутри него.
59:45
И по этой причине у вас эта штука вообще будет очень
59:49
легко работать, потому что у вас деревень в этом
59:51
случае просто развернет эмку, посмотрит, ага, у вас
59:52
ридер, ну как определенно монад ридер для ридера, ну вот так.
59:55
Как монад стей для ридера определен, ну вот так.
59:57
Как монад эо для ридера определен, ну вот так.
59:59
И все. И определить их автоматически.
1:00:03
Вот. Либо еще, ну тогда можно совсем тупо, если
1:00:09
typewise просто использовать. Вот. Да. Соответственно,
1:00:15
теперь у вас, может, такие вот вещи можно
1:00:19
превратить вообще вот в это. Можно еще круче пойти.
1:00:23
Можно сказать, что у нас здесь вообще-то не environment
1:00:27
просто, да, а у меня какой-то has environment
1:00:32
класс переменная. Вот. То есть, что мы не обязательно
1:00:35
должны чистый environment всегда доставать.
1:00:38
Мы можем доставать больше, просто мы должны уметь из-за этого получать environment.
1:00:43
Тогда вообще становится все полиморфно, даже утер.
1:00:46
То есть мы буквально всегда можем кидать любые аргументы,
1:00:49
любые, делать эти вычисления в любой монаде, и
1:00:51
он все равно будет работать. Главное, чтобы
1:00:53
вот это вот констринты были удовлетворены.
1:00:56
И эта штука может реально разрастаться. То есть у меня было
1:00:59
такое, что у меня там штук 40 констринтов в
1:01:01
один момент получилось, там бага, это почти
1:01:05
апогенережка была. Вот. Можно еще раз? Зачем
1:01:09
нам здесь has environment делать? Почему это не
1:01:14
оборачивается в monadreader? Почему-то не сделать его
1:01:18
частью ответственности? Смотрите, объясняю.
1:01:21
Что делает monadreader? Monadreader позволяет вам получить
1:01:25
какой-то environment, так? Но мы здесь жестко
1:01:27
прописываем, что monadreader должен получить
1:01:30
именно environment значение. Вместо этого, если мы
1:01:33
хотим сделать это еще более полиморфным, мы
1:01:35
можем прописать, что у нас monadreader на самом
1:01:38
деле здесь не environment возвращает, а какую-то переменную k.
1:01:40
Типовую, да? И вот для этой переменной k мы умеем делать какой-то has environment.
1:01:46
То есть environment может быть каким-то
1:01:48
подмножеством k. Просто мы гарантируем, что мы умеем из
1:01:54
этого множества k получить вот это подмножество environment.
1:01:59
Понятно? Это просто может быть нужно иногда для того, чтобы вообще
1:02:04
все заполиморфить. То есть мы еще environment могли
1:02:09
бы различные передать в эту monad. Более-менее.
1:02:17
Так лучше на самом деле не делать.
1:02:22
То есть если вы пишете какую-то lib, тогда да, тогда можно,
1:02:27
потому что непонятно, кто и в каком контексте
1:02:30
будет юзать вашу библиотечку. И там можно делать
1:02:33
все полиморфным до жути. Вот если вы посмотрите
1:02:36
какие-нибудь хаскинговые большие библиотеки для работы
1:02:38
с базами, с вебом, с телегой, с андроидом, с чем угодно.
1:02:44
Вы увидите, что на самом деле большинство
1:02:49
библиотек действительно вот так вот определено.
1:02:53
Самому такие вещи лучше не писать. Если вы не пишете библиотеку,
1:02:58
а пишете какую-то просто функцию, то лучше прописывайте четко monad, которые должны
1:03:02
использоваться, потому что вы точно знаете, что вы
1:03:04
будете использовать. И это позволит читателю
1:03:07
гораздо проще понять, что вообще здесь вы делаете.
1:03:12
Вот это то, что мы пытались достичь. Мы просто перечислили
1:03:18
список эффектов, которые мы должны и хотим здесь
1:03:22
применить, и тип. Примерно такой же у нас здесь и получилось.
1:03:25
То есть у нас перечислены все
1:03:28
эти monad что-то. Это эффект, который мы хотим использовать.
1:03:30
А в типе она осталась простенькой параметром.
1:03:36
Да, значит, какие паттерны стоит использовать? Ну, Reader.io это просто классика.
1:03:46
Я об этом много рассказал. TaglessFinal это вот
1:03:50
то, что на самом деле это продолжение вот этой
1:03:56
вот MTL практики. Что такое MTL? Оно позволяет
1:04:04
задавать вам эффект, который вы делаете.
1:04:07
То есть monadReader это доступ к изменяемому окружению.
1:04:10
Давайте теперь введем собственную monad, например
1:04:12
monadDatabase, которая под капотом будет там тем же
1:04:14
MonadReader с иошкой, но зато мы теперь у нее
1:04:17
определяем, что у нас есть какой-то monadDatabase,
1:04:20
который позволяет вам получить юзера или дайвить
1:04:23
юзера, например. Или сделать запрос с connection там
1:04:26
или еще что-нибудь такое. Это нужно, чтобы достать
1:04:29
детали реализации того, как вы там в базу ходите на самом деле.
1:04:32
И при этом, соответственно, использовать
1:04:36
этот monadDatabase в любом контексте, независимо
1:04:39
от того, как мы реально хотим в эту базу ходить.
1:04:47
Понятно? То есть, вот смотрите, у вас здесь есть AppM,
1:04:58
который ходит, видимо, в реальную базу, потому что у него есть TO.
1:05:01
Есть TestM, который на самом деле
1:05:04
просто хранит каких-то юзеров, но их как-то меняет
1:05:07
в зависимости от действия, которое вы делаете.
1:05:13
И, соответственно, в зависимости от того, что
1:05:16
вы хотите использовать функцию в реальности или
1:05:19
в тестовом окружении, вы подменяете монаду внутреннюю.
1:05:22
Ну и, соответственно, в одной из них у вас
1:05:25
идет вычисление. Как-то. Я об этом, кстати, говорил
1:05:29
на самом начале. У нас было в Sirocco, например,
1:05:33
там другая ситуация. У нас была библиотечка для работы
1:05:38
с блокчейн-сетью, и вот мы хотим, соответственно,
1:05:44
мы хотим какие-то вещи протестить, но проблема, что
1:05:46
протестить их на реальной блокчейн-сети, там каждая
1:05:49
операция выполняется 30 секунд реального времени.
1:05:51
Вот просто constraint такой стоит. Соответственно,
1:05:54
любой тест у вас будет выполняться 30 умножить
1:05:56
на количество операций, которые вы хотите в этом тесте сделать.
1:05:58
Что мы сделали? Мы ввели два environment.
1:06:01
Один для продуктовой сети, в которой мы
1:06:05
можем, соответственно, использовать эти же
1:06:07
функции, но, блин, да, они будут требовать времени.
1:06:09
И другой для тестовой сети, в которой каждая операция
1:06:12
выполняется одну секунду. И чтобы не переписывать
1:06:16
каждую функцию под разные контексты, мы просто
1:06:20
написали функции один раз, функции такие,
1:06:23
к которым мы можем передавать вот этот вот паттерн
1:06:27
того, где мы хотим использовать эту функцию.
1:06:38
Понятно? Да. То есть, грубо говоря, если в Java мы создаем
1:06:44
интерфейс блокчейн и две реализации. Это интерфейс
1:06:50
аквас реализации, и передаем в приложение объекты,
1:06:54
которые реализуют интерфейс тестовой блокчейн
1:06:57
и приложение веб-блокчейн. Здесь мы определяем
1:07:01
сразу типы тестовой блокчейн и нормальный блокчейн и
1:07:06
передаем типы, не экземпляры. Да. Хорошо.
1:07:16
Экземпляры вы создаете, соответственно, потом, когда хотите что-то
1:07:27
в этом типе, оно будет эти операции выполнять
1:07:31
следующим образом. А интерфейс в этом случае
1:07:34
создает то, что вы, в принципе, можете выполнять эти операции.
1:07:37
То есть, в данном случае, вот этот monad-датабейс
1:07:41
это интерфейс, apm и tstem это конкретная реализация
1:07:45
этого интерфейса, а вот когда вы запустите,
1:07:47
вы уже передаете конкретный экземпляр. Хорошо. Вот, что делать не стоит.
1:07:55
Трансформер с PLUS.io, не совсем правильно назвал,
1:08:02
трансформер, очевидно, можно использовать с
1:08:08
EO, потому что вы не можете выбирать того,
1:08:14
чтобы использовать трансформер с EO. Однако, чего делать не стоит.
1:08:17
Значит, по-самому не стоит комбинировать
1:08:19
EXCEPT с EO и STATE с EO, можно комбинировать, просто
1:08:24
очень аккуратно. Почему? Потому что в этом случае EO,
1:08:28
как я уже говорил, имеет очень забавное и неприятное свойство,
1:08:31
оно вообще ломает нафиг все вычисления и говорит, что, типа,
1:08:33
я вот выбросил ошибку, иди ее там где-то лови. Все, что должно
1:08:37
произойти дальше по вычислениям, у меня не особо волнует.
1:08:40
Вот. По этой причине, во-первых, то, что у вас должно вылететь
1:08:43
как EXCEPT, вылетает как EO, ну, соответственно,
1:08:46
понятно, что смысла в этом вообще не много.
1:08:49
Потому что EXCEPT нужно для того, чтобы мягко схендлить ошибку,
1:08:54
EO выкидывает ошибки жестко. Их комбинация, ну, очевидно, будет кидать
1:08:58
ошибки жестко, и больше ничего вам для этого вычисления не дает.
1:09:01
Используйте либо одно из них, либо другое. STATE T плюс EO, тут та
1:09:05
же проблема, что с EXCEPT и STATE, на самом деле, мы сейчас увидим,
1:09:09
что STATE в этом случае может сломаться. В плане не сам STATE, а в плане
1:09:18
STATE, который вы передаете, он может откатиться к начальному состоянию,
1:09:27
а может не откатиться. То есть вы не можете
1:09:29
зафиксировать STATE на том месте, где вылетела ошибка.
1:09:34
Потому что она вылетевшая ошибка не дает правильно этот STATE похендлить.
1:09:47
Ну, собственно, то, что там кто-то из вас говорил на тему порядка комбинации монад.
1:09:55
Вот у нас, допустим, есть READER T, EXCEPT T, STATE T.
1:10:01
Это все нормально работает, это тоже работает, но немножко по-другому.
1:10:08
Почему? Потому что... А, сейчас, в обоих случаях EXCEPT
1:10:13
над STATE, предположим, что у нас был бы STATE над EXCEPT.
1:10:18
То есть поменяем местами EXCEPT и STATE. В этом случае, в одном из этих случаев, у вас
1:10:24
произойдет то, что я описывал только, что вылетевшая ошибка, она прервет вычисление STATE,
1:10:32
и вы в результате получите начальный STATE, который вы передавали, и ошибку саму.
1:10:42
В другом случае, я сейчас не помню, какой из них
1:10:45
какой, скину вам потом в чат конкретный пример.
1:10:49
В другом случае, у вас вылетевшая ошибка не прервет вычисление, и вы в результате все равно берете
1:10:56
результат, который ошибка, плюс какой-то STATE, который посчитался до того момента, пока ошибка не вылетела.
1:11:04
То есть, если у вас...
1:11:09
Сейчас, ладно, я не беру стражащихся, потому что, по-моему,
1:11:12
в каком-то из них порядка не должна при этом быть.
1:11:14
Понятно примерно?
1:11:18
Можно задать вопрос, может, глупый.
1:11:20
Зачем UNIT на конце объявления, на конце сигнатуры?
1:11:24
В смысле, у вас же в каждой сигнатуре должно быть
1:11:27
возвращаемое значение, тип возвращаемого значения.
1:11:30
То есть, в этом случае у вас что?
1:11:32
EXCEPT принимает на вход A ошибку, которую она может кидать.
1:11:36
B это монада, которая будет внутренняя монада трансформера.
1:11:45
А последний аргумент всегда это возвращаемое значение.
1:11:48
Но у вас это возвращаемое значение, но в данном случае, видимо, никого не волнует.
1:11:53
Но его же надо перечислить в какой-то тип.
1:11:54
Обычно возвращают той тип, который вводит в плюсах.
1:12:02
Или в джави, или где-то в этом типе.
1:12:04
Да, много где.
1:12:09
Не совсем, на самом деле, потому что с вайдом
1:12:10
можно, кажется, жуткие вещи творить в плюсах,
1:12:12
а вот в хаскере это просто обозначает того, что функции ничего не возвращают.
1:12:18
Если EXCEPT принимает три аргумента, то там в
1:12:21
определении FULL, похоже, скобочки не там стоят.
1:12:27
Сейчас, вот тут?
1:12:30
Да.
1:12:31
Нет, здесь все правильно.
1:12:36
Смотрите.
1:12:43
Можно в гугл-презентации уже прикрутить джамборд, чтобы мог показывать это дело.
1:12:58
И нам все еще только презентацию видно.
1:13:00
Да, сейчас, подождите, у меня просто компьютер тупит.
1:13:04
О! Видно? Отлично.
1:13:21

1:13:24
Можно описывать, какая прелесть.
1:13:37
В чем-то был вопрос о скобках EXCEPT.
1:13:43
Значит, что происходит?
1:13:58
Что происходит?
1:13:59
У вас тип большинства трансформеров выглядит следующим образом.
1:14:07
Это типа NAME.
1:14:13
Значит, давайте-ка я...
1:14:16
Ой, какое жуть, какое запаздывание.
1:14:22
Типы большинства трансформеров выглядят так.
1:14:23
NAME, R, M, A.
1:14:28
R где-то какое-нибудь state, environment или exception.
1:14:32
M это внутренняя монада, а A возвращаемого значения.
1:14:40
Смотрите.
1:14:43
Внутри должна быть монада.
1:14:45
Что такое монада?
1:14:47
Что такое монада, понятно.
1:14:49
Но самое главное, монада это класс, который получает на вход один типовой аргумент.
1:14:56
Забегая вперед, у этой штуки есть такая штука как COUNT.
1:14:59
И у него следующее.
1:15:00
Звездочка, стрелка, звездочка, стрелка, звездочка,
1:15:06
звездочка,
1:15:09
звездочка, звездочка.
1:15:11
Мак rated 2.
1:15:20

1:15:21
То есть, есть эта монада, она получает на вход типовой параметр,
1:15:26
который не принимает других аргументов,
1:15:28
типовой параметр, который принимает один аргумент,
1:15:31
типовой параметр, который не принимает аргументов.
1:15:33
И она получает собственно...
1:15:37
Поэтому M в этом случае должно быть что-то, что еще должно принимать один аргумент.
1:15:42
Теперь посмотрим обратно на презентацию.
1:15:45
У вас ридер t с первым аргументом, с третьим аргументом, с вторым аргументом
1:15:50
и с третьим аргументом не принимает больше никаких типовых аргументов, так?
1:15:56
Вот.
1:15:57
Эксцепт работает точно так же. Эксцепт с тремя аргументами не принимает других
1:16:01
аргументов, а нам нужно что-то, что еще один типовой аргумент будет принимать.
1:16:05
Поэтому здесь эксцепт t, r, у него два только аргумента
1:16:08
определены, а третий, он на самом деле вот отсюда берется.
1:16:12
Понял. Спасибо.
1:16:14
Это на самом деле причина, почему у вас монада она в центре.
1:16:19
Ну то есть она в центральном аргументе. Чтобы вы могли
1:16:22
их вот так вот комбинировать, было удобнее просто.
1:16:25
Короче, это частичное применение.
1:16:27
Да, буквально.
1:16:29
Я еще буду вам читать одну лекцию, вот где мы подробнее
1:16:32
рассмотрим, как это происходит с точки зрения типов.
1:16:36
Мне интересно, сколько туда придет людей, потому что рекорд пока шесть человек.
1:16:43
Да, то есть это частичное применение, поэтому здесь отсутствует последний аргумент.
1:16:49
Еще вопросы? Пока вроде нет.
1:16:56
Окей.
1:16:58

1:17:00
Да, соответственно...
1:17:02
Неужели кто-то решил...
1:17:04
А, все, окей.
1:17:06
Это сколько? Я буду сам в себе читать лекцию, да?
1:17:11
Да.
1:17:12
Соответственно, да.
1:17:19
Не думаю, что это ваше.
1:17:21
А получается, да?
1:17:22
А вы знаете, как мы можем правильно использовать эту информацию?
1:17:28
Да, хорошо, ну вы понимаете.
1:17:37
Значит, если вы не знаете, то лучше почитать.
1:17:38
Да, ну можно, конечно.
1:17:39
То, что я показывал, вот, я прям, ну сюда
1:17:39
стремился, пока я не мог на них расстаться.
1:17:40
Это, можно сказать, та как я и делал... Я!
1:17:43
вот это вот добавление нескольких различных эффектов к вашим вычислениям, к вашей
1:17:48
функции. Есть еще несколько способов справиться с этой проблемой, на самом деле,
1:17:52
и, признаюсь честно, с того, что я слышал на докладах, на самом деле, Monad Transformers,
1:17:58
их очень тяжело на продакшен применить эффективно. Есть более эффективные вещи.
1:18:04
Но, однако, они самые простые для понимания, потому что
1:18:07
все, что остальное, это Free Monads, они сложнее сильно.
1:18:13
Вот, собственно, Free Monads позволяют вам, на самом деле, делать вот что-то такое.
1:18:17
То есть вы просто перечисляете вычисления, а потом просто перечисляете эффекты.
1:18:21
Да, и это мема из 2000, я даже не знаю какого.
1:18:25
Не знаю, кто-нибудь шарит за этот мем или нет.
1:18:27
Мне просто интересно, насколько я старый.
1:18:33
Капец.
1:18:37
Господи.
1:18:39
Так, ладно, презентацию нужно обновлять.
1:18:43
Молодые.
1:18:47
Вот.
1:18:50
Соответственно, что у вас получается?
1:18:53
Это выглядит, как реально может хаскельный код выглядеть,
1:18:57
когда у вас здесь вот эти эффекты просто перечислены.
1:19:01
Это вот то самое Free Monads, еще куча всего, что
1:19:04
мы будем изучать на той лекции, которая жесткая.
1:19:09
Вот.
1:19:10
Да.
1:19:11
Собственно, это все по трансформерам.
1:19:14
На следующей лекции у вас, по-моему, лекций не будет, по-моему, у вас
1:19:18
будет практика, где вы просто можете посидеть и разбирать эти задачки.
1:19:21
На следующей трансформере я очень советую понять.
1:19:25
Потому что, блин, это настолько основа, что любой код, который хотите записать более-менее,
1:19:30
чем однострочный, он, скорее всего, будет трансформером в том или ином виде юзать.
1:19:35
И сейчас у вас есть время задать вопросы.
1:19:42
Вы шарите из-за домашки?
1:19:45
В каком-то смысле да, я же отвечаю за их проверку.
1:19:51
Ну просто, я думаю, я уже начал писать домашку без
1:19:55
использования монад. А какая у вас домашка сейчас,
1:20:00
давайте посмотрим. Там просто порядок немножко изменили.
1:20:03
Вот вы спрашивали про парсер, и на самом-то
1:20:06
деле домашка-то про парсер, на самом-то деле,
1:20:09
потому что у нас клипон, что и является отчасти,
1:20:15
если так, в упрощенном формате. А, нет, сейчас,
1:20:19
подождите, у вас сейчас задачка нет. Про деревья у вас уже была? Была.
1:20:23
У нас сейчас одна из задач — это сделать рисинг по строке, по символу. Ну, хорошо.
1:20:35
Вот, думаю, как бы прикрутить сюда парсер. Ну, смотрите,
1:20:40
нет, подождите, в этой задаче... Это какой, таск-3? Таск-2.
1:20:49
Homework-2, таск-2, да? Да. Ну, окей, здесь вам
1:20:53
не нужно никаких монад использовать, более того,
1:20:56
домашке вообще вам не нужно использовать никаких
1:20:58
монад, здесь можно справиться только исключительно
1:21:00
всякими фолдами, траверсалами и так далее.
1:21:05
Хорошо, да, ну, то есть, высший порядок функция.
1:21:09
Надеюсь, будет сказано, когда надо применять монады, чтобы можно было.
1:21:13
Я вам так скажу, там по монадам...
1:21:18
Короче, смотрите, когда у вас будет задание на конкретно
1:21:20
гигантский парсер, а оно будет, мы его, к сожалению,
1:21:23
так и не распилили, вот там прям можете использовать
1:21:26
вообще, бомбардировать всем, чем только можно,
1:21:28
там и gdt можно использовать, и надо даже использовать, но
1:21:31
мы их еще не проходили, там монады можно поиспользовать,
1:21:34
какие-нибудь всякие стейты и так далее, вот, там уже на свое усмотрение.
1:21:37
Здесь пока что вам хватает всякой банальщины.
1:21:43
Трансформеры, тем более, точно нужно применять.
1:21:48
Еще вопросы? В этом плане волнует ситуация, когда кажется
1:21:55
хватает всякой банальщины, пишешь банальщину, и
1:21:57
потом боюсь на ревью получить вердикт, что здесь
1:22:00
можно было проще, а потом куча непонятных букв, символов и подобных
1:22:04
монописных штук. Давайте так, к моменту, когда вы уже на эту домашнюю,
1:22:10
насколько я помню, вы еще монады не прошли. Или прошли.
1:22:14
Да, не суть. Суть в том, что, типа, здесь раньше эта домашня
1:22:18
давалась еще до того, как люди проходили монады, поэтому
1:22:21
будьте спокойны, вам никто не скажет на вердикте,
1:22:24
что все хреново, потому что вы можете сделать проще.
1:22:30
Пишите код нормально, красиво и правильно в плане. И вам никто ни за что не снизит.
1:22:36
То есть у меня были просто люди, которые написали
1:22:38
откровенно так, что у них там отступ улетает по всей
1:22:41
странице, и получается не весь что. Ну, так не надо
1:22:44
делать, потому что за такое точно снижать буду.
1:22:47
За более-менее красивый код, да пожалуйста. Единственное, что,
1:22:51
пожалуйста, я не знаю, вы уже умеете компилировать с опциями
1:22:56
VOL и VR? Полагаю, что это не то чтобы Rocket Science.
1:23:02
Ну вот да, типа, я просто к тому, что, короче, мне очень сильно не нравится,
1:23:09
если есть там мое мнение по домашкам, мне очень сильно
1:23:11
не нравится, когда люди оставляют ворнинги в коде,
1:23:13
потому что у них есть ворнинги по типу, например,
1:23:15
non-executive pattern matching. Это самое страшное, что вы
1:23:17
можете оставить в коде, который вы задаете на
1:23:20
проверку, потому что за такое бить по рукам надо.
1:23:23
Non-executive pattern matching – это когда вы делаете
1:23:27
pattern matching, но не определили все возможные исходы в
1:23:32
pattern matching. В этом случае, если у вас прилетит
1:23:34
исход, который вы не обрабатываете, у вас на рантайме все сломается.
1:23:37
Это такая проблемка, которая, к сожалению, типа, warning, а не вообще-то error.
1:23:45
Например, в том же росте она error вполне себе.
1:23:48
Вот, поэтому, если вы такое оставляете,
1:23:52
такое будет бить по рукам, а за все остальное
1:23:55
– да нет, все должно быть нормально.
1:24:02
Еще вопросы? Ну, мне выдавал, выдает ворнинг non-executive, а,
1:24:06
incomplete patterns, тоже про pattern matching,
1:24:10
но я смотрю, что он выдает и что не матчится,
1:24:13
и я считаю, что он категорически неправ,
1:24:15
и матчи все правят. Ну, либо вы открыли багу
1:24:20
в компиляторе GHC, либо вы все-таки неправы.
1:24:27
Ставлю, скорее, на второй вариант. Вот, поэтому...
1:24:33
Ну, просто проблема, скорее, в том, что,
1:24:39
говоря про AVL-дерево, ты же разбираешь логику и,
1:24:43
в целом, понимаешь, что какие-то варианты не могут наступить.
1:24:48
Нет, то, что вы с точки зрения логики
1:24:51
понимаете, что варианты могут не наступить, это похвально.
1:24:54
Но все равно, и я более вам так скажу, скорее всего, даже наши тесты пройдут.
1:25:02
Даже наши тесты, которые должны проверять такую штуку, они,
1:25:03
скорее всего, пройдут, потому что, действительно,
1:25:05
с точки зрения логики такое невозможно.
1:25:08
Компилятор об этом не знает. Поэтому рекомендую просто,
1:25:11
вот в крайнем случае, если вам не получается
1:25:13
сделать так, чтобы вы матчингами покрыли вообще все
1:25:15
варианты, потому что обычно так можно сделать,
1:25:21
добавляйте в конце вот такую штуку. Вот буквально, вообще везде.
1:25:28
Это позволяет вам ворнинг, соответственно, нейтрализовать.
1:25:40
При этом, если вы с помощью вашего третьего глаза
1:25:42
гарантируете, что этот вариант никогда не наступит,
1:25:45
он никогда не вылетит. А если вылетит, значит, вы были неправы.
1:25:51
И ворнинг там был не с краса. Такая штука,
1:25:56
если что, существует даже в продакшн-коде, когда точно можно доказать, что не вылетит
1:26:01
здесь такого варианта. Вообще, по-хорошему, либо
1:26:05
покрывать все, либо не делать по-другому, чем.
1:26:11
Еще вопросы? Тогда останавливаю запись.
1:26:19
На сегодня все. Или так, например. Месседж любой какой
1:26:26
хотите, который означает, что какого-то черта оно
1:26:28
дошло до части, до которой оно вообще доходить не должно.
1:26:30
Все. На сегодня тогда все. Спасибо. Всего доброго. До свидания.
