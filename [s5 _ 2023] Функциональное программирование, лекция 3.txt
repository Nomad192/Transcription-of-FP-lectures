0:06
Рад вас видеть на третьей лекции по функциональному программированию.
0:13
Давайте краткий план у нас на сегодня.
0:16
Мы научимся создавать свои собственные типы данных,
0:23
поговорим про алгебрические типы данных,
0:26
про рекорды, нью-тайпы, разные способы создать свои типы данных в Haskell.
0:35
Поговорим про type-классы, про полиморфизм.
0:38
Довольно интересная тема.
0:39
И какие-то разные мелочи про модули.
0:46
Погнали.
0:48
Мы хотим создавать свои типы данных.
0:52
Давайте сначала подумаем, почему нам это нужно.
0:56
Если нам нужен какой-то набор данных, который как-то связан, например, какой-то юзер,
1:02
то почему не можем использовать просто tuple?
1:07
Передаем tuple,
1:10
можем написать функцию, типа сгенерить full ID для юзера.
1:17
Казалось бы, в чем проблема?
1:20
Но понятно, что есть разные неудобства с этим.
1:24
Я забыл сказать, если у вас есть какие-то
1:26
вопросы, можете любое время меня прерывать.
1:30
Можно просто говорить, потому что я, скорее
1:32
всего, не буду смотреть чат во время лекции.
1:36
Можно просто голосом становиться и говорить.
1:40
Я буду стараться делать паузы в каких-то тривиальных местах,
1:44
чтобы вы тоже могли немножко подумать, сознать,
1:48
понимаете ли вы все.
1:51
Но если вопросы возникнут после, опять же, у нас есть чат в Телеграме,
1:56
там можно задавать вопросы.
2:00
Я думаю, что по этой лекции, как минимум,
2:03
и по остальным тоже я смогу что-нибудь ответить.
2:08
Коллеги мне помогут.
2:10
Продолжаем.
2:15
Понятно, какая проблема здесь.
2:16
Во-первых, что если мы возьмем какой-нибудь другой
2:21
тип данных, какой-нибудь другой набор данных, не юзер,
2:23
а аккаунт, у которого такой же набор данных.
2:26
Мы можем что-то перепутать.
2:28
В общем, у нас никаких проверок.
2:29
У нас такой тип питон, грубо говоря.
2:37
Значит, первая операция.
2:39
Что мы можем улучшить?
2:40
Мы можем создать type alias, то есть синоним,
2:44
который, во-первых, у нас уже сигнатура будет выглядеть удобно, красиво,
2:52
но опять же, у нас есть проблема в том,
2:55
что синоним совершенно не добавляет никаких новых проверок в compile-time.
3:04
То есть если у нас будет юзер и будет аккаунт
3:08
с одинаковым набором полей,
3:10
то, грубо говоря, у нас они будут совершенно взаимозаменяемы.
3:14
То есть если мы где-то сделаем ошибку,
3:16
все еще компилятор никак не сможет нам помочь.
3:19
Но, как минимум, читаемость у нас улучшилась.
3:26
Собственно, вот какие-то такие распространенные type alias, их примеры.
3:33
То есть string — это просто лист черов, например.
3:38
Ну, не всегда, на самом деле.
3:42
Можно использовать разные вероятности, которых string будет означать разная.
3:46
В этом тоже некоторые удобства есть.
3:49
Но, значит, что тут важно отметить,
3:52
что type alias спокойно могут быть параметрическими,
3:56
то есть принимать различные аргументы,
3:58
что довольно естественно и удобно.
4:02
Да, тут вроде пока все понятно.
4:06
Значит, агибарические типы данных.
4:08
Пытаемся сделать какое-то более правильное решение.
4:11
И для этого немножко теории.
4:16
Haskell-ные типы строятся на так называемой теории агибарических типов.
4:21
Суть в том, что у нас есть типы,
4:25
у нас есть одними операции произведения,
4:31
что, по сути, просто tuple.
4:36
И почему произведение?
4:37
Тут проводится такая аналогия, что типы — это как бы...
4:42
их можно, если не копать глубоко, воспринимать как множество.
4:46
И, в общем, когда мы хотим...
4:49
если мы делаем пару из двух типов,
4:51
то у нас получается количество элементов,
4:55
которые населяют произведение типов,
4:58
это произведение множества.
5:00
То есть мы берем любой элемент первый из первого множества,
5:05
любой второй элемент из второго множества, получается произведение.
5:11
Ну, в общем, да.
5:12
User — это произведение int, двух стрингов.
5:16
Собственно, да.
5:18
В Haskell мы это уже видели, это tuple.
5:20
Ну и раз у нас есть произведение, давайте введем и сумму.
5:24
Сумма означается знаком плюс.
5:28
Написано сложно найти какие-то аналогии в нефункциональных языках.
5:32
В целом, да, но сейчас во многих современных языках
5:37
они впитывают функциональную парадигму и вносят ее.
5:41
И, в общем, какие тут примеры?
5:44
Самый оперативный — это union, который есть еще в плюсах,
5:52
но там далеко от того, что воспринимается обычно под суммами типов.
5:59
Это еще называют вариантами.
6:01
То есть в 17-х плюсах, например, введен стандартный вариант.
6:07
Это, по сути, суммы типов.
6:09
То есть у нас есть тип, который умеет хранить
6:13
несколько разных вариантов других типов,
6:17
и они помечены тегом, и мы можем их различить,
6:20
делать на нем паттерн-матчинг и так далее.
6:27
Собственно, героические типы — это, значит, либо какой-то атомарный тип,
6:34
int, char, double, либо сумма типов, либо произведение типов.
6:39
То есть мы задаем некоторую грамматику, как могут выглядеть типы.
6:44
Ну и, собственно, понятно, суть в том, что это напоминает нам некоторую алгебру,
6:50
мы можем выписать для них какие-то правила,
6:51
работать с ними как с математическими объектами.
6:55
В общем, довольно удобно, когда у вас есть формальное определение
7:00
того, что вы вообще можете написать в своей программе.
7:06
Значит, давайте посмотрим, как это выглядит в Haskell, например.
7:09
Самый простой пример — это enum.
7:11
То есть есть TrafficLight, у него есть почему-то четыре цвета.
7:18
Я не совсем понимаю, почему, но для прикола.
7:21
В общем, мы можем написать функцию для работы
7:24
с ним, просто как бы разобрав все случаи.
7:29
Значит, вроде бы все понятно.
7:35
Значит, понятно.
7:36
Дальше мы можем эту функцию использовать, сделать
7:39
map по листу, каждому применить, увидеть результат.
7:44
Да, и тут важно то, что компилятор может вам
7:47
помочь проверить, что ваш pattern matching,
7:51
то есть сопоставление с образцом, что вы рассматриваете все варианты в нем,
7:57
то есть что он полный, что вы делаете полный разбор всех случаев.
8:02
Да.
8:05
Для этого нужно включить нужные флажки, и будет вам счастье.
8:11
Значит, окей, давайте посмотрим дальше.
8:15
У нас есть ключевое слово — data.
8:19
По сути, мы создаем кастомный тип данных.
8:23
Это уже не alias, это уже новый тип, который не совпадает со всеми остальными.
8:29
И, значит, у него есть... Давайте разберем сигнатуру.
8:35
У нас data, дальше идет имя, дальше идет название конструктора.
8:40
Оно все начинается с большой буквы, потом идут его параметры.
8:44
То есть, по сути, у нас тут задана...
8:51
Давайте посмотрим, как с этим работать дальше.
8:55
Как получить доступ к полям?
8:57
Мы можем просто сметчиться на конструкторе.
9:01
То есть мы делаем паттерн-матчинг, указываем имя конструктора,
9:05
имя полей, на которых мы матчимся.
9:07
Если какие-то не нужны, заменяем их класс-холдерами,
9:09
чтобы не было опять варлинга, что мы не
9:11
используем какие-то переменные или что-то такое.
9:15
И, в общем, вот у нас есть геттеры.
9:20
Значит, да, конструкторы — это просто функции.
9:26
Просто функции, которые принимают, по сути, инк, стринг, стринг,
9:30
в данном случае возвращают нам тип, который мы только что создали.
9:33
Они ничем особо не отличаются.
9:36
Везде, где можно использовать функции, можно использовать конструктор.
9:40
В общем, довольно удобно.
9:44
Да, можно опять же в jash-сайт посмотреть тип.
9:53
Значит, да, можно создать список юзеров, применить им какую-нибудь функцию.
10:06
Например, список уникальных имен.
10:10
Выглядит, собственно, как какие-нибудь джаоские стримы.
10:14
Собственно, они берут свое начало отсюда.
10:20
Окей, значит, типы данных могут быть параметрическими.
10:36
Можно вопрос? Да, вопрос.
10:39
Да, я слушаю.
10:43

10:49
Я не слышу, к сожалению.
10:53
Получается это круг?
11:02
Да.
11:03
Давайте вы напишите вопрос в чате.
11:04
Я не знаю, я не слышу вас.
11:08
Вы очень сильно пропадаете.
11:15
Что, серьезно?
11:16
В каких-то странах есть голубой цвет светофора? Офигеть.
11:19
Ну, ладно.
11:21

11:24
Напишите, пожалуйста, вопрос в чате.
11:25
Я его посмотрю буквально через пару минут.
11:31
Собственно, давайте продолжим.
11:32
У нас есть...
11:34
Извините, у меня сейчас должно быть лучше слышно, у меня просто был интернет выходит.
11:39
На предыдущем слайде был мк-юзер и юзер.
11:42
Мк-юзер – это, получается, имя конструктора?
11:46
Да, мк-юзер – это имя конструктора, совершенно верно.
11:51
А юзер – это имя? А это имя, да.
11:54

11:56
То есть, да, смотрите.
11:57
Если, допустим, у вас больше опыта работать с плюсами,
12:02
то тут конструкторы и имена типов – они разные.
12:09
Это удобно, потому что, на самом деле,
12:11
если в плюсах вы создаете разными конструкторами тип, вы получаете один и тот же тип.
12:17
То есть их никак нельзя различить.
12:18
Нельзя узнать, с помощью какого конструктора был создан тип.
12:21
Это неинтересно в плюсах.
12:23
Здесь немножко другая концепция.
12:26
Тут все конструкторы помечают наш объект.
12:36
Мы можем узнать, с помощью какого конструктора был создан объект.
12:48
Тут конструктор является неотъемлемой частью представления типа.
12:53
То есть это его как бы часть структурная.
12:57
То есть в этом есть немножко отличие,
13:05
более какой-то математичный подход здесь.
13:11
Но мы это все увидим.
13:12
Например, дальше, если будут вопросы, я отвечу.
13:19
Еще вопросы?
13:22
Там вопрос в чате задали,
13:24
можно ли создать более одного конструктора для одного типа.
13:28
Да, можно. Сейчас мы увидим.
13:34
Мы пока разобрали тип с одним конструктором.
13:38
Когда мы пройдем дальше, мы увидим все.
13:42
Мы не зря говорили про суммы типов.
13:44
Сейчас все будет.
13:45
Давайте закончим эту часть, потом тут вопрос.
13:49
Я спрошу.
13:53
Типы могут быть параметрическими.
13:56
Параметрический параметризм, как говорится.
14:02
Понятно зачем.
14:03
Мы хотим точку, допустим,
14:05
написать какой-то код общий,
14:12
без указывания конкретных типов.
14:14
Мы хотим, чтобы и длинна работала, и для дабла,
14:19
и, допустим, для двухмерной точки.
14:21
Вот простые примеры.
14:23
Типа, точку в список превратить,
14:27
взять точку и превратить ее в точку,
14:38
в которой пространство, а осями являются тоже 2D пространства, удвоить.
14:45

14:47
Взять максимальную координату,
14:52
остальные от нуля посчитать.
14:56
Такие простые, хоть понятные,
14:58
примеры, на которых должно быть просто видно,
15:02
что вообще происходит.
15:07
Создаем типы, видим результат.
15:13
Получается конструктор имеет такое же название,
15:15
как и тип данных.
15:17
Да, совершенно верно.
15:18
Здесь у нас немножко другой пример,
15:21
тут конструктор имеет такое же название, как тип данных,
15:24
и в Haskell это разные синтаксические вещи.
15:30
Там, где предполагается тип,
15:34
и вы пишете Point2D,
15:36
он будет депортироваться как тип.
15:40
Там, где предполагается какая-то функция,
15:42
будет восприниматься как конструктор.
15:46
То есть они вообще разнесены.
15:49
Пока что.
15:50
Пока у нас нет зависимых типов.
15:53
Но, в общем, да.
15:57
Вполне из контекста понятно, что такое Point2D, конструктор и тип.
16:01
В целом, довольно удобно.
16:07
Давайте пойдем дальше.
16:10
Суммы типов.
16:12
Когда у нас может быть несколько конструкторов.
16:14
Если у нас есть intResult,
16:16
у нас intResult воплощает в себе либо успешное вычисление числа,
16:23
какой-то совочисленный результат вычислений, или это ошибка с сообщением.
16:29
И success и failure — это две функции,
16:32
которые принимают параметры за счет типа.
16:42
Если проводить аналогию с пульсами, это такой вариант,
16:45
в котором лежат string и int.
16:50
И как в варианте,
16:52
мы можем по индексу спросить,
16:53
какой из вариантов лежит.
16:57
То есть у нас они протеганы,
17:01
в отличие от union, у нас есть доступ к тому, что мы можем спросить,
17:07
какой из вариантов лежит сделать pattern matching.
17:10
И давайте реализуем saveDiff.
17:14
Если у нас деление на 0,
17:15
то мы кидаем ошибку, грубо говоря.
17:19
Такой способ обрабатывать ошибки.
17:21
Мы возвращаем сообщение.
17:26
Вот.
17:29
ShowResult.
17:32
Собственно, да.
17:37
Вот так вот.
17:39
Все понятно.
17:40
Давайте дальше.
17:42
Параметрические суммы могут быть легко.
17:44
Допустим, у нас есть вектор,
17:46
и мы хотим с ним работать как с вектором, вне зависимости от того,
17:53
сколько там 2D это вектор или 3D.
17:59
Ну, такие игрушечные примеры.
18:02
Наверное, нет у них большого смысла, но, в общем,
18:07
можно писать функцию, которая из обоих вариантов делает список.
18:13
Посчитать длину.
18:17
Собственно, да.
18:19
Превращаем все в список.
18:20
И дальше берем сумму квадратов,
18:23
корень суммы квадратов,
18:24
и, собственно,
18:30
всякие конкретные примеры.
18:33
Да, и при этом, понятно,
18:35
все еще конструкты — это функции,
18:36
просто теперь эти функции полиморфные.
18:45
А вот вопрос.
18:46
В самой первой строчке у нас написано «вектор А» после даты.
18:51
Это полностью название?
18:53
Ну, типа, «А» — это что такое?
18:55
«А» — это параметр.
18:56
Это тип параметра.
19:00
А, типа, генерик какой-то?
19:03
Типа, type name А.
19:06
Да, это генерик.
19:21
Да, и вектор, собственно, «АА» —
19:28
это немножко такой, на мой взгляд,
19:31
немножко странноватый синтаксис.
19:36
Довольно легко привыкнуть.
19:39
Ну, типа, если бы мы использовали в конструкторе
19:41
какие-то дефолтные типы, а не генерики,
19:44
то нам бы не нужно было «вектор А» указать.
19:46
Достаточно было бы просто написать «вектор».
19:48
Дата, вектор равно.
19:51
Да, если мы не используем... Если у нас тип не параметризован никаким типом,
19:57
то мы как бы не пишем никаких аргументов, как это было там с юзером.
20:03
Ну, понятно.
20:04
Да, спасибо.
20:09
Да.
20:14
То есть, по факту, мы это делаем, чтобы сузить возможный аргумент,
20:20
типа, аргумент, который мы можем принять.
20:22
То есть, грубо говоря, мы сузили до того,
20:24
что у нас должны быть аргументы в векторе 2D и в векторе 3D
20:28
строго одного и того же типа.
20:30
То есть, что они там не могут быть разных типов, там, int и string.
20:36
Да, да, да.
20:37
То есть, это как темплейты, грубо говоря, в плюсах.
20:43
Да, все верно.
20:44
Это действительно как темплейты в плюсах.
20:47
Ну, то есть, и то, и то.
20:49
Это способ создать генерик,
20:52
тип проэматризованный типом.
20:58
И да, если мы делаем более полиморфный тип,
21:06
мы с ним меньше чего можем сделать,
21:08
потому что у нас меньше информации о типе и у нас
21:15
меньше способов облажаться в некотором смысле.
21:16
Если мы правильно задизайнили тип и мы все еще
21:20
можем сделать все, что мы хотим с ним делать,
21:21
то да, каких-то вариантов,
21:25
что мы можем сделать не так, меньше.
21:27
Это правда.
21:32
А можно несколько конструкторов с одинаковым названием, но разными типами?
21:38
К сожалению, нет.
21:40
Потому что в Haskell нет такой штуки,
21:49
как оверлоадинг.
21:50
То есть не может быть одной и той же функции
21:53
с разными реализациями, как в плюсах, например.
21:58
Но есть способ сделать
22:04
такой ad-hoc полиморфизм, как он называется,
22:06
но с конструкторами это не совсем прокатит.
22:09
Потому что, допустим,
22:11
мы все еще хотим их различать.
22:12
Если мы делаем pattern match, мы хотим знать,
22:15
мы сматчились на, не знаю, на что-то name конструктор
22:19
и как понять, сколько у него параметров.
22:23
То есть мы все еще хотим их как-то различать.
22:27
Да, есть некоторые неудобства, возможно,
22:32
если мы, допустим, не знаю,
22:35
можно представить себе ситуацию, какая-то неудобная, но как бы это некоторые трейдов,
22:39
что все остальное продолжает работать.
22:50
Давайте закончим эту главу все-таки.
23:02
Еще последний вещь, которую я хотел сказать.
23:04
Понятно, если мы вызовем функцию
23:11
Vector2D242 со стрингами,
23:13
что-нибудь вызовем, один будет VectorInt,
23:16
на выходе другой будет VectorString, это будут разные типы.
23:19
Ну, понятно.
23:24
И мы их никак не просоцировать не сможем.
23:28
То есть нет какого-то общего типа у них вектор.
23:33
Это скорее как плюсах.
23:34
Это совершенно разные классы, разные типы.
23:37

23:40
Так, окей, значит, maybe,
23:42
значит, очень полезный тип.
23:44
А можно еще по параметрам такой вопрос?
23:48
Мы можем как-нибудь из вот типа вектора, который у нас здесь,
23:53
который параметризованный,
23:55
можем ли мы из него сделать
23:57
его непараметризованный аналог для какого-то конкретного типа?
24:01
Взять и вычли из него вектор от Int?
24:06
Ну, ты можешь написать TypeAlias,
24:08
IntVector,
24:10
TypeIntVector равно VectorInt.
24:14
То есть можешь.
24:19
Да, все можно.
24:20
То есть можно сделать TypeAlias,
24:22
можно сделать NewType,
24:23
NewType будет дальше.
24:26
Мы как бы разберем это тоже.
24:31
Окей, давайте дальше.
24:35
Все можно, сейчас увидим.
24:36
Думаю, что вопросы сами эти отпадут.
24:38
В общем, давайте разберем maybe.
24:40
Maybe, значит, похожая штука, только мы, похожая штука,
24:45
что из IntResult, только у нас здесь как бы более общий тип.
24:49
То есть у нас можно вспомнить, что это некоторые вычисления,
24:53
то есть некоторые результаты вычисления, которые имеют тип A,
24:56
и у него она может свейлиться,
24:57
то есть может вернуть просто nothing.
24:59
То есть, по сути, это optional.
25:00
Optional в плюсах.
25:02
Не помню, наверное, в Java тоже есть что-то похожее.
25:07
В общем, да, это некий подход,
25:13
чтобы моделировать нул-пойнтеры,
25:18
то есть либо pointer, либо null.
25:24
С помощью этого можно писать
25:26
некоторые такие безопасные функции,
25:28
типа maybe second, то есть взять второй элемент массива,
25:31
но если как бы не получилось его взять, то nothing.
25:33

25:38
Безопасные в том смысле,
25:38
что мы можем легко проверить результат работы.
25:44
У нас нет какого-то ошибки, которые мы не можем поймать.
25:52
В общем, исключение.
25:56
Плюс maybe, забегая вперед, это monad, очень полезная.
26:01

26:02
То есть мы можем использовать ее для вычислений,
26:07
композировать вычисления,
26:09
которые нам дают,
26:10
могут вернуть ошибку или нет.
26:12
Это все будет в следующей лекции.
26:15
В общем, можно представить,
26:17
что maybe это некий такой бокс,
26:20
некая коробка, в которой либо есть что-то, либо нет.
26:21

26:23
То есть это значение и некоторый контекст,
26:28
который еще называют эффект.
26:32
Пока это, наверное, просто слова.
26:33
Дальше будет все более понятна аналогия.
26:37
А можно вопрос по поводу в коде предпоследней строчкой, тут maybe second,
26:41
и дальше аргумент в скобках.
26:44
Можно это расшифровать?
26:45
Да, это происходит pattern matching по листу.
26:51
Значит, у листа есть конструктор,
26:55
он принимает два аргумента.
26:57
Он принимает элемент и список,
27:00
то есть хвост, head и хвост.
27:05
Ну и, понятно, возвращается список.
27:06
То есть мы сматчились.
27:08
По сути, что тут происходит?
27:09
Первый underscore значит первый элемент,
27:12
x значит второй элемент,
27:14
а второй placeholder значит остальной список.
27:23
То есть мы вызвали просто just от второго элемента списка?
27:27
Да.
27:28
Спасибо.
27:30
То есть что мы сделали?
27:32
Мы взяли x, передали в конструктор,
27:35
и нам вернулся maybe.
27:36
То есть мы завернули наше значение в эту коробку maybe
27:41
и вернули пользователю.
27:43
А он же там сам будет проверять,
27:46
есть что-то в коробке или нет.
27:54
Так, ну давайте дальше.
27:57
Azure – другой способ обрабатывать ошибки,
28:04
когда мы хотим знать какое-то еще сообщение.
28:08
Ну или тег какой-то нашей ошибки,
28:13
строковый, не строковый.
28:14
В общем, left значит, что все, капут,
28:18
у нас вычисление исправилось,
28:20
right значит, что нормально вычислилось.
28:25
И вот, например, azure second.
28:28
Опять делаем matching,
28:33
проверяем, какие у нас могут быть ошибки,
28:35
разбираем случаи и возвращаем right x,
28:37
если все хорошо.
28:39
Да, ну и такой маленький совет, что надо смотреть за порядком матчинга.
28:51
Потому что в прошлой лекции,
28:53
вы знаете, что нужно в правильном порядке
28:58
заставлять потом матчинг,
28:59
потому что он идет сверху вниз,
29:02
всегда проверяется.
29:06
Ну и вот ссылочка на какое-то обсуждение,
29:09
у нас такое info про ошибку в функциональном программировании.
29:13
Интересная тема, много вариантов есть.
29:18
С вами проблемами.
29:19
Давайте дальше.
29:21
Рекурсивность.
29:22
Ну, понятно.
29:23
Дошли наконец-то до листа.
29:25
Типы могут быть рекурсивны.
29:27
То есть мы можем использовать в параметре сам тип, который мы сейчас определяем,
29:31
тем самым получая рекурсивные типы.
29:37
В общем, у нас есть два конструктора, nil и cons.
29:41

29:42
nil – это просто пустой список,
29:44
cons – это head, хвост.
29:49
И мы возвращаем уже наш тип.
29:53
Понятно, вот список из 2, 1, 3.
29:59
Можно писать свой мэп.
30:00
Вот, пожалуйста.
30:05
Ну да.
30:07
Отличие от реального листа только в том,
30:09
что у нас конструктор у листа – это оператор.
30:14
То есть мы не пишем cons, мы просто используем оператор в двоеточии.
30:19
Ну и плюс там еще какой-то синтаксический сахар сверху всего этого.
30:25
Вот.
30:27
Да.
30:33
Ну да, собственно, вот определение,
30:36
как оно могло бы быть в основном в библиотеке.
30:43
Ну да, и у нас еще есть специальный синтез для типа,
30:46
потому что у нас имени для листа нет.
30:51
У нас квадратные скобки для этого используются, для краткости.
30:57
Не уверен, кстати, что это можно самому определить.
30:59
Мне кажется, это вшито скорее в язык,
31:01
но, в общем, потому что здесь используется.
31:06
Хорошо.
31:09
Извините, а можете, пожалуйста, объяснить,
31:11
что происходит в myList,
31:13
когда myList равно cons 2, cons 1, cons 3.
31:19
Да, давайте, смотрите.
31:21
Ну еще раз.
31:22
Мы читаем эту запись, читаем ее по порядку,
31:32
как мы вычисляем лямбдовыражение.
31:35
То есть в самом начале вычисляется, грубо говоря, внутреннее.
31:39
Мы парсим это.
31:42
Что тут происходит?
31:42
Функция cons, сам внутри.
31:45
Ей передается два параметра, 3 и nil.
31:49
То есть смотрим, совпадает это ли с сигнатурой.
31:53
Да, совпадает.
31:54
То есть мы передаем 3 и nil.
31:57
И в итоге эта скобка имеет тип list.
32:02
Дальше следующий конс принимает 1.
32:05
И вот эту скобку, которую мы поняли,
32:07
что тоже возвращает list int.
32:11
То есть опять мы возвращаем.
32:14
Опять внешняя скобка, вот этот тоже list.
32:21
Мы конструируем наш список.
32:25
Получается будет длиной 3.
32:28
Да, да.
32:31
То есть мы сделали просто... Это тип или что это? Это переменная.
32:37

32:44
Это не функция, я так понимаю.
32:45
Константы.
32:47
Константы, да.
32:50
Это философский вопрос.
32:51
Все функции.
32:55
Сори, я до этого читал курс по теории типов, поэтому у меня немножко сдвиг.
33:04
Константы и функции большой разницы не имеют.
33:07
Функция, которая понимает ноль аргументов, это константы.
33:17
Ну да, это константы.
33:20
Не переменные, потому что у нас все немутабельное пока что.
33:25
Потом будут переменные.
33:28
Сразу видно, как они выглядят.
33:30
Ну, в общем, да.
33:35
То есть еще раз.
33:40
Давайте такая интуиция.
33:42
Что такое конструктор?
33:43
Конструктор это функция.
33:44
В целом обычная функция.
33:46
У нее есть сигнатура, которая принимает элемент,
33:52
принимает хвост списка и возвращает список, прибавляя к нему вот этот один элемент.
33:57
Но при этом она еще и является представлением типа.
34:00
То есть, грубо говоря, посмотрев на то,
34:05
как мы определили этот список из трех элементов,
34:10
мы можем понять, как оно и в памяти представляется.
34:14
Оно точно так же представляется.
34:16
То есть у нас есть тег конструктора, его параметры.
34:21
И второй параметр это тоже лист, у которого тег конс
34:27
и два параметра и так далее.
34:30
То есть у нас такая как бы древовидная структура.
34:35
В общем, если вы напишите это на вариантах,
34:38
в плюсах, будет так же выглядеть.
34:44
В нормальной ситуации мы здесь не увидим скобок, а тут будут доллары.
34:49
Что?
34:50
Ну, где вот моя лист равна конус 2, конус 1.
34:57
Сейчас, не понял.
35:02
По какую строчку вы говорите?
35:05
Моя лист равна конус 2, конус 1.
35:09
Там будут вместо скобок деньги.
35:13
Ну, да.
35:15
Можно продать скобки, получить деньги.
35:18
Можно написать везде доллары без проблем.
35:24
Потому что конструкторы нормальной функции, они так же композируются без проблем.
35:33
А вот где мы определяем...
35:36
Я правильно понимаю, что вот этот тип представляет просто нам список?
35:45
Да, это просто список.
35:47
А вот где мы определяем... Ну, допустим, мы написали конус 1, конус 3.
35:52
И почему оно переводится в список?
35:56
То есть мы же потом обращаемся в MyMap
35:59
как к первому элементу и хвосту.
36:03
Но, допустим, не особо видно.
36:06
То есть у нас есть у списка конструктор с двоеточием.
36:13
Но когда мы делаем... Мы просто определили тут какой-то конструктор с именем конус,
36:18
и не определили, как он работает, или я что-то не понял?
36:22
Вот, окей, смотри, я понял вопрос.
36:26
Мы нигде не определяем, как работает конструктор.
36:29
В этом смысле разница между конструкторами в плюсах
36:32
и конструкторами в функциональных языках в algebraических типах данных.
36:38
Конструктор представляет собой просто структуру, структуру типа.
36:46
Он никак не работает.
36:48
Он как бы...
36:54
Ну, не знаю, если я скажу... Я понял, о чем вы.
36:57
Датакласс, ты понимаешь, о чем я говорю?
36:59
Да, я понимаю, о чем вы.
37:00
Я тогда не понимаю просто, почему мы там можем обращаться как к голове и хвосту.
37:05
Как он определяет, что есть голова, что есть хвост? По параметрам.
37:09

37:11
Ты матчишься типа на...
37:14
То есть еще раз, вот MyMap как работает.
37:16
Мы делаем паттерн-матчинг по листу.
37:20
Это либо nil, либо cons.
37:22
Это switch-кейс такой.
37:25
Мы делаем кейс.
37:26
Мы видим, что если nil, вернем nil.
37:30
Если cons, то мы матчимся на параметрах,
37:34
и мы знаем, что есть x, а есть xs.
37:39
Значит, x это первый параметр, он имеет тип a,
37:42
и xs это второй параметр, он имеет тип лист a.
37:45
Вот мы сматчились на...
37:47
Я все понял, да, спасибо.
37:49
То есть это такие как бы дата-классы.
37:53
В питоне есть...
37:56
В общем, это класс, который представлен...
37:58
Его определение класса, это то, какая у него структура.
38:08
То есть в плюсах, как ты пишешь конструкцию,
38:11
ты можешь написать какое-то сложное определение, как конструировать твой тип,
38:16
сделать какие-то вычисления перед этим, еще что-то.
38:18
Здесь это все не нужно.
38:20
Здесь ты сначала пишешь, как у тебя представляется тип,
38:25
а дальше ты можешь просто рядом написать функцию,
38:27
какую-то умную, которая конструирует этот тип,
38:30
используя меньшее количество данных, например,
38:32
что-то вычисляя или еще что-то.
38:34
Она просто рядом, сбоку.
38:39
Да, я все понял, спасибо.
38:46
Дата от TypeAlias отличается только конструктором?
38:52
Она много чем отличается.
38:54
TypeAlias это просто синтоксический сакр, грубо говоря.
38:59
Грубо говоря, это макрос такой.
39:01
Везде, где мы пишем имя alias,
39:03
мы можем подставить его определение.
39:06
Ну, по сути, перед определением просто
39:09
напишешь имя конструктора и получишь TypeAlias.
39:10
Ну, и как там дата?
39:12
Нет, это разные вещи, потому что, когда мы пишем дата, мы определяем новый тип.
39:18
Мы не можем заменить его на какое-то определение,
39:22
то есть мы определяем новый тип.
39:25
Принципиальная разница, мы определяем новый тип или мы создаем просто синоним.
39:29
Синоним это не новый тип.
39:31
Он совпадает совершенно с его определением.
39:43
Ну, типа, в плюсах есть, опять, понятные плюсы.
39:48
Типа, using это алиас.
39:51
Класс это новый тип.
39:53
Это разные вещи.
39:58
Мы дальше увидим что-то между ними,
40:01
какую-то конструкцию.
40:03
Думаю, что будет понятнее.
40:05
Хорошо, значит, по героическому типу данных есть еще вопросы?
40:11
У нас лекция не сложная.
40:13
Я думаю, что есть вопросы.
40:19
Ок, давайте дальше.
40:21
Значит, как это называется по-русски? Записи.
40:26
Нанозаписи.
40:29

40:30
В общем, я буду говорить с рекорды.
40:34
Значит, у нас есть возможность определить рекорды.
40:38
Это, по сути, такие кюплы с именованными полями.
40:47
В общем, да.
40:49
Можно представить, как такой синтактический сахар, просто с такими гетерами,
40:57
которые написаны на правом слайде.
40:59
То есть, понятно.
41:01
Опять же, логин, пасвод это просто функции,
41:05
которые определяются вместе с типом.
41:10
Есть специальный синтаксис для определения.
41:16
Понятно.
41:18
В общем, хотим спросить, чему равен какое-то поле.
41:25
Взяли сначала у юзера, примели функцию логин к рекорду юзера,
41:36
получили строчку, сравнили с Иваном.
41:41
Если Иван, то вернули трубку.
41:46
Собственно, да, хоть понятно.
41:49
Значит, паттерн-матчинг.
41:50
Мы можем делать паттерн-матчинг на рекордах очень удобно.
41:55
То есть, если мы хотим сматчить только какой-то один элемент,
42:00
можем сделать такой синтаксис фигурной скобки логин
42:04
равный юзернейм, где логин, первое, это имя поля,
42:08
юзернейм это переменная,
42:11
которую мы хотим забиндить, привязать к этому значению.
42:17
То есть, опять, какую проблему мы здесь решаем?
42:20
Если у нас, допустим, есть юзер,
42:21
как в самом начале нашей лекции, возвращаясь к ней, у нас есть два стринга.
42:28
Есть логин и что-то еще, пасворд.
42:32
Чтобы их не перепутать, они оба стринг,
42:35
мы их именуем, и теперь мы должны все представить,
42:38
что юзернейм это именно логин и пасворд.
42:46
Можем делать паттерн-матчинг такой вот.
42:51
В любом паттерн-матчинге мы можем записать вместо переменной,
42:55
которую мы хотим забиндить значение,
42:57
можем писать само значение,
42:58
тогда будет поверх то, что это равно имя.
43:03
В общем, очень удобно.
43:06
Есть такой специальный синтаксис update-синтакс.
43:12
В смысле, мы хотим взять Ivan,
43:17
взять запись и поменять только одно поле,
43:19
а все остальные оставить на своем месте.
43:23
Это, кажется, называется как-то функциональное
43:28
обновление, что ли, в оперативном мире.
43:34
В общем, да, у нас все иммутабельное, поэтому мы вынуждены скопировать весь объект,
43:43
но поменять только одно поле.
43:45
Чтобы не писать слишком много, есть такой удобный синтаксис.
43:51
Там прям все копируются, да?
43:54
Ну как, по сути, да.
43:58
Но как это представляется, вопрос.
44:01
Скорее всего, копируется...
44:06
В общем, если не лезть глубоко,
44:08
какие-то вещи могут просто скопироваться как ссылки, грубо говоря.
44:12
Но копируется все, да.
44:22
В общем, операторы...
44:29
Да, собственно, полем могут быть операторы тоже.
44:39
Честно говоря, я никогда не видел это, чтобы оно так использовалось.
44:43
Но, в общем, может быть, это удобно.
44:48
В общем, да.
44:50
Понятно, операторы — это просто функции.
44:55
И, в общем, тут получается, у нас мы сделали такой тип данных R,
44:59
у которого есть оператор, который делает что-то с n,
45:02
например, прибавляет 1.
45:04
Это будет конкретный какой-то... По сути, один объект
45:11
типа R — это какой-то оператор, который что-то делает.
45:13
И дальше мы можем через стрелочку его применить к числу.
45:22
То есть можно с помощью этого какой-то прикольный синдекс создавать.
45:28
В общем, enjoy.
45:33
Понятно.
45:35
Мы можем использовать вместе суммы типов и записи.
45:40
Например, person — это может быть админ или юзер.
45:44
У них одинаковые поля, но не совсем одинаковые поля.
45:48
Но даже если они были одинаковые, мы их можем всегда различить.
45:56
Есть такой нюанс, что, допустим, у нас есть теперь функция login.
45:59
Что же она делает?
46:00
Она принимает person и возвращает поле юзера или админа.
46:07
Но если мы вызовем UID, то для админа она не определена,
46:13
потому что у нее просто нет такого поля.
46:16
То есть эта функция не полная.
46:22
Она может упасть, что может быть потенциально опасно.
46:27
То есть лучше бы написать какой-нибудь типа maybe UID или что-то такое.
46:32
В общем, можно все безопаснее сделать.
46:38
По дефолту оно, к сожалению, вот так.
46:41
Да, собственно, можно писать функцию проверки, что это админ.
46:46
Тут такой синдекс тоже.
46:48
Если нам неважно, какие поля находятся, мы можем проверить, это юзер или админ,
46:56
пишутся пустые фигурные скобки.
47:00
Это важно.
47:01
По-моему, нельзя просто написать фигурные скобки.
47:06
В смысле, опустить фигурные скобки и просто написать админ.
47:11
Но это не точно.
47:13
В общем, можно написать админ и подчеркивать.
47:20
А не одно подчеркивание?
47:23
Одно, по-моему, нельзя, да?
47:25
Два надо написать.
47:26
Да, тут есть такой прикол, что в целом у нас все еще есть функция админ,
47:31
которая принимает int и string и возвращает нам person.
47:36
То есть мы можем использовать как рекорд синдекс,
47:40
так и просто обычные конструкторы.
47:48
Потому что, как мы поняли, рекорд это тоже синдексический саппорт, по сути.
47:55
Окей.
47:57
Есть некоторые проблемы с этим.
48:00
То, что, допустим, у нас есть два типа данных, у которых одинаковые имена,
48:04
одинаковые имена полей.
48:08
Что такое функция name здесь?
48:12
Она не может принимать совершенно любой тип.
48:16
Это другая ситуация по сравнению с логином, который здесь был.
48:20
Потому что тут можно нормально выписать
48:24
сигнатуру функции логина, а тут уже нельзя.
48:26
То есть это либо main, либо cat. Непонятно.
48:30
И, в общем, одно из решений не использовать одинаковые поля,
48:40
что может быть как бы...
48:43
В целом это возможно, и я думаю, что на практике тоже многие так делают.
48:47
То есть дальше мы посмотрим, какие Haskell предоставляет возможности
48:52
для сокрытия какой-то реализации через модули.
48:58
То есть не все совсем плохо.
49:04
Также есть расширение, которое пытается убрать такое неудобство.
49:14
Мы добавляем это расширение, пишем language duplicated record fields,
49:19
и после этого у нас создается некий статистический сакр,
49:26
который при компиляции делает эти неймы, эти функции разными.
49:34
И пытается из контекста понять, какая из них используется заменить.
49:41
И, например, у нас есть какая-то функция, которая принимает main
49:51
и использует функцию name к нему, но тут проблема есть некая,
49:55
что нам приходится указывать явно тип функции,
50:02
потому что иначе он не может догадаться...
50:06
Далеко не во всех случаях он может догадаться, какая функция name используется.
50:14
В общем, есть нюансы с этим.
50:22
Но да, для паттерн-матчинга это спокойно работает.
50:27
То есть для некоторых случаев это работает всегда, например, для паттерн-матчинга,
50:32
а для применения функции приходится выписывать тип.
50:37
Ну, в общем, некоторые трейдовы опять.
50:42
Когда-то удобно одно, когда-то другое.
50:51
Значит, давайте дальше.
50:54
Да, вот тут есть ссылочка, кстати, обратите внимание, про inference.
51:00
Собственно, как это примерно работает.
51:04
Вот это расширение.
51:06
Так, record wildcard, значит, тоже удобная штука.
51:13
Допустим, у нас есть юзер, у него есть опять вот эти поля,
51:17
и мы хотим сматчиться...
51:29
Да, смотрите, тут суть в том, что мы не хотим выписывать все поля совершенно.
51:34
То есть мы хотим на них сматчиться, но просто на те имена, которые у них есть.
51:43
То есть мы просто пишем в синдексе с UID 0, 1, 2 точки,
51:52
и дальше мы можем использовать как UID, так и логин, и пасворд.
52:00
Если мы не хотим матчиться на поля или их как-то переименовывать,
52:07
мы просто пишем 2, 2 точки и используем их.
52:10
Понятно, еще один синтезический сахар.
52:13
И для этого нужно подключить расширение record wildcard.
52:23
Да, и это даже работает с duplicate fields, что реально выглядит немножко как магия.
52:36
Окей, ну, собственно, мы переприсвоили name из man.
52:46
Окей, new type. Очень интересная штука.
52:50
В общем, у нас есть 2 синтаксиса, data message и new type, имя типа.
52:58
Сразу скажу, что у Haskell очень странное название типов.
53:06
Есть data, которое можно как-то еще просоцировать с датаклассом,
53:11
а new type это новый тип, но как бы data это тоже новый тип.
53:16
В общем, не обращайте внимания на название, скорее запоминайте, в чем суть.
53:23
То есть если data это какой-то общий тип, то
53:26
new type это некоторый его частный случай,
53:29
когда у типа всего один конструктор и, возможно, одно поле.
53:37
То есть оно может быть именованное, может быть нет.
53:40
В общем, в чем прикол?
53:42
Прикол в том, что если у нас всего один конструктор,
53:46
мы можем как бы избавиться вообще от тега.
53:49
То есть когда мы делаем паттерн-матч, у нас всего один вариант.
53:52
По сути, паттерн-матч можно вообще убрать.
53:57
И на самом деле Haskell поступает намного умнее,
54:01
он вообще не делает между ними различий в рантайме.
54:06
То есть после компиляции у нас нет различия между месседжем и стрингом.
54:14
То есть мы используем, как бы, мы вводим новый тип, месседж.
54:21
Он отличается от всех остальных.
54:23
И в compile-time он будет проводиться проверки, в отличие от type-alias.
54:29
Но в рантайме это будет одно и то же.
54:34
То есть мы получаем больше гарантии, не платя за это реформенсом.
54:43
Собственно, давайте посмотрим на примере.
54:49
Значит, да, тут такой предысторий к примеру,
54:52
что у нас есть какая-то функция derivePublicKey.
54:57
Она как бы из публичного ключа дает секретный ключ.
55:01
Есть функция, которая проверяет пару, что она корректная.
55:06
И, в общем, у нас publicKey и secretKey это один и тот же тип.
55:11
То есть, грубо говоря, легко их перепутать, и последствия будут страшные.
55:17
То есть мы используем типы, но они нам не особо помогают.
55:22
Как сделать так, чтобы они помогали?
55:24
Давайте просто скажем, что publicKey и secretKey — это разные типы.
55:28
И после этого мы никогда не сможем их перепутать.
55:32
То есть как мы не можем перепутать int и bool,
55:34
точно так же мы не можем перепутать эти два типа.
55:40
И теперь у нас derivePublicKey имеет осмысленную сигнатуру.
55:45
То есть это не просто из string в string, так же как функция inside.
55:53
А это конкретный тип из secretKey в publicKey.
55:57
И на самом деле это один из способов прототипирования в Haskell.
56:02
То есть ты сначала думаешь о типах, пишешь только
56:06
типы, а потом уже пишешь для них реализацию.
56:11
Причем не реализуя все в правильном порядке.
56:16
Да, ну и, собственно, функция checkKeyPair тоже выглядит теперь более осмысленно.
56:25
И мем, что если код не компилируется, он не может работать неправильно.
56:30
Прекрасно.
56:33
Так, какие вопросы по newType? Есть? Окей.
56:49

56:51
Меня же слышно еще?
56:53
Да, хорошо слышно, все прекрасно.
56:55
Хорошо, идем дальше.
56:57
Type классы. Самое, наверное, интересное в этой лекции, на мой вкус.
57:02
В общем, ad-hoc полиморфизм. Что значит ad-hoc?
57:09
В общем, это значит, что мы используем то, что
57:13
мы сейчас хотим использовать, то и используем.
57:18
Грубо говоря, мы из контекста использования понимаем, что нам нужно.
57:22
Например, overloading в плюсах — это тоже ad-hoc, типа полиморфизм.
57:28
Мы пишем функцию плюс, и независимо от того, что мы...
57:36
Мы не указываем, какой конкретный плюс мы
57:37
используем, оно просто выводится из контекста.
57:40
Если рядом стоят строки, мы складываем строки — это одна реализация.
57:44
Если мы складываем числи — это другая реализация.
57:47
И, собственно, мы посмотрим, как такие же штуки делать в Haskell.
57:52
Значит, у нас есть type классы, это называется.
57:55
Мы, значит, классы типов.
57:59
Мы объявляем это с помощью следующего синтеза — класс printable P.
58:03
Это интерфейс.
58:04
То есть мы говорим, что у нас есть некоторый интерфейс,
58:08
которому некоторые типы могут удовлетворять или нет.
58:12
То есть какие-то типы могут входить в этот класс или нет.
58:15
Значит, этот интерфейс обязует реализовать следующие функции.
58:21
printme, который принимает, собственно, тип P.
58:26
P — это, собственно, тот класс, который будет реализовывать.
58:30
Это тот тип, который будет реализовывать этот класс.
58:33
И, собственно, простыми словами, это класс объектов, который мы можем распечатать.
58:40
Распечатать куда-то в конце, в строчку, в общем.
58:44
И, допустим, у нас есть некоторый класс просто enum из foo и bar.
58:52
И, значит, да, то есть тут давайте это немножко опустим.
58:59
Значит, дальше мы можем написать, значит, instance.
59:03
То есть объявить то, что наш тип foo удовлетворяет этому интерфейсу.
59:12
То есть его можно распечатать.
59:14
Для этого нужно реализовать функцию printme.
59:18
Вот так это работает.
59:22
Значит, понятно, у нас есть тут кейворды.
59:29
Класс — это определение класса.
59:31
Инстанс — это определение инстанса.
59:34
Определение того, что мы... Определение имплементации.
59:39
Инстанс — это имплементация.
59:41
Класс — это интерфейс.
59:45
Вот.
59:46
И теперь, допустим, мы хотим использовать этот type class,
59:53
чтобы написать некую полиморфную функцию, собственно,
59:57
которая использует этот полиморфизм.
59:59
Как?
1:00:00
Мы пишем, допустим, helloP.
1:00:02
Это некая функция, которая принимает объект
1:00:07
и печатает его в консоль, добавляя там hello.
1:00:08
И мы хотим потребовать,
1:00:13
что обязательно P, которое мы хотим распечатать,
1:00:16
должно удовлетворять интерфейсу printableP.
1:00:20
То есть, говоря на других языках,
1:00:24
это значит, что мы проверяем из instance of P printable.
1:00:30
То есть, если P удовлетворяет этому интерфейсу,
1:00:34
то тогда у нас type checking проходит.
1:00:37
Иначе он не проходит.
1:00:39
То есть, огромный плюс всего этого,
1:00:42
что все эти проверки происходят в compile-time, а не в run-time.
1:00:47
Да, собственно, так это можно выглядеть.
1:00:53
Ошибки, если мы передадим true, для которого мы не реализовали наш интерфейс,
1:00:59
то нам скажут, что sorry, не могу найти instance.
1:01:03
То есть, не могу найти реализацию этого дела.
1:01:06
В общем, давайте посмотрим какие-то базовые примеры всего этого.
1:01:15
Допустим, type class equal.
1:01:20
То есть, это интерфейс объектов, которые можно сравнивать на равно.
1:01:26
Ну и соответственно, если есть равно, есть и не равно.
1:01:29
И дальше мы видим один пример такого классного аспекта в Haskell.
1:01:36
То, что можно писать интерфейсы с дефолтными реализациями.
1:01:39
Здесь мы объявили сначала типы.
1:01:42
Не обязательно делать это прям так, можно это писать рядом.
1:01:46
То есть, тип, потом ниже реализация, как это обычно пишут на топ-левеле.
1:01:57
Но смотрите, в чем тут соль.
1:01:59
То, что у нас есть дефолтная реализация для обоих методов.
1:02:03
И она взаимно рекурсивная.
1:02:05
То есть, мы равно можем реализовать через
1:02:07
неровно, неровно можем реализовать через равно.
1:02:10
И плюс этого, что мы даем выбор пользователю,
1:02:16
точнее, пользователю нашего интерфейса, кто будет реализовывать его.
1:02:21
Если мы реализуем только равно, то мы получим сразу оба метода.
1:02:25
То есть, по сути, у нас просто дефолтная реализация
1:02:31
перекроется реализацией, которая в инстанте написана.
1:02:35
Или, допустим, для какого-то типа сложно написать равно, удобнее написать неровно.
1:02:45
Немножко игрушечный пример, но все же.
1:02:47
В общем, он может реализовать только функцию неровно,
1:02:50
и у него будет автоматом функция равно.
1:02:53
И дальше есть специальная директива, которая добавляет...
1:02:58
Собственно, все это проверяется.
1:03:00
То есть, комператор должен удостовериться, что ты реализовал все нужные функции.
1:03:06
Но тут такая проблема, что может быть так, что у
1:03:10
тебя функции реализованы, но взаимно рекурсивно.
1:03:15
Чтобы такого не было, есть специальная директива,
1:03:16
которая указывает, какие наборы операторов ты должен реализовать.
1:03:23
Какие из них является полными, а какие нет.
1:03:28
Ну и также, если мы хотим как-то оптимизировать оба оператора,
1:03:33
мы можем это сделать без проблем.
1:03:40
Да, но, кажется, чтобы писать вот эти типы, явно выписывать
1:03:50
типы для операторов, нужно instance.sig расширение.
1:03:57
Это нужно, чтобы в реализации выписывать тип.
1:04:01
Чтобы явно написать тип в реализации, нужно вот этот instance.
1:04:05
В общем, можно просто всегда использовать, и все.
1:04:14
Смотрим теперь, допустим, здесь TrafficLight.
1:04:17
Мы реализуем для него интерфейс ик таким естественным образом.
1:04:25
Матчимся на всех парах, которые равны.
1:04:27
Все остальные пары false.
1:04:29
Все понятно.
1:04:30
Теперь у нас есть instance TrafficLight, и мы можем сравнивать.
1:04:40
Ниже еще один пример, как написать полиморфную функцию,
1:04:43
которая, допустим, берет три объекта, которые можно сравнивать,
1:04:48
и проверяет, что они все три равны.
1:04:51
То есть пишем полиморфный код и радуемся жизни.
1:05:00
Потому что не нужно делать какое-то копипасту.
1:05:03
Давайте посмотрим следующий пример.
1:05:06
Ордеринг, когда мы хотим проверить на равенство.
1:05:11
Когда мы проверили на равенство, теперь мы хотим проверить на неравенство.
1:05:14
В общем, понятно, что если мы проверяем на неравенство,
1:05:18
то для этого нужно, чтобы изначально интерфейс
1:05:24
удовлетворял свойства, что у него есть равенство.
1:05:25
Мы расширяем наш type класс, добавляем в него две функции,
1:05:30
и с помощью этого у нас есть специальный синтезис.
1:05:33
Опять же, eq равно больше, такая стрелочка.
1:05:43
Эта стрелочка обозначает, что мы предоставляем требования к типу A.
1:05:48
Справа от стрелочки обычный тип, а слева от стрелочки constraint, то есть ограничение.
1:05:56
И как это было для функции, мы объявляем, что тип A должен удовлетворять constraint,
1:06:05
это ограничение, что у него должен быть instance eq.
1:06:10
И также мы объявляем это для класса.
1:06:12
То есть мы объявляем класс для тех типов, для которых уже есть eq.
1:06:19
Ну и понятно, дальше мы можем в дефолтной реализации использовать те методы,
1:06:33
которые мы потребовали, что существуют у этих типов.
1:06:37
Ну и тут видно, зачем нужна вот эта дефолтная реализация.
1:06:40
То есть можно реализовать compare, как это, 3-way comparing,
1:06:49
типа spaceship оператор в плюсах.
1:06:55
В общем, одну функцию достаточно реализовать
1:06:58
и автоматно получить все остальные операторы,
1:07:00
которые несложно выражаются через него.
1:07:04
В общем, да, вот такая штука.
1:07:08
Да, ну и опять же какие-то ссылочки для монетного чтения.
1:07:14
Ну, значит, числа в Haskell тоже полиморфные.
1:07:19
То есть если мы пишем семерка, это просто, на
1:07:22
самом деле, как бы семерка некоторого типа num.
1:07:26
То есть она может быть и флотовая, так и целочисленная.
1:07:34
И, значит, давайте посмотрим, вот прям так выглядит базовый тип num.
1:07:39
У него есть плюс, минус, умножить.
1:07:43
Прошу прощения, а minimal.complete.
1:07:45
definition в Word надо было написать или нет?
1:07:52
Нет, смотрите, у нас есть compare и...
1:08:03
Ща.
1:08:05
Хороший вопрос, кстати, сейчас.
1:08:06
У нас получается как?
1:08:07
У нас compare реализован через меньше либо равно.
1:08:11
И равно, да?
1:08:12
То есть мы можем реализовать либо compare, либо меньше, либо равно.
1:08:18
Ну, учитывая, что у нас есть равно уже.
1:08:26
Наверное, можно написать типа compare или меньше, либо равно.
1:08:29
Возможно, тут просто опущены для краткости.
1:08:32
А может быть, какие-то вещи компилятор сам умеет выводить.
1:08:37
Может быть, я не знаю, за последнее время.
1:08:40
Может выводить больше или меньше, в общем.
1:08:42
Поэтому это немножко на расширениях все еще остается,
1:08:45
потому что не совсем стабильная штука.
1:08:50
То есть что-то может компилятор вывести, а что-то нет.
1:08:56
А раз уж вернулись, можете, пожалуйста, еще раз повторить.
1:09:00
Где у нас написано class ик а стрелочка орт а.
1:09:06
Еще раз, что это значит?
1:09:11
Это означает, что мы определяем интерфейс орт для типа а
1:09:19
и требуем, чтобы для него уже был реализован интерфейс ик.
1:09:27
То есть, когда мы будем определять instance орт,
1:09:31
мы перед этим обязаны объявить instance ик.
1:09:34
Все, понял, спасибо.
1:09:37
Мы расширяем интерфейс, грубо говоря.
1:09:40
То есть это некоторый такой способ расширения интерфейса,
1:09:48
который у нас уже есть.
1:09:52
Так, раз уж мы остановились, время 12.
1:09:55
Мы начали в 10.40.
1:09:56
Сколько?
1:09:59
Пошло почти полтора часа.
1:10:01
Хотите ли вы сделать перерыв?
1:10:05
Ну, по идее, минут 10, если как-то вместится.
1:10:13
В целом мы больше половины рассмотрели, мне кажется.
1:10:17
Поэтому можно сделать перерыв.
1:10:21
Вот.
1:10:24
Ну, давайте, сколько? 10, 5 минут.
1:10:28
Давайте 10.
1:10:29
10, ок.
1:10:31
12.10, тогда возвращаемся.
1:10:41
Можете какие-то вопросы задать, если есть.
1:11:05
Да, вопрос был в слайде 19.1.
1:11:11
19.1...
1:11:15
Вот этот?
1:11:18
Да, что за оператор такой, стрелочка с двумя адефисами,
1:11:22
и не будет ли это считаться комментарием?
1:11:26
Потому что он у вас выделил, ну, подчеркнулся.
1:11:28
Да-да-да.
1:11:30
Я, честно говоря, не уверен.
1:11:39
У меня в репле тоже не получилось, я не особо встал.
1:11:43
Ну, да, то есть как бы это такое себе...
1:11:53
Ну...
1:11:56
Может, это пример неудачный.
1:11:58
Может, так можно сделать.
1:12:12
И на 28-ом слайде там еще hype-классы, а не type-классы.
1:12:15
Я не знаю, может, это intended?
1:12:19
Возможно, это intended.
1:12:22
Короче, я не знаю.
1:12:23
Ну, не знаю, поменяй на Unicode стрелочку, типа.
1:12:29
Ну, грубо говоря, типа... Сейчас, а три тоже нельзя, да? Три адефиса.
1:12:33

1:12:36
Ну...
1:12:37
Блин, сейчас.
1:12:38
Может, надо в хугле просто забить,
1:12:40
есть там такие операторы или нет.
1:12:43
Есть, слушай.
1:12:45
Есть такие операторы.
1:12:46
Значит, как-то можно.
1:12:48
Может, это проблемы чисто репла?
1:12:53
Наверняка, спасибо.
1:12:57
А можно вот еще раз объяснить, что значит фигурные скобочки?
1:13:01
Это, получается, мы объявляем функции в них?
1:13:06
Что мы делаем?
1:13:08
Фигурные скобки — это синтексис рекордов,
1:13:11
синтексис записей.
1:13:19
Ну вот.
1:13:21
А запись — это сокращение от того,
1:13:23
что мы делали до этого? Или как бы.
1:13:26
..
1:13:28
Запись — это такое понятие, как бы это тюпл с помеченными полями.
1:13:39
То есть мы, грубо говоря, дали имя...
1:13:44
Аргументам компьютера, грубо говоря.
1:13:48
Да.
1:13:51
Это такие геттеры.
1:13:55
А?
1:13:57
Ну, учитывая то, что все это, по сути, функции,
1:14:01
это вот такие геттеры.
1:14:03
Ну да, вот по сути, вот слайд, собственно, который на экране,
1:14:08
мы просто, ну, как бы статистически сахар.
1:14:10
Типа мы...
1:14:13
дали имена, значит, полям.
1:14:17
То же самое, что просто объявить геттеры.
1:14:29
Вроде бы очень тихо,
1:14:31
но может быть это только у меня.
1:14:32
Нет, у меня тоже.
1:14:35
Можно вопрос?
1:14:36
Вопрос по поводу 20-теряжного слайда,
1:14:40
где мы объявляли базовый пассворд.
1:14:44
Здесь же мы, как бы, получается,
1:14:46
что объявили в борде функцию compare,
1:14:50
и операторы меньше, меньше, равно, больше, равно, больше.
1:14:53
Но вот дальше мы ниже написали,
1:14:55
что x меньше равно y, равно compare xy, не равно gt.
1:15:00
А можно как-то расшифровать, что здесь происходит?
1:15:05
Ну, что происходит? Типа.
1:15:07
..
1:15:09
вспоминаем порядок, как это, операторов,
1:15:12
как называется, я не помню.
1:15:15
Ну, типа, приоритет операции,
1:15:18
что сначала применяется функция compare к xy,
1:15:23
возвращается значение,
1:15:27
типа ordering,
1:15:29
и мы сравниваем, что оно не равно gt.
1:15:36
Вопрос, почему это именно меньше, либо равно?
1:15:41
Вопрос, скорее, просто в синтексисе, потому что, кажется... В синтексисе...
1:15:47
Так, какой вопрос в синтексисе?
1:15:49
Ну, просто мы не должны нигде скобочки поставить,
1:15:52
потому что мы сначала функцию вызываем,
1:15:54
потом применяем оператор к результату.
1:15:56
Как-то не очень понятно, как это сработает.
1:16:02
Так это же прекрасно.
1:16:03
Меньше скобочек, как бы, компактный код.
1:16:07
Ну, типа, смотри, в Haskell интересный синтексис в целом.
1:16:14
То есть, нужно запомнить порядок операторов.
1:16:17
То есть, есть как бы всего 10, по-моему, уровней.
1:16:23
Вроде бы, да, 10.
1:16:26
Ну, это нормальный порядок операции.
1:16:30
То есть, как в математике умножение, оно сильнее, чем сложение.
1:16:35
Поэтому сначала мы вычисляем умножение.
1:16:37
И тут то же самое.
1:16:38
Самое сильное – это применение функции.
1:16:43
Функция – это compare функция.
1:16:45
Значит, мы ее применяем к x и y.
1:16:48
Дальше идет оператор.
1:16:49
Типа, он слабее, чем применение функции.
1:16:52
Поэтому сначала мы вычисляем его операнды.
1:16:56
Все, я понял, я распортил.
1:16:58
То есть, если хочешь, можешь выделить скобочки compare и x и y.
1:17:05
Но тебе compare расскажет, что можно убрать, если хочешь.
1:21:11
Что из этого нам дает ику, которую мы просим от класса? Еще раз.
1:21:25

1:21:27
Мы пишем класс ико а.
1:21:34
Что он нам дает, этот ико?
1:21:46
Допустим, мы уберем эту ико-стрелочку.
1:21:49
В чем получим?
1:21:52
Сейчас, секунду.
1:22:00
Смотри, допустим, мы уберем ико, что сломается?
1:22:06
Он нам в моменте использования x равно y скажет, что это за функция.
1:22:18
А остальное при этом не сломается.
1:22:20
То есть, если мы уберем это равно-равно, у нас все сработает.
1:22:25
Ну как, если ты уберешь равно-равно, то у тебя
1:22:29
в целом попадет смысл этого класса, но да.
1:22:34
Там же еще останется lt, gt.
1:22:40
Представь, что у тебя элементы можно сравнивать
1:22:42
на меньше, но нельзя сравнивать на равно.
1:22:53
Это как? Я не понимаю, как такое может быть.
1:22:54
Ну это когда не меньше и не больше.
1:22:57
Да, можно же выразить равно-через меньше-больше.
1:23:01
Ну можно, да.
1:23:02
Это правда.
1:23:09
То есть, можно написать какой-то другой класс,
1:23:12
орд, который не требует этого constraint,
1:23:16
который не требует равно-равно.
1:23:21
Это вопрос дизайна, наверное.
1:23:23
Я думаю, что есть какие-то математические вариации,
1:23:35
когда другая иерархия классов строится, но тут вот так, в стандартной библиотеке.
1:23:42
В целом, довольно разумно.
1:23:44
Но существует такой вопрос, что если мы используем равно-равно,
1:23:50
то мы должны в сигнатуре функции или класса указать,
1:23:54
что мы требуем выполнения этого constraint,
1:24:03
что действительно эти элементы можно сравнить на равно.
1:24:12
Для compare x, y, первая строчка это x равно-равно y.
1:24:16
Понятно, мы ее просим у ICO.
1:24:19
А вторая, x меньше-равно y, она откуда берется?
1:24:22
А это мы вызываем recursive на функцию, которую в этом же классе определяем.
1:24:29
Так, а у нас очередь происходит через compare.
1:24:34
Да, это взаимная рекурсия опять.
1:24:38
То есть до этого класса нам нужно где-то instance написать,
1:24:43
и в этом instance что должно быть?
1:24:46
После этого класса мы напишем instance,
1:24:47
и там минимально мы должны определить либо compare, либо меньше-равно.
1:24:58
Ага, класс, супер.
1:25:00
И еще должен быть ICO, который бы определил нам равно-равно.
1:25:04
Да, он просто должен быть виден в этом месте.
1:25:08
Там не надо указывать.
1:25:10
Так, но если все равно нужно определять меньше-равно,
1:25:14
то ICO ни через что не выражается в определении,
1:25:17
то, в принципе, он нам не особо нужен здесь.
1:25:26
Сейчас, не понял.
1:25:28
Ну вот, кроме строчки, где x равно-равно y равно ICO,
1:25:32
он нигде ни через что не выражается.
1:25:35
Ну да.
1:25:36
Тогда, по сути, можно убрать ICO, вообще не просить больше.
1:25:43
И, например, внизу добавить x равно-равно y, а compare x, y не равно gt и lt.
1:25:54
Да, так можно.
1:25:55
Но, по сути, ты что сделаешь тем самым?
1:25:57
Ты просто одну из функций ICO перенесешь в ORD.
1:26:03
Ну да, зато нам теперь не нужно будет требовать от A, чтобы был реализован ICO.
1:26:09
Окей, согласен.
1:26:11
Но выиграли ли мы от этого что-нибудь?
1:26:13
То есть сейчас мы хотим, чтобы у нас до этого был какой-то instance,
1:26:17
который реализует меньше либо равно знак, и плюс еще ICO.
1:26:20
А так нам на одно требование меньше.
1:26:21
Это просто интерфейс ICO понадобится кому-то
1:26:25
другому, кто хочет именно ICO, а не ORD.
1:26:27
И ты его не будешь реализовывать, и будет грустно в такой ситуации.
1:26:31
То есть, да, вопрос.
1:26:33
Во-первых, декомпозиция — это хорошо.
1:26:37
Во-вторых, допустим, у тебя есть тип, у которого ты требуешь ORD.
1:26:43
Для него количество constraint не изменилось.
1:26:45
Ему как нужно было определить равно-равно, так и остается.
1:26:50
Ничего не меняется.
1:26:57
Убрав constraint у класса, по сути оставив
1:27:01
все равно то, что нужно определить равенство,
1:27:07
ничего не меняется.
1:27:09
То есть, смотри, ты не упрощаешь constraint
1:27:13
какой-то функции, ты упрощаешь constraint класса.
1:27:15
Constraint всех функций остаются такие же.
1:27:24
Может, я запутал? Нет?
1:27:28
Понятно?
1:27:33
Так, значит, давайте вернемся.
1:27:38
Сейчас, а можно еще один небольшой вопрос здесь?
1:27:41
Мы там внизу, вот, compareXY не равно GT, так легко используем,
1:27:45
а мы же нигде не писали реализацию equal для ordering.
1:27:50
Она автоматически где-то згенерировалась или ее надо тоже писать?
1:27:54
Да, хорошее замечание, его тут нет.
1:27:56
Его нужно, ну, надо либо его определить, instance, либо задеравить.
1:28:04
То есть, deriving значит, что он автоматически может быть сгенерен.
1:28:09
Инстанцы могут автоматически генериться, мы тоже сейчас увидим.
1:28:15
Не всегда нужно все это определять руками.
1:28:19
Спасибо.
1:28:22
В этом смысле Haskell прекрасен в том, что он, как сказать,
1:28:31
мотивирует тебя создавать новые типы.
1:28:37
То есть, на любой чих новый тип, без проблем вообще.
1:28:46
Мы хотим сделать новый тип, я не знаю, для security.
1:28:51
Без проблем, создавай.
1:28:54
Равенство для этого нужно переопределять.
1:28:58
Равенство, типа, орд, еще что-то.
1:29:00
Все это можно сгенерить.
1:29:04
То есть, это как бы прекрасно.
1:29:06
Да, еще я хотел, это один момент, а второй момент, который я хотел сказать,
1:29:10
в целом, чтобы было понимание общее, почему
1:29:13
вообще вот то, что я сейчас рассказываю, важно.
1:29:16
Даже если вы не будете писать на Haskell, вообще
1:29:19
сама концепция тип-классов, она очень интересная.
1:29:23
Потому что, во-первых, она теоретически
1:29:25
интересная, то есть, там можно посчитать статью,
1:29:28
она будет либо где-то в конце слайдов, либо я так могу скинуть про тип-классы.
1:29:37
То есть, она с точки зрения теории типов интересная.
1:29:40
Плюс еще тип-классы, например, есть язык Rust.
1:29:46
У него тоже такая же система тип-классов.
1:29:49
Ну, она не такая же, она похожая, но они как бы вдохновлялись тем же самым.
1:29:54
Там это называется Type Traces.
1:29:59
Плюсы, по-моему, тоже в какую-то эту же сторону двигаются.
1:30:02
Если раньше там было вот эти enable-if-t или что-то такое,
1:30:11
то есть, это компиляторная магия, то в целом,
1:30:16
по-моему, они двигаются в сторону концептов, которые, если я не ошибаюсь, они тоже...
1:30:24
Суть в том, что ты декларативно указываешь
1:30:26
какие-то constraints на классы, на реализацию.
1:30:30
В общем, идея очень классная, прикольная.
1:30:33
И при этом в Haskell она реализована.
1:30:35
Это, наверное, одна из лучших реализаций тип-классов,
1:30:39
потому что они довольно мощные в Haskell.
1:30:44
То есть, мы там дальше увидим, они могут быть
1:30:48
и параметрические, и, в смысле, полиморфные,
1:30:53
и можно писать инстансы полиморфные,
1:30:56
и, в общем, там есть какие-то функциональные зависимости.
1:30:59
В общем, куча разных фич.
1:31:01
Я даже видел какой-то чувак, типа, зависимые
1:31:04
типы кодировал с помощью этих тип-классов.
1:31:08
Там можно вараги делать, вараг-функцию с помощью тип-класса.
1:31:13
В общем, прикольная штука.
1:31:18
Вот.
1:31:20
Собственно, давайте дальше ее взбирать.
1:31:23
А как работает тип, который внизу написан?
1:31:26
Который от Summa, от Moe University и Sirocco.
1:31:33
Хорошая шутка.
1:31:36
Или нет, подожди.
1:31:41
Ты шутишь или, типа, я реально вопрос?
1:31:45
Ну, вообще шучу.
1:31:47
Окей, все.
1:31:48
Ну, на всякий случай, типа.
1:31:50
Мало ли.
1:31:53
Может, у нас такой уровень понимания не терялось сейчас, я не знаю.
1:31:58
Вы говорите, мне тоже сложно понимать, что понятно, что нет.
1:32:07
Вот.
1:32:09
Да, тип.
1:32:12
В общем, давайте дальше.
1:32:15
Ну, мы смотрели уже.
1:32:17
У нас есть класс, есть у него куча всяких методов.
1:32:22
Типа, плюс, негейт, апс, ну и так далее.
1:32:27
Вот.
1:32:28
Интересный у него метод, наверное, fromInteger.
1:32:31
То есть это, типа, из любого интеджера можно сконвертировать в...
1:32:38
То есть...
1:32:41
Как из интеджера, типа, можно сделать int, можно сделать double и так далее.
1:32:46
То есть...
1:32:50
Это полезно для как раз вот этих вот литералов, которые полиморфные.
1:32:55
То есть когда мы пишем, если мы в Haskell напишем...
1:33:00
Спросим у GHCI, типа, тип.
1:33:03
Спросим тип.
1:33:06
В чиселке у нас будет 0p.
1:33:08
То есть это, на самом деле, синтаксический сахар для fromInteger 5.
1:33:16
FromInteger 5.
1:33:20
Значит, и...
1:33:21
В зависимости от того, в каком контексте будет использоваться это выражение,
1:33:26
там уже будет вывозиться, типа, это double, int.
1:33:30
В общем, очень удобно.
1:33:34
Да.
1:33:39
Ну и мы видим, что у нас, типа, у нас тут...
1:33:41
Вот тут класс, типа, тоже не сильно дробится.
1:33:44
То есть его, наверное, можно было разбить, типа, вот это вот на кольцо, на что-то еще.
1:33:49
В общем, можно было так сделать.
1:33:53
В стандартной библиотеке вот такое принято решение.
1:33:56
Ну, это вот набор вот таких классов.
1:34:00
Значит, дальше у нас есть type класс, height класс show.
1:34:06
Ну, это, типа, printable, который у нас до этого был.
1:34:09
Так он называется в стандартной библиотеке, он называется show.
1:34:17
Значит, он должен быть... Он всегда используется в JSCI.
1:34:21
Всегда мы пишем...
1:34:23
Когда мы пишем, типа, 5, он показывает это с помощью show.
1:34:34
Значит... Ну, вот.
1:34:36
Да.
1:34:38
В общем, как-то так.
1:34:45
Ну да.
1:34:46
Есть разные num типы, которые творятся в интерфейсе num.
1:34:51
Это int, double, rational.
1:34:54
У них там тоже есть какая-то иерархия.
1:34:58
Есть fractional, который, по-моему, включает в себя num.
1:35:04
Вот.
1:35:05
Ну, это можете в стандартной библиотеке там...
1:35:07
В этом...
1:35:11
В кугле поискать.
1:35:13
Вот.
1:35:13
В общем, да.
1:35:15
Read.
1:35:17
Тоже важный тип.
1:35:19
Потому что... Важный type класс, потому что он на самом деле...
1:35:26
Нужен для парсинга.
1:35:30
Да.
1:35:30
Вот.
1:35:32
Короче... Понятно.
1:35:34
Чтение...
1:35:37
Чтение строки.
1:35:41
Ну, понятно, что это не полная функция.
1:35:43
Да, и тут есть такой момент, что...
1:35:47
Когда мы пишем read, мы не можем...
1:35:52
Из строчки понять, что нам нужно... Какую функцию вызывать.
1:36:03
Допустим, double или int.
1:36:04
Непонятно.
1:36:06
То есть для этого нужно явно указывать тип, который возвращаем, и мы хотим.
1:36:10
Потому что иначе...
1:36:16
Есть какая-то неоднозначность.
1:36:20
Вот.
1:36:21
Ну, и по дефолту, возможно, это может как-то вам выстрелиться в ногу.
1:36:25
То, что, допустим, если мы напишем read true,
1:36:28
там вывезется какой-то непонятный тип.
1:36:34
Возможно, случайный.
1:36:36
Возможно, он вывезется как-то из вашего использования.
1:36:39
И read просто упадет.
1:36:41
Потому что...
1:36:43
Вот как-то вывелось, что там должен быть такой
1:36:45
тип, а вы думаете, что там должен быть bool.
1:36:48
Вот.
1:36:48
Поэтому, в общем, в таких случаях лучше всегда указывать, что вы ожидаете типом.
1:36:55
Вот.
1:36:56
Но это прекрасно, что не нужно называть функцию по-разному как-то.
1:37:03
Типа read bool, read true.
1:37:05
Это все одна и та же функция.
1:37:06
Она полиморфная.
1:37:08
И если из контекста реально понятно,
1:37:10
если вы сразу после read композируете из какой-то функции, которая принимает bool,
1:37:16
оно вывезется, что там должен быть bool.
1:37:22
Просто не всегда это может быть очевидно.
1:37:24
Да.
1:37:24
И есть функции readMaybe, readEither,
1:37:28
которые позволяют чекнуть, проверить, что результат правильный.
1:37:37
Вот, собственно, пример использования.
1:37:43
Такие вот типы у них.
1:37:46
То есть по типу, наверное, должно быть уже понятно, что readA стрелочка значит,
1:37:50
что мы требуем, что тип A должен быть читаемый.
1:37:54
И у него должна быть реализована функция read.
1:37:58
Ну, в общем, вот все понятно должно быть.
1:38:06
Полиморфные примеры.
1:38:07
Допустим, вычитание.
1:38:12
Собственно, мы требуем, чтобы был тип num у A.
1:38:17
После этого мы можем вычитать, использовать минус.
1:38:24
И как бы неважно, какой это конкретный тип.
1:38:27
Да, вот я, кстати, говорил уже про fractional.
1:38:29
Есть fractional, который расширяет класс num,
1:38:33
добавляет деления.
1:38:46
Есть инстансы такие.
1:38:50
Если мы хотим посчитать, например, среднее, то нам нужно деление.
1:38:53
Нам уже num не достаточно.
1:38:56
Нужно fractional.
1:39:01
Но давайте посмотрим, например, у нас есть функция.
1:39:04
Какой у нас наиболее общий тип этой функции?
1:39:08
Причем этот тип сам выведется компилятором, если вы его спросите.
1:39:15
Причем прелесть type-классов, что у них есть какая-то под ними теория,
1:39:20
есть алгоритм вывода и все такое.
1:39:22
В общем, они могут вводиться.
1:39:26
Смотрим, у нас используется меньше оператор.
1:39:30
Значит, мы идем туда, где он определен.
1:39:33
Он определен в классе орд.
1:39:35
Значит, у нас x и y должны быть орд.
1:39:40
Иметь тип какой-то орд а.
1:39:43
Плюс, значит, нам нужен num.
1:39:45
Умножить тоже num.
1:39:48
Можем проверить себя, спросить GHCI, он скажет, орд и num должны быть.
1:39:54
То есть, да, если не оставлять комплиментов,
1:39:56
они указываются просто в скобочках через запятую.
1:40:02
На самом деле, никакой магии нет под type-классами.
1:40:10
Это работает как?
1:40:11
У нас нет каких-то виртуальных таблиц или чего-то такого.
1:40:15
На самом деле, вот эти орд а и num а это можно воспринимать как неявные аргументы.
1:40:21
То есть, функция cmp сам принимает instance,
1:40:30
который определяет для а функцию орд,
1:40:37
интерфейс орд,
1:40:39
и использует их внутри своего тела,
1:40:41
внутри, значит, определения.
1:40:45
А почему недостаточно только одного num?
1:40:47
Мы и так можем число сравнивать, зачем num явно указывает, что мы еще орд требуем?
1:40:54
Давайте посмотрим определение num.
1:40:57
Num не требует орда.
1:41:04
То есть, по дефолту num не может сравниваться друг с другом? Да, да, да.
1:41:08

1:41:13
Это специально сделано или просто для непонятной магии?
1:41:21
Нет, я думаю, что это специально сделано.
1:41:23
То есть, к чему обязательно числа должны сравниваться?
1:41:28
Какие числа буквально сравниваются?
1:41:32
Ну, допустим, это...
1:41:35
Ладно, мы не говорим про комплексные числа.
1:41:37
Нет, ну, допустим, комплексные, я не знаю.
1:41:41
Допустим, это, я не знаю, какие-то кольца,
1:41:46
я не знаю, в кольце у тебя есть сравнение?
1:41:49
Ну, оно как бы есть, но там толку от него.
1:41:53
Если все равно все операции замкнуты.
1:41:56
Ну, там типа не выполняется какое-нибудь правило треугольника,
1:41:59
или что-нибудь такое, я не знаю.
1:42:03
Ну, короче...
1:42:08
Ну, вот так сделано, я не знаю.
1:42:11
Мне кажется, что можно пойти в Google.
1:42:16
Давайте сходим.
1:42:18
Есть Num, да?
1:42:20
Класс Num в Prelude.
1:42:25
Да, и вот мы видим его определение.
1:42:28
Видно, да, что я показываю?
1:42:33
Да, да, да, видно.
1:42:34
Вот определение, написаны какие-то его законы,
1:42:37
к которым должны удовлетворяться инстансы.
1:42:40
Ну, это они неформальные,
1:42:41
они не могут быть проверены компилятором,
1:42:46
но их часто указывают в документации,
1:42:48
какие свойства должны выполняться.
1:42:53
Значит, да, вот мы видим, значит, все это определение.
1:42:55
Вот есть инстансы, по крайней мере, которые есть в Prelude.
1:42:59
И вот что тут есть? bool float int.
1:43:01

1:43:04
Вот строки, например, есть.
1:43:07
Строки как сравниваются?
1:43:08
Ну, окей, строки можно литерографически сравнивать,
1:43:12
в целом,
1:43:14
но можно притвориться, что есть несколько способов,
1:43:17
как сравнивать строки, поэтому непонятно.
1:43:19
Не обязательно, чтобы они были.
1:43:25
Ну, не знаю.
1:43:36
Короче, в целом тут как раз это про то,
1:43:42
про что говорил ваш коллега,
1:43:46
что зачем нам требовать больше, чем нужно?
1:43:49
Мы нигде не используем ORD.
1:43:50
Зачем нам его требовать?
1:43:54
Если бы мы его использовали, то да.
1:43:56
Типа, окей.
1:43:57
А так зачем? Так, спойлеры.
1:44:08

1:44:10
Ага, вот, мы здесь остановились.
1:44:15
Да, я сказал про то, что, на самом деле,
1:44:17
type classes — это просто как бы некоторые такие неявные параметры у функций.
1:44:22

1:44:25
Которые компилятор может выводить
1:44:27
и подставлять вместо нас.
1:44:30
То есть, поэтому можно... Зачем я это говорю?
1:44:33
Потому что дает такую некоторую интуицию, почему вот пишется вот так вот, типа там,
1:44:39
круглые скобочки, запятая.
1:44:40
Потому что это, на самом деле, реально
1:44:45
typo из instances.
1:44:49
Вот.
1:44:51
У нас вот этот вывод типов,
1:44:52
ну вот из значка плюс мы, например, выводили num.
1:44:55
А если я заведу свой type класс со значком плюс,
1:44:57
то будет ambiguous?
1:45:00
Да.
1:45:03
А в цупле у нас есть порядок?
1:45:15
В цупле есть ли порядок?
1:45:17
В смысле?
1:45:19
Ну, ort a и num a,
1:45:21
и num a, ort a — это не одно и то же?
1:45:26
А, нет, это одно и то же.
1:45:28
Нет, нет порядка.
1:45:30
В смысле, да, я понял.
1:45:33
Нет, констрейты указываются в любом порядке.
1:45:36
Констрейты в любом, а вот если бы у нас был нормальный tuple,
1:45:40
то там уже не в любом.
1:45:42
Ну, типа два стринга, наверное, перепутать не очень хочется.
1:45:49
В смысле, у тебя же у конструктора есть первый, второй? Да, конечно.
1:45:52

1:45:53
Ну, типа да, обычно у tuple есть.
1:45:58
Нет, конечно, haskell — это странный немножко язык,
1:46:00
когда ты первый раз на него пишешь, но не настолько.
1:46:07
Так, а tuple у нас встречаются вообще вне контекста этих констрейнтов?
1:46:13
В смысле?
1:46:14
Ну, там, типа, первые слайды там были.
1:46:19
Вот tuple.
1:46:23
А, так, ну вот type alias как раз.
1:46:25
Ну, вот здесь уже порядок важен.
1:46:29
Да.
1:46:30
Ага, в порядках есть, прикольно.
1:46:35
Ну, синтактически, как бы, и круглые скобочки
1:46:38
не всегда одно и то же получаются сначала.
1:46:42
Ну, да.
1:46:45
Так и почти во всех языках.
1:46:47
Ну, блин, нет, в смысле, короче, есть tuples, да?
1:46:53
Типа, вот внизу написано, типа,
1:46:55
uid.login.name — это tuple выражение, да?
1:46:59
Оно имеет тип tuple int string string.
1:47:05
Окей.
1:47:07
То, что я сказал про констрейнты, это как бы интуиция.
1:47:11
Это не обязательно, типа, так.
1:47:14
Это тоже просто синтаксис.
1:47:17
Ну, да, короче, порядок констрейнтов неважен.
1:47:26
Скобочки, значит, разные, да.
1:47:28
Например, можно выражение в скобочке взять.
1:47:30
Это не значит, что это tuple.
1:47:34
Ну, понятно, что в контексте, когда там у нас в скобочках типы записаны.
1:47:38
Да, да, да.
1:47:40
То есть порядок как бы в типе важен, порядок в констрейнтах не важен.
1:47:47
Да, да, все верно.
1:47:51
Окей.
1:47:54
Окей.
1:47:57
Так.
1:48:01
Полиморфные штуки.
1:48:02
Короче, да, это мы все посмотрели.
1:48:05
Что дальше?
1:48:07
Ну, это маленькое такое отступление.
1:48:10
То, что есть...
1:48:13
Есть такие функции, как undefined,
1:48:16
которые означают как бы...
1:48:19
Ну, это типа bottom в теории типов, если кто ходил, слышал.
1:48:25
Короче, это вычисление некоторое, которое не завершается.
1:48:31
В бесконечной циклице, грубо говоря.
1:48:34
И теоретически это значит, что оно имеет false.
1:48:38
Типа ложь.
1:48:40
Оно совершенно любого типа.
1:48:45
То есть если мы спросим тип undefined, у него тип A.
1:48:48
То есть его можно подставить совершенно вместо любого выражения в коде,
1:48:51
чтобы как бы заткнуть любую дырку им можно.
1:48:57
Например, у нас есть тип fu.
1:48:59
У него какой-то сложный тип.
1:49:04
Он принимает string.
1:49:06
Там A, 2B, возвращает string.
1:49:08
Есть какие-то constraints на A и B.
1:49:11
Но, допустим, мы пока что только прототипируем.
1:49:15
И мы пока придумывали только тип.
1:49:18
Мы можем просто воткнуть undefined и все.
1:49:22
И потом это реализовать когда-нибудь потом.
1:49:26
То есть мы завтра это реализуем, а сегодня оно уже будет отчекаться.
1:49:31
То есть в этом примере понятно, немножко непонятно,
1:49:34
что такое A, что такое B, что такое fu.
1:49:36
Но если как-то ее нормально назвать,
1:49:39
то это очень удобно.
1:49:44
Можно определить функцию.
1:49:46
Я не знаю, вы пишете код.
1:49:48
Не обязательно все писать с начала до конца.
1:49:51
Вы пишете код, вам нужна какая-то функция.
1:49:52
Вы выше определили ее тип, который вам нужен.
1:49:59
Дописываете интересную часть.
1:50:00
Потом реализуются всякие скучные вещи.
1:50:04
Понятно.
1:50:06
Я просто объясняю, наверное, что такое прототипирование.
1:50:08
Это, я думаю, вам понятно.
1:50:11
Есть еще функция error, которая такая же, только она еще принимает строчку.
1:50:15
То есть она умеет кидать какое-то сообщение об ошибке.
1:50:19
То есть если мы попытаемся вычислить undefined, это будет exception.
1:50:27
А если мы пытаемся вычислить error,
1:50:30
это будет exception, но с каким-то сообщением.
1:50:37
То есть если у нас есть в нескольких местах эти error,
1:50:41
можем их различить. Понятно.
1:50:50
Понятно.
1:50:51
Варнинг все выполнен профессионалами.
1:50:56
В реальном коде не надо использовать.
1:50:58
То есть код, который вы уже не прототипируете, запускаете,
1:51:01
там оставлять error и undefined – плохая идея.
1:51:07
Ну а если мы хотим обработать какой-то кейс,
1:51:10
когда у нас какая-то невыполнимая ситуация,
1:51:13
то есть какая-то ошибка, которая не должна случиться?
1:51:17
В этом случае тут разговор про обработку ошибок.
1:51:21
Чего мы хотим? Чего мы хотим, зависит от ситуации.
1:51:24
Если это ошибка, которая типа паник, error,
1:51:27
все, мы никогда не хотим восстанавливаться после нее,
1:51:31
да, можно, наверное, написать error и все.
1:51:35
Но мы хотим как-то на уровне типов нам себя
1:51:38
гарантировать, что этой ошибке не случится.
1:51:43
Если мы хотим на уровне типов
1:51:48
обеспечить себе, чтобы эта ошибка не случалась,
1:51:50
то error нам никак не поможет, понятно, да?
1:51:53
Ну, в итоге были прикольные всякие штуки по
1:51:56
типу вывода отрицаний в функциях в этих типах.
1:52:02
Ну и вот можно что-то там придумать, например.
1:52:09
Вывод отрицания...
1:52:12
Короче,
1:52:16
все еще мое утверждение, мне кажется, верным,
1:52:18
что error никак не поможет.
1:52:22
Или подождите, что ты имеешь в виду?
1:52:23
Типа отрицание через ложь выразить?
1:52:29
Короче, я не очень понял тебя.
1:52:35
Ну да, можно некоторые ошибки избегать с помощью типов.
1:52:40
Haskell в целом про это.
1:52:43
Но тут вопрос, по какие конкретно ошибки мы
1:52:45
говорим, не все можно избежать с помощью типов,
1:52:49
по крайней мере, haskellных.
1:52:51
И это зависит от ошибки.
1:52:53
То есть даже если мы просто заведем new type
1:52:57
для secret и public key,
1:53:00
мы уже избежим от этого... С помощью этого куча ошибок, правильно?
1:53:03
У нас будет тапчекаться, что они разные, что мы никуда не передадим.
1:53:08
Secret, там должен быть public.
1:53:12
Ну да,
1:53:14
ты правильно говоришь.
1:53:21
Но в целом... Окей, у нас есть тип еще,
1:53:24
этот void, который data void.
1:53:28
Так.
1:53:30
Какое это имеет отношение к MDF? Типа абсурд.
1:53:36

1:53:39
Ну, я вообще имел в виду именно функцию absurd,
1:53:42
когда говорил про Matlab.
1:53:44
Абсурд. Из индреса, что ли?
1:53:51
Которая используется...
1:53:53
Я понял тебя.
1:53:55
Это немножко не то.
1:53:59
Это, короче...
1:54:00
Окей, void это такая штука...
1:54:04
Сейчас.
1:54:10
Немножко...
1:54:11
Время у нас, наверное, есть?
1:54:12
Можно немножко отвлечься.
1:54:13
Короче, void...
1:54:15
Если мы откроем data void, то это немножко... Это тип, у которого нет конструкторов.
1:54:22
Это не то же самое, что undefined.
1:54:24
Undefined, как бы, это любой тип, а void это.
1:54:27
..
1:54:29
Это как бы тоже ложь.
1:54:31
Немножко по-другому закодированная.
1:54:34
С точки зрения теоретиков.
1:54:35
Он буквально возвращает a,
1:54:38
что по сути собой является undefined.
1:54:42
Потому что тип undefined a.
1:54:47
Абсурд возвращает a.
1:54:49
Ты имеешь в виду? Да, да.
1:54:51

1:54:52
Да, но ты не можешь передать абсурду никакое реальное значение,
1:54:57
потому что он не существует.
1:55:02
Да, все верно.
1:55:03
Знаешь, вся эта логическая суть прекрасна,
1:55:07
но она вся ломается, когда появляется undefined.
1:55:11
Потому что ты можешь сломать...
1:55:16
Ты можешь в месте,
1:55:17
где у тебя предполагалось доказательство,
1:55:21
подсунуть undefined.
1:55:27
И ты уже не можешь гарантировать,
1:55:28
что если ты что-то доказал,
1:55:30
если у тебя все скомпилировалось,
1:55:32
то нет никаких ошибок.
1:55:34
Потому что, возможно, ты просто это сделал с помощью undefined.
1:55:40
Я думаю, что void немножко для этих целей существует.
1:55:44
Если мы притворимся,
1:55:45
что у нас нет undefined,
1:55:47
то что-то можно, наверное, доказывать.
1:55:51
Какие-то constraints на уровне типов.
1:56:03
Это немножко другая тема.
1:56:04
Это тема формального доказательства и теорем прулеров.
1:56:14
Пока не про это.
1:56:17
Deriving.
1:56:19
Что такое deriving?
1:56:21
Допустим, у нас есть traffic.
1:56:23
light, и мы не хотим для него определять все инстансы.
1:56:26
Можем писать просто deriving,
1:56:31
специальный кейворд deriving,
1:56:33
и он выведет нам все инстансы.
1:56:36
Если мы хотим, можем написать их кучу.
1:56:40
Янум, орд, шоу.
1:56:43
И он все это выведет.
1:56:45
Компилятор за нас.
1:56:46
Нам ничего не нужно делать.
1:56:49
Это пожалуйста.
1:56:50
Очень удобно.
1:56:52
Все автоматизировано за вас.
1:56:57
Можно сравнивать,
1:56:59
можно проверять неравенство.
1:57:04
Есть всякие toYanum, fromYanum.
1:57:09
У нас есть bound,
1:57:10
поэтому мы можем создавать
1:57:15
list comprehensions.
1:57:19
Сравнение лексикографическое,
1:57:21
или что это вообще?
1:57:24
Сравнение работает просто по номеру.
1:57:26
Red меньше, чем green.
1:57:40
Red меньше, чем yellow.
1:57:46
Янумы.
1:57:47
Если ты определяешь какие-то янумы,
1:57:49
обычно оно работает в плюсах каких-то.
1:57:56
Есть у этого некоторое неудобство.
1:58:00
Если я хочу что-то умное,
1:58:02
хочу, чтобы у меня орд как-то по-другому работал,
1:58:08
но я все равно не хочу его писать руками.
1:58:10
Тут уже все становится сложнее.
1:58:15
Иногда приходится писать много руками.
1:58:18
А что это i.x.
1:58:22
сверху? i.x.
1:58:24
ShowRead и i.x.
1:58:31
Это в блоке deriving на первой строчке.
1:58:35
Все, я вижу.
1:58:37
x это индекс.
1:58:40
Он является индексом, что ли.
1:58:45
Ну, в общем, посмотри в кугле.
1:59:04
Тут такой слайд вопрос.
1:59:07
Что если у нас есть какой-то дататайп,
1:59:10
который хранит функцию?
1:59:14
Что если мы для него попросим вывести?
1:59:16
Суть в том, что мы не можем гарантировать, что во всех
1:59:22
случаях мы можем вывести хотя бы какой-то тривиальный инстанс.
1:59:27
То есть есть функции, которые непонятно,
1:59:29
как печатать, например, или читать из строки.
1:59:33
Поэтому нужно понимать, что все это некоторые эвристики,
1:59:38
которые не всегда работают.
1:59:50
Причем...
1:59:57
Сейчас я немножко забыл.
1:59:59
Короче, надо уточнить.
2:00:01
Бывает так, что он сгенерит тебе что-то,
2:00:04
но для функции она не работает совсем.
2:00:07
Или она сгенерит тебе какой-нибудь инстанс,
2:00:10
в котором будут взаимно рекурсивные
2:00:14
просто дефолтные реализации.
2:00:20
Это надо уточнить.
2:00:23
А правила для дерайвинга, они вообще зашиты в компилятор для контрактных типов?
2:00:27
Или они где-то в исходниках есть?
2:00:29
Это не зашиты в компилятор.
2:00:34
Вот эти все дерайвинги, они предоставляются компилятором,
2:00:38
но есть способы писать свои дерайвинги.
2:00:46
Там, мне кажется,
2:00:47
подключается немножко метапрограммирование,
2:00:51
когда тебе хочется потраверсить тип,
2:00:56
взять все его конструкторы.
2:00:58
Короче, какие-то рефлекшены там есть,
2:01:00
говоря языком Java,
2:01:03
для которых ты можешь генерить эти все дерайвинги.
2:01:05
Поэтому, в общем,
2:01:09
это не first class сущность в языке,
2:01:13
но есть поддержка.
2:01:17
В общем, например,
2:01:19
есть NewType, любимый.
2:01:25
Давайте посмотрим,
2:01:26
какие есть проблемы с NewType, например.
2:01:31
Нам, допустим, нужно реализовать метод show.
2:01:34
Для этого нужно сделать паттерн-матчинг по этому элементу.
2:01:38
Если мы делаем, допустим, ик,
2:01:41
мы должны сделать паттерн-матчинг на левом и правом операнде,
2:01:45
взять инты оттуда и сравнить их.
2:01:49
То есть мы предполагаем,
2:01:50
что NewType — это некоторый синоним инта,
2:01:52
но не совсем,
2:01:55
которые отличаются от него по тигму.
2:01:59
И у нас проблема.
2:02:00
У нас уже нет реальный какой-то код.
2:02:02
У нас не просто enum и сравниваются, а надо какой-то паттерн-матчинг делать,
2:02:06
еще что-то, потом обратно это заворачивать,
2:02:08
наверное, где-то там в плюсе.
2:02:10
В общем, с этим есть проблема.
2:02:13
Это уже не включено в язык стандартный,
2:02:15
но есть расширение,
2:02:16
называется generalized NewType deriving,
2:02:19
который это все делает.
2:02:21
Ну и вот deriving может быть довольно большим
2:02:24
для NewType,
2:02:27
потому что,
2:02:31
смотрите, тут как это работает.
2:02:33
Например, функтор.
2:02:35
Он не генерирует с нуля функтор,
2:02:37
но если у типа, который внутри,
2:02:39
уже есть функтор,
2:02:40
например, у инта,
2:02:41
но у инта нет,
2:02:42
допустим, NewType,
2:02:44
какой-нибудь параметр list есть,
2:02:46
аргумент,
2:02:47
то для него уже есть функтор.
2:02:50
Ему нужно просто, по сути,
2:02:52
написать определение,
2:02:53
которое делает паттерн-матчинг
2:02:58
на одном, единственном существующем конструкторе,
2:03:02
применяет функцию,
2:03:03
потом опять это заворачивает, если нужно.
2:03:04

2:03:08
И в антайме вообще-то вот эти вот
2:03:09
боксинги, анбоксинги,
2:03:11
они будут вообще,
2:03:12
типа, они будут уничтожены,
2:03:14
их не будет в антайме.
2:03:16
Поэтому
2:03:19
для NewType все проще,
2:03:21
и существуют эти директивы, которые почти все можно для него вывести вообще.
2:03:26
То есть там никаких
2:03:28
ручных действий не нужно.
2:03:32
Причем тут, видите,
2:03:32
даже какие-то есть параметры у deriving, типа.
2:03:39
В общем, да.
2:03:44
Довольно удобно на практике.
2:03:49
Да, и там вот ссылочки есть,
2:03:50
какой-то комментарий про то,
2:03:54
что делать, если вот этот список deriving
2:03:57
слишком длинный, и хочется у каждого повторять.
2:04:00
Хорошо.
2:04:01
Теперь давайте посмотрим модули.
2:04:04
Значит, смотрите,
2:04:06
какая есть проблема вот с type-классами, которые мы до этого смотрели.
2:04:11
Чем они отличаются от классов
2:04:12
в плюсах, например.
2:04:14
У нас нет области видимости,
2:04:16
у нас нет вот этого вот
2:04:18
public полей, private полей, вот этого всего нет.
2:04:22
У нас все public всегда.
2:04:26
Что как бы на самом деле не очень хорошо.
2:04:29
Оно как бы упрощает жизнь
2:04:31
и позволяет реализовать
2:04:33
какие-то механизмы,
2:04:34
какой-то type-checking, наверное, упрощает.
2:04:35

2:04:36
Но вообще это не очень удобно в жизни.
2:04:39
Но это можно
2:04:41
похожую функциональность реализовать с помощью модулей.
2:04:44
То есть, смотрите,
2:04:46
у нас, допустим,
2:04:47
смотрим с первой строчки.
2:04:50
У нас есть модуль lib,
2:04:54
то, что в начале каждого файла мы пишем модуль lib.
2:04:58
Это модуль, который определяется в этом файле.
2:04:59
Ну, понятно.
2:05:01

2:05:02
Модуль — это набор кода,
2:05:05
который мы можем
2:05:07
отдельно скомпилировать,
2:05:09
потом куда-то заимпортить.
2:05:12
И мы указываем после lib в скобочках
2:05:15
те функции,
2:05:17
те модули,
2:05:18
те типы,
2:05:20
которые мы экспозируем, которые мы
2:05:24
делаем открытыми для импорта.
2:05:27

2:05:30
То есть, если есть какие-то детали реализации,
2:05:33
мы просто их не добавляем в этот список,
2:05:34
и они остаются закрытыми.
2:05:37
Понятно, зачем это нужно.
2:05:40
Если мы захотим поменять реализацию, мы это можем сделать.
2:05:43
И будем уверены, что никто,
2:05:46
ни пользователя, никого пользователя мы не сломаем
2:05:50
в нашей библиотеке,
2:05:51
потому что он не мог
2:05:54
использовать эти детали реализации.
2:05:55

2:05:58
Посмотрим, как мы делаем импорт.
2:06:00
Мы пишем
2:06:04
foo.a, например.
2:06:06
То есть, у нас модули имеют иерархию какую-то.
2:06:10
Иерархия строится,
2:06:11
по-моему, как в Java,
2:06:14
значит, по
2:06:15
файловой системе. То есть, есть папка foo,
2:06:19
в ней есть файл a, файл b,
2:06:23
в нем определяются модули a и b,
2:06:25
поэтому мы определяем еще рядом файл foo, в котором описывается модуль
2:06:34
foo.
2:06:35
Причем модуль foo может
2:06:37
импортить, значит,
2:06:40
какие-то,
2:06:42
грубо говоря, protected вещи, какие-то детали
2:06:45
реализации, которые доступны
2:06:47
всему модулю foo, но не выдавать их туда наверх.
2:06:50
То есть,
2:06:55
не делать их видимыми для
2:06:58
всего модуля foo.
2:07:00
Для всей библиотеки, грубо говоря.
2:07:02

2:07:05
Давайте пробежимся еще раз по синтаксису.
2:07:08
Значит, у нас есть импорт,
2:07:10
мы можем дальше в скобочках написать,
2:07:12
что мы конкретно хотим заимпортить.
2:07:15

2:07:16
Вот, например, мы здесь,
2:07:17
посчитаю, что здесь написано, мы импортим
2:07:21
тип
2:07:21
foo b2 и
2:07:24
один его конструктор mkb1.
2:07:27
Возможно, это не один конструктор, а их несколько.
2:07:30
Мы только этот хотим заимпортить.
2:07:34
Ну, собственно, справа у нас есть определение, foo b2 у него два
2:07:40
конструктора,
2:07:41
мы только один из них импортим.
2:07:45
Ну, то есть,
2:07:50
когда-нибудь, наверное, это нужно.
2:07:51
То есть, наверное, уже потомачить мы уже не сможем сделать, но
2:07:55
пока немного создать
2:07:59
элемент мы сможем.
2:08:01
Вот, foo b3
2:08:03
значит,
2:08:06
с этим типом мы импортим все его конструкторы.
2:08:10
Да, если мы не напишем вот эти скобочки с двумя
2:08:13
точками, мы вообще не будем импортить конструкторы.
2:08:15
Это тоже нужно учитывать.
2:08:17
Мы можем импортить тип, но не его конструкторы.
2:08:19
Это разные вещи.
2:08:22
Ну, мы помним, что конструкторы просто функции.
2:08:23

2:08:25
Вот, значит,
2:08:28
дальше мы можем сделать хайдинг. То есть, мы можем
2:08:32
заимпортить все, кроме.
2:08:34
Например, это удобно для
2:08:35
прелюда, когда мы хотим...
2:08:37
Есть какая-то функция, которая называется print, но
2:08:40
нам она не нравится, мы хотим ее по-своему реализовать.
2:08:43
Мы ее не импортим, чтобы у нас не было
2:08:48
переопределения,
2:08:49
не было одинаковых имен.
2:08:53
Дальше у нас пример, как можно импортить операторы. Они в скобочках указываются.
2:08:57

2:08:59
Отдельных обязательно.
2:09:00
Потом мы можем заимпортить пустые скобочки.
2:09:02

2:09:04
Смотрите, какой смысл пустых скобочек.
2:09:09
Казалось бы, мы делаем импорт, но ничего не импортим.
2:09:13
То есть, как будто бы ничего. На самом деле,
2:09:15
тут важный вопрос, а как происходит импорт инстансов и классов?
2:09:20
Потому что для них на самом деле нет никакого отдельного синдекса.
2:09:22
Например, я хочу заимпортить только вот этот
2:09:24
класс, и вот этот класс, и вот этот инстанс.
2:09:30
Для этого работает правило, что если мы импортим модуль,
2:09:34
то мы импортим все его инстансы и все классы.
2:09:36
То есть,
2:09:38
принято такое решение в Хаскере.
2:09:40
То есть, понятно, у него есть свои плюсы и минусы,
2:09:43
но, в общем,
2:09:46
инстансы должны быть видны,
2:09:48
если мы импортим какой-то модуль, все его инстансы видны и все классы.
2:09:52
Да, еще раз повторюсь.
2:09:54
И
2:09:56
такой синдекс позволяет заимпортить только
2:09:59
инстансы и классы, если мы не указываем
2:10:01
в скобках ничего.
2:10:04
Мы все еще
2:10:06
импортим так классы.
2:10:08

2:10:13
Давайте дальше разберем.
2:10:15
Импорт.
2:10:17
База.
2:10:18
Мы можем как-то по-другому назвать модуль.
2:10:21
Например,
2:10:23
x, y, z у нас какое-то длинное название, мы не хотим
2:10:27
постоянно его писать, мы можем переназвать как-нибудь,
2:10:30
дать короткое имя.
2:10:32
Потом есть
2:10:33
специальное слово qualified,
2:10:35
которое означает, что
2:10:40
любой символ,
2:10:41
который мы заимпортили,
2:10:45
который мы импортировали
2:10:46
из этого модуля, мы обязаны указывать его
2:10:51
квалификатора,
2:10:52
то есть указывать его полное имя.
2:10:53

2:10:54
Допустим, есть какая-нибудь функция fold из data.
2:10:57

2:10:59
list модуля,
2:11:02
мы обязаны везде писать data.
2:11:06
list data.list.
2:11:09
fold fold fold в общем.
2:11:10
 
2:11:15
Это удобно, потому что опять же, если у нас есть
2:11:19
своя функция fold,
2:11:21
и она совпадает с тем, что мы
2:11:26
импортировали,
2:11:27
мы указываем qualified,
2:11:29
и у нас
2:11:32
неоднозначность пропадает, потому что мы знаем, что один из них
2:11:34
обязан быть указан с полным путем модуля.
2:11:38

2:11:40
Но, понятно, полный путь указать постоянно неудобно,
2:11:43
поэтому мы можем комбинировать это с
2:11:48
синонимом, допустим,
2:11:49
c,
2:11:51
опять же, можно
2:11:53
спрятать какие-то вещи и не импортить их.
2:11:57
Можно заимпортировать только что-то, что мы хотим.
2:12:00
В общем, понятно.
2:12:01
Причем, да, смотрите, в последнем примере у нас есть,
2:12:07
мы импортируем
2:12:09
модуль x и y,
2:12:11
и оба из них называем export,
2:12:13
тем самым мы их как бы собираем в один модуль, мы их как бы объединяем.
2:12:19
Тоже может быть удобно.
2:12:23
Вот, вроде бы все разобрал.
2:12:26
Давайте,
2:12:27
какие есть вопросы?
2:12:38
А если мы заимпортировали
2:12:40
fu.x и fu.
2:12:41
y одним и тем же именем, как мы сможем
2:12:44
к ним обращаться?
2:12:47
Смотри, они оба обозначены
2:12:49
как qualified, поэтому мы обращаемся как export.что-то.
2:12:56
Если они оба
2:12:57
импортируют одинаковое имя, я думаю, что очень жаль.
2:12:59
Ага, хорошо.
2:13:02

2:13:10
А чем отличается просто import fu.
2:13:13
y s-export
2:13:15
от import qualified fu.
2:13:17
y s-export?
2:13:19
Смотрите, повторяю,
2:13:20
qualified значит, что ко всем символам из
2:13:23
этого модуля ты обязан обращаться с квалификатором.
2:13:29

2:13:30
То есть ты обязан писать
2:13:31
fu.x.имя.
2:13:34
Ну а если не qualified,
2:13:36
то я тоже могу так сделать, но не обязательно.
2:13:38
Да.
2:13:54
Ну то есть слайд выглядит на самом деле сложно,
2:13:57
но на самом деле тут как бы все довольно понятно,
2:13:59
и все что хотелось бы иметь
2:14:04
от модулей, оно есть.
2:14:05

2:14:07
Изначально в Haskell нельзя два модуля в одном файле объявлять, это неудобно.
2:14:10

2:14:12
Ну,
2:14:15
какие-то трейд-оффы.
2:14:24
Но при этом, при том, что нельзя объявлять два модуля в одном файле, модуль может
2:14:30
экспортировать модуль,
2:14:32
потому что он может его перед этим заимпортить.
2:14:34
То есть, видите, модуль lib
2:14:40
импортит
2:14:41
fu.x и fu.y как экспорт,
2:14:44
и потом экспорт
2:14:46
экспортирует дальше.
2:14:52
То есть, как бы, lib, он немножко пересобирает область видимости библиотеки
2:15:00
и создает такой интерфейс.
2:15:06
Вот.
2:15:09
Ну ладно, если понятно, давайте пойдем дальше.
2:15:11
Там осталось вроде немного.
2:15:14
Значит,
2:15:16
extra knowledges.
2:15:19
Тут, короче, какие-то интересные ссылочки.
2:15:22
Вот последняя-то статья, про которую я говорил.
2:15:25
How to make ad-hoc polymorphism less ad-hoc.
2:15:30
Кому интересно, почитайте.
2:15:31
Прикольно должно быть.
2:15:32
Вот.
2:15:33
И какие-то еще фичи тэп-классов мы еще будем говорить
2:15:37
в следующих лекциях.
2:15:38

2:15:41
Что тут осталось?
2:15:44
Нерекурсивные ADT.
2:15:47
А, ну, такой
2:15:52
теоретический
2:15:54
пассаж, наверное.
2:15:58
Сейчас я попытаюсь сказать более простыми словами,
2:16:01
что, допустим, у нас есть вот такой тип
2:16:05
DoctorWho, это Tardis
2:16:06
или Dalek, в общем, какая-то сумма типов у нас есть.
2:16:11
И, на самом деле, можно закодировать с помощью функций.
2:16:16
То есть, как бы,
2:16:18
это называется Churching Coding,
2:16:20
то есть кодирование черча для
2:16:25
алгебрыческих типов данных.
2:16:27
Что
2:16:30
мы можем закодировать
2:16:32
тип Doctor
2:16:34
через такие, как бы, замоками.
2:16:36
То есть, допустим,
2:16:41
допустим, у нас нет
2:16:42
директивы Data,
2:16:45
у нас нет
2:16:46
никакого синтеза для этого, но мы все еще можем сделать алгебрыческие
2:16:50
типы данных просто на лямбда-исчислении, на самом деле.
2:16:52
То есть просто на функциях.
2:16:55
Допустим, функция fTardis это функция, которая принимает a и b, это параметры
2:17:00
первого конструктора,
2:17:02
и возвращает, как бы,
2:17:04
такой
2:17:07
continuation или замыкание,
2:17:10
которое принимает
2:17:18
тип...
2:17:20
которое принимает две функции Tardis и Dalek.
2:17:23
И эти функции это функции, которые хотят что-то сделать
2:17:29
с обоими вариантами.
2:17:30
То есть это такой, как бы, кейс,
2:17:32
какой-то такой pattern matching,
2:17:34
который уже, как бы, вшит в конструктор.
2:17:37
То есть конструктор уже ждет две функции
2:17:42
и применяет только одну из них, потому что это
2:17:46
конструктор, он знает параметры двух, и он, как бы,
2:17:49
сохраняет
2:17:50
их замыкание и применяет к ним левый.
2:17:52

2:17:55
И при этом симметрично вторая функция, второй
2:18:00
конструктор, он принимает один параметр, потому что
2:18:02
конструктор имеет только один параметр,
2:18:04
его сохраняет замыкание
2:18:06
и в этом случае уже игнорирует, как бы,
2:18:12
левый рекурсивный вызов и вызывает правый от этого конструктора.
2:18:16
То есть смотрите, у нас получается, что эти две функции,
2:18:20
если на них посмотреть, то они обе, они сначала принимают параметры
2:18:24
своих конструкторов,
2:18:26
потом принимают
2:18:29
одинаковые две функции, значит,
2:18:34
рекурсивного вызова от вариантов,
2:18:36
но одна вызывает, значит, от одного,
2:18:38
а другая от другого. То есть вот этот вот хвост
2:18:40
у них одинаковый.
2:18:42
И вот этот хвост
2:18:44
на самом деле
2:18:46
является нашим типом. То есть смотрите,
2:18:48
как это дальше использовать. Допустим, у нас есть там какая-то функция travel,
2:18:54
которая принимает
2:19:00
паттерн
2:19:06
А, это было предыдем определено.
2:19:15
Что?
2:19:16
Это какие-то две функции, которые типа что-то делают. Ага, смотрите,
2:19:20
дальше у нас есть два конструктора, мы хотим сделать
2:19:22
типа паттерн-матчинг. Паттерн-матчинг выглядит как? Мы просто передаем
2:19:27
нашему типу две функции.
2:19:28

2:19:30
Две функции, которые, собственно, левая и правая.
2:19:32
И в зависимости от того, с помощью чего
2:19:34
был сделан наш конструктор, с помощью функции f-targets или f-dialog,
2:19:40
будет соответствующий результат.
2:19:42
То есть вот, если мы передадим
2:19:44
в f-travel, значит, наш тип
2:19:47
сконструированный,
2:19:49
созданный конструктором f-targets 0,0,
2:19:52
у нас будет один результат, с помощью f-dialog будет другой результат.
2:19:56
И, смотрите, если мы сделаем
2:19:58
type alias на
2:20:00
типа вот это вот хвост, который у нас был у этих конструкторов,
2:20:04
то на самом деле мы
2:20:07
получим нормальную сигнатуру конструкторов.
2:20:08

2:20:12
Ну, это такой стандартный способ закодировать
2:20:16
географические типы данных с помощью просто функции.
2:20:17

2:20:19
То есть
2:20:21
это интересно теоретикам,
2:20:25
которые показывают типа, вот сколько можно классных
2:20:30
штук сделать с помощью простого лямбда-счисления.
2:20:31
На курсе теории типов про это рассказывают.
2:20:36
Под компотом оно разве
2:20:38
точно так же не кодируется?
2:20:41
Под компотом как оно кодируется, я не могу сказать.
2:20:44
То есть
2:20:47
я не думаю, что это самый эффективный
2:20:50
способ
2:20:51
представления этого всего.
2:20:53
Это не про эффективность,
2:20:55
это про выразительность, что с помощью функции можно закодировать вот это.
2:21:00
Потому что как будто на функции написали то же самое
2:21:03
с точки зрения функции, потому что если все это функция, то оно как будто бы
2:21:07
так и было закодировано, только это было скрыто с эхором.
2:21:11
Ну, смотри, в случае
2:21:14
более императивном мы можем сохранить объект
2:21:18
доктор просто как тег и какие-то поля.
2:21:23
В случае этого черчен-кодинга у нас
2:21:26
объект это какое-то замыкание,
2:21:30
которое на самом деле это уже не объект, который хранится в памяти,
2:21:34
это как бы
2:21:36
этим объектом это замыкание, то есть это функция.
2:21:42
Ну, как так сказать...
2:21:45
Смотри, если у нас
2:21:46
под капотом язык реализован императивно,
2:21:50
то
2:21:50
лучше все-таки первый вариант,
2:21:52
когда мы просто храним в памяти эту гравитационную структуру,
2:21:55
грубо говоря,
2:21:58
с тегом,
2:22:00
как вариант в плюсах.
2:22:02
Если у нас под капотом есть какие-то символьные вычисления, если мы
2:22:06
говорим, ну, мы, короче, делаем там бета-редукцию,
2:22:09
мы, типа, упрощаем выражение просто,
2:22:12
тем самым делаем вычисления,
2:22:14
то, да,
2:22:16
второй вариант лучше.
2:22:20
Как Haskell
2:22:21
в GHCI реально реализован,
2:22:24
я думаю, что там как бы что-то среднее.
2:22:26

2:22:29
Я не берусь говорить, как там реально это
2:22:31
реализовано, я не копался под капотом компилятора.
2:22:41
Ну, короче, иногда вот такой... смотри,
2:22:44
плюс Haskell в том, что ты можешь как бы иметь оба
2:22:48
варианта, что у тебя есть как бы встроенная в язык
2:22:51
такая штука эффективная,
2:22:53
есть вот такая вот, типа, на функциях, и иногда
2:22:57
вот эта штука на самом деле используется.
2:23:00
Довольно редко
2:23:01
в участии, но
2:23:03
иногда используется.
2:23:14
Надеюсь, я ответил на вопрос.
2:23:18
Или просто испугал.
2:23:20

2:23:23
Нет, но мы же писали
2:23:24
эти всякие черт-инкодинги на нот-логику.
2:23:27
А, ну вот.
2:23:38
Ну, типа...
2:23:39
Да, я бы все сказал.
2:23:45
Короче, да.
2:23:50
Да, и вот тут еще есть комментарий, что на самом деле вот такую штуку,
2:23:53
типа, вот эти все определения можно с помощью
2:23:57
метапрограммирования, короче, все это
2:23:59
сгенерить, на самом деле.
2:24:02
Иногда это очень удобно.
2:24:04
Потому что потом это еще увидите.
2:24:07
Вот.
2:24:09
Ну, дальше какие-то слова про то, что, типа, на самом деле C++ это
2:24:14
такие
2:24:16
словари
2:24:18
с методами,
2:24:19
но я про это говорил.
2:24:22
Инстанции, на самом деле, это просто, типа, с объектами.
2:24:25

2:24:28
Типа с реализацией методов, с функциями.
2:24:32
Вот.
2:24:33
В общем-то все.
2:24:35
На этом, я думаю, что лекция закончена.
2:24:37
Давайте вопросы какие-то.
2:24:40
Домашка, соответственно, будет после этой лекции?
2:24:46
Это я, честно говоря, не знаю.
2:24:48
Я не отвечаю за домашки.
2:24:51
Вот.
2:24:51
Я, возможно, отвечаю за их проверки, но не за их выкрутку.
2:24:56
Это скорее к Диме.
2:24:56

2:24:58
Очень было бы хорошо, если бы она была.
2:25:01
Ну да, чтобы было на чем помедитировать.
2:25:02

2:25:05
Сейчас слишком много всего.
2:25:07

2:25:08
Да, я понимаю вас.
2:25:10
Я вас понимаю.
2:25:19
Я, честно говоря,
2:25:20
плохо знаком с домашками в этом году.
2:25:23
Но
2:25:25
мне кажется, что там должно быть что-то
2:25:27
такое, как это сказать,
2:25:29
простое, типа написать каких-то инстансов.
2:25:31

2:25:35
Потому что, понятно, да, очень много нового всего, а тут
2:25:38
скорее проблема в том, что очень много непонятных концепций,
2:25:41
каких-то непривычных, если вы до этого
2:25:43
писали только на плюсах, например.
2:25:46
Мы все писали на клажуре.
2:25:47

2:25:49
Про логию мы тоже писали.
2:25:52
Ой, ну клажур,
2:25:53
про лог это, да.
2:25:55
Клажур это же инвалидная ФП.
2:25:59
Ну как инвалидная?
2:26:01
Оно как бы, типа это гибрид.
2:26:03
Гибрид.
2:26:05
ФП и джава.
2:26:11
Клажур.
2:26:12
Я тоже писал карты на клажуре.
2:26:14
Парсер.
2:26:16
На 70-ок.
2:26:25
Все мы когда-то писали парсеры.
2:26:29
Да.
2:26:37
Ну, всем спасибо.
2:26:39
Я не знаю,
2:26:40
если еще какие-то есть вопросы,
2:26:42
если хотите отсудить, можем отсудить.
2:26:45

2:26:46
Если нет, то давайте.
2:26:49
Всем удачи.
2:26:51
Спасибо, до свидания.
2:26:54
Спасибо, до свидания.
2:26:59
И вам спасибо, что пришли.
2:27:06
Как слышно на языке Штукенберга.
2:27:13
Ладно, всем пока.
