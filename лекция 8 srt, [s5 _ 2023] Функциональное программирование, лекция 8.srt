1
00:00:01,401 --> 00:00:02,234
Отлично, так.

2
00:00:03,000 --> 00:00:06,978
Ну что ж, всех приветствую на восьмой
лекции по функциональному программированию.

3
00:00:07,060 --> 00:00:12,640
Сегодня мы поговорим про
performance и про строгость в Haskell.

4
00:00:13,730 --> 00:00:14,966
План будет следующий.

5
00:00:16,050 --> 00:00:17,640
Мы поговорим про...

6
00:00:18,220 --> 00:00:19,750
Начнем с difference-листа,

7
00:00:20,590 --> 00:00:22,649
того, какую он разрешает проблемку.

8
00:00:23,060 --> 00:00:25,897
На самом деле, он
разрешает довольно маленькую

9
00:00:25,980 --> 00:00:27,417
проблему, такую
незначительную, я бы сказал.

10
00:00:27,500 --> 00:00:28,697
Тем не менее, разрешает.

11
00:00:28,780 --> 00:00:29,940
Дальше мы поговорим про строгость.

12
00:00:29,941 --> 00:00:33,750
Потом про механизм
предотвращения накапливания

13
00:00:33,793 --> 00:00:37,141
преимущественных представлений в памяти,

14
00:00:37,840 --> 00:00:39,135
функцию deforestation.

15
00:00:39,890 --> 00:00:43,283
Поговорим про объект,
который предотвращает

16
00:00:43,326 --> 00:00:46,601
накапливание этих представлений в памяти,

17
00:00:46,760 --> 00:00:48,137
это называется streamfusion.

18
00:00:48,220 --> 00:00:50,317
И немножко поговорим
про бутабельные объекты.

19
00:00:50,400 --> 00:00:52,860
Начнем с difference-листа.

20
00:00:54,240 --> 00:00:56,064
Итак, вот есть функция Trinity.

21
00:00:56,580 --> 00:00:58,740
Она принимает три списка.

22
00:00:58,741 --> 00:01:02,953
И, судя по тому, что
написано здесь, конкретизирует

23
00:01:02,995 --> 00:01:06,081
их каким-то соответствующим способом.

24
00:01:06,100 --> 00:01:09,500
Их вообще способов здесь три строчки.

25
00:01:10,530 --> 00:01:13,298
Но на самом деле, конечно же, способов

26
00:01:13,340 --> 00:01:16,741
конкретизации два
списка, их только две штуки.

27
00:01:18,800 --> 00:01:19,859
Вопрос номер один.

28
00:01:20,220 --> 00:01:23,860
Помним ли мы, какая ассоциативность
у конкретизации списков?

29
00:01:29,640 --> 00:01:30,787
Совершенно верно, да.

30
00:01:30,870 --> 00:01:33,635
Конкретизация списков у нас…
извиняюсь, сейчас… Правая статья.

31
00:01:34,170 --> 00:01:37,248
Я просто хочу еще
начать смотреть, на всякий

32
00:01:37,290 --> 00:01:39,568
случай, если у вас
вопросы есть и так далее.

33
00:01:39,650 --> 00:01:41,510
Но сейчас не получается.

34
00:01:44,690 --> 00:01:45,867
Ассоциативность правая.

35
00:01:45,950 --> 00:01:47,362
По определенной причине.

36
00:01:48,250 --> 00:01:50,747
Поэтому фактически ведет
первая строчка в определении Trinity.

37
00:01:50,830 --> 00:01:53,110
Это эквивалент, на самом деле, второй.

38
00:01:53,710 --> 00:01:58,058
Просто такой способ не
ставить скобочки, чтобы они

39
00:01:58,101 --> 00:02:02,491
автоматически бандились
к rightmost конкретизации.

40
00:02:02,610 --> 00:02:05,527
Поскольку у нас, опять
же, правая ассоциативность.

41
00:02:05,610 --> 00:02:06,170
Вопрос следующий.

42
00:02:06,270 --> 00:02:11,050
А какое определение из среди этих
трех, тем не менее, лучше не использовать?

43
00:02:11,650 --> 00:02:14,010
И почему, на ваш взгляд?

44
00:02:24,200 --> 00:02:25,040
Есть идеи? Последнее.

45
00:02:36,420 --> 00:02:37,253


46
00:02:37,480 --> 00:02:41,820
Потому что мы хотим к более
короткому списку прибавлять.

47
00:02:42,340 --> 00:02:48,120
Потому что нам нужно у последнего обновить
ссылку на следующую ноду, последнего узла.

48
00:02:49,180 --> 00:02:50,013
Да.

49
00:02:50,620 --> 00:02:51,657
Я совершенно согласен с вами.

50
00:02:51,740 --> 00:02:56,480
Последнее лучше не использовать по
причине определения конкретизации списков,

51
00:02:56,660 --> 00:02:59,685
и по тому, что мы именно
перемачиваем, как мы именно

52
00:02:59,728 --> 00:03:02,618
перемешиваем наши
конструкторы, конс и так далее.

53
00:03:02,700 --> 00:03:03,533
Вопрос.

54
00:03:04,400 --> 00:03:05,233
Смысл?

55
00:03:05,380 --> 00:03:05,600
Да.

56
00:03:06,120 --> 00:03:06,953
Дефолт.

57
00:03:07,180 --> 00:03:08,013
Нет.

58
00:03:08,320 --> 00:03:11,791
Выбирать корректное определение
ассоциативности на простом.

59
00:03:12,020 --> 00:03:14,340
Ассоциативность правая и рейдер пятый.

60
00:03:15,040 --> 00:03:18,300
Потому что, вспомним
определение ассоциативности.

61
00:03:18,500 --> 00:03:21,383
У нас конкординация
ленивая по второму аргументу.

62
00:03:21,600 --> 00:03:23,697
То есть второй аргумент может
быть, на самом деле, бесконечным.

63
00:03:23,780 --> 00:03:26,233
Но первое должно быть
бесконечным, чтобы можно

64
00:03:26,275 --> 00:03:29,041
было взять, например, n
элементов из конкординации.

65
00:03:29,041 --> 00:03:33,160
По первому аргументу
перемешиваем просто конус. Вот и все.

66
00:03:34,660 --> 00:03:39,149
Если мы проанализируем эти
два отрывка, мы увидим, что, в

67
00:03:39,192 --> 00:03:43,881
принципе, на самом деле,
поскольку ассоциативность ленивая,

68
00:03:44,355 --> 00:03:49,400
вот эта строчка, конечно, тут не будет
вычислена, вот эта скобочка первая,

69
00:03:49,540 --> 00:03:55,820
это вычислится сначала
конкординация с левым списком

70
00:03:55,900 --> 00:03:57,747
из n элементов, поэтому
сначала будет n операций.

71
00:03:57,830 --> 00:04:01,477
Ну, не n, на самом деле, а, я бы сказал,
n плюс 1, потому что, на самом деле,

72
00:04:01,560 --> 00:04:06,920
список n элементов – это n
элементов плюс пустой список.

73
00:04:07,080 --> 00:04:11,139
Поэтому, на самом деле, n плюс 1
операция – не важно. Плюс константы.

74
00:04:11,520 --> 00:04:13,340
То есть сначала будет n операций.

75
00:04:13,420 --> 00:04:18,660
И когда мы конкординируем левый список,
по определению ровно конкординации,

76
00:04:18,661 --> 00:04:29,260
а потом уже мы конкординируем результат
с непосредственно списком 1 и так далее,

77
00:04:29,380 --> 00:04:31,380
n плюс 1 и так далее, k.

78
00:04:31,620 --> 00:04:33,917
И вот здесь, конечно,
будет уже n операций.

79
00:04:34,000 --> 00:04:36,280
В итоге будет ровно n плюс 1 операция.

80
00:04:37,200 --> 00:04:39,977
Именно если у нас имеет
место правая ассоциативность.

81
00:04:40,060 --> 00:04:43,277
Посмотрим тогда на левую ассоциативность
и посмотрим на то, что изменится.

82
00:04:43,360 --> 00:04:48,440
Значит, опять же, у нас плюс-плюс
строгий, де-факто, по первому аргументу.

83
00:04:48,520 --> 00:04:50,815
Поэтому вычислится сначала левая часть.

84
00:04:51,560 --> 00:04:55,360
Безусловно, то, что я
выделил, будет n операций.

85
00:04:55,460 --> 00:04:55,940
Это и так понятно.

86
00:04:56,370 --> 00:04:58,710
А вот потом, когда мы конкординируем наш

87
00:04:58,753 --> 00:05:01,313
жадивающий список
со списком 1 и так далее,

88
00:05:01,630 --> 00:05:05,680
будет у нас теперь n плюс m операций.

89
00:05:06,270 --> 00:05:10,200
Потому что мы, опять же,
потормачиваемся по результату, то

90
00:05:10,201 --> 00:05:12,820
есть левому списку, а этот
список из n плюс m элементов.

91
00:05:13,540 --> 00:05:17,400
Поэтому у нас будет n плюс m
плюс 1, на самом деле, операции,

92
00:05:17,560 --> 00:05:21,620
и того у нас будет 2 n плюс
m операций в общем случае.

93
00:05:22,360 --> 00:05:26,320
И, ну, как бы, вроде это
все равно от n плюс m.

94
00:05:27,280 --> 00:05:30,680
Ну, просто мы делаем личный
траверсал нашего списка.

95
00:05:31,580 --> 00:05:33,037
Личный траверсал, личный проходок.

96
00:05:33,120 --> 00:05:37,120
Личный траверсал делать, как бы,
если его не сбежать, то это хорошо.

97
00:05:38,105 --> 00:05:39,811
Лишних траверсалов не делать.

98
00:05:40,920 --> 00:05:43,540
По этой ссылочке можно
перейти и посмотреть,

99
00:05:44,220 --> 00:05:50,300
как работают постановки всяких
определений, которые вы вводите в Haskell.

100
00:05:50,400 --> 00:05:52,798
Только в отличие от Haskell, здесь вот по

101
00:05:52,841 --> 00:05:55,518
этой ссылочке, по этой
интерактивной игрушке,

102
00:05:55,600 --> 00:06:02,240
можно будет выбрать, какие
под выражения вы учисляете.

103
00:06:02,340 --> 00:06:05,160
То есть вы кликаете на
пузырики, и там эти пузырики,

104
00:06:05,161 --> 00:06:07,687
и вот это вот выражение,
которое можно редуцировать.

105
00:06:07,770 --> 00:06:08,997
У вас есть там выбор.

106
00:06:09,080 --> 00:06:14,580
Вы можете задать свое определение и
посмотреть на то, как все редуцируется.

107
00:06:15,740 --> 00:06:21,000
Если вы предпочитаете… Да, собственно,
если вы предпочитаете проверить ленивость,

108
00:06:21,080 --> 00:06:24,436
то вы должны всегда
попытаться попасть в самые

109
00:06:24,479 --> 00:06:27,581
левые пузырики в этой интерактивной среде.

110
00:06:28,860 --> 00:06:32,177
Есть такая вещь, можно какие-то
попробовать, когда у вас будет время.

111
00:06:32,260 --> 00:06:33,093
Very fun.

112
00:06:33,740 --> 00:06:34,180
Вот.

113
00:06:34,320 --> 00:06:38,280
Итак, избегать проблемы
выбора ассоциативности.

114
00:06:38,540 --> 00:06:45,080
Как сделать так, чтобы у нас не было,
скажем, явного выбора ассоциативности,

115
00:06:45,160 --> 00:06:46,880
и так, чтобы не сделать ошибку,
если у человека ошибки случаются?

116
00:06:46,881 --> 00:06:48,587
Ошибки случаются, это бывает.

117
00:06:49,120 --> 00:06:50,356
Решение на следующее.

118
00:06:51,540 --> 00:06:54,177
Создадим такой тип данных,
который называется The List.

119
00:06:54,260 --> 00:06:56,084
Сочиняется как Difference List.

120
00:06:56,330 --> 00:07:00,300
Он энкапсулирует в себе
функцию из списка А в список А.

121
00:07:03,185 --> 00:07:07,320
Логично было бы в рамках
использования The List не экспортировать,

122
00:07:07,360 --> 00:07:13,160
это я уже в мысли вслух, не экспортировать
конструктор DL данных, естественно,

123
00:07:13,480 --> 00:07:17,797
потому что основная вещь
здесь будет происходить

124
00:07:17,880 --> 00:07:19,060
именно в этих двух
функциях, From List и To List.

125
00:07:21,160 --> 00:07:24,620
А From List принимает или возвращает,
собственно, DL от какой-то функции,

126
00:07:24,700 --> 00:07:28,112
и эта функция, внимание, это
в точности компетенция слева.

127
00:07:28,660 --> 00:07:31,637
Вспоминаем, базовая
синтексис Хаскелла, это

128
00:07:31,720 --> 00:07:34,132
называется, господи, какая
это секция? Правая секция.

129
00:07:34,960 --> 00:07:39,820
Здесь лямбда, скажем, L', стрелка L++ L'.

130
00:07:41,120 --> 00:07:48,220
То есть мы добавляем L к аргументу
нашей лямбды, причем L слева.

131
00:07:48,570 --> 00:07:52,420
Вот это является ключевым
моментом в определении From List,

132
00:07:53,030 --> 00:07:54,337
что мы L добавляем слева.

133
00:07:54,420 --> 00:07:57,400
Сейчас мы видим, что это поплечет.

134
00:07:58,220 --> 00:08:01,300
А как перевести тогда The List в To List,

135
00:08:01,340 --> 00:08:04,317
то мы просто применяем
нашу функцию в кустом списке.

136
00:08:04,400 --> 00:08:11,540
Внимание, To List от From List, вот L,
это по определению L++ кустой список.

137
00:08:12,040 --> 00:08:17,420
И это у нас, опять же,
координация, она является моноидом,

138
00:08:18,880 --> 00:08:20,857
и у нас кустой список –
это центральный элемент.

139
00:08:20,940 --> 00:08:23,400
Поэтому L++ кустой список – это L.

140
00:08:23,720 --> 00:08:27,240
Поэтому To List от From
List L – это L, что хорошо.

141
00:08:28,990 --> 00:08:31,620
Итак, смотрим теперь.

142
00:08:32,790 --> 00:08:33,623
Насчет обмена.

143
00:08:34,160 --> 00:08:39,612
У нас есть координация, и теперь мы можем

144
00:08:39,654 --> 00:08:46,621
произвести семигруппную
операцию склеивания двух тл.

145
00:08:48,930 --> 00:08:53,860
Я не помню, освещалось ли это на
лекции по моноидам, которую я вел,

146
00:08:54,020 --> 00:08:56,097
я даже не помню свою лекцию, печально.

147
00:08:56,180 --> 00:08:59,187
Но там действительно есть такой
теган, который называется endo,

148
00:08:59,270 --> 00:09:02,976
который капсулирует в себе
эндоморфизм, то есть функцию из ова.

149
00:09:03,360 --> 00:09:07,831
Здесь то же самое, у нас операция,
фактический эндоморфизм, списка в список.

150
00:09:08,500 --> 00:09:12,080
Операция append, которая типа
добавляет два списка вместе,

151
00:09:12,160 --> 00:09:14,155
хотя там функция, на
самом деле, казалось бы,

152
00:09:14,197 --> 00:09:16,098
какие списки она добавляет, у нас функции.

153
00:09:16,180 --> 00:09:19,769
Но это просто координация, ой,
композиция функций, вот и все.

154
00:09:20,900 --> 00:09:23,002
И да, у нас композиция, естественно,

155
00:09:23,045 --> 00:09:25,843
анастатична, поэтому L
образует семиполигруппу.

156
00:09:27,690 --> 00:09:34,200
Более того, тут M append стоит, то есть
можно подумать, а что, L образует моноид?

157
00:09:34,280 --> 00:09:35,692
Конечно образует моноид.

158
00:09:36,220 --> 00:09:39,357
Нейтральный эвент у лековой
композиции – это identity, морфизм,

159
00:09:39,440 --> 00:09:43,360
то есть это одно, которое
принимает и возвращает то же самое.

160
00:09:44,060 --> 00:09:47,237
Поэтому L вполне себе
полноценный моноид, что классно.

161
00:09:48,460 --> 00:09:54,640
И вот, соответственно, два
случая того, как расставить скобки.

162
00:09:55,040 --> 00:09:57,760
Что они публикуют оба? Какой результат?

163
00:09:58,160 --> 00:10:02,640
На самом деле, забегая вперед, не
анализируя подробно, что тут написано,

164
00:10:04,180 --> 00:10:07,880
это элементарно просто будет
TL от композиции трех функций.

165
00:10:08,560 --> 00:10:10,560
F, допустим, наш аргумент – это X.

166
00:10:11,020 --> 00:10:13,080
Ну и XS, окей, XS, пока здесь.

167
00:10:13,600 --> 00:10:16,060
И вот F в обоих случаях, что важно.

168
00:10:16,240 --> 00:10:18,340
F от J, от H, от XS.

169
00:10:18,890 --> 00:10:20,420
Тут, конечно, не написано.

170
00:10:20,960 --> 00:10:25,900
Ну, как бы тут вот T – это та самая
функция, на самом деле, которая J от H.

171
00:10:28,460 --> 00:10:31,100
Получается F от J от H от XS.

172
00:10:31,510 --> 00:10:33,220
По определению M-аппенга.

173
00:10:33,320 --> 00:10:34,820
Тут по определению нашего даймонда.

174
00:10:34,900 --> 00:10:39,430
Напоминаю, я называю это даймондом и
наша полугруппная операция, астротипная.

175
00:10:40,060 --> 00:10:42,857
Вот. Вопросы есть?
Нет вопросов пока, нет, окей.

176
00:10:42,940 --> 00:10:46,352
У меня чат перед полицами,
поэтому задавайте, если хотите.

177
00:10:46,720 --> 00:10:50,140
Так. Ну, как бы, отлично.

178
00:10:50,280 --> 00:10:52,060
F от J от H от XS.

179
00:10:52,300 --> 00:10:54,140
И что за того, казалось бы?

180
00:10:55,080 --> 00:10:59,520
Ну, вспомним, что мы имеем
право по консенсусу нашему

181
00:11:00,720 --> 00:11:06,560
пользоваться исключительно from-листом,
чтобы лист лифтить в контекст DL.

182
00:11:07,140 --> 00:11:10,360
Поэтому F – это что-то наподобие…

183
00:11:10,900 --> 00:11:14,202
Вот какой-то список здесь, это
список F-штрих, F-штрих плюс плюс.

184
00:11:14,285 --> 00:11:17,449
Вот D-штрих плюс плюс – это
рот тот самый L-плюс плюс,

185
00:11:17,492 --> 00:11:20,698
который мы определили в
рамках определения from-листа.

186
00:11:21,180 --> 00:11:23,638
Значит, F – это F-штрих плюс плюс, J – это

187
00:11:23,680 --> 00:11:26,358
J-штрих плюс плюс, H –
это H-штрих плюс плюс.

188
00:11:27,510 --> 00:11:33,020
Итого, F от J от H от XS – вот здесь это Y
или S, не важно вообще, просто аргумент –

189
00:11:33,021 --> 00:11:38,460
превращается вот в такую серию, в общем, в
обоих случаях, в такую серию координаций.

190
00:11:39,410 --> 00:11:42,953
И вот теперь уже прикол
в том, что именно поэтому

191
00:11:42,995 --> 00:11:46,141
мы добавляем определение
from-лист L слева.

192
00:11:47,040 --> 00:11:54,340
Это поплечет, как бы мы скобки не
ставили, в правоостативность координации,

193
00:11:55,260 --> 00:12:00,400
что, естественно, избавит
нас от лишних траверсовов,

194
00:12:01,000 --> 00:12:03,746
потому что правоостативное
выполнение операции

195
00:12:03,789 --> 00:12:07,001
координации поплечет
наименьшее количество траверсов.

196
00:12:07,175 --> 00:12:11,717
Сначала пройдется по всему F-штрих, потом
по всем, мы сконструируем новый список,

197
00:12:11,800 --> 00:12:15,980
потом J-штрих, потом H-штрих, ну и
потом мы просто добавим YS и все.

198
00:12:16,640 --> 00:12:21,315
Итого у нас будет ровно
от длина AF-штрих плюс

199
00:12:21,357 --> 00:12:26,381
длина J-штрих плюс длина
H-штрих в обоих случаях.

200
00:12:27,010 --> 00:12:28,737
Как бы мы скобки не ставили здесь.

201
00:12:28,820 --> 00:12:32,140
В отличие от левоостативности плюс-плюс.

202
00:12:32,490 --> 00:12:39,660
Там будет операции, господи, длина
F плюс F плюс J плюс F плюс J плюс H.

203
00:12:39,880 --> 00:12:42,500
То есть это прям 3F плюс 2J плюс H.
Печаль.

204
00:12:42,680 --> 00:12:46,328
Это хуже, чем хотелось бы.
Хотелось бы просто F плюс J плюс H.

205
00:12:46,630 --> 00:12:48,197
Вот. В этом прикольный difference list.

206
00:12:48,280 --> 00:12:54,369
Difference list решает
довольно не такую капитально

207
00:12:54,411 --> 00:13:00,301
значимую проблему с
точки зрения time complexity,

208
00:13:01,200 --> 00:13:02,730
но тем не менее разрешает.

209
00:13:03,020 --> 00:13:07,620
И, опять же, желательно иметь
меньше траверсов по нашим спискам.

210
00:13:09,140 --> 00:13:10,729
Вопросы по difference list.

211
00:13:11,045 --> 00:13:14,057
Дальше у нас… А, да.
Дальше у нас немножко про sequence.

212
00:13:14,140 --> 00:13:18,040
Один слайд. Вопросы слушаю, если есть.
Если нет, мы пойдем дальше.

213
00:13:24,410 --> 00:13:25,243
Так, окей.

214
00:13:25,350 --> 00:13:28,046
Вот тут один слайд
посвящен просто reference-у

215
00:13:28,088 --> 00:13:30,528
типа данных, который называется sequence.

216
00:13:31,480 --> 00:13:32,422
Точнее, seq, да?

217
00:13:33,480 --> 00:13:35,327
С большого буквы.
У нас скоро будет seq с маленьким буквы.

218
00:13:35,410 --> 00:13:36,667
Это разные вещи принципиально.

219
00:13:36,750 --> 00:13:44,090
Вот. Data sequence, точнее, типа данных
seq, он реализован с помощью Finger3.

220
00:13:44,520 --> 00:13:49,873
Finger3 – это такая
функциональная структура данных,

221
00:13:49,915 --> 00:13:54,791
на которой можно
реализовать двусвязный список.

222
00:13:55,530 --> 00:13:58,350
И вот иллюстрация
того, как оно получается…

223
00:13:58,351 --> 00:14:02,687
Вот, короче, есть видео где-то в
деблях интернета, где-то в ютубе, точнее.

224
00:14:02,770 --> 00:14:05,863
Можно там глянуть на
то, как получить Finger3

225
00:14:05,905 --> 00:14:08,691
из обычного бинарного дерева. Визуально.

226
00:14:10,250 --> 00:14:13,263
Спойлер. Там, в общем, берется нода, она

227
00:14:13,306 --> 00:14:16,971
перевешивается, она
становится, короче, root-ом.

228
00:14:17,750 --> 00:14:20,017
Наша нода где-то внутри
дерева, то есть под дерево, да?

229
00:14:20,100 --> 00:14:22,352
Становится root-ом, а все
остальное двигается вниз.

230
00:14:22,435 --> 00:14:27,190
И там, внезапно, получается такая
немножко нетривиальная структурка.

231
00:14:27,940 --> 00:14:31,128
Но, на самом деле,
Finger3 – это действительно

232
00:14:31,170 --> 00:14:34,891
структура не такая простая
с точки зрения реализации.

233
00:14:35,430 --> 00:14:40,170
Может быть непонятно, как вообще
реализовать двусвязный список на Finger3.

234
00:14:40,450 --> 00:14:41,627
Тем не менее, можно.

235
00:14:41,710 --> 00:14:45,005
Поэтому, если вам интересно,
посмотрите на DataSequence.

236
00:14:45,450 --> 00:14:48,010
Но пока мы подходим к строгости в Cascade.

237
00:14:50,790 --> 00:14:52,390
Итак, начинаем мы с seq.

238
00:14:52,470 --> 00:14:53,927
Вот вот самый, который с маленькой буквы.

239
00:14:54,010 --> 00:14:56,087
Не имейте никакого отношения к
sequence, о котором я только что упомянул.

240
00:14:56,170 --> 00:14:58,700
Seq – это вообще другая
вещь, другой зверь.

241
00:15:01,650 --> 00:15:03,474
Sequence делает следующую вещь.

242
00:15:05,050 --> 00:15:05,933
Вот его модель.

243
00:15:06,900 --> 00:15:08,287
Она… Очевидно, неопределение, внимание.

244
00:15:08,370 --> 00:15:10,950
Очевидно, это неопределение,
потому что мы не

245
00:15:10,992 --> 00:15:13,788
можем играть в каждый
параметр bottom, очевидно.

246
00:15:13,870 --> 00:15:15,987
Да, в Cascade bottom – это
что-то подобное, defined.

247
00:15:16,070 --> 00:15:18,306
Вообще, bottom – это, например, error.

248
00:15:18,450 --> 00:15:23,390
Опять же, если мы… SignatureError –
это функции строки в произвольном типе.

249
00:15:25,290 --> 00:15:32,390
Если стомить matlock, который у
нас был весной, то там, в общем…

250
00:15:34,040 --> 00:15:39,190
Опять же, пустой тип void
можно определить как for all a.a.

251
00:15:40,420 --> 00:15:41,927
Это как undefined фактически.

252
00:15:42,010 --> 00:15:45,830
Тогда error – это
стринг, стрелка for all a.a.

253
00:15:46,050 --> 00:15:49,607
То есть, по эзоморфизму Кори
Ховарда, то же самое, что не строка.

254
00:15:49,690 --> 00:15:51,850
То есть, error – это отрицание строки.

255
00:15:51,851 --> 00:15:53,734
Вот, на самом деле, тип error'а.

256
00:15:54,830 --> 00:15:57,910
Немножко астропемиологическое,
как называется,

257
00:16:00,940 --> 00:16:03,390
signature error'а, как она
воспринимается в чеке matlock'а.

258
00:16:03,410 --> 00:16:05,850
Это отрицание строки, что-то типа того.

259
00:16:08,090 --> 00:16:09,607
Ну, undefined – это
что-то подобное bottom'а.

260
00:16:09,690 --> 00:16:11,220
Ну, как error, в принципе.

261
00:16:12,595 --> 00:16:20,510
А bottom – это что-то, что либо
является непродуктивной рекурсией.

262
00:16:21,230 --> 00:16:22,348
В общем случае, да.

263
00:16:22,970 --> 00:16:24,807
Например, infinite loop – это
непродуктивная рекурсия.

264
00:16:24,890 --> 00:16:27,714
Либо что-то, что никогда
не завершается успешно.

265
00:16:27,810 --> 00:16:29,327
То есть, какой-нибудь exception.

266
00:16:29,410 --> 00:16:31,207
То есть, потом это самокупность там.

267
00:16:31,290 --> 00:16:32,190
Как и именно в двух случаях.

268
00:16:32,230 --> 00:16:36,583
Непродуктивная рекурсия и exception,
который невозможно поймать, например.

269
00:16:37,250 --> 00:16:38,577
Но это, конечно, слишком строго.

270
00:16:38,660 --> 00:16:40,867
То есть, на самом деле,
это просто любой exception.

271
00:16:40,950 --> 00:16:42,186
Потому что, опять же,

272
00:16:42,590 --> 00:16:46,310
прокопирование подобное
Java, C++, Kotlin, Scala – неважно.

273
00:16:47,010 --> 00:16:52,150
Все exceptions имеют тип bottom'а.

274
00:16:52,810 --> 00:16:55,870
Не тип bottom'а, а это
является bottom'ами.

275
00:16:57,070 --> 00:16:59,070
Но их, естественно, можно поймать.

276
00:17:00,460 --> 00:17:06,317
То, что я сказал, типа, которые нельзя
поймать, это, конечно, страйд, я извиняюсь.

277
00:17:06,400 --> 00:17:08,577
То есть, любой exception, фактически.

278
00:17:08,890 --> 00:17:10,147
И непродуктивная рекурсия.

279
00:17:10,230 --> 00:17:14,090
Значит, это bottom, называется
расходящееся вычисление.

280
00:17:15,230 --> 00:17:16,407
Что делает sequence?

281
00:17:16,710 --> 00:17:20,250
Все, переходим к, собственно, sequence'у.

282
00:17:20,630 --> 00:17:21,190
Вот его модель.

283
00:17:21,450 --> 00:17:23,287
Это не определение, просто модель.

284
00:17:23,370 --> 00:17:26,018
Если слева стоит bottom,
возвращается bottom.

285
00:17:26,290 --> 00:17:31,210
Sequence вычисляет левый
аргумент до его первого аргумента.

286
00:17:31,470 --> 00:17:33,327
Слабая, главная, нормальная форма.

287
00:17:33,410 --> 00:17:34,750
Я буду говорить о
какой-нибудь нормальной форме,

288
00:17:34,751 --> 00:17:37,967
потому что слабая, главная,
нормальная форма тяжело выговаривается.

289
00:17:38,050 --> 00:17:40,756
Weak-head normal form.
Вот как здесь написано.

290
00:17:41,000 --> 00:17:43,824
Вычисляет его, но
возвращает он второй аргумент.

291
00:17:45,800 --> 00:17:47,742
Вот это все, что делает sequence.

292
00:17:48,070 --> 00:17:51,207
Да, и вот его сигнатура, если она
принимает a, принимает b, возвращает b.

293
00:17:51,290 --> 00:17:55,947
Потому что возвращает она второй аргумент,
вычисляя первый до weak-head normal form.

294
00:17:56,030 --> 00:17:56,863
Вот и все.

295
00:17:59,050 --> 00:18:04,710
Предлагаю следующий микроквиз по тому, как
ведет себя sequence на разных input'ах.

296
00:18:05,210 --> 00:18:05,690
Начинаем.

297
00:18:06,110 --> 00:18:08,270
Zero, sequence, 10. Что вернется?

298
00:18:12,110 --> 00:18:12,943
10.

299
00:18:14,670 --> 00:18:15,967
Все наверное, 10 вернется.

300
00:18:16,050 --> 00:18:21,130
Да, мы вычистим 0, получим 0, отлично, до
weak-head normal form, и потом вернем 10.

301
00:18:21,790 --> 00:18:23,047
Undefined sequence, 10.

302
00:18:23,130 --> 00:18:25,778
А разве 0 не в слабоголовной
форме находится?

303
00:18:27,510 --> 00:18:29,510
Почему 0, sequence, 10, вернул 10?

304
00:18:32,170 --> 00:18:38,550
Потому что мы вычислили 0, он может
уже пребывать в weak-head normal form.

305
00:18:38,890 --> 00:18:41,007
Это зависит от того, какой тип у нас.

306
00:18:41,090 --> 00:18:44,180
Например, если у нас
тут тип int hash, то он

307
00:18:44,222 --> 00:18:47,211
уже там пребывает в weak-head normal form.

308
00:18:47,360 --> 00:18:48,747
Просто возвращаем 10, отлично.

309
00:18:48,830 --> 00:18:53,950
А если это какой-нибудь, скажем, сейчас
ratio, напоминаю, что сейчас rational.

310
00:18:54,480 --> 00:18:59,710
Rational – это ratio
integer, это процент integer.

311
00:19:00,770 --> 00:19:03,289
То вот там вместо 0
поставится from integer

312
00:19:03,331 --> 00:19:05,713
0, вместо 10 поставится from integer 10,

313
00:19:06,170 --> 00:19:10,303
вычислится from integer
0, вот он уже вычислится,

314
00:19:10,346 --> 00:19:17,270
from integer 0, и вернется конструктор с
процентом, тот самый, типа данных ratio.

315
00:19:18,190 --> 00:19:21,207
Надеюсь, вы помните, что такое ratio –
это один из нумерических типов данных,

316
00:19:21,290 --> 00:19:27,070
который представляет из
себя division числей заменателя.

317
00:19:27,730 --> 00:19:29,848
Причем явно, это произведение типов.

318
00:19:30,210 --> 00:19:33,799
Будет вычислиться, получится
там внешний конструктор процент,

319
00:19:34,290 --> 00:19:37,232
отлично, вычислится, все
в порядке, и вернется 10.

320
00:19:38,210 --> 00:19:40,230
То есть это тоже зависит
от того, какой тут тип стоит.

321
00:19:40,231 --> 00:19:44,630
Напоминаю, что 0 и 10 – это
просто литералы нумерические,

322
00:19:45,250 --> 00:19:49,610
и это синтетический сахар,
from integer 0, и from integer 10.

323
00:19:49,770 --> 00:19:51,027
Это зависит от ваших типов.

324
00:19:51,110 --> 00:19:53,228
Допустим, здесь int, вроде простоты.

325
00:19:53,810 --> 00:19:57,928
Но 0 же пребывает, we have double
form, отлично, просто возвращаем 10.

326
00:19:58,250 --> 00:20:00,074
Это стало понятно? Я правильно?

327
00:20:01,485 --> 00:20:03,780
Ты ответил на вопрос,
надеюсь, или нет? Вроде да.

328
00:20:04,890 --> 00:20:05,723


329
00:20:07,420 --> 00:20:08,330
Что делать с undefined?

330
00:20:08,410 --> 00:20:14,830
Если undefined стоит в первом
аргументе, что случится? Ошибка, т.

331
00:20:16,930 --> 00:20:19,150
к. undefined не вычислится.

332
00:20:21,180 --> 00:20:26,770
Я бы сказал, вычислится, потому
что он… Он выкидывает ошибку.

333
00:20:27,140 --> 00:20:27,973
Да, конечно.

334
00:20:29,930 --> 00:20:32,670
Undefined – это же bottom, напоминаю.

335
00:20:33,250 --> 00:20:36,190
Bottom – exception.

336
00:20:36,810 --> 00:20:38,399
Just undefined sequence 10.

337
00:20:42,780 --> 00:20:43,613
10.

338
00:20:44,970 --> 00:20:46,460
Совершенно верно, 10.

339
00:20:46,930 --> 00:20:50,401
Потому что just undefined
пребывает в weakhead normal form.

340
00:20:50,760 --> 00:20:51,957
Что такое weakhead normal form?

341
00:20:52,040 --> 00:20:57,420
Давайте напомним, что это либо внешний
конструктор, и только внешний конструктор.

342
00:20:58,720 --> 00:21:02,960
То, что находится внутри него,
если оно есть, не вычисляется.

343
00:21:03,620 --> 00:21:04,937
Либо это лямбда-абстракция.

344
00:21:05,020 --> 00:21:09,197
То есть лямбда-аргумент, стрелка и
дальше тело нашей лямбда-абстракции.

345
00:21:09,500 --> 00:21:11,067
Здесь это конструктор just.

346
00:21:11,150 --> 00:21:12,757
Нам плевать, что тут undefined стоит.

347
00:21:12,840 --> 00:21:14,057
Отлично, пускай стоит.

348
00:21:14,140 --> 00:21:16,842
Он не вычислится, потому что у
нас weakhead normal form – это just.

349
00:21:16,925 --> 00:21:18,573
Just уже есть. Отлично, все.

350
00:21:18,740 --> 00:21:21,505
Вычислили это weakhead
normal form, вернули 10.

351
00:21:21,680 --> 00:21:22,513
Вот все.

352
00:21:23,300 --> 00:21:27,140
Маленький перк, связанный с
очередным отличием data и newtype.

353
00:21:27,240 --> 00:21:31,476
Мы знаем, что newtype – это оберточка,
а data – это просто плацентимент.

354
00:21:32,130 --> 00:21:34,540
В компайл-тайме newtype
происходит так называемое…

355
00:21:34,541 --> 00:21:37,337
Сейчас, я не знаю, это
корректный термин – newtype erasure.

356
00:21:37,420 --> 00:21:39,880
То есть стирание конструкторов newtype.

357
00:21:40,210 --> 00:21:42,269
Вот в компайл-тайме так происходит.

358
00:21:43,060 --> 00:21:48,140
Поэтому здесь, когда мы
передаем конструктор nw,

359
00:21:48,141 --> 00:21:51,540
это можно воспринимать
как undefined sequence 42.

360
00:21:52,480 --> 00:21:54,069
Если кто-то ставит newtype.

361
00:21:54,590 --> 00:21:56,497
Это можно воспринимать
просто как то, что я выделил.

362
00:21:56,580 --> 00:21:57,477
В случае newtype.

363
00:21:57,560 --> 00:21:59,557
Поэтому это просто выбросится undefined.

364
00:21:59,640 --> 00:22:04,340
В случае data, естественно,
никаких таких магий

365
00:22:04,490 --> 00:22:06,900
на потопе erasure
конструкторов не происходит,

366
00:22:06,980 --> 00:22:09,660
потому что data – это не особый случай.

367
00:22:10,340 --> 00:22:13,837
Поэтому внешний конструктор
dw – это уже weakhead normal form.

368
00:22:13,920 --> 00:22:16,332
То есть это как just, по-корочему говоря.

369
00:22:16,810 --> 00:22:19,046
Эта часть эквивалентна вот этой части.

370
00:22:20,150 --> 00:22:24,208
Вот эта часть, то, что сейчас
выделено, эквивалентна вот этой части.

371
00:22:24,400 --> 00:22:25,617
То есть без конструктора nw.

372
00:22:25,700 --> 00:22:28,620
Из-за newtype erasure, что-то типа того.

373
00:22:29,080 --> 00:22:30,139
Erasure, стирание.

374
00:22:30,700 --> 00:22:32,360
Это еще один перк.

375
00:22:32,420 --> 00:22:34,980
Я не помню, он обсуждался или нет.

376
00:22:35,320 --> 00:22:37,760
Это было в самом начале курса, кажется.

377
00:22:38,640 --> 00:22:39,993
Разница newtype и data.

378
00:22:40,380 --> 00:22:42,060
А, я же определил лекцию, кажется.

379
00:22:42,061 --> 00:22:43,120
Я не помню ничего.

380
00:22:43,280 --> 00:22:44,113
Вот.

381
00:22:46,880 --> 00:22:49,704
Теперь поговорим про
строгости в рамках сверток.

382
00:22:50,780 --> 00:22:52,780
Ну, мы знаем, что у нас также есть

383
00:22:54,200 --> 00:22:56,140
две классические свертки – левая и правая.

384
00:22:56,200 --> 00:23:00,000
Например, когда мы спрашиваем список,
мы можем это сделать в два способа.

385
00:23:00,060 --> 00:23:04,737
И фундаментально, и синтетически,
и схематически – это разные вещи.

386
00:23:04,820 --> 00:23:06,337
Правая свертка и левая свертка.

387
00:23:06,420 --> 00:23:07,877
Зависит от того, как его собирать здесь.

388
00:23:07,960 --> 00:23:09,297
Например, здесь плюсы и нолик.

389
00:23:09,380 --> 00:23:12,377
Фолдер, эквивалентин, фолдл – они
все вернут один и тот же результат.

390
00:23:12,460 --> 00:23:15,057
Потому что плюс – это
коммутативная основательная

391
00:23:15,140 --> 00:23:18,160
операция, и плюс образует
коммутативный манойд.

392
00:23:18,260 --> 00:23:19,580
Все. Это достаточно.

393
00:23:19,800 --> 00:23:22,212
Мы знаем, что такое коммутативный манойд.

394
00:23:22,310 --> 00:23:24,428
Поэтому фолдер, эквивалентин, фолдл.

395
00:23:24,940 --> 00:23:25,882
В данном случае.

396
00:23:26,700 --> 00:23:27,533
Тем не менее.

397
00:23:27,640 --> 00:23:31,100
Допустим, мы захотим
посчитать фолдр плюс ноль.

398
00:23:31,180 --> 00:23:33,592
То есть мы просто суммируем все элементы.

399
00:23:33,900 --> 00:23:36,253
От списка из десяти миллионов элементов.

400
00:23:36,720 --> 00:23:39,840
Это будет довольно медленно.

401
00:23:40,380 --> 00:23:41,733
Как фолдр, так и фолдл.

402
00:23:42,310 --> 00:23:43,200
Оба варианта.

403
00:23:43,880 --> 00:23:45,700
Сейчас я на следующей стадии

404
00:23:46,500 --> 00:23:49,200
продемонстрирую в
очередной раз определение

405
00:23:49,240 --> 00:23:50,637
фолдра и фолдра, чтобы
можно было их отличить.

406
00:23:50,720 --> 00:23:51,917
Если мы вдруг забыли.

407
00:23:52,000 --> 00:23:54,295
А вот если мы пытаемся посчитать это на

408
00:23:56,420 --> 00:23:58,900
списке из 100 миллионов элементов,

409
00:24:00,820 --> 00:24:02,762
то, возможно, у вас все зависнет,

410
00:24:02,900 --> 00:24:04,900
и ваша машина немножко поломается.

411
00:24:05,850 --> 00:24:11,020
Поэтому рекомендую не
запускать вашу программу на

412
00:24:11,021 --> 00:24:13,500
гигантских структурах без
верхнего предела по памяти.

413
00:24:15,720 --> 00:24:16,603
Как так добыть?

414
00:24:16,860 --> 00:24:18,422
Вдруг у нас реально гигантские списки.

415
00:24:18,505 --> 00:24:20,388
А как их, собственно, вычислять?

416
00:24:21,080 --> 00:24:22,340
Есть строгая версия.

417
00:24:22,780 --> 00:24:25,117
Строгая версия, например, левой свертки.

418
00:24:25,200 --> 00:24:29,617
Более того, строгая версия левой свертки
лучше, чем строгая версия правой свертки.

419
00:24:29,700 --> 00:24:30,818
Более того, я не...

420
00:24:31,780 --> 00:24:34,500
Называется строгая версия правой
свертки фолдр-штрих, очевидно,

421
00:24:34,540 --> 00:24:37,776
потому что фолдр и штрих –
это как бы строгостика того.

422
00:24:38,220 --> 00:24:41,580
Она определена в классе типа foldable.

423
00:24:42,280 --> 00:24:44,877
Как и фолдл-штрих, собственно
говоря, они все определены в foldable.

424
00:24:44,960 --> 00:24:48,020
Это можно глянуть на их предутствие там.

425
00:24:49,580 --> 00:24:52,580
Фолдл-штрих – это строгая версия фолдла,

426
00:24:52,680 --> 00:24:55,504
и мы потом выясним, в
чем заключается строгость,

427
00:24:56,180 --> 00:25:01,320
как она отражается на редукции,
как мы вычисляем наши операции.

428
00:25:02,220 --> 00:25:04,897
10 миллионов элементов
вычисляется довольно быстро.

429
00:25:04,980 --> 00:25:07,863
100 миллионов не ломает
нашу систему, что хорошо.

430
00:25:08,760 --> 00:25:09,702
Из-за строгости.

431
00:25:10,780 --> 00:25:13,780
Более того, я бы сказал,

432
00:25:14,240 --> 00:25:16,770
что тут, на самом деле,
можно сделать фолдл

433
00:25:17,160 --> 00:25:20,572
из-за определения фолдла,
из-за того, как он определяется,

434
00:25:20,920 --> 00:25:21,920
хоть на миллиард.

435
00:25:22,300 --> 00:25:23,200
Такое ощущение.

436
00:25:23,900 --> 00:25:26,480
Да, у нас будут довольно большие числа.

437
00:25:28,060 --> 00:25:32,040
Зависит от вашей памяти, как минимум.

438
00:25:32,660 --> 00:25:36,360
Но, чисто теоретически, на
миллиард чисел ваш список

439
00:25:36,361 --> 00:25:39,900
тоже можно сделать за
фолдл-штрих идти, короче говоря.

440
00:25:40,660 --> 00:25:41,543
Да, это теория.

441
00:25:42,360 --> 00:25:43,417
В смысле, спекуляция.

442
00:25:43,500 --> 00:25:46,206
Нет, я не попробовал,
не хочу сам попробовать.

443
00:25:46,980 --> 00:25:48,477
Тем не менее, фолдл – фолдер.

444
00:25:48,560 --> 00:25:49,913
Фолдл – правая сторона.

445
00:25:50,220 --> 00:25:51,809
Мы знаем, что такое фолдер.

446
00:25:52,000 --> 00:25:56,622
Это применяем функцию f к пустому списку
к голове и к пустому списку к фолдеру.

447
00:25:56,705 --> 00:26:00,057
А если список пустой, возвращаем
так называемое начальное значение z.

448
00:26:00,140 --> 00:26:00,973
Оно начальное.

449
00:26:01,920 --> 00:26:02,100
Вот.

450
00:26:02,620 --> 00:26:05,060
Фолдл – это почти фолдер,

451
00:26:05,160 --> 00:26:07,197
только здесь, во-первых,
функция немножко другая.

452
00:26:07,280 --> 00:26:08,300
Из b и a в b.

453
00:26:08,600 --> 00:26:10,520
А тут из a в b.

454
00:26:10,820 --> 00:26:11,997
В функции с fb в fb.

455
00:26:13,340 --> 00:26:18,320
Да, кейс с пустым списком такой же,
но вот этот элемент теперь в фолдле

456
00:26:20,500 --> 00:26:23,880
называют аккумулятором, потому
что мы аккумулируем значение

457
00:26:23,881 --> 00:26:27,040
и делаем холостовую рекурсию,
как вы можете заметить.

458
00:26:27,680 --> 00:26:29,117
Именно поэтому я спекулировал,

459
00:26:29,200 --> 00:26:32,617
а вот вдруг можно реально сделать
фолдл от списка на миллиард элементов.

460
00:26:32,700 --> 00:26:33,759
Вдруг это удастся.

461
00:26:34,220 --> 00:26:35,397
Мне кажется, сейчас.

462
00:26:36,700 --> 00:26:39,960
Есть ли списки из них, те же
элементы, типа units или там нолик,

463
00:26:40,300 --> 00:26:41,300
то, наверное, да.

464
00:26:41,440 --> 00:26:44,117
Но если там гигантские
числа, наподобие, опять

465
00:26:44,200 --> 00:26:46,180
же, миллиарда, то,
наверное, все поломается.

466
00:26:46,280 --> 00:26:47,220
Неважно. Все.

467
00:26:48,480 --> 00:26:51,093
Не будем говорить о списках,
о количестве элементов.

468
00:26:52,080 --> 00:26:56,400
Но такая проблема возникает
вот в реализации фолду, например.

469
00:26:57,760 --> 00:27:01,220
У нас аккумулируются
результаты пробежуточные

470
00:27:01,221 --> 00:27:04,600
в нашем втором аргументе,
в нашем аккумуляторе.

471
00:27:04,960 --> 00:27:06,666
Мы знаем, что хаскер ленивый.

472
00:27:07,560 --> 00:27:09,560
Нам пока нет смысла его вычислять.

473
00:27:13,970 --> 00:27:18,420
Поэтому я обращусь пока к
второму определению с фолдлом.

474
00:27:19,140 --> 00:27:21,900
Вот у нас аккумулируется
на первой стадии 0,1.

475
00:27:22,640 --> 00:27:25,097
Он не вычисляется, очевидно,
потому что его нет смысла вычислять.

476
00:27:25,180 --> 00:27:26,533
Мы пока его не вернули.

477
00:27:27,200 --> 00:27:28,197
У нас нестройки вычисления.

478
00:27:28,280 --> 00:27:29,400
Потом 0,1 плюс 2.

479
00:27:30,240 --> 00:27:31,593
Левостативно, очевидно.

480
00:27:32,860 --> 00:27:34,757
Вот наш старый аккумулятор,
собственно говоря.

481
00:27:34,840 --> 00:27:35,673
Потом плюс 3.

482
00:27:36,645 --> 00:27:38,881
А потом уже мы возвращаем аккумулятор.

483
00:27:39,060 --> 00:27:42,720
И вот теперь на этой стадии, когда мы
вернули аккумулятор, мы начинаем редукцию.

484
00:27:42,800 --> 00:27:46,720
Мы начинаем вычислять 0,1, 1,2 и 3,3.

485
00:27:47,580 --> 00:27:49,580
Мы получаем 6, очевидно.

486
00:27:50,020 --> 00:27:52,040
Фолдер работает более понятно.

487
00:27:52,400 --> 00:27:56,780
Мы не можем пока сложить
единицу с тем, что стоит справа,

488
00:27:56,800 --> 00:27:59,597
потому что справа у нас
реквизитный вызов фолдера.

489
00:27:59,680 --> 00:28:01,280
И так далее, и так далее.

490
00:28:01,510 --> 00:28:02,377
Вот тут уже возвращаем 0.

491
00:28:02,460 --> 00:28:05,620
Потом уже выполняем редукцию вычисления.

492
00:28:06,020 --> 00:28:07,726
4 плюс 0, 2 плюс 3, 1 плюс 5.

493
00:28:08,320 --> 00:28:13,420
В обоих случаях тут на самом
деле возникает 7 переходов.

494
00:28:13,580 --> 00:28:15,992
Раз, два, три, четыре, пять, шесть, семь.

495
00:28:17,320 --> 00:28:18,153
Ну и проблема.

496
00:28:18,260 --> 00:28:20,777
Явная проблема в том,
что у нас и в фолдере,

497
00:28:20,860 --> 00:28:24,800
и в фолдле, особенно в
фолдле я даже поговорю,

498
00:28:24,900 --> 00:28:28,840
почему именно фолдл является
критически важной функцией здесь.

499
00:28:30,220 --> 00:28:32,620
Аккумулируется значение, во
втором аргументе, гигантское.

500
00:28:32,700 --> 00:28:34,230
Это thunk, он не вычислен.

501
00:28:35,880 --> 00:28:41,540
И если у нас здесь возникает список
из, опять же, 10 миллионов элементов,

502
00:28:42,480 --> 00:28:46,080
и мы делаем fold2, у нас во
втором аргументе будет копиться

503
00:28:47,100 --> 00:28:49,620
колоссальных размеров гигантский thunk,

504
00:28:50,140 --> 00:28:52,780
который не вычислен до тех
пор, пока мы не прогревать

505
00:28:52,781 --> 00:28:54,723
по всему списку из единых
10 миллионов элементов.

506
00:28:55,040 --> 00:28:55,873
Вот.

507
00:28:58,560 --> 00:28:59,443
Как быть тогда?

508
00:29:00,975 --> 00:29:04,211
Передача макетинговый запрос,
маленький квиз очередной,

509
00:29:04,960 --> 00:29:06,257
создающий задание вопроса.

510
00:29:06,340 --> 00:29:10,600
Что вернет фолдер,
конъюнкция false и repeat false,

511
00:29:10,740 --> 00:29:12,682
это бесконечный список из фалсов,

512
00:29:12,980 --> 00:29:15,540
и аналогично только четко левая.

513
00:29:15,840 --> 00:29:18,723
Что вернет каждая из этих
функций, на ваш взгляд?

514
00:29:19,570 --> 00:29:21,280
Чет пока мертв, к сожалению.

515
00:29:21,281 --> 00:29:24,458
Пишите вопросы, если у вас
есть, я попытаюсь ответить.

516
00:29:25,840 --> 00:29:30,900
Первый фолдер вернет фалс, а
фолдер будет бесконечной ситуацией.

517
00:29:31,540 --> 00:29:32,660
Абсолютно верно.

518
00:29:33,020 --> 00:29:36,580
Фолдер, конъюнкция false, repeat false,

519
00:29:36,720 --> 00:29:39,237
средуцируется в, вот как
по определению фолдер,

520
00:29:39,320 --> 00:29:44,140
на списке бесконечных фалсов всегда
const стоит, фалс, конъюнкция, фолдер.

521
00:29:44,360 --> 00:29:47,797
Вот на текущем этапе мы вычислим
конъюнкцию от фалса и фолдера.

522
00:29:47,880 --> 00:29:50,292
Конъюнкция от фалса делает short circuit.

523
00:29:50,740 --> 00:29:52,505
Короткое замыкание вычислений.

524
00:29:52,640 --> 00:29:54,180
Это не вычисляется, возвращается фалс.

525
00:29:54,260 --> 00:29:55,740
Ну, очевидно, у нас есть
конъюнкция с конъюнкцией,

526
00:29:55,780 --> 00:29:58,133
хотя в один фалс, то еще фалс, очевидно.

527
00:29:58,470 --> 00:29:59,897
Так и определен фалс фразками.

528
00:29:59,980 --> 00:30:01,777
И не только фразками, в принципе.

529
00:30:01,860 --> 00:30:04,802
Вообще, если конъюнкция
ленивая, и дезюнкция тоже.

530
00:30:05,860 --> 00:30:09,520
Не одна из всех, но хотя
бы в javac, скажем, да.

531
00:30:10,100 --> 00:30:10,982
Если правильно помню.

532
00:30:11,065 --> 00:30:15,600
Фолдер, однако, будет
аккумулировать фалс, конъюнкция, фалс,

533
00:30:15,820 --> 00:30:18,115
причем, очевидно, он не будет вычислен,

534
00:30:18,610 --> 00:30:22,258
потому что у нас нету строгости
к второму аргументу, спойлеры.

535
00:30:23,360 --> 00:30:26,817
Он будет аккумулировать, аккумулировать,
он будет аккумулировать до бесконечности.

536
00:30:26,900 --> 00:30:29,077
И рано или поздно ваша система умрет.

537
00:30:29,580 --> 00:30:32,992
Ну, надеюсь, что потом она
будет оживить каким-то образом.

538
00:30:33,980 --> 00:30:36,628
Главное сделать control
все как можно скорее.

539
00:30:37,405 --> 00:30:41,780
Лучше не вызывать фолдл, конъюнкция
фалса, репит фалс, никогда вообще,

540
00:30:41,781 --> 00:30:47,720
чтобы случайно не набороться
на смертельный случай.

541
00:30:48,520 --> 00:30:49,777
Это смертельный номер.

542
00:30:49,860 --> 00:30:51,060
Вот, да, верно.

543
00:30:51,240 --> 00:30:53,020
Это вернет фалс, это записнет.

544
00:30:53,520 --> 00:30:54,353
Правильно.

545
00:30:55,840 --> 00:30:57,370
Итак, в чем прикол фолдла?

546
00:30:57,520 --> 00:30:58,932
Вот в чем прикол фолдла.

547
00:30:59,080 --> 00:31:02,277
Вот здесь вместо того,
чтобы аккумулировать

548
00:31:02,360 --> 00:31:04,243
гигантский фланг, мгновенно
происходит вычисление.

549
00:31:04,360 --> 00:31:08,197
То есть здесь раньше было 0 плюс
1, если не помню, теперь это просто 1.

550
00:31:08,540 --> 00:31:11,599
Ну и дальше было 0 плюс
1 в скобочках, потом плюс 2,

551
00:31:11,740 --> 00:31:12,697
теперь это плюс 3.

552
00:31:12,780 --> 00:31:14,075
Не плюс 3, а просто 3.

553
00:31:14,870 --> 00:31:15,703
А логично 6.

554
00:31:17,220 --> 00:31:18,657
Итого у нас всего 4 перехода.

555
00:31:18,740 --> 00:31:22,035
4, потому что у нас список
элементов плюс пустой список.

556
00:31:22,730 --> 00:31:23,730
Вот, да, логично.

557
00:31:24,460 --> 00:31:25,990
Все вычисляется мгновенно.

558
00:31:26,120 --> 00:31:28,473
И это, между прочим, хвостовая рекурсия,

559
00:31:29,590 --> 00:31:30,826
что, по идее, хорошо.

560
00:31:32,340 --> 00:31:36,280
Собственно, как можно
определить фолдл-штрих?

561
00:31:37,030 --> 00:31:39,217
Фолдл-штрих можно
определить через sequence,

562
00:31:39,300 --> 00:31:43,600
который вычисляет
наш вот этот вот f от a и x.

563
00:31:45,240 --> 00:31:48,600
Вот помните, да, это наш
новый аккумулятор, который мы

564
00:31:48,660 --> 00:31:50,425
поставляем в фолдл-штрих,
когда мы вызываемся от хвоста.

565
00:31:51,340 --> 00:31:56,880
Давайте его в LED binding
сделаем локальную связку,

566
00:31:57,400 --> 00:32:01,180
произведем sequence, вычислим
а-штрих до weak-head-normal-form,

567
00:32:01,510 --> 00:32:03,900
и потом пропихнем это в фолдл, и все.

568
00:32:04,350 --> 00:32:07,117
То есть а-штрих вычисляется
до weak-head-normal-form.

569
00:32:07,200 --> 00:32:08,318
Ну, это уже что-то.

570
00:32:09,220 --> 00:32:12,300
Вот уже что-то этого недостаточно.

571
00:32:13,480 --> 00:32:15,880
Потому что у нас, как бы очевидно,

572
00:32:16,580 --> 00:32:20,520
в нашем списке могут быть,

573
00:32:21,060 --> 00:32:23,357
не в нашем списке, а в нашем, точнее, B,

574
00:32:23,440 --> 00:32:26,499
у нас могут быть, ой, нет,
A, в данном случае это A,

575
00:32:26,680 --> 00:32:29,220
более сложные структуры, наподобие пары.

576
00:32:30,720 --> 00:32:32,857
Что делает интересная у нас пара?
Ничего, страдать.

577
00:32:32,940 --> 00:32:34,557
Почему страдать?
Ну, потому что у нас пара.

578
00:32:34,640 --> 00:32:37,540
То есть там, внешний
конструктор, это запятая,

579
00:32:37,760 --> 00:32:39,996
уже пребывает в weak-head-normal-form.

580
00:32:40,120 --> 00:32:43,340
Ак плюс икс, лен плюс один не вычислятся,

581
00:32:43,490 --> 00:32:47,228
потому что они пребывают внутри
пары, внутри конструктора запятая.

582
00:32:47,620 --> 00:32:50,057
А sequence вычисляет
до weak-head-normal-form.

583
00:32:50,140 --> 00:32:52,057
Какова weak-head-normal-форм у пары?

584
00:32:52,140 --> 00:32:53,317
Конструктор запятая.

585
00:32:53,560 --> 00:32:55,700
Нам плевать на аргументы запятой.

586
00:32:55,880 --> 00:32:58,297
Они не вычислятся у нас, опять
же, в weak-head-normal-form.

587
00:32:58,380 --> 00:33:00,840
Поэтому фолдл-штрих на более сложных

588
00:33:00,841 --> 00:33:02,959
структурках будет работать
так же, как к фолдлу.

589
00:33:03,240 --> 00:33:04,073
Ну, почти.

590
00:33:06,365 --> 00:33:09,860
Конечно, будет вычислено это выражение.

591
00:33:10,180 --> 00:33:11,460
Как вы можете заметить, оно вычислено.

592
00:33:11,520 --> 00:33:15,980
То есть тут именно применяется
функция f к паре иксу.

593
00:33:16,190 --> 00:33:19,249
Но вот это выражение,
внутри уже пары, не вычислено.

594
00:33:19,840 --> 00:33:20,673
Что печально.

595
00:33:23,080 --> 00:33:24,040
А когда быть?

596
00:33:25,000 --> 00:33:28,412
А вдруг нам хочется везде все
максимально строгим сделать? Даже с парой.

597
00:33:29,610 --> 00:33:30,443


598
00:33:31,160 --> 00:33:33,631
На помощь приходит так называемый deepseq.

599
00:33:35,160 --> 00:33:36,219
Что такое deepseq?

600
00:33:38,880 --> 00:33:40,880
Deepseq это определенная функция,

601
00:33:41,840 --> 00:33:46,340
которая задана с помощью другой функции.

602
00:33:46,420 --> 00:33:47,832
Сейчас мы увидим, какой.

603
00:33:50,560 --> 00:33:53,384
И эта функция, которая
называется rnf, спойлеры,

604
00:33:53,800 --> 00:33:55,800
она вычисляет до-нормальные формы.

605
00:33:56,430 --> 00:33:58,417
Не слава богу, это нормальные формы.

606
00:33:58,500 --> 00:34:00,265
А именно это нормальные формы.

607
00:34:00,820 --> 00:34:03,440
Мы вычисляем seq от этого списка.

608
00:34:03,780 --> 00:34:05,000
Но у нас, очевидно, в
динамике конструктор.

609
00:34:05,060 --> 00:34:06,296
Это конструктор cons.

610
00:34:08,780 --> 00:34:10,440
Undefined это вообще глубже в списке.

611
00:34:10,500 --> 00:34:11,857
Поэтому это верный триггер.

612
00:34:11,940 --> 00:34:17,920
А вот deepseq, по названию уже
понятно, что это deep sequence.

613
00:34:18,200 --> 00:34:22,100
То есть мы вычисляем
максимально глубоко до,

614
00:34:22,400 --> 00:34:26,420
так сказать, как корректно
выразиться, до, видимо,

615
00:34:28,120 --> 00:34:31,062
листа нашего абстрактового
статистического дерева.

616
00:34:32,840 --> 00:34:34,457
Правда ли, мы забыли
о том, что это undefined.

617
00:34:34,540 --> 00:34:38,140
Пытаемся сделать, вычисляем
undefined и выкинем exception.

618
00:34:42,120 --> 00:34:42,953
На deepseq.

619
00:34:43,040 --> 00:34:44,158
Deepseq, извиняюсь.

620
00:34:45,340 --> 00:34:46,173
Вот.

621
00:34:47,040 --> 00:34:47,873
Так.

622
00:34:50,680 --> 00:34:51,900
Как вы считаете...

623
00:34:52,720 --> 00:34:54,427
А, да, тоже довольно простой вопрос.

624
00:34:54,510 --> 00:34:57,860
Что будет, если вызвать
sequence от repeat false в 15?

625
00:34:58,120 --> 00:34:59,473
И аналогично с deepseq.

626
00:34:59,680 --> 00:35:02,920
Из тематики, которую я
только что описал, про deepseq.

627
00:35:02,980 --> 00:35:04,628
На ваш взгляд, что
случится? Парус ломается.

628
00:35:07,860 --> 00:35:08,800


629
00:35:10,050 --> 00:35:11,227
Что значит ломается?

630
00:35:11,340 --> 00:35:14,400
Более детально, что это означает.

631
00:35:15,670 --> 00:35:18,360
Не завершится или упадет с out of memory.

632
00:35:19,340 --> 00:35:19,600
А, да.

633
00:35:19,980 --> 00:35:20,813
Спасибо.

634
00:35:21,040 --> 00:35:21,700
Действительно, да.

635
00:35:21,740 --> 00:35:24,080
Мы попытаемся вычислить
бесконечный список.

636
00:35:24,130 --> 00:35:25,248
Причем бес, он бес.

637
00:35:25,460 --> 00:35:26,437
Вы должны бесы вычислить.

638
00:35:26,520 --> 00:35:30,220
По аниматории deepseq вычисляется
вообще все, что стоит слева.

639
00:35:30,600 --> 00:35:31,433
До nf.

640
00:35:31,940 --> 00:35:32,917
Нормальная форма.

641
00:35:33,000 --> 00:35:33,520
Правильно, да.

642
00:35:33,600 --> 00:35:35,360
И мы нигде не завершимся.

643
00:35:35,680 --> 00:35:37,597
А рано или поздно, если мы
не завершим предвидительно,

644
00:35:37,680 --> 00:35:40,563
опять же, лучше это не
вызвать специальный номер.

645
00:35:41,120 --> 00:35:44,617
Лучше... Не лучше, а... Просто
не вызывать вообще никуда.

646
00:35:44,700 --> 00:35:45,717
Упадем с out of memory.

647
00:35:45,800 --> 00:35:46,633
Правильно.

648
00:35:47,340 --> 00:35:49,240
Это наиболее приятный исход.

649
00:35:50,100 --> 00:35:52,159
Ну, а в первом случае что
случится? Второе понятно.

650
00:35:52,760 --> 00:35:54,400
А с первым?

651
00:35:56,940 --> 00:35:57,773
15.

652
00:35:58,600 --> 00:35:59,433
Да, 15.

653
00:35:59,840 --> 00:36:00,540
Repeat false.

654
00:36:00,720 --> 00:36:01,060
Это фалс.

655
00:36:01,140 --> 00:36:02,493
Две точки repeat false.

656
00:36:02,860 --> 00:36:03,200
Две точки.

657
00:36:03,560 --> 00:36:04,913
Наш лишний конструктор.

658
00:36:05,160 --> 00:36:06,557
Это уже выход норма форм.

659
00:36:06,640 --> 00:36:06,980
Отлично.

660
00:36:07,160 --> 00:36:07,780
Возвращение 15.

661
00:36:07,940 --> 00:36:08,773
Правильно.

662
00:36:09,900 --> 00:36:10,200
Так.

663
00:36:10,380 --> 00:36:10,560
Все.

664
00:36:11,060 --> 00:36:12,354
И... Ой, что? А, да, окей.

665
00:36:12,520 --> 00:36:13,200


666
00:36:13,400 --> 00:36:14,860
Вот теперь определение deepseq.

667
00:36:14,940 --> 00:36:16,058
Начинаем с nf.data.

668
00:36:16,840 --> 00:36:17,673
nf.data.

669
00:36:19,120 --> 00:36:20,657
Это... Как я хочу пошутить.

670
00:36:20,740 --> 00:36:21,573
Это прям...

671
00:36:22,770 --> 00:36:24,359
Чувствуется, язык пошутить.

672
00:36:25,320 --> 00:36:26,257
Сейчас, ладно, без шуток.

673
00:36:26,340 --> 00:36:26,700
Окей, без шуток.

674
00:36:26,800 --> 00:36:26,820
Все.

675
00:36:27,260 --> 00:36:29,880
nf.data – normal form data.

676
00:36:30,780 --> 00:36:32,016
Не non-fungible data, но normal form.

677
00:36:32,270 --> 00:36:33,260


678
00:36:33,580 --> 00:36:34,522
Это класс типов.

679
00:36:34,840 --> 00:36:35,673
Принимает a.

680
00:36:35,820 --> 00:36:37,317
У него есть одна функция – rnf.

681
00:36:37,400 --> 00:36:40,399
Вот та самая функция rnf, которая
вычисляет нормальные формы.

682
00:36:40,780 --> 00:36:43,800
Вот тут написано, что
rnf a равен aseq unit.

683
00:36:44,740 --> 00:36:48,350
Ну, это... Что-то наподобие
дефолтного определения rnf,

684
00:36:49,220 --> 00:36:51,456
который используется
для примитивных типов.

685
00:36:51,820 --> 00:36:52,653
Наподобие int,

686
00:36:52,920 --> 00:36:53,240
не знаю,

687
00:36:53,340 --> 00:36:54,173
char, double, word.

688
00:36:54,340 --> 00:36:55,173


689
00:36:56,080 --> 00:36:56,560


690
00:36:56,720 --> 00:37:00,620
Word, напоминаю, это
unsigned integer в Haskell.

691
00:37:00,621 --> 00:37:01,454


692
00:37:02,440 --> 00:37:02,600
Вот.

693
00:37:03,240 --> 00:37:04,073
Отлично.

694
00:37:04,300 --> 00:37:04,360
Да.

695
00:37:04,660 --> 00:37:05,660
Вот, по идее, если instance.

696
00:37:06,000 --> 00:37:07,600
nf.data для всех них,

697
00:37:07,760 --> 00:37:09,060
а очевидно, для всех этих,

698
00:37:09,200 --> 00:37:11,600
которые только что упомянул,

699
00:37:11,860 --> 00:37:12,120
типов, есть instance.

700
00:37:12,440 --> 00:37:13,537
nf.data.

701
00:37:13,620 --> 00:37:13,880
Очевидно.

702
00:37:13,940 --> 00:37:14,320
Безусловно.

703
00:37:14,460 --> 00:37:15,293
Как же это?

704
00:37:15,880 --> 00:37:18,920
Я думаю, что там не
прописывается явно определение rnf.

705
00:37:19,020 --> 00:37:20,360
Просто потому, что, опять же, int,

706
00:37:20,520 --> 00:37:20,900
double,

707
00:37:21,240 --> 00:37:21,540
char,

708
00:37:21,760 --> 00:37:22,593
word,

709
00:37:22,720 --> 00:37:24,480
это все примитивные типы.

710
00:37:25,900 --> 00:37:28,277
Поэтому можно использовать
для них дефолтное определение.

711
00:37:28,360 --> 00:37:31,340
Но для более сложных структур, наподобие
суммы типов, представим типов data.

712
00:37:31,341 --> 00:37:32,240
Именно с data.

713
00:37:33,440 --> 00:37:34,273


714
00:37:35,550 --> 00:37:37,840
Лучше определить rnf кастомным образом.

715
00:37:37,980 --> 00:37:38,813
Вот пример.

716
00:37:39,100 --> 00:37:39,983
Начнем с maybe.

717
00:37:41,140 --> 00:37:41,500
Окей.

718
00:37:41,640 --> 00:37:43,240
Ну, мы... Что происходит?

719
00:37:43,340 --> 00:37:45,560
Мы здесь вычисляем до... Явно сразу же,

720
00:37:45,920 --> 00:37:46,753
видимо, да,

721
00:37:47,000 --> 00:37:48,639
вычисляем до weakly normal form.

722
00:37:48,970 --> 00:37:49,640
Pattern matching

723
00:37:49,765 --> 00:37:51,140
по внешнему конструктору –

724
00:37:51,141 --> 00:37:53,196
это ровное вычисление
до weakly normal form.

725
00:37:53,800 --> 00:37:54,680
rnf от nothing – это unit.

726
00:37:54,681 --> 00:37:55,140
Отлично.

727
00:37:55,380 --> 00:37:55,720


728
00:37:55,880 --> 00:37:56,822
Мы уже вычислили

729
00:37:57,180 --> 00:37:57,660
левую часть,

730
00:37:57,760 --> 00:37:58,797
там просто nothing.

731
00:37:58,880 --> 00:38:00,503
Он не принимает никаких других значений,

732
00:38:00,640 --> 00:38:01,140
возвращаем unit.

733
00:38:01,200 --> 00:38:02,033
Отлично.

734
00:38:02,380 --> 00:38:03,322
А вот если у нас

735
00:38:03,860 --> 00:38:05,100
just с x,

736
00:38:05,790 --> 00:38:07,496
давайте вызовемся рекурсивно.

737
00:38:07,700 --> 00:38:09,818
Попытаемся вычислить до нормальной формы.

738
00:38:10,040 --> 00:38:12,476
rnf приводится как reduce to normal form.

739
00:38:13,440 --> 00:38:14,120
Что, в принципе, логично.

740
00:38:14,220 --> 00:38:15,053


741
00:38:15,660 --> 00:38:19,745
Пропихнем rnf внутрь, попытаемся
вычислить до нормальной формы x.

742
00:38:20,000 --> 00:38:21,757
Именно из этого возникает constraint.

743
00:38:21,840 --> 00:38:22,673
rnf data – a.

744
00:38:23,330 --> 00:38:24,389
x имеет тип a, да.

745
00:38:25,485 --> 00:38:27,494
Поэтому a обязан станцировать

746
00:38:27,610 --> 00:38:28,800
type class rnf data.

747
00:38:29,560 --> 00:38:29,760
Отлично.

748
00:38:29,920 --> 00:38:31,600
Вот и все определение maybe.

749
00:38:31,601 --> 00:38:32,434


750
00:38:33,120 --> 00:38:34,709
Сейчас, наверное, на время.

751
00:38:36,600 --> 00:38:36,820
Вот.

752
00:38:37,240 --> 00:38:39,422
Death risk аналогично, совершенно прям.

753
00:38:41,940 --> 00:38:43,137
Эквивалентное определение.

754
00:38:43,220 --> 00:38:44,053
Мы вычисляем

755
00:38:44,420 --> 00:38:46,538
аргумент до weakly normal form явно,

756
00:38:46,680 --> 00:38:48,617
делаем pattern matching к
логическому конструктору.

757
00:38:48,700 --> 00:38:51,237
То есть, в принципе, возвращаем u
сразу же, нам нечего больше вычислять.

758
00:38:51,320 --> 00:38:52,540
И здесь у нас есть глава x и хвост xs.

759
00:38:52,541 --> 00:38:53,620


760
00:38:54,680 --> 00:38:55,760
Вычисляем голову.

761
00:38:57,500 --> 00:38:57,980
Делаем seek.

762
00:38:58,080 --> 00:38:58,460
Собственно,

763
00:38:58,780 --> 00:39:02,560
seek как раз делается, чтобы
мы явно вычислили голову.

764
00:39:02,720 --> 00:39:03,260
Потому что, опять же,

765
00:39:03,480 --> 00:39:04,240
seek вычисляет

766
00:39:04,340 --> 00:39:06,756
левую вещь до weakly normal form.

767
00:39:07,920 --> 00:39:08,900
Слева стоит rnf x.

768
00:39:08,901 --> 00:39:09,734


769
00:39:10,020 --> 00:39:13,240
То есть, мы уже будем
вычислять до нормальной формы.

770
00:39:13,640 --> 00:39:15,420
Поэтому seek достаточно.

771
00:39:15,520 --> 00:39:16,353
Вот.

772
00:39:17,430 --> 00:39:18,900
Да, мы вычисляем rnf x.

773
00:39:19,020 --> 00:39:19,853
x имеет тип a.

774
00:39:20,100 --> 00:39:20,420
Опять же,

775
00:39:20,580 --> 00:39:22,814
из-за этого у нас имеет место constraint.

776
00:39:23,120 --> 00:39:23,953
rnf t от a.

777
00:39:24,100 --> 00:39:25,380
Ну и дальше вызываемся
рекурсивно от хвоста.

778
00:39:25,381 --> 00:39:26,214


779
00:39:26,600 --> 00:39:27,433
И, собственно,

780
00:39:27,900 --> 00:39:29,480
это все определяет rnf t для списка.

781
00:39:29,900 --> 00:39:31,380
И deep seek тогда
определяется почти как seek.

782
00:39:31,890 --> 00:39:32,773


783
00:39:34,730 --> 00:39:35,563
Deep seek b

784
00:39:35,720 --> 00:39:36,553
это

785
00:39:37,640 --> 00:39:39,294
вычисление a до

786
00:39:39,560 --> 00:39:40,393
normal form seek b.

787
00:39:40,970 --> 00:39:41,803


788
00:39:42,200 --> 00:39:44,443
Seek обеспечивает нам однозначно

789
00:39:44,800 --> 00:39:45,280
вычисление левой части.

790
00:39:45,281 --> 00:39:46,114


791
00:39:47,340 --> 00:39:47,620
Потому что,

792
00:39:47,800 --> 00:39:49,500
если мы просто вернем b, очевидно,

793
00:39:49,660 --> 00:39:50,700
если мы вернем b,

794
00:39:50,880 --> 00:39:51,320
у нас a

795
00:39:51,520 --> 00:39:52,537
уже будет не вычислено.

796
00:39:52,620 --> 00:39:54,137
Это максимально бесполезная функция.

797
00:39:54,220 --> 00:39:55,940
Это flip const.

798
00:39:56,440 --> 00:39:57,740
Вообще-то.

799
00:39:57,840 --> 00:39:59,440
А deep seek тогда был flip const.

800
00:39:59,540 --> 00:40:00,420


801
00:40:00,620 --> 00:40:01,477
Это бесполезная функция.

802
00:40:01,560 --> 00:40:02,393
Поэтому

803
00:40:03,680 --> 00:40:04,400
поставим seek,

804
00:40:04,560 --> 00:40:06,436
чтобы вычислить a до нормальной формы.

805
00:40:07,780 --> 00:40:07,940
Вот.

806
00:40:08,040 --> 00:40:10,737
И из-за этого a обязан
дистанцировать rnf t.

807
00:40:11,310 --> 00:40:12,663
И такая такая страница.

808
00:40:12,920 --> 00:40:13,753
Вот.

809
00:40:14,320 --> 00:40:16,717
То есть, это ответ на вопрос, почему
нам нужен type class для deep seek.

810
00:40:16,800 --> 00:40:17,660


811
00:40:18,160 --> 00:40:18,993
Потому что для

812
00:40:19,490 --> 00:40:21,138
соответствующих типов данных

813
00:40:21,380 --> 00:40:22,213
кастомных,

814
00:40:22,420 --> 00:40:24,698
они имеют кастомную структуру.

815
00:40:25,960 --> 00:40:29,300
И для соответствующих кастомных
структур можно, конечно же,

816
00:40:29,580 --> 00:40:33,436
сейчас я уже ухожу в
дебри того, что будет потом.

817
00:40:33,880 --> 00:40:34,713
Очень потом.

818
00:40:34,940 --> 00:40:35,360
Можно, конечно,

819
00:40:35,500 --> 00:40:36,736
на самом деле сделать

820
00:40:38,240 --> 00:40:38,800
кажется,

821
00:40:38,960 --> 00:40:41,074
реализовать какой-нибудь nf data для

822
00:40:41,980 --> 00:40:42,820
произвольных типов.

823
00:40:42,860 --> 00:40:44,677
А вообще произвольных с
помощью tplate haskell'а, кажется.

824
00:40:44,760 --> 00:40:44,980


825
00:40:45,240 --> 00:40:46,874
Кажется, в таком машинаре
можно просто произвести.

826
00:40:48,080 --> 00:40:48,913


827
00:40:49,420 --> 00:40:50,974
Но лучше просто делать

828
00:40:51,380 --> 00:40:51,900
мануально, мне кажется.

829
00:40:51,980 --> 00:40:52,380


830
00:40:52,740 --> 00:40:53,120
Мануально

831
00:40:53,640 --> 00:40:56,060
делать instance nf data,
потому что, конечно,

832
00:40:56,415 --> 00:40:57,592
структуры кастомные.

833
00:40:59,140 --> 00:41:02,752
Ваши суммы типов, ваши определения,
они все кастомные, зависит от того,

834
00:41:03,220 --> 00:41:05,439
сколько у вас там полей
в ваших структурах.

835
00:41:05,940 --> 00:41:07,554
Вот всех нужно вычислить с помощью

836
00:41:08,360 --> 00:41:09,040
pseek'а

837
00:41:09,190 --> 00:41:10,640
и вызвав rnf от полей.

838
00:41:10,990 --> 00:41:11,823
Вот и все.

839
00:41:11,920 --> 00:41:12,753


840
00:41:15,000 --> 00:41:15,600
Да, вопрос есть.

841
00:41:15,700 --> 00:41:16,674



842
00:41:17,820 --> 00:41:18,653
Нельзя,

843
00:41:18,760 --> 00:41:18,900
разве,

844
00:41:19,080 --> 00:41:19,320
через

845
00:41:19,470 --> 00:41:21,153
генерики, очевидно,

846
00:41:21,260 --> 00:41:22,093
задеравить

847
00:41:22,480 --> 00:41:24,199
структуру реализации nf data?

848
00:41:24,900 --> 00:41:27,880
Ну, типа, надо просто
пройти по всем вариантам, для

849
00:41:27,881 --> 00:41:29,080
каждого варианта вызвать
рекурсивно для всех полей.

850
00:41:29,081 --> 00:41:29,964


851
00:41:31,240 --> 00:41:31,760
Да,

852
00:41:32,100 --> 00:41:32,220
ну,

853
00:41:32,320 --> 00:41:33,840
то, что я упоминал сейчас,

854
00:41:34,160 --> 00:41:36,540
это не делается на обычном haskell'е,

855
00:41:36,800 --> 00:41:37,320
это делается

856
00:41:37,545 --> 00:41:39,560
в tplate haskell'е.

857
00:41:40,540 --> 00:41:40,760
Я,

858
00:41:40,900 --> 00:41:41,140
мне кажется, это даже можно.

859
00:41:41,141 --> 00:41:41,920


860
00:41:42,020 --> 00:41:43,734
Потому что tplate haskell'е позволяет

861
00:41:44,280 --> 00:41:45,113
анализировать

862
00:41:46,350 --> 00:41:49,654
уже в рамках языка haskell'а то,

863
00:41:49,800 --> 00:41:52,057
как у нас сконструированы
наши типы данных.

864
00:41:52,140 --> 00:41:53,254
Какие там конструкторы

865
00:41:53,390 --> 00:41:54,357
и какие там поля.

866
00:41:54,440 --> 00:41:54,520
Да,

867
00:41:54,720 --> 00:41:55,720
совершенно верно,

868
00:41:56,080 --> 00:41:57,660
вот это как бы эдскин того,

869
00:41:57,780 --> 00:41:58,780
как можно сделать

870
00:41:59,680 --> 00:42:01,154
nf data запросто, бесплатно.

871
00:42:01,520 --> 00:42:02,000


872
00:42:02,300 --> 00:42:03,874
Пройти по всем кейсам,

873
00:42:04,100 --> 00:42:04,680
по всем полям,

874
00:42:04,820 --> 00:42:06,320
вызвать rnf от всех полей и сделать

875
00:42:06,420 --> 00:42:07,340
ряд секвенсов и все.

876
00:42:07,341 --> 00:42:07,560
Да, согласен.

877
00:42:07,840 --> 00:42:07,900


878
00:42:08,480 --> 00:42:08,920


879
00:42:09,160 --> 00:42:10,820
Это именно тот способ,

880
00:42:10,980 --> 00:42:11,200
который я говорю.

881
00:42:11,500 --> 00:42:13,400
Но это просто сложно, там
нужно использовать tplate,

882
00:42:13,560 --> 00:42:14,580
сложно кому-то, кому-то нет.

883
00:42:14,720 --> 00:42:15,553


884
00:42:16,460 --> 00:42:19,800
Нужно использовать tplate haskell,
а tplate haskell'е мы поговорим,

885
00:42:20,140 --> 00:42:20,500
не мы,

886
00:42:20,600 --> 00:42:23,520
а с кем-то другим, мне кажется,
поговорим потом на лекции 10 или 11.

887
00:42:24,060 --> 00:42:25,020
Сейчас пока 8.

888
00:42:26,340 --> 00:42:27,080


889
00:42:27,220 --> 00:42:28,460
Значит, тут есть ссылочка

890
00:42:29,620 --> 00:42:30,453
про то,

891
00:42:30,560 --> 00:42:31,393
как

892
00:42:31,960 --> 00:42:32,793
избежать

893
00:42:33,180 --> 00:42:34,013
многих

894
00:42:34,260 --> 00:42:35,874
вызовов rnf, если у нас

895
00:42:37,260 --> 00:42:38,378
строгие вычисления,

896
00:42:40,220 --> 00:42:40,740
предпочтительные, извиняюсь.

897
00:42:40,860 --> 00:42:41,160


898
00:42:41,480 --> 00:42:43,260
И это делать с помощью такого
типа данных, который называется once.

899
00:42:43,261 --> 00:42:43,600


900
00:42:43,720 --> 00:42:44,140
Вот он определен по этой ссылке.

901
00:42:44,141 --> 00:42:44,680


902
00:42:44,820 --> 00:42:45,780
Ссылка работает,

903
00:42:46,380 --> 00:42:47,380
там все доступно.

904
00:42:48,400 --> 00:42:49,400
Пойду посмотреть.

905
00:42:49,540 --> 00:42:49,820
Вот.

906
00:42:50,140 --> 00:42:51,140
Это весь deepseq.

907
00:42:51,500 --> 00:42:52,333
Довольно

908
00:42:53,220 --> 00:42:53,900
простая вещь,

909
00:42:54,040 --> 00:42:56,961
довольно простой инструментарий
для вычисления нормальной формы.

910
00:43:00,840 --> 00:43:01,673
Микро-вопрос.

911
00:43:02,860 --> 00:43:04,560
У всех от определений сам есть проблема.

912
00:43:04,960 --> 00:43:05,960


913
00:43:06,660 --> 00:43:07,440
У всех у всех есть проблема.

914
00:43:07,441 --> 00:43:07,480
есть проблема.

915
00:43:08,180 --> 00:43:09,013


916
00:43:10,200 --> 00:43:12,280
В чем заключается
проблема каждого? Как и с fold.

917
00:43:17,620 --> 00:43:19,760
Мы делали до этого,

918
00:43:20,000 --> 00:43:20,600
что у нас типа,

919
00:43:20,760 --> 00:43:23,300
если мы запутаемся на очень
большом списке каком-то,

920
00:43:23,580 --> 00:43:24,413
то мы

921
00:43:24,810 --> 00:43:25,060
проиграем,

922
00:43:25,180 --> 00:43:25,360
потому,

923
00:43:26,010 --> 00:43:27,128
у нас очень трудно.

924
00:43:27,260 --> 00:43:29,737
Просто как в конце
будет огромное, огромное,

925
00:43:29,820 --> 00:43:30,660
огромное выражение, которое
никогда не вычисляется.

926
00:43:30,661 --> 00:43:31,544
Справедливо.

927
00:43:32,060 --> 00:43:32,460


928
00:43:32,940 --> 00:43:33,797
Да, действительно.

929
00:43:33,880 --> 00:43:35,400
Например, вот здесь кейс ровно fold.

930
00:43:35,401 --> 00:43:36,234


931
00:43:36,630 --> 00:43:39,872
У нас в аккумуляторе
аккумулируется пеганский фланг,

932
00:43:39,915 --> 00:43:43,641
который не вычислен до тех
пор, пока мы не вернем его явно.

933
00:43:46,010 --> 00:43:48,585
Тут нечего вычислять, тут x
плюс реквизитный выставка.

934
00:43:48,628 --> 00:43:51,482
Тут нужно ждать, пока список опустеет.

935
00:43:53,660 --> 00:43:58,741
Это предотвратить чуть-чуть менее
тривиально, чем fold, но тем не менее можно.

936
00:43:58,840 --> 00:44:08,280
А здесь, в втором случае, это описывалось
в лекции по 1.0, typeclass 1.0 и т.д.

937
00:44:09,860 --> 00:44:14,057
Это то же самое ровно. Мы делаем плюсик, у

938
00:44:14,099 --> 00:44:18,741
нас сами в кастингере
аккумулируются значения,

939
00:44:19,780 --> 00:44:23,089
и потом, когда мы делаем
get сам, мы вычисляем сам.

940
00:44:23,131 --> 00:44:26,481
Тогда уже этот гигантский
фланг будет средуцирован.

941
00:44:27,640 --> 00:44:32,686
Проблема в том, что там
гигантские танки, которые не нужно

942
00:44:32,729 --> 00:44:38,781
желательно вычислять, чтобы памяти
не занимать больше, чем ожидается.

943
00:44:40,480 --> 00:44:42,716
Да, пожалуйста, это же самая проблема.

944
00:44:44,380 --> 00:44:45,910
Тут их 6, да? 6 переходов.

945
00:44:49,910 --> 00:44:52,040
Значит, как это можно исправить?

946
00:44:54,420 --> 00:44:58,455
Это просто больше инструментария
в рамках языка Haskell,

947
00:44:58,497 --> 00:45:02,501
который позволяет делать
некоторые вещи более строгими.

948
00:45:03,280 --> 00:45:09,120
Первая вещь, точнее, в рамках текущей
секции нашей лекции, это bang by trans.

949
00:45:10,400 --> 00:45:12,948
Опять же, наш аккумулятор
слишком ленив, мы

950
00:45:12,991 --> 00:45:15,701
хотим вычислять на
каждой хвостовой рекурсии.

951
00:45:16,920 --> 00:45:23,341
Мы можем добавить bang, то есть знак
восклицания, ровно перед нашим аккумулятором.

952
00:45:23,520 --> 00:45:25,756
Внимание, тут не должно быть пробелов.

953
00:45:26,600 --> 00:45:31,940
Если нет пробелов, тогда это
воспринимается как индексный оператор.

954
00:45:32,180 --> 00:45:34,651
То есть тут ровно не должно быть пробелов.

955
00:45:35,730 --> 00:45:37,907
Вообще не привык я к авторам текстов.

956
00:45:40,870 --> 00:45:44,317
Значит, этот bang ставится
единожды, и он вычисляет

957
00:45:44,360 --> 00:45:47,301
то, что стоит после
него, ровно после него.

958
00:45:47,680 --> 00:45:49,739
То, опять же, weak headorable form.

959
00:45:51,415 --> 00:45:55,474
Спойлеры, опять, будут маленькие проблемы.
Сейчас мы до этого дойдем.

960
00:45:58,460 --> 00:46:02,948
Раньше, для того, чтобы делать bang,
необходимо было прописывать этот extension.

961
00:46:03,030 --> 00:46:07,320
Если я правильно помню,
в версии GHC 2021...

962
00:46:07,520 --> 00:46:11,040
Какая-то версия GHC в годе 2021.

963
00:46:12,030 --> 00:46:15,020
Это стало по умолчанию
синтезатором Хаскова.

964
00:46:15,220 --> 00:46:18,162
Я не уверен в этом, но я
где-то видел эту новость.

965
00:46:18,700 --> 00:46:21,620
Я не спермитировал, но надо попробовать.

966
00:46:23,240 --> 00:46:26,020
Не писать bang patterns, а написать bang.

967
00:46:26,590 --> 00:46:29,097
Если у вас все скомпилируется,
то да, действительно,

968
00:46:29,140 --> 00:46:31,688
это уже теперь по умолчанию
часть синтезатора языка.

969
00:46:31,770 --> 00:46:35,460
Но раньше bang patterns просто
расширялся в языках Хаскова,

970
00:46:35,620 --> 00:46:38,735
в котором можно было
добавлять воскресенье ровно перед

971
00:46:38,778 --> 00:46:41,818
тем, что мы хотим вычислить
до weak headorable form.

972
00:46:41,900 --> 00:46:43,606
Причем это делается единожды.

973
00:46:44,890 --> 00:46:49,540
И это типа-типа раскрывает
что-то наподобие вот этой вещи.

974
00:46:51,840 --> 00:46:56,940
Причем, да, это определение ровно
эквивалентно обычному самому.

975
00:46:57,490 --> 00:46:59,843
То есть вычисляется это вот то же самое.

976
00:47:00,420 --> 00:47:01,420
Что тут написано? Тут есть guard.

977
00:47:02,880 --> 00:47:03,763


978
00:47:04,550 --> 00:47:08,139
Guard можно опять же ставить в
локальных связках без проблем.

979
00:47:08,500 --> 00:47:09,780
Например, в where.

980
00:47:10,560 --> 00:47:11,443
Очевидно можно.

981
00:47:13,180 --> 00:47:14,357
Легальный синтаксис.

982
00:47:14,880 --> 00:47:16,822
Мы делаем seek, ack, а тут false.

983
00:47:17,560 --> 00:47:18,757
То есть это вернет false.

984
00:47:18,840 --> 00:47:21,137
Мы вычислим ack до weak
headorable form, вернется false.

985
00:47:21,220 --> 00:47:23,217
Undefined никогда не будет
вычислен, потому что это false.

986
00:47:23,300 --> 00:47:24,771
Аck, guard, false, state.

987
00:47:24,920 --> 00:47:25,240
Отлично.

988
00:47:25,241 --> 00:47:26,074
Все.

989
00:47:26,400 --> 00:47:28,657
Вот тут уже на этом моменте ack вычислен.

990
00:47:28,740 --> 00:47:29,997
До weak headorable form.

991
00:47:30,080 --> 00:47:33,020
Переходим в оставшиеся два кейса.

992
00:47:34,740 --> 00:47:35,573
Вот еще.

993
00:47:35,960 --> 00:47:41,060
То есть эти два определения
типа-эквивалентны.

994
00:47:43,120 --> 00:47:45,480
На самом деле можно сделать вместо ack,

995
00:47:46,820 --> 00:47:50,820
ой, вместо вот такой вот
машины можно сделать не guard,

996
00:47:51,080 --> 00:47:55,720
а написать case, ack, off,
нижнее подчеркивание, стрелка,

997
00:47:55,980 --> 00:47:57,745
и дальше то, что стоит справа.

998
00:47:58,040 --> 00:48:00,217
Потому что case expression в хаскеле,

999
00:48:00,500 --> 00:48:04,940
именно case, это ровно та
самая синтетическая конструкция,

1000
00:48:05,080 --> 00:48:07,557
которая позволяет вычислять
до weak headorable form.

1001
00:48:07,640 --> 00:48:08,473
Ровно case.

1002
00:48:09,440 --> 00:48:12,088
Case это прям фундамент
вычисления в хаскеле.

1003
00:48:12,660 --> 00:48:13,500
Вот и все.

1004
00:48:14,040 --> 00:48:14,873
Так.

1005
00:48:16,460 --> 00:48:19,220
Вопросы по bank-паттерну
на текущий момент.

1006
00:48:20,540 --> 00:48:21,835
Если не есть, конечно.

1007
00:48:22,340 --> 00:48:23,120
Час, милосердце, час.

1008
00:48:23,220 --> 00:48:24,691
Никто не пишет, ну ладно.

1009
00:48:31,480 --> 00:48:33,069
Да, теперь пишите, отлично.

1010
00:48:33,960 --> 00:48:34,793
Так, окей.

1011
00:48:35,160 --> 00:48:36,100
Больше bank-паттерна.

1012
00:48:36,180 --> 00:48:38,717
Можно ставить банк-паттерны
внутри конструкторов.

1013
00:48:38,800 --> 00:48:40,677
Например, здесь у нас есть
конструкция запятая, есть два поля.

1014
00:48:40,760 --> 00:48:41,320


1015
00:48:41,520 --> 00:48:45,740
Вот я прописываю здесь банк
внутри первого элемента пары.

1016
00:48:47,050 --> 00:48:51,800
То есть это будет что-то наподобие,

1017
00:48:52,620 --> 00:48:53,453
сейчас скажу,

1018
00:48:55,020 --> 00:48:57,840
g, это сахар следующий,

1019
00:48:58,220 --> 00:49:01,260
gb, стрелка case p, ровно case p of,

1020
00:49:01,800 --> 00:49:03,742
дальше у нас конструктор запятая,

1021
00:49:04,120 --> 00:49:05,240
x штрих y,

1022
00:49:06,010 --> 00:49:08,600
а потом у нас стоит банк у xа.

1023
00:49:08,700 --> 00:49:09,220
Мы делаем что?

1024
00:49:09,360 --> 00:49:11,040
Мы делаем case x штрих of,

1025
00:49:12,480 --> 00:49:15,206
x стрелкой, и дальше мы возвращаем список.

1026
00:49:15,600 --> 00:49:17,840
То есть мы явно делаем case еще,

1027
00:49:18,150 --> 00:49:20,268
пол, внутри него элемент нашей пары.

1028
00:49:20,400 --> 00:49:23,440
Теперь можно прописывать как глубоко,

1029
00:49:23,820 --> 00:49:24,938
как только захотим,

1030
00:49:26,160 --> 00:49:28,400
наши более сложные типы данных.

1031
00:49:29,360 --> 00:49:30,890
В лет-связках то же самое.

1032
00:49:32,860 --> 00:49:33,693
Лет...

1033
00:49:33,830 --> 00:49:37,968
Ну тут, да, это как жилье,
только это локальная связка.

1034
00:49:38,120 --> 00:49:40,120
Тут явный паттерн-матчинг паре,

1035
00:49:40,720 --> 00:49:46,720
и первый элемент пары у нас будет
чуть более строгим, чем по дефолту.

1036
00:49:48,680 --> 00:49:53,920
Более того, можно ставить
backpattern, извините, в лямбде.

1037
00:49:54,920 --> 00:49:56,391
Напоминаю, это донотация,

1038
00:49:56,760 --> 00:49:59,440
это нам проследуется в
bind, вспоминаем монады,

1039
00:50:00,100 --> 00:50:03,200
донотацию в монаде, это
pop, bind, дальше лямбда x,

1040
00:50:03,340 --> 00:50:04,740
стрелка и так далее.

1041
00:50:07,860 --> 00:50:11,200
Можно ставить bang в аргументах лямбды.

1042
00:50:11,900 --> 00:50:15,940
Это как раз транслируется,
лямбда x', стрелка, кейс x', off x.

1043
00:50:16,080 --> 00:50:19,680
Мы сделаем один шаг вычисления

1044
00:50:20,230 --> 00:50:24,660
до выходного формулы x',
получим x, отлично, да, правильно.

1045
00:50:25,700 --> 00:50:28,260
Не x, извиняюсь, а нижнее подчеркивание.

1046
00:50:28,520 --> 00:50:30,680
У нас уже и так x' вычисляется.

1047
00:50:30,800 --> 00:50:32,624
То есть там просто кейс x, off.

1048
00:50:33,470 --> 00:50:35,880
Опять же, можно ставить bang в лямбдах.

1049
00:50:37,440 --> 00:50:41,214
На основе этого можно думать на тему того,

1050
00:50:41,680 --> 00:50:42,975
как мы можем вычислять

1051
00:50:44,370 --> 00:50:45,782
аргументы наших функций,

1052
00:50:46,660 --> 00:50:50,399
когда мы передаем
аргументы к какой-то функции.

1053
00:50:51,005 --> 00:50:53,220
Помним доллар, обычная аппликация.

1054
00:50:53,455 --> 00:50:55,520
Аппликация с bang – это

1055
00:50:57,420 --> 00:50:58,950
строгая версия аппликации,

1056
00:51:00,060 --> 00:51:02,632
когда мы вычисляем наш
аргумент, потом вызываем функцию f.

1057
00:51:05,140 --> 00:51:07,320
Это строжайшая версия аппликации

1058
00:51:07,645 --> 00:51:08,646
доллар-бэнг-бэнг.

1059
00:51:08,780 --> 00:51:11,940
Это когда мы делаем
deep-seq, вычисляем x до

1060
00:51:12,020 --> 00:51:13,726
нормальной формы, потом
уже передаем функцию f.

1061
00:51:17,100 --> 00:51:18,080
На самом деле,

1062
00:51:18,500 --> 00:51:23,640
вот тут, конечно, есть bang-паттерн,
но я бы это написал через x-seq-fx.

1063
00:51:25,360 --> 00:51:27,097
Потому что мне кажется,
это эквивалентная вещь.

1064
00:51:27,180 --> 00:51:30,718
Это как здесь, где deep-seq стоит,

1065
00:51:32,020 --> 00:51:33,837
мы вычисляем x до нормальной формы.

1066
00:51:33,920 --> 00:51:35,377
Это то же самое, что делает bang.

1067
00:51:35,460 --> 00:51:37,420
То есть это x-seq-fx.

1068
00:51:37,990 --> 00:51:40,881
Должно быть абсолютно
эквивалентно тому, что написано здесь.

1069
00:51:41,820 --> 00:51:42,820
Но, тем не менее,

1070
00:51:43,540 --> 00:51:45,540
оба варианта максимально легальны.

1071
00:51:45,940 --> 00:51:49,019
То есть строгое вычисление
аргументов и потом передаем функцию f,

1072
00:51:49,160 --> 00:51:51,657
и строжайшее вычисление аргументов до

1073
00:51:51,740 --> 00:51:53,446
нормальной формы, потом
передаем эту функцию f.

1074
00:51:54,820 --> 00:51:58,600
Вот тут есть маленький примерчик,
примерчик, да, русский язык,

1075
00:51:58,800 --> 00:51:59,320
примерчик того,

1076
00:51:59,480 --> 00:52:00,951
как мы можем использовать

1077
00:52:02,340 --> 00:52:03,458
строгое вычисление.

1078
00:52:04,800 --> 00:52:05,977
Мы тут униформально,

1079
00:52:06,880 --> 00:52:07,763
что происходит?

1080
00:52:08,900 --> 00:52:11,856
Господи, униформально,
то есть uniform distribution,

1081
00:52:12,300 --> 00:52:14,220
генерируем чиселки от 1 до 10.

1082
00:52:14,340 --> 00:52:17,133
От 1 до 10, конечно, исключительно,
если я правильно помню.

1083
00:52:17,890 --> 00:52:19,820
У нас будет список
разнообразных элементов.

1084
00:52:19,900 --> 00:52:21,560
Делаем sum, но мы при этом вычисляем sum.

1085
00:52:21,561 --> 00:52:22,900


1086
00:52:24,840 --> 00:52:25,800
С учетом,

1087
00:52:26,000 --> 00:52:30,118
с надеждой на то, что sum
здесь тоже довольно строгий.

1088
00:52:31,420 --> 00:52:33,997
Сейчас я скажу вещь,
надеюсь, будет понятно.

1089
00:52:34,080 --> 00:52:34,913
sum sum,

1090
00:52:35,665 --> 00:52:37,760
первое sum это s, это вот sum,

1091
00:52:37,990 --> 00:52:40,591
это русское sum, да, а второе
sum это вот сум, сам сум.

1092
00:52:41,040 --> 00:52:45,280
Сам сум может быть не строгим,
но он вычисляется, потому что у нас

1093
00:52:45,281 --> 00:52:48,355
доллар black стоит. Но
желательно, чтобы сум был строгим.

1094
00:52:49,150 --> 00:52:51,397
Потому что вот, опять
же, мы это уже обсудили.

1095
00:52:52,250 --> 00:52:55,360
Соответственно, чисел
желательно, чтобы было строгим.

1096
00:52:55,840 --> 00:52:57,900
Потом мы дойдем до всех кейсов,

1097
00:52:57,920 --> 00:52:59,360
которые мы рассматривали на
протяжении, например, части лекции.

1098
00:52:59,420 --> 00:53:00,253


1099
00:53:01,395 --> 00:53:04,000
Вопрос к собственно зрителям,

1100
00:53:04,620 --> 00:53:05,760
ну и вам тоже, очевидно.

1101
00:53:05,840 --> 00:53:07,899
Чем отличаются две функции f1 и f2?

1102
00:53:17,580 --> 00:53:18,413
Есть идеи?

1103
00:53:22,300 --> 00:53:23,418
Казалось бы, ничем.

1104
00:53:24,460 --> 00:53:27,320
Ну, потому что, когда
мы решили банк паттерн,

1105
00:53:27,321 --> 00:53:29,040
в первом случае на
пару, у нас пара, как бы,

1106
00:53:29,760 --> 00:53:31,408
запятая это уже конструктор.

1107
00:53:31,860 --> 00:53:33,260
Ну вот, собственно, он и есть вычисленный.

1108
00:53:33,261 --> 00:53:37,013
Да, максимально справедливо
мы, да, спасибо большое,

1109
00:53:37,220 --> 00:53:40,818
мы вычисляем запятую до выхода термоформ,

1110
00:53:41,180 --> 00:53:42,837
получаем запятую, ничего не меняется.

1111
00:53:42,920 --> 00:53:45,862
То есть, когда мы пишем
здесь явно, на самом деле,

1112
00:53:46,140 --> 00:53:49,214
потормачиваемся по
структурке здесь, вот тут вот, да,

1113
00:53:50,080 --> 00:53:51,460
мы вот ровно это и производим.

1114
00:53:51,500 --> 00:53:53,383
Мы производим, как я уже говорил

1115
00:53:53,560 --> 00:53:54,393
миллион раз

1116
00:53:55,340 --> 00:53:57,164
вычисления до выхода термоформ.

1117
00:53:57,570 --> 00:53:59,360
Поэтому эти две…

1118
00:54:00,760 --> 00:54:01,380
У меня слышно?

1119
00:54:01,520 --> 00:54:04,226
Интернет у меня работает?
У меня слышно? Алло?

1120
00:54:04,980 --> 00:54:05,860
Да, все слышно, все хорошо.

1121
00:54:05,920 --> 00:54:06,753


1122
00:54:07,140 --> 00:54:09,157
Да, мне просто написано,
что интернет пропал.

1123
00:54:09,240 --> 00:54:10,780
Окей, сори, господи.

1124
00:54:11,120 --> 00:54:12,560
Так, спокойно.

1125
00:54:13,700 --> 00:54:15,936
Было бы плохо, если бы интернет пропал

1126
00:54:17,060 --> 00:54:17,700
и набегнуло в лекции.

1127
00:54:17,750 --> 00:54:18,640


1128
00:54:19,060 --> 00:54:22,060
Да, в общем, ничем они
друг от друга не отличаются.

1129
00:54:22,680 --> 00:54:23,513
Вот.

1130
00:54:23,690 --> 00:54:25,060
А теперь поговорим про

1131
00:54:25,620 --> 00:54:27,444
полярную противоположность bng,

1132
00:54:28,140 --> 00:54:30,357
которая называется Lazy Pattern Matches.

1133
00:54:30,440 --> 00:54:34,820
Раньше, вроде, как-то это
имело название irrefutable pattern,

1134
00:54:35,340 --> 00:54:36,520
что, на самом деле,

1135
00:54:36,620 --> 00:54:38,077
с точки зрения английского
языка, тоже логично.

1136
00:54:38,160 --> 00:54:39,460


1137
00:54:40,900 --> 00:54:42,959
Выглядит оно вот таким вот образом.

1138
00:54:44,620 --> 00:54:45,973
Значит, что тут прикол?

1139
00:54:46,850 --> 00:54:47,760
У нас есть f от пары abm.

1140
00:54:47,810 --> 00:54:48,900


1141
00:54:50,380 --> 00:54:53,393
Ну да, мы делаем, опять
же, паттерн-матч, мы делаем

1142
00:54:53,660 --> 00:54:55,484
редукцию до weakly normal form,

1143
00:54:55,920 --> 00:54:58,082
достаем этот первый
элемент, делаем const 1a.

1144
00:54:58,280 --> 00:55:01,200
Ну, const 1a вычислится до единицы,

1145
00:55:01,330 --> 00:55:02,683
это так понятно, число.

1146
00:55:03,260 --> 00:55:04,237
Определение const.

1147
00:55:04,320 --> 00:55:06,909
Но, на самом деле, эта
пара слишком строгая.

1148
00:55:09,500 --> 00:55:10,357
Казалось бы, в чем?

1149
00:55:10,440 --> 00:55:13,029
Ну, какая разница?
Ну, пускай будет строгая.

1150
00:55:13,140 --> 00:55:16,620
Проблема в том, что если мы сделаем
f от undefined, то будет undefined.

1151
00:55:17,440 --> 00:55:19,940
Спойлер к следующей части этого слайда.

1152
00:55:21,340 --> 00:55:23,164
f от undefined, несмотря на то,

1153
00:55:23,590 --> 00:55:26,497
казалось бы, у нас const 1,
от чего-то, неважно от чего,

1154
00:55:26,580 --> 00:55:30,400
он выходит в единицу, если мы
передадим const 1 в любой аргумент.

1155
00:55:31,350 --> 00:55:33,876
Хочется, чтобы f от undefined
означало единицу тоже.

1156
00:55:35,660 --> 00:55:36,896
Для этого существует,

1157
00:55:38,000 --> 00:55:38,833
уже,

1158
00:55:39,300 --> 00:55:40,653
если я правильно помню,

1159
00:55:41,020 --> 00:55:43,231
именно вот часть английского
языка Haskell, тильда.

1160
00:55:43,940 --> 00:55:44,773
Похоже на bang.

1161
00:55:45,600 --> 00:55:46,483


1162
00:55:46,640 --> 00:55:48,560
Опять же, пишите тильды
вместе с тем, что стоит справа.

1163
00:55:48,561 --> 00:55:50,679
Без пробела.

1164
00:55:51,040 --> 00:55:52,940
Иначе это ух, иначе это равенство типов.

1165
00:55:53,340 --> 00:55:55,080
И это уже будет потом.

1166
00:55:55,320 --> 00:55:56,153
Это будет

1167
00:55:57,505 --> 00:55:59,057
лекция, опять же, 10, 11, 12.

1168
00:55:59,140 --> 00:55:59,973
Не помню.

1169
00:56:01,900 --> 00:56:02,733
Вот. Тильда.

1170
00:56:02,900 --> 00:56:04,489
Значит, что делать тильдом?

1171
00:56:04,980 --> 00:56:06,760
Значит, я сейчас скажу...
Нет, давайте я сделаю так.

1172
00:56:06,761 --> 00:56:11,287
Я сейчас копирую функцию, у меня же открыт
блокнотик. Я специально его подготовил.

1173
00:56:11,370 --> 00:56:13,537
Тот самый, в котором я
уже писал миллион раз.

1174
00:56:13,620 --> 00:56:15,268
Видно, да, что я пишу здесь?

1175
00:56:18,370 --> 00:56:19,203
Друзья?

1176
00:56:21,090 --> 00:56:25,490
Это закомментирую пока. Ну, в
смысле, это не Haskell, но не важно.

1177
00:56:25,690 --> 00:56:26,523
В общем,

1178
00:56:26,910 --> 00:56:28,850
по что трансформируется

1179
00:56:29,050 --> 00:56:31,130
типа вот этого вот тильда?

1180
00:56:31,630 --> 00:56:34,030
Значит, еще раз, тильда
называется lazy pattern match.

1181
00:56:35,130 --> 00:56:36,660
Когда я пишу здесь тильду,

1182
00:56:37,315 --> 00:56:39,727
и дальше мы делаем pattern matching явно,

1183
00:56:40,490 --> 00:56:42,850
это трансформируется в следующую вещь.

1184
00:56:43,210 --> 00:56:44,043
Сделаю align.

1185
00:56:45,770 --> 00:56:46,603
g от p.

1186
00:56:47,490 --> 00:56:49,210
Именно от p.

1187
00:56:49,211 --> 00:56:50,044
p это просто идентификатор.

1188
00:56:51,250 --> 00:56:52,130
И не больше.

1189
00:56:53,290 --> 00:56:55,761
То есть мы не паттерматимся в этом прикол.

1190
00:56:55,970 --> 00:56:56,803
Вот тут

1191
00:56:57,360 --> 00:56:59,243
проблема в том, что тут стоит a.

1192
00:56:59,430 --> 00:57:01,010
Очевидно, откуда a взялось.

1193
00:57:01,090 --> 00:57:02,967
Тут стоит a, и не очевидно,
откуда a взялось на первый взгляд.

1194
00:57:03,050 --> 00:57:05,168
На самом деле очевидно, но не важно.

1195
00:57:05,350 --> 00:57:07,351
Вот это вот a, это первый элемент.

1196
00:57:08,410 --> 00:57:09,170
Вот это вот a, это f of t, p.

1197
00:57:09,220 --> 00:57:10,690


1198
00:57:12,190 --> 00:57:15,029
То есть когда мы тут заполучаем
какие-то элементы в нашем

1199
00:57:17,410 --> 00:57:18,410
pattern matching,

1200
00:57:18,550 --> 00:57:20,303
в смысле не элементы, а поля,

1201
00:57:20,770 --> 00:57:22,610
а это поля, пары,

1202
00:57:23,190 --> 00:57:26,543
то когда мы делаем тильду, опять же,

1203
00:57:27,400 --> 00:57:30,342
пары больше нет.
У нас есть просто произвольный p.

1204
00:57:30,605 --> 00:57:31,630
Его не вычисляем в этом прикол.

1205
00:57:31,730 --> 00:57:32,563


1206
00:57:32,950 --> 00:57:35,070
Тут как бы стоит не f of t,

1207
00:57:35,250 --> 00:57:39,310
а вроде как чисто более
формально лямбда p стрелка

1208
00:57:39,410 --> 00:57:41,110
кейс p of a, стрелка a.

1209
00:57:42,350 --> 00:57:43,183


1210
00:57:43,620 --> 00:57:44,550


1211
00:57:47,520 --> 00:57:50,556
Ну или вот лямбда кейс,
давайте я сделаю вот так вот.

1212
00:57:51,980 --> 00:57:52,813
Да, так лучше.

1213
00:57:54,030 --> 00:57:56,130
Вспоминаем лямбда кейс, мы его проходили.

1214
00:57:57,710 --> 00:57:58,543
Вот.

1215
00:57:58,965 --> 00:58:01,130
Итого. И refutable pattern,

1216
00:58:01,330 --> 00:58:05,344
то есть lazy pattern matching,
трансформирует то, что мы pattern matching в

1217
00:58:06,970 --> 00:58:07,850
индикатор 1,

1218
00:58:08,130 --> 00:58:09,370
тут это я назвал tp,

1219
00:58:10,050 --> 00:58:11,350
и поля становятся

1220
00:58:12,490 --> 00:58:14,050
то же самое, что селектор.

1221
00:58:14,390 --> 00:58:15,223
Это селектор.

1222
00:58:15,650 --> 00:58:18,810
Мы берем нашу пару

1223
00:58:19,110 --> 00:58:20,390
и возвращаем левую часть.

1224
00:58:21,070 --> 00:58:21,903


1225
00:58:22,070 --> 00:58:24,407
То же самое, что левая
проекция нашей пары.

1226
00:58:24,490 --> 00:58:25,608
Мы называем батлок.

1227
00:58:26,530 --> 00:58:27,589
Вот, это селектор.

1228
00:58:28,670 --> 00:58:29,906
Что прикол функции j?

1229
00:58:30,670 --> 00:58:32,782
В том, что если мы
произведем здесь undefined,

1230
00:58:32,865 --> 00:58:36,470
вот тут уже предупредим
undefined для j, поскольку мы явно не

1231
00:58:36,670 --> 00:58:38,494
pattern matching на самом деле.

1232
00:58:39,490 --> 00:58:43,082
Тут будет undefined, const, по
определению конста не вычисляет

1233
00:58:43,180 --> 00:58:45,967
правую часть, он ленив
по второму аргументу.

1234
00:58:46,050 --> 00:58:47,168
Возвращает единицу.

1235
00:58:50,220 --> 00:58:51,240
И написано здесь,

1236
00:58:51,500 --> 00:58:53,680
что делает refutable pattern.

1237
00:58:53,960 --> 00:58:58,280
Я уже сразу не хочу больше
пока что уходить по атлантику.

1238
00:58:58,360 --> 00:59:00,537
Если непонятно, я снова
вернусь по атлантику, поясню.

1239
00:59:01,420 --> 00:59:02,540
Значит, это jp

1240
00:59:02,790 --> 00:59:07,294
равно const 1, и тут селектор
левого аргумента, левое поле p.

1241
00:59:08,070 --> 00:59:10,380
Я уже говорил about
undefined, потому что мы тут

1242
00:59:10,381 --> 00:59:12,911
pattern matching, мы
вычисляем наш аргумент

1243
00:59:13,350 --> 00:59:14,645
по первому форму явно.

1244
00:59:14,880 --> 00:59:16,400
В j мы не вычисляем,
потому что стоит тильда.

1245
00:59:16,401 --> 00:59:17,234
Вот и все.

1246
00:59:18,300 --> 00:59:19,133


1247
00:59:20,660 --> 00:59:22,500
List-нестройность нам,
казалось бы, не очень нужна.

1248
00:59:22,520 --> 00:59:23,403


1249
00:59:25,400 --> 00:59:25,420
Вот.

1250
00:59:26,100 --> 00:59:27,277
И refutable patterns

1251
00:59:29,080 --> 00:59:33,440
активно используют в тех местах,

1252
00:59:33,620 --> 00:59:34,453
где у нас один

1253
00:59:34,760 --> 00:59:36,172
конструктор, как у пары, и много полей.

1254
00:59:36,400 --> 00:59:37,280


1255
00:59:39,660 --> 00:59:40,720
Вот я сказал один конструктор.

1256
00:59:40,800 --> 00:59:42,600
Почему важно, что там один

1257
00:59:42,800 --> 00:59:44,400
конструктор? Вот почему.

1258
00:59:45,720 --> 00:59:46,280
LazyHat.

1259
00:59:46,480 --> 00:59:47,598
Смотрим на LazyHat.

1260
00:59:47,900 --> 00:59:50,420
У нас везде refutable patterns.

1261
00:59:50,910 --> 00:59:53,087
Везде refutable lazy pattern matches.

1262
00:59:54,290 --> 00:59:55,408
Приков в следующем.

1263
00:59:56,620 --> 00:59:58,060
В этой строке, опять
же, у нас стоит тильда.

1264
00:59:58,061 --> 00:59:59,760
Тильда.

1265
01:00:05,180 --> 01:00:05,860
..

1266
01:00:05,861 --> 01:00:07,920
список трансформируется в просто L.

1267
01:00:08,440 --> 01:00:11,026
Опять же, я отдал
название идентификатору L.

1268
01:00:11,660 --> 01:00:12,600
Фреш, например.

1269
01:00:14,060 --> 01:00:15,540
Это трансформируется в LazyHat.

1270
01:00:15,541 --> 01:00:17,306
fresh равно undefined.

1271
01:00:18,900 --> 01:00:19,733
Но LazyHat.

1272
01:00:20,520 --> 01:00:21,880
fresh,

1273
01:00:22,160 --> 01:00:23,396
где фреш – это просто

1274
01:00:24,100 --> 01:00:28,655
аргумент, не вычисленный, равен undefined,
уже вот здесь, на первом определении,

1275
01:00:30,120 --> 01:00:33,760
будет возвращаться undefined на
любых аргументах нашего списка.

1276
01:00:34,060 --> 01:00:35,825
Каковый мы список не передали.

1277
01:00:36,140 --> 01:00:37,337
LazyHat от пустого списка – undefined.

1278
01:00:37,420 --> 01:00:40,887
Потому что LazyHat от
любой, опять же, fresh state,

1279
01:00:41,460 --> 01:00:42,820
любой идентификатор – undefined.

1280
01:00:42,821 --> 01:00:46,300
LazyHat от списка 1.2.3 – undefined.

1281
01:00:48,640 --> 01:00:50,820
Вот этот кейс второй, он redundant,

1282
01:00:51,140 --> 01:00:53,320
он ненужный, потому что второй кейс

1283
01:00:55,320 --> 01:00:56,000
трансформируется в LazyHat.

1284
01:00:56,001 --> 01:00:57,420
fresh равен

1285
01:00:57,570 --> 01:00:59,280
Hat.fresh.

1286
01:00:59,500 --> 01:01:00,912
Hat – это, опять же, перед головой.

1287
01:01:04,740 --> 01:01:07,560
Опять же, у нас происходит кейс по всем

1288
01:01:08,680 --> 01:01:09,880
аргументам, всем

1289
01:01:10,620 --> 01:01:11,880
случаям сверху вниз.

1290
01:01:13,320 --> 01:01:15,360
У нас этот кейс будет
удовлетворен моментально,

1291
01:01:15,420 --> 01:01:19,540
потому что это кейс по произвольному
аргументу, там, опять же, fresh.

1292
01:01:19,860 --> 01:01:21,067
Давайте я буду говорить L.

1293
01:01:21,150 --> 01:01:21,983
L списка, да?

1294
01:01:22,900 --> 01:01:23,733
Вот.

1295
01:01:25,420 --> 01:01:26,460
Вопрос вам.

1296
01:01:27,300 --> 01:01:29,359
Что будет, если мы поменяем местами

1297
01:01:29,950 --> 01:01:30,833
эти два случая?

1298
01:01:31,800 --> 01:01:34,180
Напоминаю, что здесь
undefined у любого списка.

1299
01:01:34,540 --> 01:01:35,880
Что будет, если мы
поменяем местами два случая?

1300
01:01:35,960 --> 01:01:38,784
То есть это станет первым
случаем, а это вторым.

1301
01:01:40,790 --> 01:01:41,623
Ваше мнение.

1302
01:01:53,360 --> 01:01:54,500
На пустом списке

1303
01:01:54,950 --> 01:01:55,951
паниковать будут.

1304
01:01:57,880 --> 01:01:58,713
Как именно?

1305
01:01:58,960 --> 01:01:59,843
Да, как именно?

1306
01:02:01,800 --> 01:02:02,480
Ну, типа, типа, что,

1307
01:02:02,580 --> 01:02:03,413
скажем, откуда

1308
01:02:04,800 --> 01:02:06,212
возникает пустой список.

1309
01:02:09,620 --> 01:02:12,031
Можно не точно, можно вербально, я пойму.

1310
01:02:17,890 --> 01:02:18,510
Строго говоря,

1311
01:02:18,610 --> 01:02:21,750
когда у нас пустой список,
он как бы подходит как

1312
01:02:21,790 --> 01:02:23,690
раз таки, когда мы достаём
голову из нашу списка,

1313
01:02:23,770 --> 01:02:27,156
но при этом уже не знаем, что там за
голова, потому что там пустой список.

1314
01:02:27,610 --> 01:02:29,258
Какая-то ошибка тогда будет.

1315
01:02:29,510 --> 01:02:31,216
Ошибка будет в том, что у нас

1316
01:02:31,650 --> 01:02:32,483
просто

1317
01:02:36,930 --> 01:02:39,250
будет написано non-exhaustive cases.

1318
01:02:40,370 --> 01:02:41,203
Помним, или,

1319
01:02:41,630 --> 01:02:43,042
сейчас, дайте я подумаю.

1320
01:02:44,190 --> 01:02:45,023
Да.

1321
01:02:46,550 --> 01:02:47,290
Потому что, опять же,

1322
01:02:47,390 --> 01:02:50,362
lazy head это что-то на
подобии lazy head p равен head p.

1323
01:02:50,890 --> 01:02:53,610
То есть lazy head от
этой списка равен head.

1324
01:02:54,610 --> 01:02:55,443


1325
01:02:56,170 --> 01:02:58,210
Head это частичная
функция, partial function.

1326
01:02:58,370 --> 01:02:59,530
Она не определяет до пустого списка.

1327
01:02:59,531 --> 01:03:00,590
Ну, типа того, да.

1328
01:03:00,830 --> 01:03:05,408
То есть, если, опять же, это кейс первый,
то lazy head от пустого списка будет

1329
01:03:05,950 --> 01:03:09,203
паниковать и с ошибкой на
подобии non-exhaustive patterns.

1330
01:03:10,640 --> 01:03:13,830
Либо non-exhaustive patterns,
то есть не все паттерны были

1331
01:03:15,350 --> 01:03:15,850
учтены,

1332
01:03:16,230 --> 01:03:19,310
либо вот та самая ошибка в head.

1333
01:03:20,150 --> 01:03:21,150
Нет, неправильно.

1334
01:03:21,270 --> 01:03:22,800
Не та самая ошибка в head.

1335
01:03:23,270 --> 01:03:24,329
Я объясню, почему.

1336
01:03:25,370 --> 01:03:25,890
Всё просто.

1337
01:03:25,891 --> 01:03:27,790
Вы видите, я тут написал fst.

1338
01:03:28,130 --> 01:03:29,310
Написал бы тут fst,

1339
01:03:30,550 --> 01:03:31,609
была бы одна вещь.

1340
01:03:31,810 --> 01:03:36,812
Но здесь, опять же, lazy head от
fresh равен head fresh, это некорректно.

1341
01:03:38,330 --> 01:03:41,910
У компайлера нет доступа
к стандартным селекторам.

1342
01:03:41,911 --> 01:03:42,744


1343
01:03:43,830 --> 01:03:45,478
Тут не head стоит, тут стоит

1344
01:03:46,950 --> 01:03:47,783
case

1345
01:03:48,410 --> 01:03:49,243
a

1346
01:03:49,930 --> 01:03:50,763
colon

1347
01:03:53,490 --> 01:03:58,823
underscore a Вот именно поэтому
возникает non-exhaustive patterns.

1348
01:03:58,950 --> 01:04:00,068
Один паттерн здесь.

1349
01:04:01,150 --> 01:04:02,210
Это конс.

1350
01:04:05,350 --> 01:04:06,810
Поэтому в случае,

1351
01:04:08,150 --> 01:04:10,741
если этот кейс первый, у
нас будет, к сожалению,

1352
01:04:11,290 --> 01:04:12,377
non-exhaustive patterns.

1353
01:04:12,460 --> 01:04:14,730
А если у нас голова,

1354
01:04:16,170 --> 01:04:18,430
если у нас конс стоит,

1355
01:04:18,980 --> 01:04:20,686
то вернее лazy head от конса.

1356
01:04:26,510 --> 01:04:27,628
Тут уже всё просто.

1357
01:04:28,270 --> 01:04:29,103
Come on.

1358
01:04:29,440 --> 01:04:31,793
То, что и должно быть, всё хорошо будет.

1359
01:04:32,350 --> 01:04:32,450
Да.

1360
01:04:33,020 --> 01:04:37,467
У нас паттерн удовлетворяет кейсу,
который я написал в платнотике.

1361
01:04:37,550 --> 01:04:39,021
Прямо голову, всё хорошо.

1362
01:04:40,385 --> 01:04:41,797
Именно из-за таких вещей

1363
01:04:41,950 --> 01:04:44,009
lazy pattern matches не используют,

1364
01:04:44,310 --> 01:04:47,270
и это опасно на самом
деле, не используют в

1365
01:04:48,140 --> 01:04:49,493
вот это ещё бесполезно, в сумме типов.

1366
01:04:49,950 --> 01:04:52,950
Это используют в
произведении и больше ни в чём.

1367
01:04:53,030 --> 01:04:56,430
Это когда у нас есть дата, отдельный
конструктор и множество полей.

1368
01:04:58,370 --> 01:05:00,901
У вас были трансформеры,
я знаю, у вас они были на

1369
01:05:01,870 --> 01:05:02,753
прошлой лекции,

1370
01:05:03,910 --> 01:05:05,381
в смысле, 2 недели назад.

1371
01:05:06,470 --> 01:05:07,353
3 недели назад.

1372
01:05:08,590 --> 01:05:09,708
Да, 3 недели назад.

1373
01:05:10,010 --> 01:05:11,850
Вот там обсуждался стейт.

1374
01:05:11,851 --> 01:05:12,684


1375
01:05:13,590 --> 01:05:14,870
И даже райтер,

1376
01:05:15,050 --> 01:05:16,109
райтер t, стейт t.

1377
01:05:16,370 --> 01:05:18,370
Вот там, если взглянуть на source,

1378
01:05:18,510 --> 01:05:20,863
в стейт t используются illegal patterns,

1379
01:05:21,080 --> 01:05:24,041
потому что там не нужна лишняя
строгость в паттерн-матчике по паре.

1380
01:05:24,830 --> 01:05:25,772
Не нужна просто.

1381
01:05:27,030 --> 01:05:27,863
Вот всё.

1382
01:05:29,630 --> 01:05:32,513
У пар 1 конструктор, там
множество полей, вполне себе

1383
01:05:33,640 --> 01:05:34,490
не то, что это

1384
01:05:35,690 --> 01:05:37,604
легальный способ использовать

1385
01:05:38,985 --> 01:05:40,809
lazy pattern matches, так ещё и

1386
01:05:42,550 --> 01:05:43,110
предпочтительный.

1387
01:05:43,190 --> 01:05:44,150
Это по этой причине.

1388
01:05:44,730 --> 01:05:45,690


1389
01:05:46,850 --> 01:05:52,110
f1 очень тупая функция, принимает
either и int, тут написано write1,

1390
01:05:53,410 --> 01:05:55,957
но это вообще не важно, что тут стоит.

1391
01:05:56,040 --> 01:05:57,550
Это tilde, в этом прикол.

1392
01:05:58,950 --> 01:06:01,770
Во что превращается
f1 tilde write1 равно 42?

1393
01:06:02,295 --> 01:06:03,850
Превращается это в f1 fresh равно 42.

1394
01:06:03,851 --> 01:06:05,530
Fresh это что?

1395
01:06:06,530 --> 01:06:07,363
Вот.

1396
01:06:08,440 --> 01:06:09,810
То есть f1 здесь,

1397
01:06:09,970 --> 01:06:11,550
вот это же const, реально,

1398
01:06:11,850 --> 01:06:13,450
но это const 42.

1399
01:06:15,270 --> 01:06:17,587
Игнорируем аргумент, который стоит здесь.

1400
01:06:18,050 --> 01:06:18,883
Возвращаем 42.

1401
01:06:19,490 --> 01:06:22,437
Факт того, что мы его
не вычисляем, факт того,

1402
01:06:22,520 --> 01:06:24,330
что он ленивый, что
стоит tilde, что f1 fresh,

1403
01:06:24,890 --> 01:06:26,479
то есть underscore неважно,

1404
01:06:26,590 --> 01:06:28,473
позволяет нам писать здесь left.

1405
01:06:29,630 --> 01:06:31,042
Максимально элементарно.

1406
01:06:32,550 --> 01:06:33,383
И даже

1407
01:06:34,510 --> 01:06:37,050
пытаться выбросить ошибку в наш

1408
01:06:37,500 --> 01:06:38,618
irrefutable pattern

1409
01:06:38,820 --> 01:06:40,102
всё ещё вернуться в 42.

1410
01:06:40,185 --> 01:06:41,950
Потому что это не вычисляется.

1411
01:06:42,260 --> 01:06:43,613
Это lazy pattern match.

1412
01:06:44,160 --> 01:06:45,290
f1 fresh равно 42.

1413
01:06:47,000 --> 01:06:47,910
Ну, опять же,

1414
01:06:49,050 --> 01:06:49,450
конечно,

1415
01:06:49,590 --> 01:06:50,943
это функция безопасная,

1416
01:06:51,330 --> 01:06:52,507
это просто const 42.

1417
01:06:53,170 --> 01:06:57,090
Но, да, тут сумма типов
тоже не очень безопасна

1418
01:06:57,091 --> 01:06:59,386
в общем случае, как с lazy pattern, да?

1419
01:07:01,430 --> 01:07:01,810
Вот.

1420
01:07:02,150 --> 01:07:03,747
Поэтому лучше так не делать, наверное.

1421
01:07:03,830 --> 01:07:04,663


1422
01:07:05,150 --> 01:07:08,249
Или просто писать f1 равно
const 42, раз уж приспичили.

1423
01:07:09,930 --> 01:07:11,270
Вопросы по lazy pattern match.

1424
01:07:11,271 --> 01:07:12,104
Что дальше?

1425
01:07:12,450 --> 01:07:13,862
А, окей, strict Haskell.

1426
01:07:14,230 --> 01:07:16,583
Мы подходим к концу первой части лекции.

1427
01:07:24,400 --> 01:07:25,233
Окей.

1428
01:07:26,040 --> 01:07:26,873
В общем,

1429
01:07:28,030 --> 01:07:29,814
где ещё могут
использоваться bank patterns?

1430
01:07:30,185 --> 01:07:33,897
Мы уже узнали, что могут
использоваться в лето-байдингах

1431
01:07:33,980 --> 01:07:37,920
локальных, в аргументах
конструкторов внутри полей.

1432
01:07:38,320 --> 01:07:39,760


1433
01:07:40,220 --> 01:07:45,100
А также можно использовать bank
patterns в самих полях типов данных.

1434
01:07:45,101 --> 01:07:45,934


1435
01:07:46,200 --> 01:07:48,083
Так как здесь у нас есть конфиг,

1436
01:07:48,400 --> 01:07:49,420
это что, просто

1437
01:07:50,580 --> 01:07:52,420
экстракт, там есть int, есть
map-settings, users и extra.

1438
01:07:52,480 --> 01:07:53,313


1439
01:07:54,215 --> 01:07:56,200
Мы хотим, если мы хотим,

1440
01:07:56,400 --> 01:07:57,695
сделать так, что у нас

1441
01:07:57,870 --> 01:08:00,020
int и map-settings были строгими.

1442
01:08:00,800 --> 01:08:01,633
Всегда.

1443
01:08:02,440 --> 01:08:04,740
А элементарно давайте
мы ставим bang-bang'и

1444
01:08:06,400 --> 01:08:08,000
именно в типах,

1445
01:08:09,600 --> 01:08:11,741
не вот перед users и
extra, а именно в типах.

1446
01:08:12,680 --> 01:08:15,677
Тогда users и extra будут всегда
вычисляться на выход-нормал-форм.

1447
01:08:17,080 --> 01:08:18,316
Проблема в следующем.

1448
01:08:19,230 --> 01:08:20,348
Казалось бы, у нас,

1449
01:08:20,480 --> 01:08:24,380
опять же, у maybe есть
локотструктура nothing-adjust,

1450
01:08:24,381 --> 01:08:25,440
nothing-adjust уже прибывает
выход-нормал-форм.

1451
01:08:25,640 --> 01:08:28,240
Тут нужно пытаться понять,

1452
01:08:29,260 --> 01:08:30,460
имеет ли смысл поставить bang в maybe.

1453
01:08:30,461 --> 01:08:31,800


1454
01:08:33,280 --> 01:08:36,717
Если bang делает то же самое
ровно, что делают другие bang'и.

1455
01:08:36,800 --> 01:08:37,918
На мой взгляд, нет.

1456
01:08:39,140 --> 01:08:41,980
Ну, потому что мы
вычисляем… Нет, ну окей, ладно.

1457
01:08:42,880 --> 01:08:44,437
Это стретч, с моей стороны.

1458
01:08:44,520 --> 01:08:47,460
Возможно, это имеет смысл,
потому что даже, несмотря на то,

1459
01:08:47,500 --> 01:08:50,600
что там тут stack-maybe-settings, то, что

1460
01:08:50,601 --> 01:08:51,896
если у нас есть just
от какого-то settings,

1461
01:08:52,300 --> 01:08:53,536
он не будет вычислен,

1462
01:08:53,700 --> 01:08:59,180
то, что just будет вычислен хотя
бы до just, а не до ничего, уже что-то.

1463
01:08:59,770 --> 01:09:00,840


1464
01:09:01,970 --> 01:09:03,237
Несмотря на то, что это stack-maybe.

1465
01:09:03,320 --> 01:09:07,697
То есть, если вдруг реально нам не нужно
что-то больше, чем выход-нормал-форм,

1466
01:09:07,780 --> 01:09:08,997
пожалуйста, ставьте
ваши bang'и без проблем.

1467
01:09:09,080 --> 01:09:10,000


1468
01:09:10,420 --> 01:09:14,760
А вот у всяких таких полей как int
или опять же те же самые bool, char…

1469
01:09:14,761 --> 01:09:16,120
нет, не bool, не bool.

1470
01:09:17,200 --> 01:09:18,280
char, double, word и так далее.

1471
01:09:20,500 --> 01:09:21,333


1472
01:09:22,080 --> 01:09:22,480
Вот там

1473
01:09:22,840 --> 01:09:24,340
реально ставят bang'и.

1474
01:09:25,280 --> 01:09:26,163
И это работает.

1475
01:09:27,260 --> 01:09:28,580
А если мы хотим, чтобы

1476
01:09:28,830 --> 01:09:32,340
в нашем файле у всех типов
данных были строгие поля,

1477
01:09:32,530 --> 01:09:36,440
тогда можно просто добавить
прогму strict data и не ставить bang'и.

1478
01:09:37,500 --> 01:09:38,333
Нигде.

1479
01:09:38,920 --> 01:09:39,560
То есть, возникает вопрос,

1480
01:09:39,720 --> 01:09:42,191
а что, если мы хотим, чтобы во всем модуле

1481
01:09:42,340 --> 01:09:43,980
все было строгим?

1482
01:09:44,800 --> 01:09:46,212
Потому что мы мазохисты.

1483
01:09:47,300 --> 01:09:51,300
Можно тогда ставить strict прогму,
делать все строгим по умолчанию.

1484
01:09:54,370 --> 01:09:56,180
Ее не используют, кажется,

1485
01:09:57,080 --> 01:09:58,060
так часто,

1486
01:09:59,360 --> 01:10:04,060
как возможно ожидается кем-то из
вас или каким-то другим человеком.

1487
01:10:05,420 --> 01:10:06,303
Потому что, ну,

1488
01:10:06,960 --> 01:10:10,014
смысла в тотальной строгости,
наверное, не совсем есть.

1489
01:10:10,680 --> 01:10:11,513


1490
01:10:12,020 --> 01:10:13,940
Смысл совсем есть.

1491
01:10:14,960 --> 01:10:17,400
Более того, вы, наверное, успели
познакомиться с тем, что вот есть

1492
01:10:17,450 --> 01:10:22,060
в ваших проектах
package.yaml, в которых можно

1493
01:10:22,061 --> 01:10:23,414
указать внимание, включенное
extension по умолчанию.

1494
01:10:24,520 --> 01:10:27,840
Представьте, что вы
указываете strict по умолчанию,

1495
01:10:27,841 --> 01:10:29,720
как extension project-wide,
то есть в вашем проекте.

1496
01:10:29,920 --> 01:10:31,840
Тогда у вас весь

1497
01:10:32,190 --> 01:10:33,760
ваш проект станет строгим.

1498
01:10:37,200 --> 01:10:39,957
Я никогда в жизни такого
не видел, чтобы это было,

1499
01:10:40,040 --> 01:10:43,920
и надеюсь, никогда в жизни не
увидишь, потому что мало смысла

1500
01:10:44,720 --> 01:10:46,337
в тотальной строгости Haskell.

1501
01:10:46,420 --> 01:10:50,046
Один PR Haskell просто вперед
и пропадает. Его не используют.

1502
01:10:50,220 --> 01:10:51,053
Стрикт экстенсивно.

1503
01:10:51,840 --> 01:10:53,420
Но strict.

1504
01:10:53,421 --> 01:10:54,716
id используют однозначно.

1505
01:10:55,470 --> 01:10:56,588
И в нем есть смысл.

1506
01:10:59,040 --> 01:10:59,873
Да.

1507
01:11:00,220 --> 01:11:02,720
Естественно, как уже много раз

1508
01:11:04,560 --> 01:11:06,031
обсуждалось, строгие поля

1509
01:11:07,395 --> 01:11:08,340
позволяют избежать space leaks.

1510
01:11:08,341 --> 01:11:11,860
Space leaks, опять же, это те самые
случаи, когда у нас оказываются гигантские

1511
01:11:11,861 --> 01:11:13,780
фанки в нашей памяти,
которые вычитаются очень потом.

1512
01:11:13,781 --> 01:11:15,600
Это space leak.

1513
01:11:16,060 --> 01:11:17,717
Это у вас уже наверняка было.

1514
01:11:17,800 --> 01:11:19,271
Например, в C++, кажется.

1515
01:11:20,270 --> 01:11:22,197
То есть это было сколько лет назад?

1516
01:11:22,280 --> 01:11:23,113
Полтора, да?

1517
01:11:24,570 --> 01:11:26,453
Короче, это было давно. Неважно.

1518
01:11:26,660 --> 01:11:27,493
Вот.

1519
01:11:28,080 --> 01:11:29,492
Все, это strict Haskell.

1520
01:11:31,320 --> 01:11:34,110
Да, тут, короче, есть еще
блог-пост от Романа Чепляки

1521
01:11:34,370 --> 01:11:36,440
о том, сколько занимает
8-битный интеджер в C и Haskell.

1522
01:11:36,441 --> 01:11:37,440


1523
01:11:37,770 --> 01:11:41,560
В этом блог-посте еще Роман
также упоминает то, как в Haskell

1524
01:11:44,020 --> 01:11:44,853
представляются

1525
01:11:45,360 --> 01:11:46,193
значения в памяти, да.

1526
01:11:46,440 --> 01:11:50,280
Я это тоже себе затронул в конце лекции.

1527
01:11:50,281 --> 01:11:52,929
Это более интересная вещь.
На самом деле, это

1528
01:11:53,220 --> 01:11:54,053
уже

1529
01:11:54,860 --> 01:11:55,693
slightly

1530
01:11:56,280 --> 01:11:58,020
advanced Haskell, типа того,

1531
01:11:58,640 --> 01:11:59,935
на уровне компилятора.

1532
01:12:00,020 --> 01:12:02,117
Но я остальное затронул,
потому что это интересно.

1533
01:12:02,200 --> 01:12:04,280
Это все еще не компилятор, казалось бы,

1534
01:12:04,300 --> 01:12:06,180
все еще на уровне Haskell,
но более advanced штуки.

1535
01:12:06,181 --> 01:12:08,180
Это затронул в конце лекции.

1536
01:12:08,181 --> 01:12:09,064


1537
01:12:10,260 --> 01:12:13,260
Итого, сейчас мы будем на 20-минутной,

1538
01:12:13,610 --> 01:12:15,500
резюмируя, что делают,

1539
01:12:15,700 --> 01:12:17,827
когда можно использовать
strict evaluation.

1540
01:12:17,910 --> 01:12:18,793
Вот когда у нас

1541
01:12:19,340 --> 01:12:22,720
есть некоторые ленивые подчисления,
которые, к сожалению, возвращают

1542
01:12:22,721 --> 01:12:26,524
out of memory, ну, не с такой
workflow, как тут написано почему-то,

1543
01:12:27,900 --> 01:12:28,733
можно

1544
01:12:29,650 --> 01:12:33,570
проанализировать вашу программу, выяснить,
в каких местах у вас используются

1545
01:12:35,280 --> 01:12:38,977
слишком ленивые подчисления,
которые можно сделать более строгими.

1546
01:12:39,130 --> 01:12:42,193
В том числе, когда у нас имеются
арифметические операторы

1547
01:12:42,660 --> 01:12:45,180
по, скажем, примитивным типам.

1548
01:12:45,181 --> 01:12:47,640
Например, int, double, float,

1549
01:12:48,560 --> 01:12:49,080
хоть chart, какая разница.

1550
01:12:49,200 --> 01:12:50,033


1551
01:12:52,000 --> 01:12:55,200
Тогда можно использовать
строгость по этим аргументам.

1552
01:12:55,440 --> 01:12:57,088
Например, если мы, опять же,

1553
01:12:58,460 --> 01:12:59,420
делаем свертку,

1554
01:13:00,320 --> 01:13:01,020
например, левую,

1555
01:13:01,180 --> 01:13:02,013
мы можем

1556
01:13:03,080 --> 01:13:04,360
сделать строгим

1557
01:13:05,355 --> 01:13:06,297
наш аккумулятор.

1558
01:13:07,510 --> 01:13:10,500
Если мы, например,
сворачиваем наш список или любую

1559
01:13:10,600 --> 01:13:13,200
произвольную структуру по сложению.

1560
01:13:16,450 --> 01:13:18,243
В случае, когда у нас возникают всякие

1561
01:13:19,320 --> 01:13:20,700
состояния высовывания
функций внутри памяти.

1562
01:13:20,701 --> 01:13:21,534


1563
01:13:21,660 --> 01:13:25,009
Из-за этого можно сразу
вычислить h от x, как здесь.

1564
01:13:25,660 --> 01:13:26,680
Вычисляем h от x,

1565
01:13:27,240 --> 01:13:28,770
потому что тут стоит банк.

1566
01:13:29,640 --> 01:13:31,052
Потом мы передаем это g.

1567
01:13:34,435 --> 01:13:36,340
Или можно ставить банк у x.

1568
01:13:36,680 --> 01:13:39,515
Тогда x будет строгим,
то есть мы вычислим x.

1569
01:13:42,115 --> 01:13:43,980
h от x, конечно, sorry,

1570
01:13:44,780 --> 01:13:46,280
g от h аргумента,

1571
01:13:46,420 --> 01:13:48,240
x будет в памяти,

1572
01:13:48,590 --> 01:13:50,177
но хотя бы у нас x вычислится.

1573
01:13:50,260 --> 01:13:52,084
Вот эти два примера, они как бы

1574
01:13:52,870 --> 01:13:56,660
разные на самом деле, потому что
вычисляется h от x, а тут именно x.

1575
01:13:57,260 --> 01:13:58,093
Очевидно,

1576
01:13:59,560 --> 01:14:01,397
кейсы фундаментально отличаются.

1577
01:14:01,480 --> 01:14:03,304
Тем не менее, они используются.

1578
01:14:04,520 --> 01:14:05,140
Ну и,

1579
01:14:05,340 --> 01:14:06,870
как я уже говорил недавно,

1580
01:14:07,180 --> 01:14:08,540
поля данных, чтобы

1581
01:14:09,060 --> 01:14:11,060
изображать очередных
кейсов офф SpaceLeaks.

1582
01:14:12,880 --> 01:14:13,840


1583
01:14:15,740 --> 01:14:16,573
Вот.

1584
01:14:16,760 --> 01:14:19,840
А, нет-нет-нет,

1585
01:14:20,180 --> 01:14:22,298
я совсем забыл про эту часть лекции.

1586
01:14:23,220 --> 01:14:24,053
Да,

1587
01:14:24,690 --> 01:14:27,015
я оборачиваю еще 6 минут,
потом уйду на перерыв.

1588
01:14:27,760 --> 01:14:29,172
Немножко про SpaceLeaks.

1589
01:14:29,600 --> 01:14:31,306
И вот эта часть очень важная.

1590
01:14:31,400 --> 01:14:33,400
Давайте обсудим, что тут написано.

1591
01:14:33,780 --> 01:14:34,613
Функция pet.

1592
01:14:36,020 --> 01:14:40,360
Она вычисляет сумму списка, ну,
сворачивает по список по сложению и нулю.

1593
01:14:40,740 --> 01:14:41,573
И длину.

1594
01:14:41,760 --> 01:14:43,702
Запекивает оба результата в пару.

1595
01:14:45,720 --> 01:14:45,980
Фух.

1596
01:14:46,120 --> 01:14:48,317
Вот этот вот SpaceLeaks, он неизбежный.

1597
01:14:48,400 --> 01:14:50,000
Вообще.

1598
01:14:52,120 --> 01:14:53,297
Почему? Посмотрим следующее.

1599
01:14:54,360 --> 01:14:55,193
Допустим,

1600
01:14:55,360 --> 01:14:58,273
опять же, тут, наверное, возникнет сейчас,

1601
01:14:58,400 --> 01:15:02,689
вот тут нужно подумать, есть ли
недетерминизм в том, что вычисляется сначала.

1602
01:15:02,960 --> 01:15:03,793
Я вот не знаю.

1603
01:15:04,260 --> 01:15:05,887
К сожалению, я забыл эту часть.

1604
01:15:05,970 --> 01:15:06,803
Хаскова.

1605
01:15:08,520 --> 01:15:09,420
Но, допустим,

1606
01:15:09,720 --> 01:15:11,817
сначала вычисляется левый аргумент пары.

1607
01:15:11,900 --> 01:15:13,136
Один из двух случаев.

1608
01:15:14,440 --> 01:15:15,273
Отлично.

1609
01:15:15,500 --> 01:15:16,500
Мы вычислили sum.

1610
01:15:18,150 --> 01:15:19,440
Чтобы вычислить sum,

1611
01:15:19,920 --> 01:15:21,997
необходимо сделать паттерн матча к пиксу.

1612
01:15:22,080 --> 01:15:23,840
До тех пор, пока мы не
вычислим полностью нашу сумму.

1613
01:15:23,841 --> 01:15:24,674


1614
01:15:25,180 --> 01:15:27,360
Чтобы это завершилось, наш
список должен быть конечным.

1615
01:15:27,420 --> 01:15:28,253
Это очевидно.

1616
01:15:30,015 --> 01:15:31,016
Мы вычислили sum.

1617
01:15:32,760 --> 01:15:34,349
Дальше мы вычисляем length.

1618
01:15:34,480 --> 01:15:37,720
Поскольку мы уже сделали кейс xs, причем

1619
01:15:37,920 --> 01:15:39,020
полный кейс,

1620
01:15:39,400 --> 01:15:43,480
мы полностью разанфолдили наш
список, этот список сейчас будет

1621
01:15:43,481 --> 01:15:47,700
висеть в памяти до тех пор, пока мы не
сделаем length и не завершим функцию bed.

1622
01:15:47,701 --> 01:15:48,534


1623
01:15:50,600 --> 01:15:51,917
То есть мы вычислим функцию sum, например.

1624
01:15:52,000 --> 01:15:52,833


1625
01:15:53,820 --> 01:15:57,320
Какой бы он ни был гигантский, он
будет висеть в памяти до тех пор, пока мы

1626
01:15:57,321 --> 01:16:01,460
не вычислим length, не вернем результат
и не завершим работу нашим списком.

1627
01:16:01,461 --> 01:16:02,294


1628
01:16:03,280 --> 01:16:04,869
Это unavoidable space leak.

1629
01:16:06,140 --> 01:16:06,973
Как быть?

1630
01:16:10,820 --> 01:16:13,330
Это мы уже обсудили, когда у нас здесь

1631
01:16:14,520 --> 01:16:15,353
возникает

1632
01:16:16,660 --> 01:16:19,560
типа строгий foldable по более
сложным структуркам в аккумуляторе.

1633
01:16:19,561 --> 01:16:21,577
Это мы уже проходили.

1634
01:16:21,660 --> 01:16:25,714
Есть такая классная библиотечка от
Кабриэла Гонзалеса, называется foldable.

1635
01:16:25,920 --> 01:16:26,820
Целый пакет,

1636
01:16:27,520 --> 01:16:29,898
в котором потеряет тип
данных, сейчас я его напишу,

1637
01:16:30,600 --> 01:16:31,433
fold,

1638
01:16:32,380 --> 01:16:33,320
да, это fold,

1639
01:16:35,540 --> 01:16:38,080
он принимает два аргумента a, b, и

1640
01:16:38,580 --> 01:16:39,698
ух, сейчас вспомню.

1641
01:16:41,200 --> 01:16:44,360
В общем, это есть экзидентальный
тип, тут ставится парол

1642
01:16:45,340 --> 01:16:48,500
x.fold и дальше три значения.

1643
01:16:49,320 --> 01:16:50,909
Это то, как мы сворачиваем,

1644
01:16:52,340 --> 01:16:54,620
а это наш элемент контейнера.

1645
01:16:55,960 --> 01:16:58,400
Например, это элемент
нашего списка. Их это

1646
01:16:58,401 --> 01:16:59,740
начальное значение,
а тут просто processing.

1647
01:17:00,015 --> 01:17:04,200
То есть, мы совершили наш fold, и
дальше мы хотим вернуть просто из xа в b.

1648
01:17:04,201 --> 01:17:05,554
То есть, это

1649
01:17:06,305 --> 01:17:07,760
что-то после fold.

1650
01:17:08,610 --> 01:17:10,905
После fold, извиняюсь, после четвертки.

1651
01:17:11,060 --> 01:17:13,237
Финальная функция, собственно говоря.

1652
01:17:13,720 --> 01:17:14,817
Видели вот этот парол x?

1653
01:17:14,900 --> 01:17:16,757
Вот это то же самое,
что экзидентальный тип.

1654
01:17:16,840 --> 01:17:20,220
Пока их не было, я потом
упомяну еще экзидентальный тип

1655
01:17:20,270 --> 01:17:22,340
и объясню, что это такое
на следующей части лекции.

1656
01:17:22,341 --> 01:17:24,260
Но fold

1657
01:17:24,410 --> 01:17:28,684
это такая вот функция, ой, функция,
господи, тип данных, который капсулирует

1658
01:17:29,500 --> 01:17:30,333
переход

1659
01:17:30,620 --> 01:17:31,880
и изгибничный переход

1660
01:17:32,180 --> 01:17:34,000
в свертке начальное
значение и постпроцессинг.

1661
01:17:34,001 --> 01:17:34,884


1662
01:17:37,160 --> 01:17:37,993
Да.

1663
01:17:40,180 --> 01:17:40,580
Вот.

1664
01:17:40,680 --> 01:17:43,780
И на основе этого типа данных
тут реализуются всякие уже

1665
01:17:44,030 --> 01:17:46,300
встроенные вещи, как
length, sum, понимание.

1666
01:17:46,600 --> 01:17:47,433


1667
01:17:48,140 --> 01:17:49,611
Вот length означает fold.

1668
01:17:50,110 --> 01:17:52,367
И fold является функтором и аппликативом.

1669
01:17:52,450 --> 01:17:53,921
Fold не является монадой.

1670
01:17:55,400 --> 01:17:56,233
Такие дела.

1671
01:17:58,300 --> 01:17:59,418
Что принимает fold?

1672
01:18:04,300 --> 01:18:05,653
Он принимает fold a, b,

1673
01:18:05,840 --> 01:18:06,840
принимает f от a.

1674
01:18:07,885 --> 01:18:10,000
f от a, помните, foldable, да?

1675
01:18:10,180 --> 01:18:11,640
f от a до t, там было t от a.

1676
01:18:11,720 --> 01:18:13,485
Это просто какой-то контейнер,

1677
01:18:13,840 --> 01:18:14,877
варганизованный типом a.

1678
01:18:14,960 --> 01:18:15,843
Возвращает к b.

1679
01:18:17,080 --> 01:18:17,913
Вот.

1680
01:18:18,280 --> 01:18:19,113
И

1681
01:18:21,120 --> 01:18:21,953
здесь,

1682
01:18:22,610 --> 01:18:25,760
поскольку там все это
как композиция функции,

1683
01:18:26,160 --> 01:18:29,471
когда там возникает s-кабинатор,
вторая аксиома в матлоге,

1684
01:18:30,800 --> 01:18:34,680
когда там возникает первая аксиома в
матлоге, это pure и app, управление есть,

1685
01:18:35,100 --> 01:18:36,400
то там еще функции.

1686
01:18:36,780 --> 01:18:37,613
Это все

1687
01:18:40,140 --> 01:18:41,377
в итоге получается довольно строгим.

1688
01:18:41,460 --> 01:18:43,049
Там, кажется, какие-то есть

1689
01:18:44,460 --> 01:18:48,957
элементы фолда, которые вообще-то с
bang'ами, я не помню, какие, я забыл. Блин.

1690
01:18:49,040 --> 01:18:51,276
Кажется, начальное значение с bang'ом.

1691
01:18:51,580 --> 01:18:52,698
Вообще логично, да? Неважно.

1692
01:18:53,640 --> 01:18:54,876
В общем, да.

1693
01:18:55,560 --> 01:18:57,200
И это просто позволяет

1694
01:18:58,580 --> 01:19:01,040
для типа произвольных структур

1695
01:19:02,620 --> 01:19:03,453
делать

1696
01:19:04,780 --> 01:19:07,380
приколюхи связанные с обработкой

1697
01:19:08,000 --> 01:19:09,100
структуры, свёртки и так далее.

1698
01:19:09,160 --> 01:19:10,997
А, ну это свёртка, собственно говоря.

1699
01:19:11,080 --> 01:19:13,077
Fold, между прочим, это левая свёртка.

1700
01:19:13,160 --> 01:19:14,960
Написано fold, но на самом
деле это fold'у по фолду.

1701
01:19:14,961 --> 01:19:16,100


1702
01:19:17,540 --> 01:19:18,840
Короче, рекомендую
посмотреть видео Габриэлы.

1703
01:19:18,841 --> 01:19:24,900
Она обсуждает вот реализацию фолда, но

1704
01:19:25,150 --> 01:19:26,980
моноидальной реализации фолда.

1705
01:19:28,660 --> 01:19:30,040
То есть у нее там другие

1706
01:19:32,020 --> 01:19:34,220
определения типа данных через моноид.

1707
01:19:35,320 --> 01:19:36,620
Но моноид конкретно тому, что вот в фолду.

1708
01:19:36,621 --> 01:19:37,454


1709
01:19:38,700 --> 01:19:40,740
Там всё довольно просто.

1710
01:19:41,790 --> 01:19:43,085
Очень классный данный.

1711
01:19:44,420 --> 01:19:45,253
А ещё

1712
01:19:47,120 --> 01:19:49,220
финальная финалочка, да? Да, финалочка.

1713
01:19:49,340 --> 01:19:50,760
Всё.

1714
01:19:51,660 --> 01:19:52,840
Вот немножко

1715
01:19:52,990 --> 01:19:54,660
про то, как

1716
01:19:54,760 --> 01:19:56,880
визуализируется Spacelix.

1717
01:19:58,280 --> 01:20:01,080
Вот здесь две картинки
перед вашими глазами.

1718
01:20:01,240 --> 01:20:04,580
Слева по вертикальной шкале у нас
байты, алоцированные с правой секунды.

1719
01:20:04,581 --> 01:20:06,360
А логично с правой части.

1720
01:20:06,361 --> 01:20:07,520


1721
01:20:08,580 --> 01:20:10,380
Здесь всё это хаскилные функции.

1722
01:20:11,180 --> 01:20:12,797
Сейчас надеюсь, что это всё видно.

1723
01:20:12,880 --> 01:20:14,939
Я не знаю, что зависит
от качества трансляции.

1724
01:20:15,120 --> 01:20:16,650
Это всё хаскилные функции.

1725
01:20:16,800 --> 01:20:18,506
Можно заметить здесь, что тут

1726
01:20:19,400 --> 01:20:22,780
локация варьируется, но
примерно константная на самом

1727
01:20:22,781 --> 01:20:24,677
деле, потому что там всё
учитывается в левой части.

1728
01:20:24,760 --> 01:20:28,760
Там всё по релевантным аргументам строгое,

1729
01:20:28,761 --> 01:20:31,240
поэтому там не разрастаются фанки линейно.

1730
01:20:32,210 --> 01:20:33,152
Как это делается

1731
01:20:33,390 --> 01:20:37,320
справа? Можно заметить,
что справа у нас есть

1732
01:20:37,321 --> 01:20:39,137
линейная зависимость
от секунд и от байтов.

1733
01:20:39,220 --> 01:20:40,103
Внимание, вот здесь слева

1734
01:20:40,840 --> 01:20:42,958
мой кристалл виден, я даже вижу его.

1735
01:20:43,380 --> 01:20:46,860
Тысяча байтов. Тут миллионы,
более того, тут сотни миллионов.

1736
01:20:47,060 --> 01:20:49,178
Вот здесь это уже примерно гигабайт.

1737
01:20:50,620 --> 01:20:51,453
Потому что

1738
01:20:52,140 --> 01:20:53,082
миллиард байтов.

1739
01:20:54,180 --> 01:20:55,013
Да, правильно.

1740
01:20:56,540 --> 01:20:57,140
Типичный пример спейслика.

1741
01:20:57,141 --> 01:21:01,692
Вот тут у нас разрастается фанк,
который у нас начислен. Внимание, вот тут

1742
01:21:01,840 --> 01:21:02,673
приколчик

1743
01:21:03,760 --> 01:21:04,360
возникает с питфоллом.

1744
01:21:04,361 --> 01:21:06,417
Это гигантская пропасть.

1745
01:21:06,500 --> 01:21:08,853
Это что? А это завершение нашей функции.

1746
01:21:09,520 --> 01:21:10,991
Наша функция завершается,

1747
01:21:11,420 --> 01:21:14,080
производится вычисление
фанка, он начинается довольно

1748
01:21:14,081 --> 01:21:16,640
быстро, там всё вычисляется
в уже одно значение,

1749
01:21:17,320 --> 01:21:18,680
и аллокация теперь уже более адекватная.

1750
01:21:18,681 --> 01:21:19,514


1751
01:21:21,625 --> 01:21:24,300
Поэтому этот питфолл это непосредственно

1752
01:21:24,301 --> 01:21:26,460
вычисление аргумента
после завершения функции.

1753
01:21:26,610 --> 01:21:28,740
Явно тут графы, а не тут линейные.

1754
01:21:29,080 --> 01:21:30,551
Но в зависимости от того,

1755
01:21:30,660 --> 01:21:34,500
какого space complexity
именно space complexity.

1756
01:21:34,501 --> 01:21:38,137
Вот графы может быть хоть как парабола

1757
01:21:38,220 --> 01:21:39,220
выглядят, хоть как
логарифм, хоть как logstar.

1758
01:21:40,870 --> 01:21:44,180
Я никогда в жизни не видел алгоритм, у
которого бы space complexity был logstar.

1759
01:21:44,181 --> 01:21:45,014


1760
01:21:47,170 --> 01:21:48,440
Никогда в жизни я не
видел такого алгоритма.

1761
01:21:48,480 --> 01:21:52,020
Я не знаю, как это
работает, и есть ли такой

1762
01:21:52,021 --> 01:21:53,500
алгоритм, у которого
logstar space complexity.

1763
01:21:54,700 --> 01:21:56,137
Но, тем не менее,
наверняка можно придумать.

1764
01:21:56,220 --> 01:21:57,053
Короче говоря,

1765
01:21:57,980 --> 01:21:59,640
шейп вашей зависимости

1766
01:22:00,560 --> 01:22:02,300
отражает то, как у вас
разрастаются ваши танки.

1767
01:22:02,325 --> 01:22:04,443
Тут это линейная зависимость.

1768
01:22:05,460 --> 01:22:06,813
Во всех функциях почти.

1769
01:22:07,600 --> 01:22:08,433
Вот.

1770
01:22:09,280 --> 01:22:10,113
Да.

1771
01:22:10,380 --> 01:22:12,263
Вот как вы детектите space leak.

1772
01:22:13,470 --> 01:22:14,588
Смотрим по батикам.

1773
01:22:15,120 --> 01:22:16,717
Смотрим на то, какой у вас граф.

1774
01:22:16,800 --> 01:22:19,357
Желательно, чтобы там у вас
все, конечно, было константное.

1775
01:22:19,440 --> 01:22:23,017
То есть все прочиталось мгновенно
по релиматным аргументам.

1776
01:22:23,100 --> 01:22:24,220
Все. Окей.

1777
01:22:25,120 --> 01:22:26,157
Эта часть лекции завершилась.

1778
01:22:26,240 --> 01:22:29,064
Давайте уйдем на перерыв.
Я пока завершу запись.

1779
01:22:33,140 --> 01:22:33,973
Чпок.

1780
01:22:34,120 --> 01:22:35,560
Окей.

1781
01:22:35,860 --> 01:22:39,460
Вторая часть будет посвящена
мутабельным объектам и дефористейшну.

1782
01:22:39,461 --> 01:22:41,457
И как резолвить
дефористейшн. Ой, как резолвить,

1783
01:22:41,540 --> 01:22:44,188
наоборот, дефористейшн
— это способ резолвить

1784
01:22:44,420 --> 01:22:46,597
промежуточные представления в памяти.

1785
01:22:47,360 --> 01:22:48,193
Итак.

1786
01:22:49,020 --> 01:22:51,845
Собственно, дефористейшн —
это механизм, который позволяет

1787
01:22:52,605 --> 01:22:55,460
предотвращать или... Да,
правильно. Предотвращать

1788
01:22:55,760 --> 01:22:57,761
промежуточные структурки в памяти.

1789
01:22:58,700 --> 01:23:03,740
У нас есть несколько типичных примеров
промежуточных структур, наподобие

1790
01:23:04,190 --> 01:23:05,308
следующей ситуации.

1791
01:23:05,860 --> 01:23:07,837
Более того, ситуация первая с мапами.

1792
01:23:07,920 --> 01:23:09,580
Я ее упоминал, я помню,

1793
01:23:09,740 --> 01:23:11,920
что я упоминал ее в лекции

1794
01:23:13,240 --> 01:23:17,480
по type-классам,
которые... То есть она сейчас

1795
01:23:17,481 --> 01:23:21,120
затрагивала то, что у type-классов
есть некоторые правила.

1796
01:23:21,430 --> 01:23:25,500
Вот эти некоторые
правила как раз таки можно

1797
01:23:25,501 --> 01:23:27,360
использовать, чтобы
избавиться от промежуточных

1798
01:23:28,090 --> 01:23:29,443
представлений в памяти.

1799
01:23:30,440 --> 01:23:31,500
А что это такое?

1800
01:23:31,955 --> 01:23:33,360
Откуда возникают

1801
01:23:35,070 --> 01:23:36,718
промежуточные представления?

1802
01:23:37,060 --> 01:23:38,531
Посмотрим на левую часть.

1803
01:23:38,760 --> 01:23:39,540
В левой части у нас есть mapf.

1804
01:23:39,541 --> 01:23:41,200
mapr.

1805
01:23:41,201 --> 01:23:42,360
Мы придаем список,

1806
01:23:43,120 --> 01:23:47,337
по нему один раз применяем функцию,
по нему второй раз применяем функцию.

1807
01:23:47,910 --> 01:23:49,616
Когда мы применяем функцию g,

1808
01:23:51,740 --> 01:23:56,357
то мы заотводили весь
список, весь список у нас

1809
01:23:56,440 --> 01:23:57,793
теперь находится в памяти,
и там ко всем элементам

1810
01:23:58,200 --> 01:23:59,920
функция g применена.

1811
01:23:59,921 --> 01:24:01,260
Она будет висеть в памяти,

1812
01:24:02,530 --> 01:24:06,080
пока мы не применим функцию f, не
завершим работу с нашими двумя мапами.

1813
01:24:06,081 --> 01:24:06,914


1814
01:24:08,020 --> 01:24:09,640
Это два траверсала

1815
01:24:09,790 --> 01:24:11,202
одного и того же списка.

1816
01:24:11,860 --> 01:24:16,494
Потому что или два, список будет
оставаться, это прям как в ситуации с

1817
01:24:18,300 --> 01:24:20,301
собственно, бетом, с первым бетом.

1818
01:24:20,510 --> 01:24:23,800
Из-за того, что у нас два траверсала
списка, у нас из-за этого возникает

1819
01:24:25,660 --> 01:24:27,137
промежуточное
представление списка в памяти.

1820
01:24:27,220 --> 01:24:29,337
Только здесь оно именно промежуточное.

1821
01:24:29,420 --> 01:24:33,272
Потому что результат, это должна
быть композиция функции f и g.

1822
01:24:34,680 --> 01:24:35,975
Поэтому это называется

1823
01:24:36,460 --> 01:24:37,847
промежуточная представление.

1824
01:24:37,930 --> 01:24:41,703
Потому что мы пока что применим только
функцию g, а нужно применять еще функцию f.

1825
01:24:41,900 --> 01:24:43,900
Мы знаем, что есть функциональный

1826
01:24:44,760 --> 01:24:45,593
ло,

1827
01:24:45,910 --> 01:24:47,500
который говорит о том, что mapf.

1828
01:24:47,501 --> 01:24:48,660
mapj равен mapf.j.

1829
01:24:50,120 --> 01:24:50,953
Перк этого

1830
01:24:51,660 --> 01:24:55,491
правила в том, что у нас один
траверсал, один проход по списку,

1831
01:24:55,660 --> 01:24:58,494
мы сразу применяем
элементную функцию f от g,

1832
01:24:59,650 --> 01:25:00,886
применяем g, потом f.

1833
01:25:01,900 --> 01:25:02,733
И все.

1834
01:25:02,900 --> 01:25:05,320
Мы ничего не храним в памяти

1835
01:25:08,340 --> 01:25:09,960
промежуточного и лишнего,

1836
01:25:10,240 --> 01:25:11,077
у нас один траверсал.

1837
01:25:11,160 --> 01:25:11,993
Это хорошо.

1838
01:25:13,480 --> 01:25:14,840
По идее, аналогичная вещь в самом.

1839
01:25:14,841 --> 01:25:15,674


1840
01:25:17,420 --> 01:25:18,253
Мы

1841
01:25:18,680 --> 01:25:20,140
приезжаем по списку,

1842
01:25:21,160 --> 01:25:22,280
потом делаем сам.

1843
01:25:22,600 --> 01:25:23,895
Мы проехали по списку,

1844
01:25:26,660 --> 01:25:28,280
а потом мы свернули список.

1845
01:25:28,340 --> 01:25:30,617
И когда мы прошли по списку, у нас есть

1846
01:25:30,700 --> 01:25:32,880
список в памяти, который
мы потом сворачиваем.

1847
01:25:32,881 --> 01:25:33,714


1848
01:25:34,360 --> 01:25:38,297
Зачем хранить список в памяти, если
мы его рано или поздно сворачиваем?

1849
01:25:38,380 --> 01:25:40,820
Можно ведь это сделать сразу же.

1850
01:25:41,960 --> 01:25:43,313
И скоро будет алгоритм,

1851
01:25:43,520 --> 01:25:47,180
как сделать из вот
такой вот страшной вещи,

1852
01:25:49,000 --> 01:25:51,001
наподобие того, что написал здесь,

1853
01:25:51,390 --> 01:25:55,000
вещь, которая избавляет нас от
промежуточных представлений.

1854
01:25:55,440 --> 01:25:56,377
Вот следующий слайд.

1855
01:25:56,460 --> 01:26:00,140
А пока затронем еще
третью строку от filterp.

1856
01:26:00,390 --> 01:26:02,160
mapf.

1857
01:26:02,460 --> 01:26:06,800
Мы опять же приезжаем по списку, применяем
функцию f, потом фильтруем наш список,

1858
01:26:09,380 --> 01:26:11,040
оставляем только те f от x,

1859
01:26:11,760 --> 01:26:13,525
которые реально притягают у p.

1860
01:26:14,460 --> 01:26:15,293
Причем,

1861
01:26:15,700 --> 01:26:16,420
опять же,

1862
01:26:16,540 --> 01:26:18,400
эта функция filterp.

1863
01:26:18,401 --> 01:26:20,166
mapf работает еще и
для бесконечных списков,

1864
01:26:20,780 --> 01:26:21,722
по причине того,

1865
01:26:22,440 --> 01:26:23,580
что все ленивое.

1866
01:26:25,180 --> 01:26:29,357
У нас, например, список
бесконечный, он всегда не пустой.

1867
01:26:29,440 --> 01:26:31,920
Мы из мапы вытаскиваем gold,

1868
01:26:32,040 --> 01:26:34,276
потом этот gold обрабатываем фильтром.

1869
01:26:35,440 --> 01:26:37,076
И, например, если мы
делаем take 10 от filterp.

1870
01:26:37,210 --> 01:26:40,220
mapf.

1871
01:26:41,680 --> 01:26:47,780
l, то надо, чтобы у нашего бесконечного
списка было хотя бы 10 элементов

1872
01:26:48,360 --> 01:26:49,760
f от x, которые притягают у p.

1873
01:26:49,761 --> 01:26:50,594


1874
01:26:51,460 --> 01:26:53,940
А мы хотим сделать аналогичную функцию,

1875
01:26:54,120 --> 01:26:56,642
которая тоже будет работать
для бесконечных списков,

1876
01:26:57,140 --> 01:26:58,577
но в которой один треверсал.

1877
01:26:58,660 --> 01:27:00,484
Тут треверсалов, опять же, два.

1878
01:27:04,500 --> 01:27:08,340
Хочется, чтобы у
треверсалов была одна штука.

1879
01:27:08,580 --> 01:27:09,100
Чтобы не было,

1880
01:27:09,340 --> 01:27:10,173
опять же,

1881
01:27:11,080 --> 01:27:12,437
прогружечных представлений наших списков.

1882
01:27:12,520 --> 01:27:13,353


1883
01:27:13,800 --> 01:27:16,300
А прикол в финальной строке в том,

1884
01:27:16,405 --> 01:27:19,975
что мапа, а потом фолдер, можно
заменить на фолдер от композиции.

1885
01:27:20,060 --> 01:27:20,680
Ровно она и есть.

1886
01:27:20,840 --> 01:27:22,400
Причем ровно в таком виде.

1887
01:27:23,000 --> 01:27:24,295
f – это функция из fb,

1888
01:27:24,410 --> 01:27:25,540
f – это функция из b, функция из cfc.

1889
01:27:25,620 --> 01:27:27,740


1890
01:27:28,140 --> 01:27:31,540
f.g – это функция из a, функция из cfc.

1891
01:27:32,640 --> 01:27:33,935
Та же самая сигнатура.

1892
01:27:34,940 --> 01:27:36,411
Фолдровская, так сказать.

1893
01:27:37,780 --> 01:27:38,613
Поэтому

1894
01:27:39,875 --> 01:27:40,480
композиция вполне валидная.

1895
01:27:40,640 --> 01:27:41,582
И более того, мы

1896
01:27:41,970 --> 01:27:43,577
сразу же сворачиваем наш список.

1897
01:27:43,660 --> 01:27:44,580
Что удобно.

1898
01:27:44,740 --> 01:27:47,152
Опять же, у нас один треверсал по списку.

1899
01:27:49,200 --> 01:27:50,854
Перед тем, как мы перейдем к алгоритму,

1900
01:27:52,500 --> 01:27:53,380
мануальному алгоритму

1901
01:27:53,381 --> 01:27:55,220
произведения Deforestation, давайте
мы перепишем map немножечко.

1902
01:27:55,221 --> 01:27:56,300


1903
01:27:56,580 --> 01:28:00,737
Ну, map определяется каноническим
образом по паттерн-матчингу

1904
01:28:00,820 --> 01:28:02,600
по второму аргументу,
конечно же, нашему списку.

1905
01:28:06,120 --> 01:28:08,677
конечно, паттерн-матчинг
по аргументу сразу же – это

1906
01:28:08,760 --> 01:28:12,800
на самом деле четный потопей
сахара к кейс-экспрессиону.

1907
01:28:13,080 --> 01:28:17,517
У нас, как я уже говорил, кейс-экспрессион,
кейс-форажение – это фундаментальная

1908
01:28:17,600 --> 01:28:20,400
составляющая, которая
вычисляет наши значения.

1909
01:28:21,925 --> 01:28:23,020
Именно кейс-форажение это производит.

1910
01:28:23,021 --> 01:28:23,904


1911
01:28:24,880 --> 01:28:26,300
И, на самом деле,

1912
01:28:27,180 --> 01:28:28,420
эта запись, которая

1913
01:28:29,070 --> 01:28:32,188
здесь, она, естественно,
эквивалентна записи вот этой

1914
01:28:32,340 --> 01:28:34,080
те же самые записи.

1915
01:28:34,840 --> 01:28:38,417
Но эта запись более похожа
на ту запись, которую вы

1916
01:28:38,500 --> 01:28:42,620
можете найти, если вы
скомпилируете Haskell в его

1917
01:28:43,600 --> 01:28:44,433
первое

1918
01:28:45,260 --> 01:28:46,908
промежуточное представление.

1919
01:28:47,200 --> 01:28:48,720
У Haskell'а в мультикомпиляции
есть несколько представлений.

1920
01:28:48,721 --> 01:28:51,403
Первое из них называется core.

1921
01:28:52,120 --> 01:28:53,497
Core – это такой язык внутри Haskell,

1922
01:28:53,580 --> 01:28:56,037
очень-очень маленький, у
него очень минимальный.

1923
01:28:56,120 --> 01:28:58,560
И вот это почти core, на самом деле,

1924
01:28:58,680 --> 01:29:01,540
только тут у функций в core нету

1925
01:29:02,310 --> 01:29:05,977
списка аргументов. Есть,
опять же, lambda f стрелка,

1926
01:29:06,060 --> 01:29:08,180
lambda l стрелка, то есть там
лямбда и по одному аргументу.

1927
01:29:08,220 --> 01:29:09,380
Ну, как в обычных функциях.

1928
01:29:10,660 --> 01:29:11,493


1929
01:29:11,880 --> 01:29:14,658
Мы знаем, что в Haskell у нас
все функции по одному аргументу.

1930
01:29:15,950 --> 01:29:19,820
И тут нету инфиксных кооператоров,
тут все применение функции префиксное.

1931
01:29:20,540 --> 01:29:21,373


1932
01:29:22,350 --> 01:29:23,460
Немножко про core,

1933
01:29:23,680 --> 01:29:24,880
язык внутри Haskell.

1934
01:29:26,050 --> 01:29:27,497
Это похоже на core немножечко.

1935
01:29:27,580 --> 01:29:32,280
И вот это определение мапа, мы
будем его использовать, когда будем

1936
01:29:32,980 --> 01:29:33,680
делать differentiation

1937
01:29:33,880 --> 01:29:35,460
под этой функцией.

1938
01:29:36,000 --> 01:29:37,180
Мы здесь применяем

1939
01:29:38,500 --> 01:29:39,680
функцию умножить на 10

1940
01:29:39,681 --> 01:29:43,925
ко всем элементам, потом сворачиваем
по плюсу и нулю. То есть мы делаем sum.

1941
01:29:46,680 --> 01:29:48,100
Как мы должны сделать,

1942
01:29:48,260 --> 01:29:49,580
значит, опять же, в чем прикол?

1943
01:29:49,640 --> 01:29:50,840
Прикол в том, что мы

1944
01:29:51,990 --> 01:29:53,660
делаем два траверсала.
Хотим делать один траверсал.

1945
01:29:53,661 --> 01:29:57,377
Один проход по нашему
списку, чтобы не было

1946
01:29:58,420 --> 01:30:00,244
промежуточных списков в памяти.

1947
01:30:01,060 --> 01:30:01,893
Шаг нулевой.

1948
01:30:02,135 --> 01:30:03,547
Мы делаем это экспансию.

1949
01:30:03,820 --> 01:30:06,350
Это экспансия, это мы
добавляем аргументик.

1950
01:30:06,480 --> 01:30:08,186
У нас аргумент ожидается, да?

1951
01:30:08,480 --> 01:30:09,833
Вот эта композиция, да?

1952
01:30:10,560 --> 01:30:13,520
И потом unfolding определяем композиции.

1953
01:30:13,700 --> 01:30:15,800
Композиция в точке –
это просто аппликация.

1954
01:30:15,801 --> 01:30:17,320
Это мы знаем.

1955
01:30:18,480 --> 01:30:19,313
Очень просто.

1956
01:30:21,020 --> 01:30:22,180
Тут шаг нулевой.

1957
01:30:22,360 --> 01:30:23,537
Это мы просто берем,

1958
01:30:23,800 --> 01:30:25,580
явно аргументы вставляем и живем спокойно.

1959
01:30:25,830 --> 01:30:29,360
Дальше мы

1960
01:30:29,920 --> 01:30:31,685
вставляем определение фолдера.

1961
01:30:32,520 --> 01:30:34,180
Похоже на определение мапа,

1962
01:30:34,280 --> 01:30:37,840
только там тот андроид через кейс у
фолдера, да? Мы вставляем определение

1963
01:30:37,841 --> 01:30:41,937
фолдера, и мы его inlining определяем
фактически. Что такое фолдер?

1964
01:30:42,020 --> 01:30:43,837
Мы делаем кейс к нашему списку.

1965
01:30:43,920 --> 01:30:47,093
Вот наш список. Это весь наш
список, которым мы делаем кейс.

1966
01:30:47,560 --> 01:30:48,393
Если

1967
01:30:50,290 --> 01:30:51,780
const, то мы плюсуем

1968
01:30:51,980 --> 01:30:53,922
x и потом вызываем рекурсивность.

1969
01:30:54,040 --> 01:30:54,873
Рекурсивно.

1970
01:30:56,080 --> 01:30:59,996
Мы просто делали inlining определение
фолдера. Это ничего больше.

1971
01:31:01,780 --> 01:31:02,613
А потом

1972
01:31:03,400 --> 01:31:05,680
мы делаем inlining определение мапа.

1973
01:31:06,940 --> 01:31:09,240
Опять же, мап, мы определяем

1974
01:31:09,465 --> 01:31:11,160
мапу, как мы потормачиваемся по списку L.

1975
01:31:11,161 --> 01:31:12,120


1976
01:31:13,180 --> 01:31:15,100
Пустой список – это пустой список.

1977
01:31:15,101 --> 01:31:20,760
А если const, то смотрите,
мы применяем функцию к y,

1978
01:31:21,990 --> 01:31:23,461
производим бета-редукцию.

1979
01:31:23,720 --> 01:31:26,640
Поставляем y на нашу функцию,
получаем y умножить на 10. Вот, все.

1980
01:31:27,120 --> 01:31:29,238
А потом вызываемся рекурсивно на ys.

1981
01:31:31,020 --> 01:31:31,853
Окей.

1982
01:31:32,340 --> 01:31:33,480
На текущем этапе

1983
01:31:35,120 --> 01:31:37,767
может быть непонятно, что делать дальше.

1984
01:31:38,080 --> 01:31:38,913
У нас есть

1985
01:31:40,540 --> 01:31:41,980
кейс внутри кейса.

1986
01:31:43,660 --> 01:31:48,057
Можно ли с этого избавиться?
Можно ли сделать кейс

1987
01:31:48,140 --> 01:31:50,199
внутри кейса, как-то его
извлечь? Конечно, можно.

1988
01:31:50,840 --> 01:31:52,977
Называется case-of-case transformation.

1989
01:31:53,060 --> 01:31:56,240
Он позволяет внутренний
кейс сделать внешним, а

1990
01:31:56,241 --> 01:31:57,940
внешний кейс делать на
уровень глубже, короче говоря.

1991
01:31:58,000 --> 01:32:02,730
Смотрите, внешний кейс теперь – это
внутренний кейс. Вот он, кейс L и так далее.

1992
01:32:03,320 --> 01:32:04,180
Вот, раз и два.

1993
01:32:04,930 --> 01:32:05,763


1994
01:32:06,940 --> 01:32:07,820


1995
01:32:08,740 --> 01:32:10,270
Это ровно внутренний кейс.

1996
01:32:11,340 --> 01:32:12,173
Извините.

1997
01:32:12,740 --> 01:32:16,244
А теперь, кейс на уровень
глубже – это кейс по результату,

1998
01:32:16,830 --> 01:32:19,960
по пустому списку. И дальше у
нас есть опять же, вот тут написано,

1999
01:32:20,960 --> 01:32:21,880
это ровно

2000
01:32:23,080 --> 01:32:23,680
ой,

2001
01:32:23,930 --> 01:32:26,620
это разные фрагменты.

2002
01:32:27,270 --> 01:32:31,200
Вот это ровно эта вещь, этот
фрагмент кода и этот фрагмент кода.

2003
01:32:31,201 --> 01:32:32,700
Он дублируется.

2004
01:32:34,150 --> 01:32:34,983
Опять же, мы

2005
01:32:35,260 --> 01:32:37,143
внутренний кейс сделали внешним.

2006
01:32:38,200 --> 01:32:40,860
И тут можно заметить одну классную вещь.

2007
01:32:40,861 --> 01:32:43,300
Видите, кейс пустой
список, of и дальше кейсы.

2008
01:32:43,301 --> 01:32:44,134


2009
01:32:47,980 --> 01:32:50,760
Если заглядывать немножко
в операционную семантику, вот

2010
01:32:50,761 --> 01:32:54,396
она обычно определяется для языков
программирования, small step semantics.

2011
01:32:55,970 --> 01:32:57,206
Когда мы делаем кейс,

2012
01:32:58,380 --> 01:33:00,556
и у нас уже паттерн совпадает моментально.

2013
01:33:01,705 --> 01:33:04,700
Вот как тут у нас паттерн совпадает,
кейс пустой список, of пустой список.

2014
01:33:04,780 --> 01:33:06,133
Вот тут паттерн совпал.

2015
01:33:06,340 --> 01:33:11,757
Мы возвращаем ровно тот бренд,
который соответствует пустому списку.

2016
01:33:13,020 --> 01:33:13,853
Это логично.

2017
01:33:15,005 --> 01:33:16,940
Поэтому этот вот кейс

2018
01:33:18,000 --> 01:33:20,849
редуцируется, то есть один
шаг в small step semantics в нолик.

2019
01:33:21,320 --> 01:33:22,320


2020
01:33:24,020 --> 01:33:25,100
Опять же, логично.

2021
01:33:25,520 --> 01:33:27,380
Мы матчим пустой список,

2022
01:33:27,580 --> 01:33:31,617
получаем у нас уже есть кейс
пустому списку, получаем нолик.

2023
01:33:31,700 --> 01:33:32,533
Вот и все.

2024
01:33:34,060 --> 01:33:35,766
Аналогично вот с этим кейсом.

2025
01:33:36,360 --> 01:33:37,800
Мы делаем матчинг по консу.

2026
01:33:37,801 --> 01:33:39,480
Вот конс,

2027
01:33:40,380 --> 01:33:41,540
вот еще один конс,

2028
01:33:41,660 --> 01:33:43,460
наш branch релевантный,

2029
01:33:43,980 --> 01:33:46,098
x у нас просто это y умножить на 10.

2030
01:33:47,280 --> 01:33:50,697
Производим шаг в нашей
операционной семантике,

2031
01:33:50,780 --> 01:33:51,900
получаем вместо этой вещи вот эту вещь.

2032
01:33:54,160 --> 01:33:55,660


2033
01:33:57,010 --> 01:33:57,640
Вместо xs

2034
01:33:57,740 --> 01:33:58,600
мы подставляем

2035
01:33:59,910 --> 01:34:01,360
вот эту вещь map функции ys.

2036
01:34:01,410 --> 01:34:02,460


2037
01:34:03,340 --> 01:34:08,301
А вместо x здесь мы
подставляем y умножить на 10.

2038
01:34:09,820 --> 01:34:11,200
Я все релевантные части выделил.

2039
01:34:11,201 --> 01:34:13,360


2040
01:34:15,940 --> 01:34:17,860
Мы делаем кейс по консу.

2041
01:34:21,470 --> 01:34:24,235
Казалось бы, больше
ничего сделать мы не можем.

2042
01:34:24,590 --> 01:34:25,797
Мы сделали все, что могли.

2043
01:34:25,880 --> 01:34:28,838
Мы проанализировали
наш список внутренний l,

2044
01:34:30,220 --> 01:34:33,840
сделали case of keys transformation,
произвели шаг в семантике.

2045
01:34:34,860 --> 01:34:35,693


2046
01:34:37,920 --> 01:34:38,960
И теперь

2047
01:34:39,840 --> 01:34:41,560
смотрите, видите этот фолдер?

2048
01:34:43,900 --> 01:34:45,620
Такой же в точности этот фолдер.

2049
01:34:45,621 --> 01:34:46,454


2050
01:34:47,560 --> 01:34:48,500
Не правда ли?

2051
01:34:49,760 --> 01:34:51,280
Тут вместо l стоит ys.

2052
01:34:51,281 --> 01:34:52,140


2053
01:34:55,720 --> 01:34:56,760
Использовать этот фолдер это нехорошо.

2054
01:34:56,761 --> 01:35:00,604
Опять же, потому что у нас
все еще есть фолдер и мэп.

2055
01:35:00,700 --> 01:35:03,877
Все еще два траверсала.
Мы хотели сделать один траверсал.

2056
01:35:03,960 --> 01:35:05,902
Но без проблем. У нас
этот фолдер это фанк от ys.

2057
01:35:06,380 --> 01:35:07,500


2058
01:35:07,850 --> 01:35:08,683


2059
01:35:09,540 --> 01:35:12,253
Финальная стадия это поставить
реквизитное определение.

2060
01:35:14,320 --> 01:35:15,203
Все наше правое

2061
01:35:16,130 --> 01:35:18,556
вызов наше правое фолдер и мэп это фанк.

2062
01:35:19,280 --> 01:35:20,113
И вот теперь

2063
01:35:20,550 --> 01:35:21,383
наш фанк,

2064
01:35:21,680 --> 01:35:23,600
это простая функция, ее
можно было на самом деле

2065
01:35:23,601 --> 01:35:26,917
использовать по свойствам,
которые были на предыдущей лекции.

2066
01:35:27,840 --> 01:35:28,673
Тем не менее,

2067
01:35:30,960 --> 01:35:31,793
фанк теперь

2068
01:35:32,380 --> 01:35:34,086
проходится по списку единицы.

2069
01:35:35,110 --> 01:35:37,700
Мы гранино применяем
умноженное 10 к оберегу

2070
01:35:37,900 --> 01:35:39,959
и складываем с реквизитным вызовом.

2071
01:35:41,400 --> 01:35:42,757
Эта часть тоже очень важна.

2072
01:35:42,840 --> 01:35:46,360
Если мы оставим фолдер от мэпа, еще
раз, у нас будет два траверсала списка ys.

2073
01:35:46,361 --> 01:35:47,194


2074
01:35:49,310 --> 01:35:50,487
Что это делает фанк?

2075
01:35:51,700 --> 01:35:53,112
Мануальный дефористейшн.

2076
01:35:53,260 --> 01:35:54,496
Прошу не поджаловать.

2077
01:35:54,580 --> 01:35:56,286
Вопросы по этому слайду есть?

2078
01:36:03,530 --> 01:36:06,772
В нашем приоритете
сделать так, чтобы у нас

2079
01:36:06,855 --> 01:36:07,973
было минимальное
количество проходов по списку.

2080
01:36:11,610 --> 01:36:12,570
Вот так, окей.

2081
01:36:13,550 --> 01:36:14,290
А вот, да, все.

2082
01:36:14,430 --> 01:36:16,470
Это весь пример дефористейшна мануального.

2083
01:36:16,471 --> 01:36:17,304


2084
01:36:18,270 --> 01:36:21,030
Дефористейшн, который я бы сказал

2085
01:36:22,190 --> 01:36:23,747
автоматизированный, на самом деле.

2086
01:36:23,830 --> 01:36:24,663
Типа того.

2087
01:36:27,070 --> 01:36:27,903
Стримфьюжн

2088
01:36:28,830 --> 01:36:30,224
это название

2089
01:36:31,840 --> 01:36:35,950
типа данных, которые
реализуют предотвращение

2090
01:36:37,490 --> 01:36:38,323
формирования

2091
01:36:38,890 --> 01:36:41,147
промежуточных, ну,
давайте скажем, списков.

2092
01:36:41,230 --> 01:36:42,701
На самом деле там списки.

2093
01:36:44,550 --> 01:36:45,383
Вот.

2094
01:36:47,210 --> 01:36:47,770
Стримфьюжн

2095
01:36:47,920 --> 01:36:49,626
работает в следующем образом.

2096
01:36:49,870 --> 01:36:53,550
Начнем мы изучать стримфьюжн
с примитивных попыток.

2097
01:36:54,850 --> 01:36:55,510
Вот как

2098
01:36:55,710 --> 01:36:57,270
и было в

2099
01:36:57,520 --> 01:37:01,115
предыдущих инстанциях, мы
делаем фактически один шаг.

2100
01:37:01,450 --> 01:37:03,039
В фанке мы делаем один шаг.

2101
01:37:03,290 --> 01:37:06,130
Помните, да, фанк, который
был на слайде до этого?

2102
01:37:07,990 --> 01:37:12,660
И там, по идее, был один шаг
вычисления и регустированных вызовов.

2103
01:37:14,710 --> 01:37:17,630
Прикол фьюжна в том, что
тут тоже один шаг фактически.

2104
01:37:17,631 --> 01:37:18,464


2105
01:37:20,270 --> 01:37:21,270
Работает списка.

2106
01:37:22,710 --> 01:37:23,090
Лист

2107
01:37:23,590 --> 01:37:25,414
это тип данных, он принимает а,

2108
01:37:25,650 --> 01:37:29,310
инкапсулирует функцию из
списка а в мебе вот а из списка.

2109
01:37:29,870 --> 01:37:31,590
Эта функция похожа на uncons.

2110
01:37:31,591 --> 01:37:32,424


2111
01:37:34,265 --> 01:37:35,501
uncons, значит, берет

2112
01:37:35,610 --> 01:37:38,710
голову, если есть голова,
то он ставит голову и хвост,

2113
01:37:40,150 --> 01:37:41,327
оборочит это в just,

2114
01:37:41,450 --> 01:37:43,390
иначе это nothing, потому что

2115
01:37:44,700 --> 01:37:46,465
в списке нет головы, очевидно.

2116
01:37:46,630 --> 01:37:49,310
Это похоже на uncons,
то есть cons наоборот.

2117
01:37:53,630 --> 01:37:54,330
При этом,

2118
01:37:54,470 --> 01:37:56,882
более того, это похоже
на, на самом деле, state.

2119
01:37:57,160 --> 01:37:57,910
State transformer, я бы сказал.

2120
01:37:57,970 --> 01:38:00,710
У нас есть стрим токенов,

2121
01:38:02,830 --> 01:38:04,070
мы, типа, берем

2122
01:38:04,220 --> 01:38:06,103
первый токен и оставшиеся токены

2123
01:38:07,140 --> 01:38:08,087
и оборачиваем это в мебе.

2124
01:38:08,170 --> 01:38:09,700
То есть мы можем закончить

2125
01:38:10,480 --> 01:38:12,010
и тогда там будет nothing.

2126
01:38:12,580 --> 01:38:14,087
Вот, похоже на стрим токенов.

2127
01:38:14,170 --> 01:38:15,347
Вот, и это один шаг.

2128
01:38:15,670 --> 01:38:17,671
Просто что мы хотим анализировать.

2129
01:38:18,130 --> 01:38:19,660
Окей, обработался списком.

2130
01:38:19,750 --> 01:38:21,387
Можем ли мы генерировать map1?

2131
01:38:21,470 --> 01:38:23,490
Попробуем, окей. f это
функция из списка в мебе.

2132
01:38:23,491 --> 01:38:25,810
h тоже.

2133
01:38:26,470 --> 01:38:27,303
Значит, h, так, сейчас.

2134
01:38:29,130 --> 01:38:29,690


2135
01:38:29,910 --> 01:38:30,743


2136
01:38:33,630 --> 01:38:34,463
Да, значит,

2137
01:38:34,990 --> 01:38:36,402
h принимаем в список f',

2138
01:38:37,110 --> 01:38:39,010
и здесь мы

2139
01:38:39,310 --> 01:38:40,670
придаем f' функции f,

2140
01:38:40,870 --> 01:38:42,459
на самую функцию f в листе.

2141
01:38:43,710 --> 01:38:44,430
Если у нас nothing.

2142
01:38:44,431 --> 01:38:48,820
just, мы пропихиваем функцию j внутрь
нашего, собственно, первого элемента.

2143
01:38:51,560 --> 01:38:52,610
Это не работает

2144
01:38:53,910 --> 01:38:56,060
вообще ни в каких обстоятельствах.

2145
01:38:57,030 --> 01:38:58,107
Как вы считаете, почему?

2146
01:38:58,190 --> 01:38:59,367
Причины здесь много.

2147
01:39:00,450 --> 01:39:01,745
Мне нужна хотя бы одна причина.

2148
01:39:04,980 --> 01:39:06,920
Почему не работает?

2149
01:39:13,650 --> 01:39:15,200
У нас по типу не сходится.

2150
01:39:15,900 --> 01:39:16,900
Наверное, что-нибудь по типу.

2151
01:39:16,901 --> 01:39:17,734


2152
01:39:20,840 --> 01:39:22,782
Мы просто, как бы, я так понимаю,

2153
01:39:22,940 --> 01:39:26,740
что ожидали s', это лист
типа a, список типа a.

2154
01:39:27,000 --> 01:39:27,833


2155
01:39:28,740 --> 01:39:30,180
А потом мы его

2156
01:39:30,740 --> 01:39:34,980
почему-то запихнули в результат
нашей функции h, хотя она должна быть

2157
01:39:35,750 --> 01:39:36,986
листом типа списка b.

2158
01:39:37,660 --> 01:39:38,620
Правильно, да.

2159
01:39:38,621 --> 01:39:42,940
h принимает в список типа b, а
мы передаем f в список типа b,

2160
01:39:43,330 --> 01:39:44,760
а f ожидает в список типа a.

2161
01:39:44,761 --> 01:39:47,217
Да, это первое замечание,
совершенно справедливо.

2162
01:39:47,300 --> 01:39:48,418
Еще одно замечание.

2163
01:39:48,780 --> 01:39:50,369
Вот тут функция, видите, j.

2164
01:39:52,620 --> 01:39:54,857
Очевидно, что уже на
этом этапе будет проблема.

2165
01:39:54,940 --> 01:39:56,764
Тут type-checking не сработает.

2166
01:39:56,920 --> 01:40:01,000
Если еще дальше идти, вот тут функция j

2167
01:40:01,100 --> 01:40:02,820
принимает аргумент,
тут будет значение типа b,

2168
01:40:03,320 --> 01:40:04,300
но здесь вот

2169
01:40:05,680 --> 01:40:06,577
допустим, у меня тип список a.

2170
01:40:06,660 --> 01:40:08,260
Тут все еще список b.

2171
01:40:08,261 --> 01:40:09,180


2172
01:40:10,340 --> 01:40:12,620
Все еще, короче говоря, проблема

2173
01:40:13,020 --> 01:40:14,491
того, что тут все слишком

2174
01:40:16,360 --> 01:40:16,840
блин,

2175
01:40:16,965 --> 01:40:18,613
сейчас скажу, конечно, фразу

2176
01:40:18,740 --> 01:40:19,820
слишком однотипно.

2177
01:40:20,880 --> 01:40:25,505
У нас везде что-то типа a, и из этого
мапы не сделать никаким образом вообще.

2178
01:40:26,700 --> 01:40:27,533
Он невозможен.

2179
01:40:28,000 --> 01:40:28,833


2180
01:40:30,160 --> 01:40:32,651
Ну, возможно просто сделать тогда здесь

2181
01:40:33,100 --> 01:40:35,117
этоморфизм из a в a, тогда без проблем.

2182
01:40:35,200 --> 01:40:37,024
Но это тогда не мапа, это тогда

2183
01:40:38,460 --> 01:40:39,293
я не знаю,

2184
01:40:39,760 --> 01:40:42,280
номов какой-то, припов какого-то мапа.

2185
01:40:42,960 --> 01:40:44,137
Хочется, чтобы у нас

2186
01:40:44,460 --> 01:40:45,920
мап был ровно таким же,

2187
01:40:46,340 --> 01:40:48,120
ну, каким, какой ожидается.

2188
01:40:49,420 --> 01:40:53,651
Поэтому эта наивная реализация
Stream Fusion не работает,

2189
01:40:54,500 --> 01:40:55,500
которая one-step.

2190
01:40:56,480 --> 01:40:58,700
Но вторая версия работает нормально.

2191
01:40:59,120 --> 01:41:02,490
То есть мы для этого, для этой
фигни можем сделать однозначно

2192
01:41:03,300 --> 01:41:04,680
мап просто потому,

2193
01:41:04,800 --> 01:41:06,506
что вот это уже, вот это уже, это state.

2194
01:41:06,600 --> 01:41:07,433


2195
01:41:08,220 --> 01:41:11,780
У нас вместо состояния это
stream, вместо monad это maybe,

2196
01:41:12,260 --> 01:41:13,660
и b это наше значение,

2197
01:41:13,760 --> 01:41:15,940
которое меняется. У нас
будет тогда функция с b в c,

2198
01:41:16,220 --> 01:41:17,985
лист a в b, ссылка лист a в c.

2199
01:41:18,420 --> 01:41:19,479
Очень элементарно.

2200
01:41:20,410 --> 01:41:23,116
И наш stream имеет
один тип, и он не меняется.

2201
01:41:24,000 --> 01:41:24,833
Окей.

2202
01:41:26,960 --> 01:41:28,019
Есть еще проблема.

2203
01:41:28,900 --> 01:41:30,600
Когда мы обрабатываем список, мы

2204
01:41:32,020 --> 01:41:35,440
хотим иметь информацию
о изначальном списке.

2205
01:41:36,000 --> 01:41:36,833


2206
01:41:38,780 --> 01:41:39,800
Да, мы хотим

2207
01:41:40,680 --> 01:41:41,080
иметь

2208
01:41:41,330 --> 01:41:42,997
в владении то, с чем мы работаем.

2209
01:41:43,080 --> 01:41:44,963
Вот у нас как бы есть один степ.

2210
01:41:46,180 --> 01:41:47,013
Что-то, что

2211
01:41:47,480 --> 01:41:48,833
представляет один степ.

2212
01:41:48,920 --> 01:41:51,400
Но сам список тоже был.

2213
01:41:51,580 --> 01:41:52,698
Давайте мы добавим.

2214
01:41:53,240 --> 01:41:55,247
Добавили список.
Теперь это не new type, а data.

2215
01:41:55,330 --> 01:41:57,397
Отлично. Потому что у нас есть два поля.

2216
01:41:57,480 --> 01:41:58,716
Все. Добавили список.

2217
01:42:01,910 --> 01:42:02,852
Текущая проблема

2218
01:42:03,470 --> 01:42:05,347
реализации в том, она уже нетривиальная.

2219
01:42:05,430 --> 01:42:06,842
Нужно немножко подумать.

2220
01:42:07,870 --> 01:42:11,539
У нас есть функции, работающие
с списком, которые могут изменять

2221
01:42:13,170 --> 01:42:14,003
наши части списка.

2222
01:42:14,550 --> 01:42:17,191
Голову, хвост и так далее.

2223
01:42:19,790 --> 01:42:22,250
Но maybe это слишком строгий тип.

2224
01:42:23,150 --> 01:42:24,770
Слишком ограниченный.

2225
01:42:24,771 --> 01:42:27,410
Что тут говорит maybe?
Maybe говорит о том,

2226
01:42:27,850 --> 01:42:28,990
что у нас есть либо

2227
01:42:29,440 --> 01:42:30,970
как голова, так хвост,

2228
01:42:31,350 --> 01:42:33,250
либо ни голова, ни хвост.

2229
01:42:36,170 --> 01:42:37,190
Вспомним фильтр.

2230
01:42:37,690 --> 01:42:39,230
У нас фильтр может отбрасывать элементы.

2231
01:42:39,231 --> 01:42:40,064


2232
01:42:41,710 --> 01:42:42,770
Голову, да, и

2233
01:42:43,270 --> 01:42:45,212
возвращать хвост. То есть фильтр,

2234
01:42:45,470 --> 01:42:46,830
один степ в фильтре,

2235
01:42:47,150 --> 01:42:49,030
это кейс тот самый, в котором

2236
01:42:49,230 --> 01:42:51,190
есть хвост, но нет головы.

2237
01:42:52,230 --> 01:42:54,930
Maybe это не инкапсулирует
никаким образом. Maybe,

2238
01:42:54,931 --> 01:42:56,910
опять же, это либо
голова и хвост, либо ничего.

2239
01:42:58,170 --> 01:42:58,950
Поэтому нужен другой тип.

2240
01:42:58,951 --> 01:43:00,890
Не maybe.

2241
01:43:01,250 --> 01:43:03,270
Который допускает только хвост,

2242
01:43:03,820 --> 01:43:05,350
но может допускать голову.

2243
01:43:06,550 --> 01:43:07,190
Это первое замечание.

2244
01:43:07,191 --> 01:43:08,839
Второе замечание.

2245
01:43:10,710 --> 01:43:13,984
А нужен ли нам тип нашего

2246
01:43:15,570 --> 01:43:19,090
прям железный тип нашего
стрима, нашего списка?

2247
01:43:20,650 --> 01:43:22,850
То есть нужно ли его здесь передавать?

2248
01:43:23,310 --> 01:43:25,210
Я бы сказал, что нет. Я бы сказал, что

2249
01:43:25,211 --> 01:43:27,647
его можно абстрагировать. Я бы сказал, что

2250
01:43:27,730 --> 01:43:28,710
его можно квантифицировать
с помощью for all.

2251
01:43:28,711 --> 01:43:29,544


2252
01:43:31,170 --> 01:43:33,607
StreamFusion – это вот
этот вот тип данных.

2253
01:43:33,690 --> 01:43:34,687
Он экзистенциальный.

2254
01:43:34,770 --> 01:43:35,807
Тут стоит for all перед стримом.

2255
01:43:35,890 --> 01:43:37,690
Сейчас я объясню немножко.

2256
01:43:37,691 --> 01:43:38,770
Это будет потом в лекции 2010-й.

2257
01:43:39,610 --> 01:43:41,270
Не помню.

2258
01:43:41,990 --> 01:43:43,707
Чуть-чуть объясню про
экзистенциальный тип.

2259
01:43:43,790 --> 01:43:44,623
for all s.

2260
01:43:45,530 --> 01:43:47,178
Называется экзистенциальный.

2261
01:43:47,610 --> 01:43:51,605
Давайте я его скопирую на всякий
случай и создаю в блокноте. Быстренько.

2262
01:43:54,640 --> 01:43:55,570
У стрима тогда,

2263
01:43:55,790 --> 01:43:57,085
если узнать тип стрим,

2264
01:43:57,675 --> 01:43:58,508
именно у

2265
01:43:59,150 --> 01:44:00,690
концентра данных стрим,

2266
01:44:00,895 --> 01:44:03,690
будет иметь тип for all s.

2267
01:44:05,670 --> 01:44:10,530
s, стрелка step, s, а,
стрелка s, стрелка, стрим, а.

2268
01:44:11,290 --> 01:44:13,030
Вот его тип. Ровно
такой тип будет у стрима.

2269
01:44:13,031 --> 01:44:13,864


2270
01:44:18,290 --> 01:44:23,109
Я не знаю, обсуждали ли вы с
Дмитрием Юрьевичем Штукинбергом

2271
01:44:24,120 --> 01:44:25,070
на матлоге

2272
01:44:25,270 --> 01:44:28,530
способ трансформации экзистенциального,

2273
01:44:29,910 --> 01:44:31,070
квантера for all в квантера exists.

2274
01:44:31,071 --> 01:44:31,904


2275
01:44:33,590 --> 01:44:37,521
Но давайте я сейчас вместо этой
стрелки сделаю коррирование и поставлю

2276
01:44:37,910 --> 01:44:39,127
Я объясню, почему я так делаю.

2277
01:44:39,210 --> 01:44:41,050
Сейчас, видно, запятую.

2278
01:44:41,270 --> 01:44:42,506
Я делаю коррирование.

2279
01:44:42,850 --> 01:44:45,077
А теперь смотрите, что делает for all s?

2280
01:44:45,160 --> 01:44:47,102
Он зажирает все, что есть справа.

2281
01:44:50,090 --> 01:44:52,710
Опять же, не знаю, обсуждали ли вы
это с Дмитрием Юрьевичем Штукинбергом.

2282
01:44:52,711 --> 01:44:54,830
Мы сказали, что for all x.

2283
01:44:55,650 --> 01:44:56,610
phi сделка psi

2284
01:44:57,810 --> 01:44:58,650
эквивалентно

2285
01:44:59,450 --> 01:45:00,770
Я поставлю его

2286
01:45:00,870 --> 01:45:03,067
таким вот образом, чтобы было понятно.

2287
01:45:03,150 --> 01:45:03,983
Эквивалентно

2288
01:45:04,710 --> 01:45:05,543
Господи!

2289
01:45:07,010 --> 01:45:08,128
Ой, что происходит? Все в порядке.

2290
01:45:09,230 --> 01:45:10,063


2291
01:45:11,220 --> 01:45:12,550
Эквивалентно exists

2292
01:45:13,200 --> 01:45:14,430
x.phi сделка psi.

2293
01:45:14,680 --> 01:45:18,769
Внимание, сколько теперь
станет вот таким вот образом.

2294
01:45:20,690 --> 01:45:21,470
То есть,

2295
01:45:21,570 --> 01:45:22,403
тут for all

2296
01:45:22,710 --> 01:45:24,230
сожрал всю аппликацию, а тут x.

2297
01:45:24,530 --> 01:45:25,910
phi сожрал только аргумент.

2298
01:45:25,911 --> 01:45:26,744


2299
01:45:27,930 --> 01:45:30,070
А вот теперь я применю этот трюк.

2300
01:45:30,320 --> 01:45:31,791
Причем, более того,

2301
01:45:31,950 --> 01:45:33,847
этот трюк вспоминаемый
интуитивной логикой.

2302
01:45:33,930 --> 01:45:35,107
Этот трюк конструктивный.

2303
01:45:35,190 --> 01:45:37,770
Он оказывается, например,

2304
01:45:37,910 --> 01:45:41,312
в коке, или в вине, или в аксе, или
в баронде, или в индресе, неважно.

2305
01:45:41,395 --> 01:45:43,830
Оказывается, это конструктивный факт

2306
01:45:44,970 --> 01:45:46,206
в интуитивной логике.

2307
01:45:46,340 --> 01:45:48,667
Давайте сделаем теперь
то же самое со стримом.

2308
01:45:48,750 --> 01:45:49,350
Что у нас имеется,

2309
01:45:49,570 --> 01:45:51,410
stream, и тут стоит x.

2310
01:45:51,411 --> 01:45:53,990
phi и s. Скобки теперь
стоят вот таким образом.

2311
01:45:53,991 --> 01:45:54,824
Вот так вот.

2312
01:45:56,540 --> 01:45:57,373
И вот так.

2313
01:45:57,670 --> 01:45:59,810


2314
01:46:02,210 --> 01:46:05,610
То есть, стрим принимает
тип, он принимает тип,

2315
01:46:06,310 --> 01:46:09,430
типовый параметр, и принимает
дальше, собственно говоря, пару

2316
01:46:09,730 --> 01:46:11,230
из степа, из функции,

2317
01:46:11,450 --> 01:46:12,890
и нашего самого стрима.

2318
01:46:14,130 --> 01:46:16,451
Именно поэтому стрим
называется экзистенциальным.

2319
01:46:17,370 --> 01:46:19,018
Потому что вот этот фурорчик

2320
01:46:19,710 --> 01:46:23,028
в настоящей сигнатуре стрима
эквивалентен этому экзистцу.

2321
01:46:23,330 --> 01:46:25,742
Экзистцу, при том, что его нет в Хаскеле,

2322
01:46:26,370 --> 01:46:27,010
потому что он не нужен.

2323
01:46:27,130 --> 01:46:29,072
У нас есть фурор, его достаточно,

2324
01:46:29,630 --> 01:46:31,110
и так понятно,

2325
01:46:31,350 --> 01:46:34,889
когда тип экзистенциальный,
когда он стоит перед конструктором.

2326
01:46:36,370 --> 01:46:37,203
Вот. Экзистцу.

2327
01:46:37,290 --> 01:46:41,323
То есть, стрим де-факто, и это на самом
деле отражается в коре, в тот самый,

2328
01:46:42,360 --> 01:46:44,630
привычный язык первой рекомендации.

2329
01:46:45,030 --> 01:46:49,270
Стрим принимает типовый параметр, и
принимает две функции, из s в степ sa и s.

2330
01:46:50,290 --> 01:46:52,585
Поэтому он называется экзистенциальным.

2331
01:46:53,110 --> 01:46:53,130
Вот.

2332
01:46:53,690 --> 01:46:55,347
Двигаемся теперь снова к стриму.

2333
01:46:55,430 --> 01:46:56,489
А что такое стрим?

2334
01:46:58,450 --> 01:47:01,767
Авторогируемся мы от типа
нашего контейнера, нашего списка.

2335
01:47:01,850 --> 01:47:02,968
Это произвольный s.

2336
01:47:04,250 --> 01:47:05,083
Вот и все.

2337
01:47:05,800 --> 01:47:09,030
Функция из s в степ sa
– это наш вот один степ.

2338
01:47:09,650 --> 01:47:10,930
Вот. В чем прикол?

2339
01:47:11,490 --> 01:47:12,907
Видите, мы в степ добавили skip.

2340
01:47:12,990 --> 01:47:16,413
Вот skip – это тот конструктор,
которого нам не хватало в maybe.

2341
01:47:16,750 --> 01:47:18,550
Если мы уберем skip,

2342
01:47:18,650 --> 01:47:23,430
у нас будет степик maybe от пары,
не эквивалентный, а есть аморфен,

2343
01:47:23,770 --> 01:47:25,790
maybe от пары sa.

2344
01:47:26,090 --> 01:47:31,370
А skip нам нужен, он важен
для фильтрации, например.

2345
01:47:31,830 --> 01:47:35,190
Поэтому у степа есть
тренинг-конструктор done – мы

2346
01:47:35,191 --> 01:47:36,467
завершили наш список,
завершили обработку списка.

2347
01:47:36,550 --> 01:47:39,210
Yield – у нас есть голова, есть хвост.

2348
01:47:39,910 --> 01:47:41,499
И skip – мы пропустили гол.

2349
01:47:42,840 --> 01:47:43,610
Это называется string fusion.

2350
01:47:43,611 --> 01:47:44,444


2351
01:47:46,170 --> 01:47:47,090
Да, вот просто

2352
01:47:47,290 --> 01:47:50,770
экстрактор, то есть это
один степ в нашем стриме,

2353
01:47:51,350 --> 01:47:53,227
один шаг в обработке нашего списка.

2354
01:47:53,310 --> 01:47:58,388
И сам стрим кодируется вот в таких
вот двух полях нашего конструктора.

2355
01:48:00,450 --> 01:48:03,130
Мы можем задать функции,
которые приводят в список а в стрим а.

2356
01:48:04,490 --> 01:48:05,610


2357
01:48:07,790 --> 01:48:08,623
Вот.

2358
01:48:08,840 --> 01:48:09,967
Как этот список работает в стриме?

2359
01:48:10,050 --> 01:48:11,390
Это наша функция xs.

2360
01:48:11,890 --> 01:48:12,630
xs – это список а.

2361
01:48:12,790 --> 01:48:15,202
Значит, стрим принимает типовый параметр,

2362
01:48:15,970 --> 01:48:18,382
вспоминаем сигнатуру стрима
конструктора, и две функции.

2363
01:48:18,670 --> 01:48:19,503


2364
01:48:20,350 --> 01:48:24,090
Раз стрим принимает
типовый параметр, давайте

2365
01:48:24,091 --> 01:48:25,670
мы передадим стриму s равен список от а.

2366
01:48:26,110 --> 01:48:26,943
Вот и все.

2367
01:48:27,800 --> 01:48:30,170
Теперь next имеет ровно эту сигнатуру.

2368
01:48:31,200 --> 01:48:32,170
Функции список а

2369
01:48:32,470 --> 01:48:34,090
в степ список а и а.

2370
01:48:34,410 --> 01:48:35,470
Что делает next?

2371
01:48:35,875 --> 01:48:38,886
Next отпустил список до дал, мы
закончили обработать наш список.

2372
01:48:41,080 --> 01:48:42,450
А от конца мы

2373
01:48:43,470 --> 01:48:45,210
возвращаем наш x и хвост xs.

2374
01:48:46,220 --> 01:48:47,170


2375
01:48:47,750 --> 01:48:50,339
Вообще, в принципе,
это похоже на генератор.

2376
01:48:50,730 --> 01:48:53,329
Он не является генератором
в Python, очевидно.

2377
01:48:55,310 --> 01:48:56,428
Типа похож на него.

2378
01:48:57,030 --> 01:48:57,430
Типа того.

2379
01:48:57,431 --> 01:48:59,610
У нас есть шаг,

2380
01:49:00,570 --> 01:49:01,747
который генерируется

2381
01:49:02,730 --> 01:49:03,910
степ бай степ,

2382
01:49:04,050 --> 01:49:04,883
и это

2383
01:49:05,930 --> 01:49:07,250
все такое прикольное.

2384
01:49:08,070 --> 01:49:08,903


2385
01:49:10,550 --> 01:49:13,547
Мне кажется, генераторы
там хрустово представляют.

2386
01:49:14,300 --> 01:49:15,771
А тут просто стрим фьюжн.

2387
01:49:15,890 --> 01:49:17,470
Не суть, I digress.

2388
01:49:18,270 --> 01:49:21,530
OnStream принимает стрим
а, возвращает список а.

2389
01:49:22,210 --> 01:49:25,090
Здесь, конечно, стрим принимает
типовый параметр и next он полиморфный.

2390
01:49:25,091 --> 01:49:25,924


2391
01:49:28,570 --> 01:49:29,130


2392
01:49:29,450 --> 01:49:30,509
То есть next имеет

2393
01:49:31,550 --> 01:49:32,870
функции из s в степ а.

2394
01:49:33,110 --> 01:49:33,943
Вот наш next.

2395
01:49:36,950 --> 01:49:39,250
Но давайте, собственно говоря,

2396
01:49:39,730 --> 01:49:40,563
просто

2397
01:49:41,490 --> 01:49:44,550
вместо s, опять же, поставим
список а. Ой, что? Сейчас.

2398
01:49:45,310 --> 01:49:46,570
А, нет-нет.

2399
01:49:47,050 --> 01:49:49,190
Sorry, я сейчас подумаю.

2400
01:49:49,675 --> 01:49:50,670
Да, я тупой.

2401
01:49:50,950 --> 01:49:57,390
Нет, next это все еще список господи,
функции из s в степ с а. s0 это все еще s.

2402
01:49:59,050 --> 01:50:00,957
go это наша рекуссивная функция,

2403
01:50:02,125 --> 01:50:03,210
которая будет обрабатывать следующую вещь.

2404
01:50:03,211 --> 01:50:04,290
Face s0.

2405
01:50:05,530 --> 01:50:07,330
Тот самый

2406
01:50:07,480 --> 01:50:09,390
стрим, который мы сохранили,

2407
01:50:09,990 --> 01:50:13,581
потому что, собственно, сама
информация о нашем стриме, она важна.

2408
01:50:14,170 --> 01:50:15,003
Итого,

2409
01:50:15,260 --> 01:50:17,250
go определяется таким образом.

2410
01:50:17,251 --> 01:50:18,110
Мы смотрим на наш шаг, один шаг.

2411
01:50:18,730 --> 01:50:22,550
Если мы закончили обработку,
мы делаем пустой список.

2412
01:50:22,950 --> 01:50:24,480
Без проблем, очень просто.

2413
01:50:24,710 --> 01:50:28,967
Если у нас есть skip, то есть мы
пропускаем какой-то ребят в нашем стриме,

2414
01:50:29,050 --> 01:50:31,109
то мы просто вызываемся
рекуссивно, пишем go.

2415
01:50:31,670 --> 01:50:32,170


2416
01:50:32,450 --> 01:50:37,070
А если у нас есть yield,
мы добавляем явно a

2417
01:50:37,071 --> 01:50:38,660
с помощью конца и
рекуссивно вызываемся go.

2418
01:50:39,310 --> 01:50:40,722
То есть работает go так, как мы ожидаем.

2419
01:50:40,845 --> 01:50:43,524
Мы проезжаемся по всему нашему

2420
01:50:45,370 --> 01:50:46,610
контейнеру, нашему s,

2421
01:50:47,290 --> 01:50:48,950
а s это просто что-то.

2422
01:50:51,590 --> 01:50:53,190
Вот. И строим список,

2423
01:50:53,350 --> 01:50:54,830
исходя из результатов next-ов.

2424
01:50:55,690 --> 01:50:56,523


2425
01:50:57,440 --> 01:50:59,067
Каждый раз, когда мы
вызываем go, вызываем next.

2426
01:50:59,150 --> 01:51:00,990
Next со next-ом.

2427
01:51:01,270 --> 01:51:03,110
Мы строим список обратно.

2428
01:51:03,810 --> 01:51:05,281
Вот. Это и есть unstream.

2429
01:51:07,030 --> 01:51:08,990
Вопросы по этим функциям?
Если у вас есть, то я слушаю.

2430
01:51:08,991 --> 01:51:09,824
Окей.

2431
01:51:16,750 --> 01:51:17,583


2432
01:51:19,520 --> 01:51:22,587
У нас есть очень простые
функции, наподобие мапа и фильтра.

2433
01:51:22,670 --> 01:51:23,503
Начнем с мапа.

2434
01:51:24,870 --> 01:51:25,703
Функция

2435
01:51:26,110 --> 01:51:28,370
next это функция из s в степ s a.

2436
01:51:29,310 --> 01:51:32,273
Функция next-это функция из s в степ s b.

2437
01:51:34,150 --> 01:51:36,590
То есть s не изменяется вообще.

2438
01:51:38,115 --> 01:51:39,350
А next-зависит от next-а.

2439
01:51:39,930 --> 01:51:41,030


2440
01:51:41,190 --> 01:51:42,661
xs имеет тип s, очевидно.

2441
01:51:43,270 --> 01:51:46,750
done, done, skip s, ничего интересного.

2442
01:51:47,360 --> 01:51:48,670
А вот yield мы возвращаем f a.

2443
01:51:49,870 --> 01:51:51,550
То есть мы пропихиваем функцию f

2444
01:51:52,420 --> 01:51:54,290
для аргумента a. И не изменяем этот стрих.

2445
01:51:54,490 --> 01:51:57,960
Ну, потому что, опять же,
это просто отдельный степ.

2446
01:51:59,470 --> 01:52:00,303
Главное

2447
01:52:00,790 --> 01:52:02,430
узнать, что происходит с этим значением.

2448
01:52:02,431 --> 01:52:03,264
В нашем стриме.

2449
01:52:04,200 --> 01:52:05,083
Фильтр.

2450
01:52:05,970 --> 01:52:07,970
Теперь важно.

2451
01:52:08,730 --> 01:52:10,270
У нас есть предикат.

2452
01:52:10,271 --> 01:52:12,150
У нас есть стрим next-s. Next
опять же функция из s в степ s a.

2453
01:52:12,151 --> 01:52:13,390


2454
01:52:15,090 --> 01:52:16,973
Next опять же зависит от next-а.

2455
01:52:17,090 --> 01:52:21,788
Первые два случая абсолютно они, конечно,
информативные, но они тривиальные.

2456
01:52:23,060 --> 01:52:24,355
Еще внимание на yield.

2457
01:52:25,320 --> 01:52:27,293
Допустим, next в нашем стриме вернул a.

2458
01:52:28,360 --> 01:52:29,831
Применяем предикат a к p.

2459
01:52:30,070 --> 01:52:32,250
Если a p от a true,

2460
01:52:32,430 --> 01:52:34,010
то мы сохраняем его.

2461
01:52:34,150 --> 01:52:35,562
Иначе мы пропускаем его.

2462
01:52:35,710 --> 01:52:37,230
Здесь вот skip важен.

2463
01:52:37,890 --> 01:52:42,230
В этом случае мы используем и
ignore нашего элемента. Мы продолжаем

2464
01:52:42,605 --> 01:52:44,606
обрабатывать наш оставшийся стрим.

2465
01:52:46,030 --> 01:52:49,090
И это отражается в том,
что у нас есть skip здесь.

2466
01:52:54,720 --> 01:52:56,690
Я подумал сейчас мгновенно.

2467
01:52:56,770 --> 01:52:59,590
А если у нас есть в том
самом определении, в том

2468
01:53:00,950 --> 01:53:03,364
третьем, если вместо b поставить maybe b?

2469
01:53:07,060 --> 01:53:08,178
Что будет работать? Да, будет.

2470
01:53:09,410 --> 01:53:10,370
Ничего себе.

2471
01:53:10,750 --> 01:53:11,583


2472
01:53:11,950 --> 01:53:16,990
Можно, конечно, поставить maybe b,
тогда это будет почти из аморф в стриме.

2473
01:53:20,960 --> 01:53:22,230
Но тут слишком много всего.

2474
01:53:22,231 --> 01:53:23,650
Maybe от maybe некрасиво.

2475
01:53:23,651 --> 01:53:24,484


2476
01:53:25,350 --> 01:53:26,762
Эти конструкторы в степе говорящие.

2477
01:53:27,970 --> 01:53:28,803


2478
01:53:29,510 --> 01:53:31,393
Лучше использовать просто стрим.

2479
01:53:31,610 --> 01:53:34,967
Короче, рекомендую попробовать folder s,

2480
01:53:35,850 --> 01:53:37,427
который как фолдер, только
тут стримы, а не списки.

2481
01:53:37,510 --> 01:53:41,037
На доступе, если вам
удастся, это будет здорово.

2482
01:53:41,120 --> 01:53:42,944
Релизовать фолдер через стримы,

2483
01:53:43,230 --> 01:53:44,289
на основе стримов.

2484
01:53:47,370 --> 01:53:48,410
А теперь

2485
01:53:49,650 --> 01:53:52,610
map, который на списках,
обычный, это композиция.

2486
01:53:53,250 --> 01:53:54,210


2487
01:53:54,910 --> 01:53:56,830
Map применяет f.

2488
01:53:57,370 --> 01:54:00,470
Stream делаем из списка a, stream a.

2489
01:54:00,570 --> 01:54:02,190
Потом делаем map

2490
01:54:02,490 --> 01:54:04,630
s от f, делаем от stream a, stream b.

2491
01:54:04,690 --> 01:54:06,230
Потом делаем от stream,
получаем обратно список b.

2492
01:54:06,231 --> 01:54:07,064
Это весь map.

2493
01:54:07,990 --> 01:54:08,990


2494
01:54:09,450 --> 01:54:10,283
Все.

2495
01:54:11,030 --> 01:54:12,070
Три функции.

2496
01:54:12,190 --> 01:54:14,630
Unstream, map s, stream.

2497
01:54:14,631 --> 01:54:15,573
Их можно декомпозировать.

2498
01:54:16,210 --> 01:54:17,257
Да, фильтры тоже самое.

2499
01:54:17,340 --> 01:54:19,517
Их можно декомпозировать. Пожалуйста.

2500
01:54:19,830 --> 01:54:22,310
У нас есть map show и filter even.

2501
01:54:23,655 --> 01:54:27,872
Мы по определению мапы и фильтры поставляем
вместо фильтра, фильтра s, стрим,

2502
01:54:28,030 --> 01:54:30,110
вместо map s, стрим, вместо map s.

2503
01:54:31,240 --> 01:54:32,250


2504
01:54:33,550 --> 01:54:34,510
Так.

2505
01:54:35,930 --> 01:54:37,230
Казалось бы, у нас

2506
01:54:37,330 --> 01:54:38,830
есть следующий фрагмент.

2507
01:54:38,930 --> 01:54:39,872
Stream.Unstream.

2508
01:54:42,000 --> 01:54:43,190
Stream.

2509
01:54:43,191 --> 01:54:46,330
Unstream это все еще вызов
функции и, к сожалению,

2510
01:54:47,230 --> 01:54:48,570
занимает память и время.

2511
01:54:48,890 --> 01:54:50,050


2512
01:54:51,870 --> 01:54:52,830
Но!

2513
01:54:53,690 --> 01:54:55,396
Мы можем от этого избавиться.

2514
01:54:56,310 --> 01:54:57,470
С помощью так называемого rewrite rule.

2515
01:54:57,471 --> 01:54:58,304


2516
01:54:59,270 --> 01:55:00,230
Rewrite rule

2517
01:55:01,030 --> 01:55:04,330
это вот такая вот прагма,
которая вставляется в ваш модуль.

2518
01:55:05,250 --> 01:55:06,083
Прагма rules.

2519
01:55:06,370 --> 01:55:07,947
Дальше тут название вашей прагмы.

2520
01:55:08,030 --> 01:55:09,030
И дальше правило.

2521
01:55:09,960 --> 01:55:12,230
Для любого стрима...

2522
01:55:13,710 --> 01:55:14,769
Причем именно так.

2523
01:55:15,160 --> 01:55:18,570
Это фактически что-то подобное...
Ладно, я, конечно, сейчас скажу дичь.

2524
01:55:18,650 --> 01:55:23,390
Но это что-то подобное того, что мы
можем ввести в наших интерактивных сетах.

2525
01:55:23,590 --> 01:55:26,230
Что-то подобное зависимости.

2526
01:55:27,010 --> 01:55:28,390
Это не является зависимыми типами.

2527
01:55:28,391 --> 01:55:30,507
Это просто такой способ задать правила.

2528
01:55:30,590 --> 01:55:31,847
Это не зависимые типы ни в коем случае.

2529
01:55:31,930 --> 01:55:33,830
Это просто синтаксис, очевидно.

2530
01:55:34,890 --> 01:55:36,010
Для любого стрима S Stream.

2531
01:55:36,410 --> 01:55:37,850
Unstream это S.

2532
01:55:41,280 --> 01:55:42,633
Хорошо бы это доказать.

2533
01:55:43,670 --> 01:55:45,259
Для произвольного стрима S.

2534
01:55:46,230 --> 01:55:50,070
Это можно... Мне кажется, можно
делать в тех же самых языках

2535
01:55:50,710 --> 01:55:52,270
наподобие Coq, Lean,
Acta, Rnt, Idris и так далее.

2536
01:55:52,271 --> 01:55:53,104
Причем.

2537
01:55:57,010 --> 01:55:57,490
..

2538
01:55:57,640 --> 01:55:58,830
Наверное, я этим займусь сегодня.

2539
01:55:58,831 --> 01:56:00,390
Это будет уликательно.

2540
01:56:00,530 --> 01:56:04,673
Нужно параллельно доказать, что на самом
деле стрим Unstream это реально стрим,

2541
01:56:04,950 --> 01:56:06,390
из которого мы и начали.

2542
01:56:07,090 --> 01:56:08,687
Насколько это стримерливо,
я пока сказать не могу.

2543
01:56:08,770 --> 01:56:09,712
Честно, не знаю.

2544
01:56:13,310 --> 01:56:14,143
Другой вопрос.

2545
01:56:15,135 --> 01:56:16,527
Попробую сегодня это
сделать на суген, в Coq.

2546
01:56:16,610 --> 01:56:17,443


2547
01:56:19,070 --> 01:56:24,190
И, собственно, теперь у
нас система Unstream, это

2548
01:56:24,191 --> 01:56:26,390
будет Id, фактически, и
тогда map.s.show и filter.s.

2549
01:56:28,290 --> 01:56:29,667
even станут соседними, фактически.

2550
01:56:29,750 --> 01:56:30,583
Типа того.

2551
01:56:31,970 --> 01:56:33,527
Есть package.stream.

2552
01:56:33,610 --> 01:56:36,659
fusion, в котором это все реализовано,
все эти функции, наподобие.

2553
01:56:37,040 --> 01:56:38,770
И, кажется, вместе с rewrite.

2554
01:56:38,771 --> 01:56:39,604
rule тоже.

2555
01:56:41,410 --> 01:56:42,352
ByteString – это стрим.

2556
01:56:44,050 --> 01:56:44,910
fusion для ByteString.

2557
01:56:44,911 --> 01:56:45,744


2558
01:56:47,470 --> 01:56:47,970
Так, это все?

2559
01:56:48,380 --> 01:56:50,307
А, ну, собственно,
representation автоматически.

2560
01:56:50,390 --> 01:56:52,510
Мы переводим наш список в stream.

2561
01:56:52,511 --> 01:56:54,330
fusion.

2562
01:56:56,370 --> 01:56:57,507
Делаем rewrite.

2563
01:56:57,590 --> 01:57:00,289
rules, которые релевантны,
наподобие вот этой вот вещи.

2564
01:57:01,890 --> 01:57:05,230
И это образует differentiation,
то есть избавление от состояния.

2565
01:57:05,280 --> 01:57:07,210
Почему избавляется

2566
01:57:08,530 --> 01:57:09,667
эмоциональное состояние?

2567
01:57:09,750 --> 01:57:11,986
Ну, потому что у нас теперь получается

2568
01:57:12,670 --> 01:57:13,270
прикол в одном степе.

2569
01:57:13,271 --> 01:57:15,450
Один степ

2570
01:57:16,830 --> 01:57:17,663
инкапсулирует один шаг.

2571
01:57:18,510 --> 01:57:19,450


2572
01:57:20,050 --> 01:57:22,848
Вместо двух шагов это
один шаг, короче говоря.

2573
01:57:23,390 --> 01:57:24,450
И, собственно,

2574
01:57:25,770 --> 01:57:28,359
тогда мы просто
включаемся в список один раз

2575
01:57:28,700 --> 01:57:29,410
в рамках стрима, и это хорошо.

2576
01:57:29,510 --> 01:57:30,343


2577
01:57:32,300 --> 01:57:33,595
Автоматизация, то есть

2578
01:57:33,730 --> 01:57:37,970
вся главная информация
заключается в этом next, в этом степе.

2579
01:57:38,150 --> 01:57:38,983


2580
01:57:40,205 --> 01:57:41,690
Это building-блок нашего stream.

2581
01:57:41,790 --> 01:57:43,130
fusion.

2582
01:57:44,530 --> 01:57:45,363
Все.

2583
01:57:46,330 --> 01:57:47,801
Вопросы по stream.

2584
01:57:48,550 --> 01:57:49,410
fusion, по тому,

2585
01:57:50,530 --> 01:57:52,226
как его начать, как он
будет работать, в реализации.

2586
01:57:52,450 --> 01:57:53,283


2587
01:57:57,250 --> 01:58:01,700
У нас все равно, мы хотели же избавиться
наоборот от лишних проходов по списку,

2588
01:58:01,760 --> 01:58:04,371
но у нас все равно уже остались
лишние проходы по списку.

2589
01:58:05,110 --> 01:58:06,657
Какие лишние проходы остались?

2590
01:58:06,740 --> 01:58:10,880
Потому что мы принимаем
композицию map-as-show и filter-as-even.

2591
01:58:11,300 --> 01:58:13,220
Это два прохода по списку будут.

2592
01:58:14,640 --> 01:58:15,699
Значит, по стриму? Да, по стриму.

2593
01:58:16,660 --> 01:58:17,493


2594
01:58:17,740 --> 01:58:22,660
У нас, например, все ленивое,
поэтому мы проанализируем сначала,

2595
01:58:22,920 --> 01:58:25,433
если у нас список,
например, не пустой, голову,

2596
01:58:25,860 --> 01:58:28,660
мгновенно наша голова
поставится в наш map-as-show,

2597
01:58:30,940 --> 01:58:33,560
мгновенно результат
поставится в filter-as-even,

2598
01:58:34,800 --> 01:58:36,460
и потом мгновенно мы просто

2599
01:58:39,620 --> 01:58:40,497
сконструируем стрим.

2600
01:58:40,580 --> 01:58:44,116
Короче говоря, там из-за
ленивости все делается мгновенно.

2601
01:58:44,560 --> 01:58:45,913
На самом деле там стрим

2602
01:58:47,160 --> 01:58:48,000
как бы

2603
01:58:49,270 --> 01:58:53,220
да, он делает для нас стрим из списка,

2604
01:58:53,520 --> 01:58:56,220
а потом просто по ленивости
мы мгновенно поставляем

2605
01:58:56,221 --> 01:58:58,633
голову из гилды или скипа
в наши функции map-as,

2606
01:58:58,880 --> 01:59:00,357
в filter-as, обрабатываем все.

2607
01:59:00,440 --> 01:59:03,500
Получается новый, более сложный степ, да,

2608
01:59:04,040 --> 01:59:06,520
а потом мы делаем онстрим
по этому более сложному степу.

2609
01:59:06,560 --> 01:59:08,077
То есть это просто композиция двух степов.

2610
01:59:08,160 --> 01:59:10,808
Двух next, да?
Помните next, который был там?

2611
01:59:11,010 --> 01:59:12,834
Просто их типа

2612
01:59:13,890 --> 01:59:18,867
не композиция, а как бы это
сказать, суперпозиция, то же самое.

2613
01:59:19,050 --> 01:59:20,109
Нормально сказать.

2614
01:59:20,580 --> 01:59:21,413
В общем, они

2615
01:59:22,540 --> 01:59:23,373
вместе, да?

2616
01:59:24,585 --> 01:59:26,077
Они не прям один,
потом другой, они вместе.

2617
01:59:26,160 --> 01:59:28,040
Это просто

2618
01:59:28,140 --> 01:59:28,973
будет

2619
01:59:30,080 --> 01:59:31,940
наверное наглядно видно,
если попытаться это сделать.

2620
01:59:31,941 --> 01:59:32,774


2621
01:59:33,940 --> 01:59:37,200
О, кстати, тут же есть
сайты которые в начале

2622
01:59:38,070 --> 01:59:39,776
лекции, которые с пузыриками.

2623
01:59:39,900 --> 01:59:41,297
Мне кажется, если произвести,

2624
01:59:41,380 --> 01:59:44,527
надеюсь, что там есть саппорт
экзистенциальных типов, я не проверял.

2625
01:59:44,610 --> 01:59:46,258
Возможно, там можно привести

2626
01:59:46,780 --> 01:59:49,733
мануальную ленивость, как это все
вычисляется, да, ленивое вычисление,

2627
01:59:50,760 --> 01:59:51,593
и посмотреть,

2628
01:59:52,480 --> 01:59:55,098
действительно ли там проход
по списку один раз происходит.

2629
01:59:55,880 --> 01:59:56,998
Но он должен, иначе

2630
01:59:58,020 --> 01:59:59,820
нет в общем этом смысла.

2631
02:00:01,060 --> 02:00:03,620
Ожидается, что там будет
проход по списку один.

2632
02:00:04,800 --> 02:00:05,860
Иначе, опять же, в этом всем нет смысла.

2633
02:00:05,861 --> 02:00:06,694


2634
02:00:08,380 --> 02:00:11,745
Ну и да, я, собственно, как я уже
говорил, я ожидаю, что там просто будет

2635
02:00:12,080 --> 02:00:13,728
композиция этих вот next-ов.

2636
02:00:15,620 --> 02:00:17,973
Более сложный next из двух составляющих.

2637
02:00:18,220 --> 02:00:19,940
А next, что один степ,

2638
02:00:20,320 --> 02:00:24,551
это ровно как было с тем самым
фолдом, пусть да, фолдер от мапа.

2639
02:00:24,660 --> 02:00:26,900
Вот там один степ – это вот y на 10

2640
02:00:27,050 --> 02:00:30,109
плюс регуссивный вызов.
Это как и здесь, фактически.

2641
02:00:31,635 --> 02:00:32,677
Сейчас, что тут происходит?

2642
02:00:32,760 --> 02:00:35,120
Фигурация, потом шоу. В одном степе.

2643
02:00:35,380 --> 02:00:36,213
Что хорошо.

2644
02:00:36,760 --> 02:00:37,593
Так.

2645
02:00:41,980 --> 02:00:42,813
Все.

2646
02:00:43,460 --> 02:00:46,233
Теперь мы поговорим
про мотабельные объекты.

2647
02:00:46,340 --> 02:00:48,200
Мы завершили разговор о

2648
02:00:49,050 --> 02:00:50,497
strictness и performance.

2649
02:00:50,580 --> 02:00:54,403
Немножко, я не знаю, мотабельные
объекты как-то не совсем затрагивают.

2650
02:00:54,860 --> 02:00:56,180
Нет. Затрагивает, очевидно, performance.

2651
02:00:56,220 --> 02:00:58,279
Потому что в некоторых

2652
02:00:58,490 --> 02:01:02,440
мотабельных контейнерах
есть процесс слайсинга.

2653
02:01:02,680 --> 02:01:04,269
Возьмите, я под контейнера,

2654
02:01:04,600 --> 02:01:05,718
и он за 1 делается, что прикольно.

2655
02:01:06,180 --> 02:01:07,030


2656
02:01:08,190 --> 02:01:11,070
Некоторые просто тоже прикольные
контейнеры, которые являются айо-рэями.

2657
02:01:11,071 --> 02:01:13,630
В общем, мотабельные объекты.

2658
02:01:15,420 --> 02:01:16,090
Да, они мотабельные,

2659
02:01:16,230 --> 02:01:17,701
во-первых, что интересно.

2660
02:01:18,255 --> 02:01:19,610
Вот у нас есть айо-рэй.

2661
02:01:22,150 --> 02:01:24,151
Айо-рэй – это, собственно, массив,

2662
02:01:24,550 --> 02:01:25,383
именно массив,

2663
02:01:26,550 --> 02:01:28,080
который живет в айоманаде.

2664
02:01:29,730 --> 02:01:31,790
Не айоманаде, а айотипе данных.

2665
02:01:31,870 --> 02:01:33,223
Короче, он живет в айо.

2666
02:01:33,500 --> 02:01:35,710
Он живет в чем-то, что инкапсулируется

2667
02:01:36,830 --> 02:01:37,663
гипотетически

2668
02:01:38,750 --> 02:01:39,583
нечистые вычисления.

2669
02:01:41,010 --> 02:01:41,843


2670
02:01:42,370 --> 02:01:43,665
Ну да, айо потому что.

2671
02:01:44,330 --> 02:01:46,095
Гипотетически здесь оно важно.

2672
02:01:47,150 --> 02:01:48,590
Мы создаем new array.

2673
02:01:48,870 --> 02:01:49,727
Новый array создаем.

2674
02:01:49,810 --> 02:01:51,530
У нас индексация от 0 до 100.

2675
02:01:53,480 --> 02:01:54,590
И заполняем наш аррэй чиселками 42.

2676
02:01:54,591 --> 02:01:56,239
Вот наш аррэй.

2677
02:01:58,630 --> 02:01:59,930
Считываем в позиции 1

2678
02:02:00,530 --> 02:02:02,930
а, записываем в позицию 2

2679
02:02:03,080 --> 02:02:03,990
а плюс 64

2680
02:02:03,991 --> 02:02:05,950
и считываем позицию.

2681
02:02:07,510 --> 02:02:09,310
Фактор позиции в нашем новом аррэе.

2682
02:02:10,800 --> 02:02:11,950
Умеем получать,

2683
02:02:12,270 --> 02:02:13,947
умеем записывать, умеем создавать массивы.

2684
02:02:14,030 --> 02:02:14,950


2685
02:02:16,090 --> 02:02:17,690
В чем проблема айо-рэя?

2686
02:02:19,120 --> 02:02:23,230
Довольно на поверхности эта
проблема на самом деле возникает, и она

2687
02:02:26,730 --> 02:02:28,083
устранимая, конечно же.

2688
02:02:32,750 --> 02:02:33,583
Есть идей

2689
02:02:33,720 --> 02:02:34,950
проблемы айо-рэя.

2690
02:02:36,010 --> 02:02:39,250
Айо-рэя это максимально легальный
аррэй, и можно пользоваться когда угодно.

2691
02:02:39,251 --> 02:02:40,084


2692
02:02:41,490 --> 02:02:43,020
Инконвиниент, так сказать.

2693
02:02:45,010 --> 02:02:45,843
Нет идей.

2694
02:02:46,570 --> 02:02:47,747
Он довольно прочный.

2695
02:02:47,910 --> 02:02:48,743
Чистота?

2696
02:02:50,210 --> 02:02:51,043
Что, чистота?

2697
02:02:52,050 --> 02:02:53,756
Наоборот, не чистота айо-рэя.

2698
02:02:55,575 --> 02:02:58,867
Казалось бы, да, ведь мы там что-то
обновляем, мы там что-то чистим.

2699
02:02:58,950 --> 02:03:01,009
Проблема в том, что он живет в айо.

2700
02:03:02,055 --> 02:03:03,250
Мы не хотим

2701
02:03:04,570 --> 02:03:06,390
делать вещи в айо, которые

2702
02:03:08,410 --> 02:03:09,890
могут быть не в айо, а такие есть.

2703
02:03:10,430 --> 02:03:11,290


2704
02:03:14,630 --> 02:03:15,463
И, значит,

2705
02:03:17,390 --> 02:03:18,223
просто айо-рэй

2706
02:03:18,420 --> 02:03:19,990
живет строго в айо.

2707
02:03:20,570 --> 02:03:21,610
И, например,

2708
02:03:22,100 --> 02:03:26,530
когда мы делаем какие-то действия над
нашим аррэем, мы не можем выйти из айо

2709
02:03:27,280 --> 02:03:31,940
не использовав тот самый небезопасный
unsafeperform-айо, помните, тот самый из айо.

2710
02:03:32,550 --> 02:03:33,910
Чтобы достать там

2711
02:03:34,530 --> 02:03:36,570
значение чистенькое, которое

2712
02:03:36,870 --> 02:03:38,410
в spoiler можно сделать

2713
02:03:38,510 --> 02:03:40,922
с помощью других типов, которые сейчас мы

2714
02:03:42,750 --> 02:03:43,583
выясним,

2715
02:03:44,730 --> 02:03:45,563
что они есть,

2716
02:03:46,700 --> 02:03:50,112
делается с помощью
unsafeperform-айо, что не очень хорошо.

2717
02:03:51,620 --> 02:03:53,524
Поэтому нужно каким-то образом от айо

2718
02:03:54,130 --> 02:03:54,963
избавиться,

2719
02:03:55,070 --> 02:03:59,430
или хотя бы, спойлер,
это будет почти возможно,

2720
02:03:59,670 --> 02:04:01,200
там мы избавляемся от айо,

2721
02:04:01,720 --> 02:04:03,007
а делаем другую монаду.

2722
02:04:03,090 --> 02:04:04,738
Не сделаем, а ее используем.

2723
02:04:05,570 --> 02:04:06,403
Ну, в общем,

2724
02:04:08,430 --> 02:04:09,263
есть

2725
02:04:09,455 --> 02:04:11,808
такой тип данных, который называется st.

2726
02:04:12,410 --> 02:04:13,330
Здесь написано, что это датам.

2727
02:04:13,530 --> 02:04:14,363


2728
02:04:15,310 --> 02:04:19,254
Я только имитирую, что это stx,
stmonad, проводинг, support и так далее.

2729
02:04:19,410 --> 02:04:21,010
А s здесь.

2730
02:04:23,520 --> 02:04:25,403
Это так называемый state thread.

2731
02:04:26,610 --> 02:04:27,846
Или просто состояние.

2732
02:04:28,590 --> 02:04:31,730
st иногда называют state transformer.

2733
02:04:32,470 --> 02:04:33,303
Внимание!

2734
02:04:33,970 --> 02:04:36,847
Не стоит путать state transformer, который

2735
02:04:36,930 --> 02:04:39,390
stt, помните, stt, который я даже напишу.

2736
02:04:39,890 --> 02:04:41,130
Важно, что я

2737
02:04:41,730 --> 02:04:45,650
перейду к платформе, потому что
я буду писать вещи, связанные с st.

2738
02:04:45,930 --> 02:04:49,030
Мы помним, что у нас есть type state t,

2739
02:04:49,320 --> 02:04:52,248
которое принимает
состояние ma, и от этого стоит t,

2740
02:04:52,485 --> 02:04:55,130
от run стоит t,

2741
02:04:56,250 --> 02:04:59,650
который, что он принимает, он
принимает s, возвращает m от пары.

2742
02:05:02,030 --> 02:05:03,970
Это тоже state transformer.

2743
02:05:05,770 --> 02:05:09,446
s, это наше состояние, тоже может
быть мутабельным, оно может изменяться.

2744
02:05:10,430 --> 02:05:12,783
Только тут мутабельность, она не фразка,

2745
02:05:12,970 --> 02:05:16,410
а функция просто в этом плане мутабельная.

2746
02:05:16,411 --> 02:05:17,244
Вот.

2747
02:05:18,940 --> 02:05:21,764
А st тоже new type, между прочим.

2748
02:05:22,710 --> 02:05:23,807
Тут нету m, во-первых.

2749
02:05:23,890 --> 02:05:26,479
Это тоже состояние.
Называется state thread.

2750
02:05:27,250 --> 02:05:28,083
State thread.

2751
02:05:29,090 --> 02:05:30,090
Да, state thread.

2752
02:05:31,470 --> 02:05:34,190
Это thread, это внутренние вещи, там есть

2753
02:05:36,790 --> 02:05:37,510
целая статья по st.

2754
02:05:37,511 --> 02:05:38,370


2755
02:05:38,570 --> 02:05:42,010
Вот, кажется, сами напомнили
Джонсона, который создал jhc,

2756
02:05:42,210 --> 02:05:44,290
компайлер таскал, и
вроде как сам таскал часть.

2757
02:05:44,440 --> 02:05:45,990


2758
02:05:46,470 --> 02:05:47,950
Я не помню, где забыл.

2759
02:05:49,670 --> 02:05:50,503
В общем,

2760
02:05:51,590 --> 02:05:52,150
помните ли вы,

2761
02:05:52,250 --> 02:05:53,309
как определен IEO?

2762
02:05:54,320 --> 02:06:00,650
Прямо как он определен, помните его
определение? Оно было на слайдах лекции 6.

2763
02:06:03,230 --> 02:06:04,230
Господи, отстань.

2764
02:06:05,360 --> 02:06:06,361
Помните, да, IEO?

2765
02:06:06,910 --> 02:06:07,852
Ну, так условно.

2766
02:06:08,190 --> 02:06:09,650
Помните, что там у IEO

2767
02:06:10,130 --> 02:06:15,004
была такая фигня, как
state hash real world стрелка,

2768
02:06:15,970 --> 02:06:17,559
такой вот страшный тупол из

2769
02:06:18,250 --> 02:06:19,330
state hash

2770
02:06:19,970 --> 02:06:21,150
real world,

2771
02:06:22,570 --> 02:06:24,610
помните такого страхолюденного?

2772
02:06:25,910 --> 02:06:27,067
Внутри определение IEO.

2773
02:06:27,150 --> 02:06:29,130
Это был new type IEO от этой вещи.

2774
02:06:30,080 --> 02:06:31,170


2775
02:06:34,290 --> 02:06:35,526
Ну, вы живы, господа?

2776
02:06:36,310 --> 02:06:37,143
Как вас зовут?

2777
02:06:37,830 --> 02:06:39,630
Мы живы, но, если честно,
я не помню уже такого слова.

2778
02:06:39,631 --> 02:06:40,630


2779
02:06:42,085 --> 02:06:43,530
Да, в общем, IEO

2780
02:06:44,950 --> 02:06:46,593
это реально похоже на state,

2781
02:06:47,550 --> 02:06:48,787
IEO это state фактически.

2782
02:06:48,870 --> 02:06:52,585
Вот у нас есть состояние, оно
подблизовано магическим real world,

2783
02:06:53,210 --> 02:06:55,505
это примитив и это магический примитив.

2784
02:06:55,870 --> 02:06:57,330
При этом он boxed.

2785
02:06:57,650 --> 02:06:59,370
Ой, господи, lifted.

2786
02:06:59,810 --> 02:07:01,427
Сейчас, я забыл, он boxed или lifted.

2787
02:07:01,510 --> 02:07:03,393
Может быть, опа, boxed и lifted.

2788
02:07:03,590 --> 02:07:05,407
Сейчас я потом объясню, что я имею в виду.

2789
02:07:05,490 --> 02:07:08,067
Получается вот такая вот
пара, это похоже на tuple,

2790
02:07:08,295 --> 02:07:09,670
но когда называется unboxed tuple.

2791
02:07:09,750 --> 02:07:10,692
Unboxed, то есть

2792
02:07:12,890 --> 02:07:14,008
tuple представляет,

2793
02:07:14,590 --> 02:07:16,730
что это не pointer heap object.

2794
02:07:18,050 --> 02:07:20,010
Помните, да, у нас, кажется, в Java

2795
02:07:20,590 --> 02:07:21,850
и в Kotlin

2796
02:07:22,680 --> 02:07:26,007
мы можем создавать объекты на
heap s, потому что там u и т.д. и т.п.

2797
02:07:26,090 --> 02:07:26,923
в Scala тоже.

2798
02:07:28,190 --> 02:07:29,896
По умолчанию все типы данных,

2799
02:07:31,050 --> 02:07:34,119
у них все представления, это
pointer в какой-то heap объект.

2800
02:07:34,210 --> 02:07:35,043
Unboxed tuple

2801
02:07:35,510 --> 02:07:37,067
это не pointer в heap объект.

2802
02:07:37,150 --> 02:07:37,983
Это прям

2803
02:07:39,770 --> 02:07:40,730
tuple, они вот

2804
02:07:41,030 --> 02:07:43,290
типа стоят рядышком в регистрах.

2805
02:07:43,470 --> 02:07:44,510
У меня очень много с

2806
02:07:44,511 --> 02:07:47,070
AVM'ом, AVM-бельников это знают
гораздо лучше, чем я, в тысячу раз.

2807
02:07:47,150 --> 02:07:49,090
Но я примерно так.

2808
02:07:49,410 --> 02:07:53,050
Там есть регистры, регистрики
прикольные и т.д. Unboxed tuple

2809
02:07:53,150 --> 02:07:55,647
отличается в том, что у
него представление другое.

2810
02:07:55,730 --> 02:07:57,554
Это не pointer, это прям tuple.

2811
02:07:58,115 --> 02:07:59,210
Это в памяти рядышком,
короче говоря, стоит.

2812
02:07:59,250 --> 02:08:00,083


2813
02:08:01,645 --> 02:08:02,767
Но это все еще tuple, все еще пара.

2814
02:08:02,850 --> 02:08:03,683


2815
02:08:03,950 --> 02:08:08,535
Она обыкновенная сочетание
того, что она себе представляет и т.д.

2816
02:08:09,550 --> 02:08:12,750
Вот. И опять что IO это
вот такая вот функция.

2817
02:08:12,850 --> 02:08:17,030
И стоит hash real world вот в пару
стоит hash real world а. Внимание!

2818
02:08:18,200 --> 02:08:19,033
st это

2819
02:08:20,520 --> 02:08:22,090
ща я сделаю магию,

2820
02:08:22,270 --> 02:08:23,430
скопирую то, что

2821
02:08:24,290 --> 02:08:25,430
я тут выделил,

2822
02:08:25,550 --> 02:08:28,884
и вместо real world поставлю s.

2823
02:08:30,100 --> 02:08:30,933
Что такое st?

2824
02:08:31,650 --> 02:08:33,450
st это как IO,

2825
02:08:34,010 --> 02:08:35,930
типа того, только более общий.

2826
02:08:36,170 --> 02:08:37,890
У нас s это наш state thread,

2827
02:08:38,290 --> 02:08:40,310
это наше недоступное

2828
02:08:40,460 --> 02:08:42,390
не при каких обстоятельствах

2829
02:08:43,290 --> 02:08:44,310
типовый параметр.

2830
02:08:44,700 --> 02:08:48,026
Сейчас мы выясним, почему он
недоступен не при каких обстоятельствах.

2831
02:08:48,290 --> 02:08:51,170
И просто что-то наподобие
такой вот функции.

2832
02:08:52,090 --> 02:08:53,770
С одного состояния в другое, и вот наш а.

2833
02:08:53,771 --> 02:08:54,604


2834
02:08:56,290 --> 02:08:57,123
Вот.

2835
02:08:57,270 --> 02:08:58,103
Это st.

2836
02:08:58,760 --> 02:09:00,350
То есть IO это типа

2837
02:09:00,750 --> 02:09:02,515
the fact and just в случае st.

2838
02:09:03,650 --> 02:09:04,610
Это st от real world.

2839
02:09:04,611 --> 02:09:05,444


2840
02:09:06,270 --> 02:09:08,035
У нас есть функция, извиняюсь,

2841
02:09:08,390 --> 02:09:09,979
прям определенная st to IO,

2842
02:09:10,190 --> 02:09:11,367
которая принимает st

2843
02:09:12,130 --> 02:09:14,030
real world а, возвращает IO а.

2844
02:09:14,031 --> 02:09:16,250
Определенно максимально просто.

2845
02:09:16,251 --> 02:09:17,084


2846
02:09:18,370 --> 02:09:19,690
Достаем функцию, одну

2847
02:09:19,840 --> 02:09:20,610
перекидываем в IO.

2848
02:09:20,611 --> 02:09:21,444
Вот.

2849
02:09:24,010 --> 02:09:24,570
Итак,

2850
02:09:24,690 --> 02:09:25,523
st.

2851
02:09:27,130 --> 02:09:28,250
Она строгая.

2852
02:09:29,590 --> 02:09:30,410
Строгий state transformer.

2853
02:09:30,411 --> 02:09:30,870


2854
02:09:31,210 --> 02:09:33,830
О нём можно назвать state transformer.

2855
02:09:34,170 --> 02:09:36,288
Потому что st это реально как state.

2856
02:09:37,690 --> 02:09:42,042
Просто s это не состояние, а
это что-то параметризованное,

2857
02:09:42,880 --> 02:09:46,134
что-то, что параметризует state
hash самый, называется state thread.

2858
02:09:47,850 --> 02:09:49,709
Вот опять то самое run state,

2859
02:09:50,010 --> 02:09:51,830
у меня там конечно было

2860
02:09:53,310 --> 02:09:54,428
именно run state t,

2861
02:09:54,570 --> 02:09:58,350
она была transformer, а здесь
именно run state без трансформеров.

2862
02:09:58,950 --> 02:10:00,250
Run st, однако,

2863
02:10:01,070 --> 02:10:02,365
вот таким вот образом.

2864
02:10:03,170 --> 02:10:07,073
Первый аргумент это sts a,
где s это призвольный тип.

2865
02:10:09,470 --> 02:10:10,470
Чтобы получить a,

2866
02:10:10,730 --> 02:10:12,495
это читная функция, во-первых.

2867
02:10:13,080 --> 02:10:14,257
Тут нет никакого IO.

2868
02:10:15,430 --> 02:10:16,263
А во-вторых,

2869
02:10:18,130 --> 02:10:20,910
благодаря тому, что стоит
for all s именно в аргументе,

2870
02:10:21,410 --> 02:10:22,763
именно это обеспечивает

2871
02:10:23,740 --> 02:10:27,250
недоступность наших программ
недоступность наших программ

2872
02:10:28,590 --> 02:10:30,547
информацию о том,
какой у нас state thread.

2873
02:10:30,630 --> 02:10:33,850
Какой у нас, короче говоря,
тип, который параметризует st.

2874
02:10:34,860 --> 02:10:37,373
Он недоступен и ни при
каких обстоятельствах.

2875
02:10:39,210 --> 02:10:40,870
Что хорошо, нам не нужна информация об s.

2876
02:10:40,871 --> 02:10:41,390


2877
02:10:41,590 --> 02:10:44,238
Так же как нам нужна
информация о real world.

2878
02:10:44,730 --> 02:10:45,930
Это что-то

2879
02:10:47,530 --> 02:10:48,970
внутрикомпайлерное и

2880
02:10:50,950 --> 02:10:52,598
неналивантное с точки зрения

2881
02:10:53,490 --> 02:10:54,323
нами

2882
02:10:55,610 --> 02:10:57,470
производимых вычислений, например.

2883
02:11:02,070 --> 02:11:02,903
Run st.

2884
02:11:04,650 --> 02:11:05,870
Получаем sts a, возвращаем a.

2885
02:11:05,950 --> 02:11:06,783


2886
02:11:08,110 --> 02:11:08,970
У нас есть IO ref.

2887
02:11:08,971 --> 02:11:11,148
Наверняка он обсуждался в IO.

2888
02:11:11,550 --> 02:11:13,587
В лекции по IO на шестой лекции.

2889
02:11:13,670 --> 02:11:14,930
Естественно, у нас есть stref.

2890
02:11:16,010 --> 02:11:19,590
Референс, который живет
исключительно в st-монаде.

2891
02:11:19,790 --> 02:11:22,230
st это монада, очевидно.

2892
02:11:22,930 --> 02:11:24,342
Потому что st это state.

2893
02:11:24,470 --> 02:11:25,347
Конечно же это монада.

2894
02:11:25,430 --> 02:11:30,090
IO тоже монада, потому что IO
это state в буквальном смысле.

2895
02:11:30,890 --> 02:11:32,830
Но не изоморфно.

2896
02:11:33,250 --> 02:11:33,730
Да, это разные вещи.

2897
02:11:34,090 --> 02:11:34,923
Очевидно.

2898
02:11:37,690 --> 02:11:38,690
stref живет в st.

2899
02:11:38,950 --> 02:11:42,987
Можно создавать новый strf, можно читать,
можно писать, можно модифицировать.

2900
02:11:43,070 --> 02:11:47,491
Все то, что там с IO, только это st, и
это можно экстрактить с помощью run st.

2901
02:11:48,530 --> 02:11:49,363
Вот пример.

2902
02:11:51,090 --> 02:11:54,230
Мы хотим заполучить
собственно нашу сумму, списка.

2903
02:11:55,990 --> 02:11:56,370


2904
02:11:56,470 --> 02:11:57,303


2905
02:11:58,510 --> 02:12:00,310
Ок. Давайте мы

2906
02:12:00,510 --> 02:12:06,114
тогда будем уже жить в st типе данных
в этом блоке, потом сделаем run st.

2907
02:12:06,270 --> 02:12:07,918
В этом блоке нам не доступна

2908
02:12:08,210 --> 02:12:09,446
информация о нашем s.

2909
02:12:10,650 --> 02:12:11,592
Никаким образом.

2910
02:12:13,110 --> 02:12:14,347
Господи, время так летит быстро.

2911
02:12:14,430 --> 02:12:15,347
У меня только не мало остается.

2912
02:12:15,430 --> 02:12:16,263
Кошмар.

2913
02:12:18,490 --> 02:12:19,323
Ок.

2914
02:12:20,660 --> 02:12:22,308
Давайте создадим новый strf.

2915
02:12:22,630 --> 02:12:24,450
В нем будет жить чиселка нолик.

2916
02:12:25,010 --> 02:12:25,843


2917
02:12:26,210 --> 02:12:28,647
Потом мы пройдемся по нашему
списку с помощью for, underscore.

2918
02:12:28,730 --> 02:12:30,907
Это обсуждалось в лекции по foldable.

2919
02:12:31,990 --> 02:12:33,108
И traversable тоже.

2920
02:12:34,010 --> 02:12:34,843
Обе лекции.

2921
02:12:36,030 --> 02:12:39,490
А потом мы просто модифицируем наш n,

2922
02:12:40,370 --> 02:12:41,630
добавляем туда x.

2923
02:12:42,090 --> 02:12:43,443
Потом просто считываем.

2924
02:12:46,010 --> 02:12:48,950
В конечном итоге тут будет тип st, s,

2925
02:12:49,910 --> 02:12:51,028
а. Ой, нет, сейчас.

2926
02:12:51,190 --> 02:12:52,023
Да.

2927
02:12:53,620 --> 02:12:55,562
Потому что плюсик это полиморфная

2928
02:12:55,740 --> 02:12:56,799
функция, очевидно.

2929
02:12:58,360 --> 02:12:59,870
Вот поэтому мы вернем

2930
02:13:00,495 --> 02:13:02,010
значение суммы в нашем списке.

2931
02:13:02,011 --> 02:13:02,894


2932
02:13:06,150 --> 02:13:06,983
Более того,

2933
02:13:07,290 --> 02:13:11,230
тут есть маленькая
проблемка, которая решается

2934
02:13:11,231 --> 02:13:13,530
уже чем-то, что в крайнем
ходе данной лекции.

2935
02:13:14,490 --> 02:13:17,410
Из того, что у нас имеются монады,

2936
02:13:17,650 --> 02:13:21,750
это же пайнт, пайнт 1, функция 2.

2937
02:13:22,110 --> 02:13:23,590
Тут тоже пайнт, это же n, это n-пайнт.

2938
02:13:23,610 --> 02:13:24,510


2939
02:13:25,450 --> 02:13:27,990
Это невозможно параллелизовать,

2940
02:13:28,420 --> 02:13:29,650
потому что это просто гигантская функция.

2941
02:13:29,651 --> 02:13:31,475
Это не параллелизуемо.

2942
02:13:33,430 --> 02:13:38,010
В этом проблеме монад в общем случае,
там невозможно сделать параллелизм.

2943
02:13:39,050 --> 02:13:40,517
Из-за того, что это
одна гигантская функция,

2944
02:13:40,600 --> 02:13:43,027
там ничего невозможно
заспрыгивать практически.

2945
02:13:43,110 --> 02:13:44,130
Я вам явно

2946
02:13:45,680 --> 02:13:48,527
модифицировать какие-то строчки, чтобы
сделать параллелизм. Это невозможно.

2947
02:13:48,610 --> 02:13:49,610
Это у нас монады.

2948
02:13:49,970 --> 02:13:52,027
Все слишком секвенциально, короче говоря.

2949
02:13:52,110 --> 02:13:53,758
Есть инструментарий, который

2950
02:13:55,310 --> 02:13:56,143
должен

2951
02:13:57,210 --> 02:13:58,328
делать параллелизм.

2952
02:13:58,690 --> 02:14:02,427
Он заходит в данную лекцию, но
это есть, это прикольная тоже вещь.

2953
02:14:03,330 --> 02:14:04,801
Называются линейные типы.

2954
02:14:05,150 --> 02:14:06,386
Все, двигаюсь дальше.

2955
02:14:08,840 --> 02:14:10,810
Вопросы по этому слайду.

2956
02:14:16,210 --> 02:14:19,811
S3 тип данных – это очень прикольный тип
данных, похож на IO, опять же, тот самый.

2957
02:14:20,090 --> 02:14:20,450
И он эскейпабл.

2958
02:14:20,910 --> 02:14:23,490


2959
02:14:24,790 --> 02:14:26,379
Именно вот из-за этой вещи.

2960
02:14:31,585 --> 02:14:35,360
Окей, теперь у нас есть целый
класс типов, который называется MRA.

2961
02:14:35,361 --> 02:14:36,360


2962
02:14:37,820 --> 02:14:41,500
Для таких M, где M, внимание,
это монада состояний.

2963
02:14:43,720 --> 02:14:44,553


2964
02:14:48,180 --> 02:14:49,298
То есть это монада,

2965
02:14:49,420 --> 02:14:51,757
которая, наподобие, либо стоит, либо IO.

2966
02:14:51,840 --> 02:14:53,076
В основном это стоит.

2967
02:14:53,840 --> 02:14:55,277
S3, S3, S3, S3, извиняюсь.

2968
02:14:55,360 --> 02:14:57,302
Я, наподобие, S3, не стоит, а S3.

2969
02:14:58,060 --> 02:14:59,720
E – это тип наших элементов.

2970
02:15:00,980 --> 02:15:03,580
A – это тип нашего массива.

2971
02:15:03,581 --> 02:15:04,720


2972
02:15:05,710 --> 02:15:09,820
A имеет вот такой comment,
который я выделил только что.

2973
02:15:11,540 --> 02:15:13,776
Именно type, arrow, type, arrow, type.

2974
02:15:13,980 --> 02:15:15,460
То есть, например,

2975
02:15:15,720 --> 02:15:16,760
в случае starray,

2976
02:15:18,450 --> 02:15:21,464
starray принимает s, s –
это тот самый state thread.

2977
02:15:21,940 --> 02:15:22,773
Вот написано.

2978
02:15:23,220 --> 02:15:25,140
State variable for the st type.

2979
02:15:28,705 --> 02:15:29,540
I – это тип

2980
02:15:30,300 --> 02:15:32,540
индексируемых, короче, тип индекса, да?

2981
02:15:33,340 --> 02:15:35,280
Индекс индексируется из класс-типов AX.

2982
02:15:35,400 --> 02:15:36,753
AX – это подкласс орда.

2983
02:15:38,080 --> 02:15:40,237
AX – это тоже прикольный класс типов.

2984
02:15:40,320 --> 02:15:40,880
Обычно это int.

2985
02:15:41,180 --> 02:15:44,500
Но это могут быть еще и пары из двух AX.

2986
02:15:44,850 --> 02:15:46,439
То есть можно комбинировать

2987
02:15:47,260 --> 02:15:48,937
multi-dimensional индексацию.

2988
02:15:49,020 --> 02:15:49,903
Тоже прикольно.

2989
02:15:52,720 --> 02:15:54,000
Можно еще раз узнать,

2990
02:15:54,120 --> 02:15:56,540
для чего тип M в MRA?

2991
02:15:57,140 --> 02:15:58,720
Да, потому что

2992
02:16:00,500 --> 02:16:02,979
у MRA есть такие функции,

2993
02:16:03,420 --> 02:16:04,656
наподобие, как здесь,

2994
02:16:05,040 --> 02:16:06,688
где M – это та самая монада,

2995
02:16:08,020 --> 02:16:10,500
в которой живут значения наших arrays.

2996
02:16:11,640 --> 02:16:12,660
Эта монада M упоминает s.

2997
02:16:13,420 --> 02:16:14,780


2998
02:16:15,340 --> 02:16:16,740
Где s? А, нигде.

2999
02:16:17,240 --> 02:16:18,073
Ладно, короче.

3000
02:16:18,480 --> 02:16:20,220
Эта монада M – это монада,

3001
02:16:20,320 --> 02:16:24,720
в которой живут все мутабельные
вычисления, и в основном монада st.

3002
02:16:25,820 --> 02:16:26,220
То есть,

3003
02:16:26,620 --> 02:16:27,621
в инстанциях MRA,

3004
02:16:28,160 --> 02:16:29,572
если вклинать на список,

3005
02:16:29,740 --> 02:16:34,120
вместо M будет подправляться
почти во всех случаях, если не в 100%.

3006
02:16:34,640 --> 02:16:35,473
sts.

3007
02:16:36,300 --> 02:16:37,800
То есть M – это sts.

3008
02:16:39,070 --> 02:16:40,220
В очень многих инстанциях.

3009
02:16:40,280 --> 02:16:43,177
Но тут пометризуется M,
потому что вдруг там есть другое.

3010
02:16:43,260 --> 02:16:45,084
А, внимание, вдруг там есть IO.

3011
02:16:46,460 --> 02:16:47,760
Ну, why not?

3012
02:16:48,710 --> 02:16:49,900
IO тоже может быть,

3013
02:16:50,340 --> 02:16:54,377
как оказалось бы, если нам приспичить,
мы можем поставить вместо M IO.

3014
02:16:54,460 --> 02:16:56,197
Это как st, только там real world.

3015
02:16:56,280 --> 02:16:57,640
Вместо s.

3016
02:16:58,480 --> 02:16:59,313
Вот.

3017
02:16:59,490 --> 02:17:01,620
И тогда там не st array, а IO array.

3018
02:17:03,180 --> 02:17:03,620
Так.

3019
02:17:03,880 --> 02:17:07,134
То есть M – это монада, в которой
живут мутабельные результаты.

3020
02:17:08,190 --> 02:17:11,494
Sorry, не мутабельные, а просто
результаты мутабельных вычислений.

3021
02:17:12,760 --> 02:17:13,819
В основном это st.

3022
02:17:15,100 --> 02:17:15,933
Так.

3023
02:17:16,320 --> 02:17:17,360
Да, есть st.

3024
02:17:18,450 --> 02:17:19,877
Пойду назад, чтобы не торопиться.

3025
02:17:19,960 --> 02:17:20,793
st array, да.

3026
02:17:20,920 --> 02:17:22,450
st – это наш saved thread.

3027
02:17:22,620 --> 02:17:25,220
st i – это тип индексов и тип элементов.

3028
02:17:25,960 --> 02:17:27,640
st u array –

3029
02:17:27,641 --> 02:17:28,936
это мутабельный array,

3030
02:17:29,080 --> 02:17:31,840
как st array, только
для unboxed элементов.

3031
02:17:32,320 --> 02:17:33,960
Значит, boxed – типы данных.

3032
02:17:34,620 --> 02:17:35,453


3033
02:17:35,620 --> 02:17:39,831
Это типы данных, представление
которых – это pointer в heap-объект.

3034
02:17:40,100 --> 02:17:40,933
Ну, это boxed.

3035
02:17:43,580 --> 02:17:45,000
99.99998753 –

3036
02:17:45,100 --> 02:17:46,177
это рандомное число.

3037
02:17:46,260 --> 02:17:49,520
Процентов всех типов данных в
Haskell – это boxed типы данных.

3038
02:17:51,130 --> 02:17:52,637
Они в основном используются.

3039
02:17:52,720 --> 02:17:53,940
Boxed типы данных.

3040
02:17:54,280 --> 02:17:55,516
Но unboxed тоже есть.

3041
02:17:56,140 --> 02:17:57,897
Unboxed – это не pointer в heap-объект.

3042
02:17:57,980 --> 02:18:00,240
Это прям что-то в регистрике.

3043
02:18:01,920 --> 02:18:03,120
Int –

3044
02:18:03,121 --> 02:18:03,954
это

3045
02:18:05,300 --> 02:18:05,900
pointer,

3046
02:18:06,080 --> 02:18:07,669
к сожалению, в heap-объект.

3047
02:18:07,840 --> 02:18:09,740
Но int энкапсулирует
значение типа int hash.

3048
02:18:09,741 --> 02:18:10,680


3049
02:18:10,820 --> 02:18:13,060
И имеет представление,

3050
02:18:13,500 --> 02:18:14,677
вот в регистрике это

3051
02:18:16,400 --> 02:18:17,233
int,

3052
02:18:18,460 --> 02:18:19,620
64-битный, в регистрике.

3053
02:18:19,800 --> 02:18:20,633
Unboxed type.

3054
02:18:22,440 --> 02:18:23,320


3055
02:18:25,520 --> 02:18:26,120
Вот в чем отличие.

3056
02:18:26,240 --> 02:18:27,217
Unboxed – не boxed.

3057
02:18:27,300 --> 02:18:29,638
Pointer в heap-объект
или что-то в регистрике.

3058
02:18:30,760 --> 02:18:33,720
И не только, там еще есть
tuples, помните, unboxed tuples.

3059
02:18:34,705 --> 02:18:36,882
Вот это тоже unboxed.

3060
02:18:37,340 --> 02:18:38,240
stu.array

3061
02:18:39,740 --> 02:18:42,240
может инстанцировать m.array, но

3062
02:18:42,640 --> 02:18:43,880
только для очень

3063
02:18:44,080 --> 02:18:46,022
ограниченного количества типов e.

3064
02:18:46,940 --> 02:18:49,920
Если взглянуть на
инстанцию m.array, для stu.

3065
02:18:50,170 --> 02:18:54,533
array e может быть либо int, либо
word, либо char, либо double, либо float,

3066
02:18:54,720 --> 02:18:57,297
либо pointer, либо
функциональный pointer, fun pointer,

3067
02:18:58,680 --> 02:19:01,092
либо stable pointer, либо там что-то еще.

3068
02:19:01,240 --> 02:19:02,946
Очень ограниченное количество

3069
02:19:04,420 --> 02:19:05,840
элементов stu.array

3070
02:19:05,990 --> 02:19:07,696
может инстанцировать m.array.

3071
02:19:08,740 --> 02:19:10,060
Только те, у которых
есть unboxed representation.

3072
02:19:10,061 --> 02:19:10,944


3073
02:19:11,800 --> 02:19:12,683
Может быть, да? Int, word и т.

3074
02:19:13,020 --> 02:19:15,700
д., double, float.

3075
02:19:16,820 --> 02:19:17,653
А stu.

3076
02:19:18,060 --> 02:19:20,237
array геопроизводит
каких угодно элементов.

3077
02:19:21,220 --> 02:19:22,053
Поэтому

3078
02:19:22,620 --> 02:19:23,980
желательно использовать stu.

3079
02:19:23,981 --> 02:19:26,474
array если вам хочется работать с нитами,

3080
02:19:27,120 --> 02:19:31,597
там нету pointer в heap-объекте,
там просто регистр и т.

3081
02:19:31,680 --> 02:19:32,513
д.

3082
02:19:32,880 --> 02:19:38,094
В общем, функции, те самые re-array,
которые записываются в нашей array,

3083
02:19:39,820 --> 02:19:42,300
записывают как в
writer, считывают, да, вот

3084
02:19:42,360 --> 02:19:44,008
и я, пожалуйста, дашь
этот элемент тот самый.

3085
02:19:44,200 --> 02:19:46,100
new array, вот он создает наш a,

3086
02:19:46,500 --> 02:19:48,120
вот a тот самый имеет kind,

3087
02:19:49,240 --> 02:19:51,064
type, arrow, type, arrow, type.

3088
02:19:51,880 --> 02:19:52,320
Вот, ровное.

3089
02:19:52,400 --> 02:19:53,620
То есть stu.

3090
02:19:54,880 --> 02:19:56,645
array может быть поставлен вместо a.

3091
02:19:57,840 --> 02:19:59,076
Вот так, вот так вот.

3092
02:19:59,360 --> 02:20:00,772
Это все, да? А, да, все.

3093
02:20:01,500 --> 02:20:02,740
Вопросы в этой части.

3094
02:20:02,860 --> 02:20:07,220
Тут, да, довольно сложная
машинерия есть под капотом,

3095
02:20:07,400 --> 02:20:08,930
если глянуть на, опять же,

3096
02:20:09,340 --> 02:20:13,140
там очень много используется примитивных
функций с хэшами на конце года.

3097
02:20:13,240 --> 02:20:14,073


3098
02:20:15,680 --> 02:20:17,680
Довольно сложно, на первый взгляд.

3099
02:20:20,080 --> 02:20:20,913
Еще раз.

3100
02:20:21,100 --> 02:20:25,070
m – это монад, в котором живут
все вычисления, в основном это st.

3101
02:20:25,280 --> 02:20:27,060
s – это тот самый sv для st,

3102
02:20:27,400 --> 02:20:28,753
тот самый state thread.

3103
02:20:28,900 --> 02:20:31,489
i – это тип индексов,
e – это тип элементов.

3104
02:20:32,060 --> 02:20:33,560
a, вот здесь a, это тип array.

3105
02:20:33,561 --> 02:20:34,580
В случае stu.

3106
02:20:35,080 --> 02:20:38,793
array, это

3107
02:20:39,650 --> 02:20:41,660
stu.array принимающий s.

3108
02:20:45,180 --> 02:20:46,122
Еще пару секунд.

3109
02:20:46,400 --> 02:20:47,040
Держу слайд.

3110
02:20:47,300 --> 02:20:48,800
А, можно вопрос?

3111
02:20:49,180 --> 02:20:51,680
У нас функции newArray,

3112
02:20:51,780 --> 02:20:55,578
readArray, writeArray, у нас получается
newArray создает просто новый массив?

3113
02:20:55,900 --> 02:20:57,640
Или что вот здесь он делает?

3114
02:20:59,140 --> 02:20:59,973
Да.

3115
02:21:00,880 --> 02:21:01,400
Хороший вопрос.

3116
02:21:01,401 --> 02:21:05,717
NewArray принимает пару из двух
индексов, это lower bound и upper bound.

3117
02:21:05,800 --> 02:21:07,212
Внимание, что интересно,

3118
02:21:09,140 --> 02:21:11,072
индексы могут быть какими угодно.

3119
02:21:12,380 --> 02:21:12,940
Мы привыкли от 0 до n-1.

3120
02:21:12,941 --> 02:21:14,560


3121
02:21:15,380 --> 02:21:17,260
Ну, до n, не включая n.

3122
02:21:17,440 --> 02:21:19,617
Может быть, хоть от минус 100 до 100.

3123
02:21:20,220 --> 02:21:23,200
Поэтому есть маленькая
такая свобода в newArray.

3124
02:21:23,760 --> 02:21:25,477
Эти lower, upper bound – какие угодно.

3125
02:21:25,560 --> 02:21:27,560
Главное, чтобы они сницировали ax.

3126
02:21:27,720 --> 02:21:29,577
Значения могут быть какими угодно.

3127
02:21:29,660 --> 02:21:32,476
Хоть от числа грэма до числа грэма плюс 1.

3128
02:21:33,840 --> 02:21:34,800
Как хотите.

3129
02:21:35,920 --> 02:21:39,040
И заполняются все эти индексы e.

3130
02:21:40,320 --> 02:21:41,262
Одним элементом.

3131
02:21:43,200 --> 02:21:46,193
ReadArray подсчитывает
по позиции e, writeArray

3132
02:21:47,720 --> 02:21:49,020
запихивает в позицию i элемент e.

3133
02:21:49,021 --> 02:21:50,420


3134
02:21:52,260 --> 02:21:53,202
Unit, потому что тут прикол.

3135
02:21:53,415 --> 02:21:55,000


3136
02:21:55,220 --> 02:21:56,053
Можно вернуть

3137
02:21:57,680 --> 02:21:59,040
старый элемент, то есть m, e.

3138
02:21:59,900 --> 02:22:00,733


3139
02:22:01,140 --> 02:22:02,260
Но тут

3140
02:22:05,000 --> 02:22:07,700
ничего, видимо, продуктивного не
возвращает в writeArray, кроме unit.

3141
02:22:07,780 --> 02:22:08,613


3142
02:22:12,160 --> 02:22:13,219
NewArray заполняет

3143
02:22:13,500 --> 02:22:16,060
все индексы от этого i до этого i

3144
02:22:16,210 --> 02:22:17,328
элементами этого e.

3145
02:22:18,780 --> 02:22:21,500
Да, возвращается действительно array в m,

3146
02:22:23,080 --> 02:22:25,240
в который производится
все вычисления и только там.

3147
02:22:25,890 --> 02:22:26,723
Next.

3148
02:22:33,150 --> 02:22:33,983
Векторы.

3149
02:22:34,710 --> 02:22:35,543


3150
02:22:36,590 --> 02:22:38,002
Векторы похожи на array.

3151
02:22:38,230 --> 02:22:40,707
На самом деле, вектор
определен, как array.

3152
02:22:40,790 --> 02:22:43,587
Immutable vector это просто
вектор, который понимает только a.

3153
02:22:43,670 --> 02:22:46,387
Mutable, поскольку это
mutable, нам выгнан стоит thread.

3154
02:22:46,470 --> 02:22:50,070
То есть m-вектор имеет
s в качестве параметра

3155
02:22:50,690 --> 02:22:52,230
и, конечно же,

3156
02:22:53,490 --> 02:22:56,029
вот это там под капотом
используют очевидное st.

3157
02:22:58,190 --> 02:22:58,830
Наконец-то!

3158
02:22:58,831 --> 02:23:01,770
У нас индексация в векторах O, A, T.

3159
02:23:02,510 --> 02:23:05,530
Наконец-то! Мы использовали
листы на протяжении 20000 лет.

3160
02:23:05,531 --> 02:23:08,890
Теперь мы можем использовать
векторы с индексацией

3161
02:23:09,040 --> 02:23:12,090
в constant time complexity.

3162
02:23:12,790 --> 02:23:13,623
Finally.

3163
02:23:14,095 --> 02:23:16,087
Еще у векторов константный slicing.

3164
02:23:16,170 --> 02:23:17,003
Тоже классно.

3165
02:23:18,360 --> 02:23:19,831
То есть взять под вектор.

3166
02:23:19,970 --> 02:23:20,807
Он константный.

3167
02:23:20,890 --> 02:23:24,170
Это из-за определения array.

3168
02:23:24,171 --> 02:23:25,004


3169
02:23:25,490 --> 02:23:28,690
Тут написаны страшные вещи.

3170
02:23:29,630 --> 02:23:31,330
Прим монот какой-то страшный.

3171
02:23:31,950 --> 02:23:32,890
m-вектор еще

3172
02:23:34,080 --> 02:23:35,270
есть класс типов.

3173
02:23:35,990 --> 02:23:36,873
v это тот самый

3174
02:23:37,710 --> 02:23:38,850
мутабельный вектор.

3175
02:23:39,810 --> 02:23:40,643
Тип.

3176
02:23:42,150 --> 02:23:42,990
Прим монот.

3177
02:23:44,170 --> 02:23:45,003
Сейчас я задумался.

3178
02:23:45,510 --> 02:23:47,470
Это, короче, класс.

3179
02:23:48,270 --> 02:23:49,230
Да, класс.

3180
02:23:49,350 --> 02:23:50,790
Прим монот m.

3181
02:23:51,810 --> 02:23:53,575
Поэтому m это монот, очевидно.

3182
02:23:54,510 --> 02:23:57,287
И у него есть примитив,
который называется примитив.

3183
02:23:58,630 --> 02:23:59,463
Да.

3184
02:23:59,710 --> 02:24:00,210
То есть

3185
02:24:00,550 --> 02:24:01,470
не примитив, а функция.

3186
02:24:03,450 --> 02:24:04,283


3187
02:24:05,430 --> 02:24:06,550
Тип примитива неизвестен, к сожалению.

3188
02:24:06,610 --> 02:24:07,443


3189
02:24:08,660 --> 02:24:10,308
Он не прописан в библиотеке.

3190
02:24:11,230 --> 02:24:12,063
Бывает.

3191
02:24:13,670 --> 02:24:14,503
И

3192
02:24:14,865 --> 02:24:16,395
прим монот, короче говоря,

3193
02:24:17,630 --> 02:24:18,463
это

3194
02:24:18,710 --> 02:24:19,950
фактически иерархия

3195
02:24:20,450 --> 02:24:22,290
положенности трансформеров.

3196
02:24:25,130 --> 02:24:27,210
То есть есть прим монот например, t, e, m.

3197
02:24:30,070 --> 02:24:31,650


3198
02:24:32,250 --> 02:24:33,427
Если есть прим монот

3199
02:24:34,510 --> 02:24:36,010
m. То есть есть instance.

3200
02:24:36,011 --> 02:24:36,844


3201
02:24:37,640 --> 02:24:41,990
Есть instance аналогичный с
чукок-чукок, с господи writer t.

3202
02:24:42,640 --> 02:24:43,630
Тут стоит w.

3203
02:24:43,970 --> 02:24:44,870


3204
02:24:45,470 --> 02:24:46,570
С reader, reader t.

3205
02:24:47,190 --> 02:24:48,170


3206
02:24:48,550 --> 02:24:50,021
Тут стоит e, environment.

3207
02:24:50,630 --> 02:24:54,870
Такой вопрос. А какой прим
монот base case? Какая там база?

3208
02:24:55,940 --> 02:24:58,447
Сможете ли вы попытаться угадать, какая
там база у прим монот? Просто угадать.

3209
02:24:58,530 --> 02:24:59,710


3210
02:25:03,190 --> 02:25:04,750
Это неочевидно вообще,

3211
02:25:05,550 --> 02:25:09,070
но поскольку мы работаем
с мутабельными векторами,

3212
02:25:09,350 --> 02:25:11,670
какая база может быть у прим стоит

3213
02:25:13,970 --> 02:25:15,730
у instance у прим стоит

3214
02:25:16,030 --> 02:25:17,530
ой, господи, прим монота.

3215
02:25:17,570 --> 02:25:18,403


3216
02:25:26,680 --> 02:25:29,080
База – это прим монот iom,

3217
02:25:30,880 --> 02:25:31,713
а также прим монот sts.

3218
02:25:32,120 --> 02:25:34,240


3219
02:25:35,140 --> 02:25:36,729
То есть база у прим монота,

3220
02:25:37,540 --> 02:25:38,540
базовый instance,

3221
02:25:38,740 --> 02:25:42,457
это instance для тех типов данных, у
которых есть мутабельные вычисления или iom.

3222
02:25:42,540 --> 02:25:43,460


3223
02:25:44,120 --> 02:25:46,220
Ну, простейшие мутабельные
вычисления, то есть более сложные.

3224
02:25:46,440 --> 02:25:48,146
Это потом, это другая лекция.

3225
02:25:49,280 --> 02:25:50,113
Это base case.

3226
02:25:53,030 --> 02:25:55,780
То есть мы можем
строить nested transformers,

3227
02:25:55,920 --> 02:25:57,620
мы знаем, как строить

3228
02:25:57,870 --> 02:25:59,047
ложные трансформеры.

3229
02:25:59,260 --> 02:26:00,420
Главное, чтобы там в
base case был st или iom.

3230
02:26:00,421 --> 02:26:01,500


3231
02:26:04,880 --> 02:26:06,300
Есть функция retry,

3232
02:26:06,590 --> 02:26:10,040
это то же самое grow, freeze, внимание,

3233
02:26:10,041 --> 02:26:11,453
принимает мутабельный
вектор, то есть обычный.

3234
02:26:15,380 --> 02:26:16,900
А есть ли, короче говоря,

3235
02:26:17,920 --> 02:26:19,450
функция, которая принимает

3236
02:26:24,700 --> 02:26:27,368
и мутабельный вектор, но
возвращает в мутабельный? Есть, да.

3237
02:26:29,520 --> 02:26:30,360


3238
02:26:31,480 --> 02:26:33,377
То есть freeze – это заморочить, да?

3239
02:26:33,460 --> 02:26:35,320
Что обратно, freeze – это saw.

3240
02:26:36,200 --> 02:26:38,920
То есть tighter, заморочить
for и определённый в модуле ta.

3241
02:26:38,921 --> 02:26:41,780
vector.mutable.

3242
02:26:44,660 --> 02:26:46,420
Потом из этих модулей.

3243
02:26:47,060 --> 02:26:50,907
И да, saw делает из и
мутабельного в мутабельный.

3244
02:26:51,950 --> 02:26:54,751
То есть можно делать из
одного и другого ещё без проблем.

3245
02:26:56,980 --> 02:26:58,600
Мы знаем, что у нас есть insertion sort.

3246
02:26:58,601 --> 02:26:59,484


3247
02:27:00,320 --> 02:27:03,380
Определённо максимально просто
мы вставляем x, такой готовый.

3248
02:27:04,180 --> 02:27:04,800


3249
02:27:04,980 --> 02:27:06,520
Он меньше всех ловеров.

3250
02:27:07,840 --> 02:27:08,897
Может быть, больше
правильных всех рейтеров.

3251
02:27:08,980 --> 02:27:09,820
Ой, стоп.

3252
02:27:10,580 --> 02:27:11,780


3253
02:27:12,640 --> 02:27:14,517
Наоборот, он больше всех ловеров.

3254
02:27:14,600 --> 02:27:16,517
Может быть, меньше
правильных всех рейтеров.

3255
02:27:16,600 --> 02:27:17,542
Да, другое дело.

3256
02:27:18,280 --> 02:27:19,113
Вставляем его.

3257
02:27:19,380 --> 02:27:20,357
Дебилитный insertion sort.

3258
02:27:20,440 --> 02:27:22,146
Ничего интересного здесь нет.

3259
02:27:24,165 --> 02:27:25,957
И он на списке, что как бы не очень.

3260
02:27:26,040 --> 02:27:30,100
Time complexity у insertion sort,
конечно же, это, как минимум, квадрат.

3261
02:27:30,540 --> 02:27:31,477
Ну, как минимум.

3262
02:27:31,560 --> 02:27:33,740
Здесь, наверное, даже побольше

3263
02:27:33,890 --> 02:27:35,126
просто в том, что это

3264
02:27:36,980 --> 02:27:38,216
копирование объектов,

3265
02:27:38,480 --> 02:27:40,422
перекидывание концев и так далее.

3266
02:27:40,560 --> 02:27:40,840
Неважно.

3267
02:27:40,940 --> 02:27:43,220
В общем, квадрат, причём, плохой такой.

3268
02:27:43,840 --> 02:27:44,673


3269
02:27:46,400 --> 02:27:48,060
Да, можем сделать
insertion sort на основе stu.

3270
02:27:48,061 --> 02:27:49,944
array без проблем.

3271
02:27:50,200 --> 02:27:53,020
Ну, вот смотрите, у нас
есть тип элементов int.

3272
02:27:53,520 --> 02:27:54,520
И индексация int.

3273
02:27:55,740 --> 02:27:57,140
У нас есть instance

3274
02:27:58,360 --> 02:27:59,780
stu.array для int,

3275
02:28:00,960 --> 02:28:02,420
у которого элементы это int.

3276
02:28:02,421 --> 02:28:07,497
Потому что int, это у него
есть unboxed representation.

3277
02:28:07,580 --> 02:28:09,522
Это то, что находится внутри int.

3278
02:28:09,960 --> 02:28:11,820
Сделаем то же самое, мы делаем новый list.

3279
02:28:11,821 --> 02:28:15,320
array от нуля до, ну, от нуля, потому что
мы привыкли к нулю стартовать, от list.

3280
02:28:15,400 --> 02:28:16,342
array-1.

3281
02:28:16,760 --> 02:28:19,300
Я только что понял, что list.

3282
02:28:19,301 --> 02:28:23,441
array-1 это ровно включительно
последний индекс. Он включительно.

3283
02:28:24,660 --> 02:28:25,493
Вот.

3284
02:28:26,780 --> 02:28:27,613
Вот всё.

3285
02:28:27,940 --> 02:28:28,773
И получается,

3286
02:28:28,920 --> 02:28:31,500
сейчас, да, делаем из списка

3287
02:28:31,750 --> 02:28:33,120
int.array. int.

3288
02:28:33,121 --> 02:28:34,260
array это stu.array.

3289
02:28:38,130 --> 02:28:41,843
Дальше ещё, собственно говоря, мы
приезжаемся по списку 1, по списку 2,

3290
02:28:42,030 --> 02:28:44,590
у нас есть два индекса,
меняем местами, ой,

3291
02:28:45,970 --> 02:28:48,206
сейчас, да, правильно, меняем местами.

3292
02:28:48,430 --> 02:28:49,610
Мы запомнили курс, запомнили next.

3293
02:28:49,650 --> 02:28:50,533


3294
02:28:51,490 --> 02:28:54,196
Если курс больше, чем
next, мы меняем местами.

3295
02:28:54,410 --> 02:28:55,243
Вот всё.

3296
02:28:56,110 --> 02:28:59,059
А потом это getElements достаёт
нам, как называется, список.

3297
02:29:01,190 --> 02:29:02,023


3298
02:29:02,450 --> 02:29:03,830
И он начинает пребывать в monodest.

3299
02:29:03,955 --> 02:29:05,210


3300
02:29:06,090 --> 02:29:07,914
Поэтому runstyle нужно указать.

3301
02:29:10,160 --> 02:29:12,027
Можно через вектор
даже делать, без проблем.

3302
02:29:12,110 --> 02:29:13,207
Вот, тот самый thaw.

3303
02:29:13,290 --> 02:29:14,190
Мы делаем

3304
02:29:15,410 --> 02:29:16,646
и мутабельный вектор,

3305
02:29:17,495 --> 02:29:20,378
а потом делаем мутабельный
вектор с помощью thaw.

3306
02:29:20,770 --> 02:29:22,712
То же самое алгоритм, совершенно.

3307
02:29:22,870 --> 02:29:23,810
Тут ещё jscan.

3308
02:29:23,890 --> 02:29:25,177
Что такое jscan? Я забыл.

3309
02:29:25,260 --> 02:29:26,966
Функция, да? Да, это функция.

3310
02:29:28,750 --> 02:29:29,170
Вот.

3311
02:29:29,245 --> 02:29:31,245
Потом мы делаем freeze, потому что

3312
02:29:31,460 --> 02:29:34,590
мы можем получить список
из мутабельного вектора.

3313
02:29:36,010 --> 02:29:36,770
Вот он, мутабельный.

3314
02:29:36,830 --> 02:29:39,948
И потом делаем return.
Опять это всё патронно ставим.

3315
02:29:42,150 --> 02:29:43,209
Это финалочка, да?

3316
02:29:44,090 --> 02:29:44,910
Да, это финалочка.

3317
02:29:44,990 --> 02:29:46,520
Мы сейчас завершим лекцию.

3318
02:29:47,190 --> 02:29:48,485
Запись идёт? Да, идёт.

3319
02:29:49,450 --> 02:29:50,568
Есть много способов

3320
02:29:50,790 --> 02:29:52,630
реализовать всякие прикольные

3321
02:29:55,250 --> 02:29:56,083
алгоритмы

3322
02:29:56,730 --> 02:29:58,130
в мутабельном хаскеле.

3323
02:29:58,131 --> 02:30:00,390
Это всё очень-очень sequential.

3324
02:30:01,050 --> 02:30:03,327
То есть, это невозможно
распараллелить, потому что

3325
02:30:03,410 --> 02:30:05,705
там всё где монады, и
это очень трудно сделать.

3326
02:30:06,170 --> 02:30:07,818
Если бы я сказал невозможно.

3327
02:30:08,290 --> 02:30:09,123
Наверное.

3328
02:30:09,730 --> 02:30:11,050
Везде bind и так далее.

3329
02:30:11,130 --> 02:30:13,189
Всё гаскофункционально, фактически.

3330
02:30:15,250 --> 02:30:18,565
Но это возможно, да, с помощью
тех самых arrays и так далее.

3331
02:30:19,230 --> 02:30:20,350
st – это ваш друг.

3332
02:30:20,530 --> 02:30:23,556
Используйте его, если вы хотите
сделать мутабельные вычисления

3333
02:30:24,660 --> 02:30:26,950
и сделать escaping из них значение а,

3334
02:30:27,500 --> 02:30:29,736
то есть чистым его, его заэкстрактить.

3335
02:30:29,990 --> 02:30:31,049
st – это ваш друг.

3336
02:30:31,470 --> 02:30:33,650
Можно измерять время с помощью set++,

3337
02:30:33,830 --> 02:30:35,183
можно измерять секунды.

3338
02:30:35,550 --> 02:30:37,507
Ещё есть такой пакетчик,
который называется criterion.

3339
02:30:37,590 --> 02:30:38,473
И в самом конце

3340
02:30:39,470 --> 02:30:43,527
список почти всех, всё за то,
что было сегодня, в том числе,

3341
02:30:43,610 --> 02:30:45,877
между прочим, всего осталось
людей. Четыре человека, да?

3342
02:30:45,960 --> 02:30:47,490
Три человека, окей, класс.

3343
02:30:48,530 --> 02:30:50,804
Я уже миллион раз референшу

3344
02:30:51,870 --> 02:30:55,650
книгу Мирана Лимбабачи
«Learn the USSR for Great Wood».

3345
02:30:55,651 --> 02:30:56,670
А тут фреск-лист

3346
02:30:57,190 --> 02:30:58,661
обсуждается в чаптере 13.

3347
02:30:58,790 --> 02:31:00,570
И все остальные, собственно,

3348
02:31:02,090 --> 02:31:04,947
ссылочки про streamfusion,
про мутабельные объекты,

3349
02:31:05,030 --> 02:31:06,810
backup-presentation тоже
можно почитать, всё доступно.

3350
02:31:06,870 --> 02:31:07,703


3351
02:31:09,010 --> 02:31:11,716
Я, кстати, завершил.
Нам всем большое спасибо.

3352
02:31:11,930 --> 02:31:13,342
Рекординг останавливаем.

