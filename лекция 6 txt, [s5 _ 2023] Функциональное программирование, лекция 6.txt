0:08
Всё, супер, запись вроде началась.
0:13
Сегодня у нас будет с вами лекция про взаимодействие с внешним миром,
0:18
про то, как считывать, писать в консоль, общаться по сети и так далее,
0:24
какие возможности для этого есть в Haskell,
0:26
как такой общий механизм под названием Monado.io.
0:31
Основные монады все помимо неё вы изучили на
0:34
прошлой лекции, и сегодня речь коснётся именно её.
0:37
Будем всю лекцию говорить об одной монаде.
0:40
И, наконец-таки, с вами научимся писать Hello World на Haskell.
0:46
Сначала мы поймём, как в Haskell с моделью частоты на уровне типов
0:54
придумаем с вами, как написать функцию getChart,
0:57
которая читает что-то из консоли, один-единственный символ.
1:02
Поговорим, наконец, про то, что такое Monado.io, как оно устроено.
1:05
Также коснёмся такой вещи, которая называется дунотация,
1:09
что это синтаксический сахар для удобного написания монадических вычислений.
1:13
Поговорим про проблемы, которые бывают при взаимодействии с внешним миром в Haskell.
1:18
Поговорим про такую вещь, как FFI, Foreign Function Interface,
1:22
про то, как вызывать всякий разный C-шный код, и не только из Haskell.
1:28
Также поговорим про то, как в IEO у нас работать с
1:34
мутабельными данными, потому что IEO позволяет это делать.
1:36
Поговорим немного про эксепшены, про такую вещь, как UnsafeIO.
1:42
И также поговорим про эффективную реализацию строк.
1:45
Так как в самой первой лекции, если вы помните, мы говорили,
1:48
что строки в Haskell достаточно неэффективны.
1:52
И поговорим про эффективную реализацию под названием TextAbideString,
1:57
и при чём же там всё-таки IEO.
1:59
Давайте разбираться.
2:00
Давайте поставим такую задачу перед собой, написать функцию getChart,
2:04
которая возвращает нам символ, который пользователь печатает в консоли.
2:08
И, например, с её использованием напишем функцию getToCharts,
2:13
которая с использованием getChart просто считает два символа.
2:16
Скажите, пожалуйста, видите ли вы в этом какие-то проблемы?
2:19
Даже не глядя на реализацию, просто по сигнатуре данной функции
2:25
уже понятно, что что-то тут нечисто, что-то тут не так.
2:31
Есть какие-нибудь предположения?
2:33
...
2:36
Да, это первая из проблем.
2:41
Всё то, что не имеет аргументов у нас в Haskell, это консанта.
2:45
Поэтому, казалось бы, судя по сигнатуре типа,
2:48
когда и где бы мы не вызывали getChart,
2:50
у нас должен вернуться только лишь единственный символ.
2:54
С функцией getChart хорошо понятно.
2:56
Давайте представим на секунду, что мы всё-таки каким-то образом
3:01
реализовали функцию getChart правильно,
3:03
чтобы она возвращала разные символы из консоли при разных моментах считывания.
3:08
Что же с функцией getToCharts?
3:09
С ней тоже есть небольшая проблема.
3:20
Окей, давайте тогда я скажу.
3:21
Если вы помните, на самой первой лекции,
3:24
когда мы с вами говорили про ленивую модель вычислений,
3:28
которая задействована в Haskell,
3:30
то речь касалась того, что редукция выражений в Haskell,
3:35
в ленивой модели вычислений, вообще говоря, не определена.
3:38
Точнее, порядок редукции, вообще говоря, не определен.
3:41
Таким образом, ваше выражение может редуцироваться в каком угодно порядке,
3:46
и поэтому абсолютно непонятно, в каком порядке
3:50
в нашем результирующем списке окажется символ.
3:54
Компилятор может посчитать нужным сочетать сначала первый символ,
3:56
а потом второй, или же сначала второй, а потом первый.
3:59
Это вторая проблема. И сейчас мы потихоньку будем ее решать.
4:05
Да, это как раз таки то, что мы с вами сейчас переговорили.
4:09
И давайте попробуем все-таки как-то исхитриться
4:14
и попробовать задать порядок на вызовах функций getChart,
4:21
и также заставим ее возвращать разные символы.
4:27
Сделать это можно достаточно просто, на самом деле.
4:29
Можно просто передавать функцию getChart int,
4:33
допустим, порядковый номер символа из консоли, почему нет.
4:36
И таким образом эта функция перестает быть константной.
4:40
И мы можем просто скарливать туда int,
4:46
и, соответственно, у нас будет отдавать разные символы.
4:50
Но, к сожалению, она никак не решит проблему с порядком.
4:53
Потому что вызов второго getChart никак не зависит от вызова первого getChart.
4:58
И таким образом компилятору ничего не мешает абсолютно перепорядочить вычисление
5:01
и сначала вызвать второй getChart, а потом первый.
5:04
Есть ли какие-то мысли насчет того, как это можно исправить?
5:21
getChart взаимодействует с глобальным буфером,
5:23
из которого достают значения по индексу.
5:28
Непонятно, что есть глобальный буфер.
5:30
Это, знаете, какая-то абстрактная вещь.
5:31
Пока что все, что мы умеем, это просто скарливать int.
5:36
То есть оперировать какой-то чиселкой,
5:41
суть которой в том, чтобы наша функция не была константной.
5:46
И у нас, соответственно, проблема в том, что у нас вызовы getChart,
5:49
если мы хотим прочитать два getChart, не зависят друг от друга.
5:53
Как сделать их зависимыми друг от друга?
5:56
Используя, на самом деле, более-менее тот же трюк,
5:58
который мы использовали с int, просто добавив его в качестве аргумента.
6:04
Может быть, сказать, что getChart2, прежде чем вызваться, должен вызвать getChart1?
6:10
Вот, а как это сделать?
6:12
Это то, что нам нужно сделать.
6:14
И, соответственно, интересует вопрос как?
6:20
Как заставить компилятор сначала вызвать первую, а потом вторую?
6:27
Репорсия какая-нибудь?
6:32
На самом деле нет.
6:34
Я вполне верю, что в случае с двумя чарами действительно так можно сделать.
6:38
Но если рассматривать какую-то более общую модель, давайте посмотрим.
6:41
На самом деле можно просто возвращать из функции getChart пару char int
6:46
и возвращать оттуда следующий порядковый номер.
6:50
Таким образом, у нас вызов второго getChart,
6:55
следующий порядковый номер, который мы скормим следующему вызову getChart.
6:58
Таким образом, вызов функции getChart2 в данном
7:01
случае будет зависеть от функции getChart1.
7:05
Если мы изменим и будем возвращать пару, мы сначала
7:09
вызовем getChart1 и вернем второе значение счетчика.
7:13
И потом по второму значению счетчика вызовем уже второй getChart.
7:16
Таким образом, компилятору ничего больше не остается делать,
7:19
кроме как вычислить данные выражения в правильном порядке.
7:29
Ну и соответственно, данная модель, к сожалению, не сказать, чтобы расширяема,
7:33
потому что, допустим, мы хотим написать функцию get4charts,
7:37
которая также вернет список, но это будет весьма и весьма неудобно,
7:41
потому что вот такая запись также не подойдет.
7:45
И нам нужно сделать вот эти четыре промежуточных assignment,
7:49
чтобы все-таки наши символы считались в правильном порядке.
7:53
Так что при расширении этого на какие-то большие, при
7:56
обобщении на какое-то большее количество символов,
7:59
у нас все еще существует такая же проблема.
8:04
И, соответственно, это про то, как все-таки исправить,
8:09
переписать просто вот эту функцию так же, как мы переписывали get4charts.
8:13
И вы не поверите, но мы сейчас с вами придумали то в общем виде,
8:18
как монадическое IO работает в Haskell.
8:21
Там, конечно, все немного похитрее, без каких-либо интов.
8:26
Сейчас мы с вами посмотрим.
8:30
Давайте сначала зададим такой игрушечный тип, который будет называться IOA.
8:36
Это просто будет функция из какого-то real world,
8:39
из какого-то состояния реального мира, в котором мы с вами сейчас существуем.
8:43
В результат этой функции и новое состояние реального мира.
8:47
То есть мы просто заменили int каким-то более абстрактным дататайпом,
8:51
который представляет состояние реального мира.
8:54
Собственно, в общих чертах так и выглядит механизм IO в Haskell.
8:57
То есть вместо вот этого нашего int, который задает порядок на вычисление,
9:02
у нас между вызовами иошных функций просто передается токен,
9:06
который как-то модифицируется и задает порядок.
9:11
Соответственно, когда вы делали домашнее задание,
9:14
вы увидели то, что entry point программы в Haskell также является функция main,
9:19
которая имеет тип IO пустой кортеж.
9:21
Пустой кортеж используется тогда, когда у функции нет осмысленного результата,
9:25
и нам нужно что-либо вернуть, и это такой dummy datatype,
9:29
unit-тип, как еще говорят.
9:31
Тип, у которого всего один элемент, пустой кортеж.
9:34
Соответственно, если раскрыть вот этот алиас,
9:36
то у нас получается main принимает какой-то реальный мир,
9:39
возвращает в ничего, то есть в пустой кортеж,
9:41
и возвращает в другое состояние реального мира.
9:45
И таким образом у нас выглядит переписанная функция getChar,
9:50
ее сигнатура на новую модель, которую мы сейчас с вами задали.
9:56
И, соответственно, так можно использовать ее, например,
10:00
в функции main, если раскрыть вот этот type синоним.
10:08
Все еще остаются вопросы.
10:09
Может ли компилятор скипать или как-то переупорядочивать вызовы getChar,
10:17
как вы думаете?
10:19
Или данная модель позволяет нам достаточно безопасно быть уверенным в том,
10:25
что порядок на наших вычислениях сохраняется?
10:34
Ну, давайте не будем тянуть и отвечу сразу, что этого более-менее достаточно.
10:38
Для того, чтобы быть уверенным в том, что наша модель жизнеспособна.
10:46
Потому что действительно скипать вызовы getChar мы не можем.
10:50
Почему? Потому что каждый следующий зависит от предыдущего.
10:54
А если в конечном итоге мы используем результат нашего последнего вызова getChar,
11:00
то есть Haskell заэволюетит вот этот санк, который накопился.
11:04
Санк, напомню, это какое-то невычисленное выражение.
11:07
Если же в конце концов мы печатаем это значение на консоль,
11:10
или потом матчимся по нему, или сравниваем его с чем-то,
11:16
оно редуцируется до слабоголовной нормальной формы.
11:19
И все эти вызовы промежуточные getChar нам тоже нужны.
11:22
Поэтому скипов не может быть.
11:24
Свопов не может быть тоже, потому что мы задали линейный порядок на вычислениях.
11:28
И также не бывает каких-то дополнительных вызовов getChar,
11:32
потому что каждый раз они вызываются на разных токенах.
11:36
И каждый раз нам нужно вызвать эту функцию.
11:39
И достаточно вызвать ее единую, чтобы получить ее результат.
11:42
То есть таким вот достаточно нехитрым способом мы с
11:45
вами решили проблему взаимодействия с внешним миром,
11:49
а именно с заданием порядков на нем операции.
11:52
Что являлось на самом деле основной проблемой,
11:54
когда мы с вами рассматривали функцию getChar.
11:58
Давайте посмотрим на реальную имплементацию
12:00
IO, как она выглядит в стандартной библиотеке.
12:03
Выглядит она немного страшнее, но сути дела не меняет.
12:07
Это у нас NewTypeIO, где A – это результат какого-то иошного вычисления.
12:13
И есть у нас GetterOnIO, который также представляет функцию,
12:18
только вместо TypeAlias это NewType, потому что так правильнее,
12:22
как мы уже, наверное, с вами говорили на предыдущих лекциях.
12:27
И вместо токена realworld используется странный тип state решетка realworld.
12:34
И, в общем-то, все.
12:36
Пожалуйста, не путайте этот state с monad.state.
12:39
State решетка – это просто такой маркерный тип данных, который позволяет нам…
12:47
Вот этот маркер state на самом деле нужен для того,
12:50
чтобы при исполнении иошных действий в разных потоках,
12:56
в разных контекстах вычисления не мешались между собой.
12:58
То есть state на самом деле – это просто какой-то
13:00
маркерный тип, ничего общего с monad.state он не имеет.
13:04
Благодаря этому вопросу, откуда все-таки взялась решетка,
13:07
в Haskell есть такая конвенция про то, что когда мы оперируем какими-то
13:12
низкоуровневыми вещами, имплементация которых, возможно, задана на языке C
13:18
и используется FFI, ну, это, допустим так, на эти функции в Java какие-нибудь.
13:23
Вот есть такое соглашение, что такие вещи имеют суффикс решетка в своем имени.
13:31
Соответственно, суффикс решетка на самом деле
13:33
можете использовать и вы в вашем произвольном коде,
13:35
просто это не будет соответствовать общепринятой конвенции,
13:38
если же вы не пишете какие-то совсем уж низкоуровневые вещи.
13:42
И использовать ее можно весьма просто, просто подключить
13:46
решение magic-hash, и тогда данная синтез станет валидной.
13:48
Соответственно, если вы пороетесь в стандартной библиотеке
13:52
где-то в ее глубине, вы найдете достаточно много кода, которые
13:55
используют идентификаторы с вот этой вот решеткой,
13:58
которые говорят о том, что, чувак, мы здесь
14:00
оперируем достаточно низкоуровневыми вещами.
14:05
Как тут видно в этих примерах, вот это наш data.type.mystery, который мы определили,
14:09
он абсолютно может также использоваться, он ничем
14:12
не отличается от обычных, кроме своего имени.
14:15
Тут, кстати, есть хорошая статья про то, как
14:19
в Haskell реализованы различные примитивы.
14:24
Можете посчитать.
14:27
Соответственно, да, у нас есть такой тип данных, маркерный, как state,
14:33
с одной типовой переменной, и он как раз таки
14:35
параметризовывается вот этим нашим real-world токеном.
14:38
На то, как именно выглядит определение этих типов, мы
14:42
не будем смотреть, нам оно на самом деле и без разницы,
14:45
нам важен такой общий механизм того, как оно работает.
14:49
И, как мы уже говорили в самом-самом начале
14:52
лекции, когда рассматривали table of contents,
14:56
IO является монадой, также, соответственно, оно является функтором и аппликативом,
15:00
но эти инстанции здесь не приведены буквально для простоты.
15:04
Я думаю, более-менее очевидно, как они пишутся для вот этого типа данных.
15:10
На самом деле, этот тип данных немного похож
15:12
на монаду state, если вы обратите внимание,
15:15
потому что у нас есть тоже какое-то состояние, только это не состояние вычисления,
15:18
а состояние внешнего мира, которое задает нам порядок на вычислениях.
15:23
И, соответственно, реализация бинда и ретерна выглядит довольно похожим образом.
15:30
То, что у нас какое-то иошное действие n,
15:32
если мы биндим с какой-то стрелкой клейстрика,
15:35
то это в результате все еще получается иошное действие.
15:39
Такое, что мы сначала применяем наше действие к первому реальному миру.
15:47
Это иошное действие из какого-то стейта реального мира во что?
15:53
В то, что мы применяем вот это наше иошное действие к состоянию внешнего мира.
15:57
Получаем новое состояние внешнего мира и результат.
16:00
И, соответственно, потом мы применяем нашу стрелку
16:04
клейстрика к этому результату и новому состоянию.
16:07
Ну и здесь мы делаем an.io просто, чтобы тип сошлись.
16:10
Потому что здесь мы уже указали то, что мы заворачиваем, это ио.
16:14
И здесь нам это нужно просто развернуть.
16:16
Довольно механическая работа.
16:18
Суть дела в том, что мы применяем наше действие к состоянию внешнего мира,
16:23
потом применяем к нему стрелку клейстрика и
16:27
присовываем к этому новое наше состояние внешнего мира,
16:32
которое будет использоваться в дальнейших вычислениях.
16:35
Return выглядит тривиально, как и его реализация для всех монад.
16:42
Это просто мы запаковываем вот такую функцию, которая
16:45
никак не меняет состояние нашего внешнего мира, в панадойю.
16:51
Пожалуйста, есть ли какие-то вопросы по типу данных.
16:53
io, который определен в стандартной библиотеке, и по инстансу монада для него.
17:10
Видимо, вопросов нет. Давайте продолжим.
17:13
И поговорим про такую вещь, которая всегда идет где-то рядом с монадами в Haskell.
17:19
Это doSyntax или doNotation,
17:22
которая позволяет нам удобно в стиле, похожем на стиль написания
17:26
в императивных языках, задавать монадические вычисления.
17:31
Вспомним, что у нас есть монадический оператор, так называемый урезанный бинт,
17:37
птичка-птичка, который имеет тип monad m, mA, mB, mB.
17:42
То есть он выполняет первое действие, выполняет второе
17:45
действие и возвращает результат второго действия.
17:48
Вот, соответственно, рассмотрим следующий пример.
17:50
Здесь приведем его тип, специализированный для монада.
17:54
io, для красоты, так как речь на этой лекции будет вестись только о ней.
18:00
Рассмотрим, во что у нас дешевелится вот это синтаксис.
18:04
На самом деле это просто мы применяем наши действия сначала к первому миру,
18:11
точнее к изначальному миру world0, получаем
18:14
world1, и нас не интересует его результат.
18:16
Затем мы этот world1 скармливаем второму
18:19
действию, получаем b и world2 и возвращаем.
18:22
Вот как это будет выглядеть в нашем dosyнтаксисе.
18:25
Давайте, чтобы этот пример был хотя бы чуть-чуть реальный,
18:28
заинтродюсим сразу функцию из стандартной библиотеки, которая называется put strln,
18:32
которая принимает строчку и возвращает его в пустой кортеж.
18:36
Она печатает данную строчку на консоль.
18:39
И посмотрим, как можем написать функцию main,
18:42
заиспользовав в ней функцию put strln и do нотацию.
18:47
Вот этот пример довольно тривиальный, потому что
18:50
здесь dosyнтаксис содержит лишь одну строчку, и можно ее опустить.
18:54
Но мы можем писать следующим образом.
18:56
Мы можем писать main равно do, и затем одна
18:59
за одной писать какие-то решенные действия.
19:02
Например, сначала вызвать функцию put strln от первой строки,
19:06
потом от второй строки и потом от третьей.
19:08
При этом никаких биндов, никаких операторов птичка-птичка нет.
19:14
В основном, это дешевый рейд.
19:15
Дешевый рейд – это то, что между каждой строчкой ставится вызов нашего оператора.
19:22
Просто из-за того, что результат нам не нужен,
19:26
мы можем никоим образом не изворачиваться, просто опустить данный синтаксис.
19:31
И вместо того, чтобы на каждой строчке дородить вот этот оператор,
19:35
просто избавиться от него использованием do-нотаций.
19:38
Соответственно, оно позволяет нам просто
19:40
одну за одной писать вот эти наши действия,
19:41
которые будут выполняться в том же порядке, в котором мы их написали.
19:45
Почему они будут выполняться именно в нужном порядке,
19:48
следует из реализации вот этого оператора, который мы сейчас посмотрели.
19:52
То есть в отличие от каких-нибудь let-стейтментов,
19:55
которые, если они не зависят друг от друга напрямую, один за одним,
19:58
могут быть, вообще говоря, вычислены когда угодно.
20:02
Монадические вычисления, написанные в
20:04
do-нотации в том числе, лишены этого свойства,
20:07
и они вычисляются прямо один за одним, как мы это скажем.
20:10
Просто в силу реализации.
20:14
Поговорим еще вот о чем.
20:15
Поговорим о том, как нам исполнять какую-то цепочку действий.
20:20
Здесь мы тоже выполняли в каком-то смысле цепочку действий,
20:23
но представим, что у нас есть какой-то список действий в Monad.io.
20:28
Например, сначала распечатать что-то, потом…
20:32
А, ну функция print на самом деле…
20:34
Давайте потихоньку будем интродюсить функции стандартной библиотеки.
20:38
Буду вам о них рассказывать.
20:39
Функция print на самом деле принимает произвольный
20:43
аргумент, вызывает на нем show, и делает put strln.
20:45
Соответственно, print – это show a, а a – его пустые карты.
20:50
put str – это то же самое, что put strln, только не печатает line break.
20:56
И также у нас есть функция getChart, которая
20:58
также присутствует в стандартной библиотеке, и мы ее написали.
21:01
Она просто считывает символы в консоли.
21:04
Соответственно, мы дискаргуем ее результат
21:06
с помощью объединения с return пустой карты.
21:11
Если у нас есть такой вот список, можно исполнить его следующим образом.
21:16
Можно через do нотацию в каждой строчке по
21:19
индексу обратиться к каждому элементу списка, и данное действие будет исполнено.
21:24
Но это достаточно плохо, поэтому есть в стандартной
21:28
библиотеке функция, которая называется sinkSequence,
21:31
которая принимает список каких-то монадических действий
21:35
и выполняет их последовательно с дискардингом результата.
21:40
Кажется, на предыдущих лекциях об этом должна вестись речь,
21:44
что в Haskell существует такой naming conventions,
21:46
что если какая-то функция не возвращает никакого
21:52
результата, то есть она игнорирует результат,
21:54
у нее последним символом в имени стоит underscore.
21:58
Соответственно, есть функция sequence без underscore,
22:02
которая возвращает список результатов.
22:04
Но в данном случае никаких отмысленных результатов у нас в дейфе нет,
22:07
поэтому мы используем функцию sequence с нижним подчеркиванием.
22:10
И, соответственно, мы можем наш main определить
22:13
просто как вызов функции sequence на этом списке.
22:18
Давайте посмотрим.
22:19
Можно чуть подробнее про дискардинг результатов?
22:22
Потому что если мы игнорируем результат от всего IO actions,
22:26
то с учетом ленивости вычислений можно, грубо говоря, оптимизировать
22:30
и сделать пустую программу, которая ничего
22:32
не делает, если ее результат никому не важен.
22:35
На самом деле нет,
22:36
потому что пустой кортеж все-таки возвращается.
22:42
Это во-первых.
22:43
Потому что все-таки у нас не то, чтобы нет никакого
22:47
результата, и не то, чтобы он нам не нужен.
22:48
У нас результатом все-таки служит пустой кортеж,
22:51
который в силу нашего определения монадического минда,
22:57
этот результат пропагейтится из одной функции в другую.
23:00
И таким образом монадические вычисления не являются ленивыми.
23:04
Потому что в терминах зависимости одного звена
23:10
цепочки монадических вычислений от другого,
23:18
в силу определения монадического инстанца, и вообще type class монады,
23:23
у нас перед тем, как будет вызвано следующее действие,
23:25
всегда, вне зависимости от того, нужен ли этот результат
23:29
в конце или нет, будет использовано следующее действие.
23:31
Просто в силу определения.
23:33
Об этом мы еще говорили с вами тогда, когда мы писали функцию github.
23:39
Мы тогда не говорили о дестардинге, но это в данном случае суть и дело не меняет.
23:43
Поэтому монадические вычисления не являются ленивыми.
23:46
Конечно, каждое из этих действий, каждое из монадических действий,
23:51
из звеньев цепочки биндов, соответственно, да, оно ленивое.
23:57
Если мы посмотрим на реализацию, если мы
24:00
посмотрим на то, как оно будет исполняться,
24:03
как оно будет редуцироваться, конечно, там имеет место будет ленивость.
24:06
Но если мы посмотрим вот так вот сверху, и
24:08
будем рассматривать это действие как атомарное,
24:11
то данная цепочка не является ленивой.
24:18
И давайте, возможно, оно будет видно также из определения функции sequence,
24:24
с нижним подчеркиванием, что на пустом списке мы просто не делаем ничего,
24:30
а на списке из какой-то головы и какого-то
24:32
хвоста мы просто вызываем действие в голове
24:34
и рекурсивно вызываемся от хвоста, используя дунотации.
24:37
Соответственно, без дунотации можно было бы
24:41
написать просто x, птичка-птичка, sequence от x.
24:48
Вспомним теперь и про обычный бинд, который имеет вот такой тип.
24:51
Если мы его специализируем до типа monad.io, и поговорим про то,
24:58
каким образом данный бинд используется в дунотации.
25:00
Потому что до этого у нас были довольно скучные цепочки вычислений,
25:05
каждое действие в которых игнорирует результат предыдущего действия.
25:09
В случае IO это, наверное, только лишь вызов
25:12
функции print и put.stln и ничего более.
25:16
То есть функции, которые не возвращают результаты.
25:18
Давайте же все-таки посмотрим на обычный бинд.
25:25
Здесь у нас имеется развернутый тип.
25:27
Как у нас выглядит обычный бинд?
25:29
Как он у нас разворачивается, если мы развернем его определение.
25:34
То, что мы сначала применяем наше действие к какому-то первому миру,
25:38
к какому-то нулевому миру получаем результат и первый мир.
25:43
Соответственно, к результату и первому миру мы применяем action2,
25:47
который напоминает стрелку от Лейсли, поэтому у него на один аргумент больше.
25:51
Получаем второй мир.
25:52
И, соответственно, возвращаем результат и второй мир.
25:55
Вот таким образом это будет выглядеть.
25:58
Посмотрим на следующую функцию, которая у нас определена в стандартной библиотеке,
26:01
которая называется getline, которая просто считывает строчку
26:06
из стандартного ввода и возвращает ее запакованную в monad.io.
26:09
Каким образом будет выглядеть doSyntaxes для бинда,
26:13
если мы используем bin с функциями, которые
26:16
возвращают какой-то осмысленный результат, в отличие от пустого картежа.
26:20
Он будет выглядеть следующим образом.
26:25
У нас появляется новый оператор, который имеет следующий вид,
26:29
и который на самом деле похож на оператор присваивания.
26:33
И что мы здесь видим?
26:34
Мы связываем значение функции getline с идентификатором s.
26:39
Тип s у нас будет string, потому что тип выражения,
26:47
которое находится слева от нашего оператора стрелка,
26:52
он всегда, тип выражения, которое находится
26:55
в monad, только распакованный, без коробки.
26:58
Почему это так происходит, сейчас нам будет понятно,
27:00
когда мы посмотрим на то, как это дешевляется.
27:02
Соответственно, мы вызываем функцию getline и кладем его результат в переменную s.
27:05
А затем эту переменную s, которая имеет тип string,
27:08
мы можем спокойно использовать в функции плута стрелы.
27:11
И выглядит все это достаточно незамысловато,
27:14
потому что у нас вызывается обычный bind.
27:18
И в качестве второго аргумента бинда используется lambda,
27:22
как раз таки где результат функции getline связывается с переменной s,
27:27
которая у нас доступна во всем дальнейшем скопе.
27:31
Соответственно, вот такая запись, у нас будет развернута вот такую запись.
27:36
Все вызовы бинда просто берут и помещают результат
27:43
первой функции, которая находится в аргументе лямбда,
27:46
просто помещают ее в какую-то переменную для удобства в дальнейшей с ней работе.
27:53
Мне кажется, что данная функция действительно весьма простая,
27:56
и ее можно записать без дунотации и даже без лямбда, просто используя бинд.
28:04
Если вы будете пользоваться этим в GHCI, то вы заметите довольно забавный специфик.
28:11
GHCI на самом деле реализован достаточно просто.
28:14
Это просто бесконечный loop, бесконечный цикл в IOM-аналоге.
28:19
Соответственно, если вы будете пользоваться синтексом этой стрелочки,
28:24
то вы обнаружите то, что он вполне себе
28:27
работает, и монадой будет у нас являться IOM.
28:31
Соответственно, если вы будете использовать в GHCI какую-то полиморфную функцию,
28:37
например, функцию return, допустим, напишите return true,
28:41
то данный тип будет специализирован до типа монады IOM,
28:45
потому что GHCI – это просто блок кода в монаде IOM.
28:51
А если бы вы писали это в каком-то коде в
28:54
хаскельном модуле, то данный тип был бы полиморфным.
28:56
Потому что на самом деле return возвращает
28:59
какую-то монаду, и пока что непонятно какую.
29:01
Это должно быть выведено из контекста.
29:03
В GHCI есть такой странный спецфект.
29:06
Пожалуйста, обратите на это внимание, если
29:08
будете тестировать там какой-нибудь свой код.
29:11
Давайте поговорим про какой-то более сложный пример.
29:14
Попробуем развернуть вот такой doSyntax, который использует, соответственно,
29:20
как и урезанный бинт для выражения, который не возвращает результат,
29:24
так и бинт обычный, который имеет результат.
29:27
Соответственно, что мы делаем?
29:28
Сначала мы печатаем в консоль what's your name,
29:33
считываем строчку, потом печатаем how old are you,
29:36
считываем строчку и печатаем на консоль пару из a и b.
29:39
Принт, я напоминаю, просто вызывает show и печатает с помощью функции put strln.
29:44
Это будет выглядеть следующим образом.
29:47
Сначала мы вызываем putstr, он не возвращает нам никакого результата,
29:52
поэтому здесь используется обычный, точнее, урезанный бинт.
29:57
Затем мы вызываем функцию readln, которая возвращает нам строчку a,
30:02
которая возвращает нам строчку, которую мы связываем с переменной a.
30:06
Затем в теле лямбды мы вызываем опять функцию
30:08
putstr, которая не возвращает никакого результата.
30:11
Опять вызываем функцию readln, которая возвращает у нас результат b.
30:15
И просто печатаем a и b.
30:18
Вот, таким образом оно разворачивается.
30:20
Ставьте, пожалуйста, есть ли какие-то вопросы по донотации,
30:25
правилам дешугеринга и так далее.
30:36
Хорошо, буду считать, что вопросов нет.
30:38
Единственное, что добавлю, еще одно замечание по поводу
30:42
применения донотации с вот этим нашим урезанным бинтом.
30:48
Здесь, в примерах, вы видите, что всегда мы используем донотацию,
30:53
которая не возвращает никакого результата, на
30:57
функциях, у которых return type, это IO, пустой картеж.
30:59
И это логично, потому что действительно нам нет смысла использовать обычный бинт
31:04
и слева писать какой-то идентификатор, который будет равен пустому картежу.
31:09
Поэтому мы используем вот так.
31:10
Но на самом деле мы не ограничены тем, чтобы использовать вот
31:14
такой вот синтез на функциях с return type пустой картежи.
31:18
Мы можем это использовать на функции, которая
31:20
возвращает какой-то смысленный результат.
31:22
Но если же мы не хотим связывать его ни с какой переменной,
31:24
допустим, этот результат нам не интересен, мы просто можем это скипнуть.
31:28
Вместо того, чтобы связывать его с какой-то
31:31
переменной, которая будет не использоваться.
31:33
Можно было бы просто написать нижнее
31:36
подчеркивание стрелком влево и какая-то функция.
31:40
Но зачем?
31:41
И да, повторюсь, основной пойнт в том, что здесь мы не
31:45
ограничены функциями, которые возвращают пустой картеж.
31:46
Мы можем использовать любые функции.
31:48
Просто это не так уж и часто нужно.
31:50
Наверное, в Хаскеле, если функция возвращает какой-то результат,
31:53
наверное, все-таки он должен как-то использоваться.
32:00
Теперь поговорим про return и его использование в дунотации.
32:06
Напомним, что return для monad.io будет выглядеть следующим образом.
32:12
Когда мы писали instance, у нас была лямбда от world 0 в картеж world 0,
32:17
но нам ничего не мешает подвинуть этот world 0 слева от знака равно.
32:22
И так он выглядит, просто чуть-чуть с измененным телом в плане синтекса.
32:28
Суть и дело не меняет.
32:33
Давайте посмотрим, как у нас return используется в дунотации.
32:35
Допустим, мы хотим написать функцию getReversedLine типом iostring,
32:40
которая читает строчку из консоли и возвращает ее в реверсном виде.
32:47
Что мы делаем для этого?
32:48
Сначала мы вызываем функцию getLine, и результат
32:51
вкладываем в переменную s, которая имеет тип string.
32:53
И вот если бы мы написали здесь без return reverse s, у нас бы не сошлись типы.
32:58
Почему? Потому что результат конечного выражения у нас должен быть iostring.
33:02
И, соответственно, если нам нужно в нашем конце дунотации
33:09
сделать какое-то чистое действие с результатом предыдущих биндов,
33:15
мы должны обернуть return.
33:16
По понятным причинам, просто для того, чтобы у нас сошлись типы,
33:19
и для того, чтобы результат исходной цепочки выражений был монадическим.
33:24
Мы не можем просто так взять и избавиться от iostring контекста,
33:29
как любого другого монадического контекста,
33:31
просто потому что, если это вызывает вопросы,
33:34
просто вспомните, во что это разворачивается.
33:37
И то, что у нас каждая из стрелок лейсли имеет возвращаемый тип mb.
33:43
Соответственно, из a в mb.
33:45
Здесь мы берем контекст m просто с помощью return.
33:50
И таким образом эту функцию можно использовать.
33:52
Также в мейне считываем преверснутую строчку и печатаем ее.
34:00
И вопрос в зал. Давайте рассмотрим следующий пример.
34:04
Когда мы читаем строчку a из консоли.
34:09
Да, тут в презентации есть небольшой баг.
34:11
Представьте, что мы используем на ней функцию read, которая приводит ее к end.
34:16
Потому что строчки сравнивать с нулем мы не можем.
34:20
Это просто такой лофтовер в презентации,
34:22
который, к сожалению, не заметил изначально.
34:24
Мы считываем число из консоли.
34:27
И если число больше либо равно нуля, мы делаем return простой кротеж.
34:32
Иначе мы печатаем, что число негативное, что число отрицательное.
34:36
А следующим действием мы печатаем, что a is a positive.
34:41
И будет ли оно вызвано в случае, если мы туда передадим положительное число.
34:48
Или же этот return отработает, как в императивных
34:51
языках, и мы не дойдем до этого действия.
34:55
Мы дойдем до него. Мы не можем пропустить просто так.
35:00
Побочное действие наше.
35:02
Да, это вполне логично.
35:06
Просто очень часто на первых порах люди путаются
35:10
с тем, что у нас название функции return
35:13
очень сильно похоже на название оператора return в плюсах или в джаве,
35:17
который, соответственно, завершает выполнение функции и возвращает результат.
35:21
В хатскеле функция return просто запаковывает
35:25
наш результат в монадический контекст.
35:29
Здесь return сделает то, что результат этого
35:32
экспрессиона в цепочке наших монадических вычислений
35:36
будет равен пустому кротежу, завернутому в монад, в данном случае a.
35:41
Соответственно, да, мы не можем просто так в хатскеле написать return,
35:45
и у нас цепочка монадических вычислений не завершится.
35:49
Нет, это просто для избежания путаницы.
35:54
А можно глупый вопрос?
35:56
Да.
35:56
Последнюю строчку не заберет себе do, который написан после слова else?
36:01
Нет, это хороший вопрос.
36:04
На самом деле вложенные do-блоки также присутствуют, как вы можете видеть.
36:10
Это достаточно неинтересно, потому что он тривиально состоит из одной строчки.
36:13
Тут дело в отступах, потому что этот do имеет в
36:19
своем составе одну строчку с таким-то отступом.
36:26
Соответственно, если бы у нас была вторая
36:28
строчка, у нее должен был быть такой же отступ.
36:30
Но данная строчка в силу расстановки отступов принадлежит первому do-блоку.
36:39
А мы можем и do с двумя стейтментами написать в одну строчку?
36:43
Да, можете с использованием точки запятой.
36:46
В Haskell есть точка запятой, если вы пишете
36:49
в do нотации или в кейсе в одну строчку.
36:55
Кажется, для этого есть вот такой синтез.
37:04
В Haskell также есть фигурные сроки.
37:08
Оно не сказать, чтобы часто используется, но порой
37:11
для экономии какого-то места к этому прибегает.
37:13
Но это не является желательным код-стайлом.
37:16
Вы также в gash-сайт.
37:19
Точка с запятой может быть удобна в gash-сайт, если
37:22
вы хотите написать несколько действий в одну строчку.
37:25
Просто чтобы не заморачиваться.
37:31
Там, кажется, был еще какой-то вопрос.
37:36
Ладно, видимо, не был.
37:38
Давайте поговорим про использование let в do нотации.
37:43
С самой первой лекции вы помните, что в Haskell есть такая вещь как
37:48
let in для объявления промежуточных идентификаторов наших выражений.
37:54
Так вот, конструкция let может быть использована в do нотации, но внезапно без in.
38:01
Сейчас мы посмотрим, как это выглядит.
38:03
Давайте посмотрим на такую функцию main, на ту же функцию,
38:08
которую мы писали до этого, где мы реверсим строчку.
38:13
Считаем строчку, поместим ее в переменную s, и
38:16
в переменную rs поместим результат reverse от s.
38:20
И выведем на консоль reversed input двоеточие rs.
38:25
Здесь, как вы заметите, отсутствует in просто по причине удобства.
38:31
Потому что, на самом деле, когда оно разворачивается, точнее,
38:35
выражение после in, как само ключевое слово in, очевидно, присутствует.
38:41
Просто в do нотации это является лишним.
38:43
Потому что в let in оно кажется довольно логично, потому что если
38:48
мы не рассматриваем do нотацию, то все в Haskell это выражение.
38:53
И логично, что когда мы объявили цепочку каких-то промежуточных
38:57
ассайментов, указать выражение, которым они используются.
39:00
Но в случае do нотации, которая является синтактическим сахаром и дает
39:04
нам некоторые ощущения того, что мы пишем императивный,
39:08
в кавычках, код, где строчки исполняются одна за одной,
39:11
решили просто разрешить не писать строчку in.
39:14
Просто для удобства, чтобы разрешить объявлять промежуточные идентификаторы.
39:20
Но in по понятным причинам будет присутствовать, потому
39:24
что это не какой-то новый синтактический конструкт.
39:27
Это все тот же самый let in, просто чуть-чуть засахаренный.
39:33
И самая частая ошибка, которая бывает у людей, которые работают с do
39:37
нотацией, это когда они путаются между знаком равно и стрелочкой влево.
39:42
Давайте рассмотрим пример. Когда мы пишем let s равно
39:46
getline, мы на самом деле не считываем строчку из консоли.
39:49
Мы просто присваиваем функцию getline к какой-то
39:52
другой функции s, которую мы можем потом вызвать.
39:55
Но это присваивание не вызывает функцию.
39:59
Если бы мы хотели считать что-то из консоли, то есть выполнить
40:03
наше монадическое действие, мы бы использовали стрелку влево.
40:08
Почему? Потому что стрелка влево – это синтактический сахар над биндом.
40:15
А вот такой let s равно getline – это ничего более, кроме
40:19
как алиас для функции, который мы потом можем вызвать.
40:23
И также есть следующая ошибка, когда мы в чистых значениях
40:27
пытаемся, при вызове какой-то чистой функции справа от знака равно,
40:34
мы пытаемся использовать стрелку влево.
40:36
Это не работает, потому что справа от стрелки влево
40:39
должно стоять у нас какое-то монадическое значение.
40:42
В монаде m, в которой мы работаем, в нашем случае это айо.
40:45
Несмотря на то, что список – это тоже монада, это
40:48
абсолютно разные вещи, данная спойлерка в монаде айо.
40:52
Поэтому reverse s будет иметь тип string, и мы не
40:56
можем просто так взять и поместить ее в переменную rs.
41:03
Есть ли какие-то вопросы по этому поводу?
41:12
Окей, давайте считать, что нет. Прошу прощения, я на полминуты прервусь.
41:16
У меня сейчас сядет ноутбук, я его поставлю на зарядку и возобновлю.
42:16
Прошу прощения, давайте продолжим.
42:22
И внезапно еще одна вещь, что мы можем использовать doSyntax без монад.
42:27
Но я бы сказал, что он лишен какого-то смысла.
42:31
Потому что все, что он нам позволяет сделать,
42:34
это не писать ключевое слово in в цепочке let.
42:38
Соответственно, вспоминаем нашу функцию Pythagoras с самой первой лекции,
42:41
где у нас let x2, потом let y2, потом in x2 плюс y2.
42:46
Можно просто написать do, сделать себе цепочку let без in,
42:50
и в самой последней строчке написать результирующее выражение.
42:54
Просто знаете, что такое синтаксис есть, я бы не
42:56
сказал, что он имеет какое-то практическое применение.
42:59
Потому что я ни разу такого кода не видел.
43:01
Как-то более привычно, если мы видим do, сразу представлять то,
43:06
что у нас речь идет о каком-то монадическом вычислении.
43:09
А тут чистая функция, и это очень и очень сильно запутывает.
43:13
Вот.
43:16
Там даже есть какой-то пример внезапно.
43:20
Можете тоже почитать. Я, если честно, даже не смотрел.
43:24
Давайте разберем такой вот интересный пример.
43:27
fu, функция isn't of int, которая внезапно
43:29
используется до нотации по каким-то причинам.
43:33
И мы берем плюс один и складываем его результат в переменную a,
43:38
а затем делаем return a умножить на два.
43:41
То есть, пожалуйста, может ли кто-то рассказать, что здесь происходит?
43:45
И почему это вообще работает?
43:48
Точнее, почему это компилируется хотя бы?
43:50
Как оно работает, мы разберем сразу же.
43:53
Как только поймем, почему оно компилируется.
44:03
Давайте, смотрите, у нас do почти всегда, кроме предыдущих
44:09
наших слайдов, это какое-то монадическое вычисление.
44:11
В какой-то монаде.
44:12
А тем более, если у нас есть стрелки влево, то это точно монадическое вычисление.
44:16
Это не просто do в чьей-то функции.
44:20
На какую из монад, которые вы изучали на прошлой лекции,
44:23
хотя бы отдаленно похожа наша функция fu?
44:40
Пример достаточно нетривиальный.
44:42
Давайте я не буду вас томить.
44:44
Скажу вам, что эта монада определенная для частично примененной стрелки.
44:50
Как вы помните, она является функтором и аппликативом.
44:54
Это также определялось на соответствующей лекции.
44:56
И когда на предыдущей лекции вы говорили про монаду ридер,
45:00
речь заходила про то, что монада ридер – это
45:02
просто newtype над частично примененной стрелкой
45:05
с фиксированным аргументом e и справа результатом a.
45:09
На самом деле, это оно у нас и есть.
45:12
Это у нас монада ридер.
45:14
Или, так как мы используем ее без newtype,
45:18
корректнее сказать, что это монада для частично примененной стрелки.
45:22
И давайте посмотрим, каким образом это у нас работает.
45:24
На самом деле, в данном случае у данной монады
45:29
контекстом является выражение слева от стрелки.
45:36
Соответственно, если бы мы сейчас решили потратить
45:39
на этот пример достаточно большое количество времени,
45:41
чтобы разобрать, мы бы выяснили, что каждое следующее
45:46
действие насыщает нашу функцию, которую мы собираем.
45:50
Потому что у нас монадическое вычисление – это функция isn't a wind,
45:53
но также она могла быть и string a wind или чего-то еще.
45:56
И каждое из вот этих действий просто, так сказать…
46:02
Это можно просто рассматривать как композицию, на самом деле.
46:04
Вы же помните, что функция для частично
46:06
примененной стрелки – это просто композиция.
46:09
И вот, соответственно, здесь мы по кусочкам собираем функцию.
46:12
То есть сначала мы говорим, что это плюс один, и ее результат какой-то a.
46:16
А потом мы этот результат еще и домножаем на два.
46:19
И если мы применяем вот этот фу в тройке,
46:22
сначала к нему прибавится один, а потом умножится на два.
46:29
Это выглядит, на самом деле, довольно и довольно страшно.
46:32
Но если это просто расписать как обычный
46:35
wind, ничего там страшного не будет абсолютно.
46:39
Данный пример тут просто находится для того,
46:42
чтобы показать, что такие вещи тоже бывают.
46:45
Не сказать, что они встречаются на практике.
46:47
Конечно, потому что ничего, кроме как запутать
46:50
человека, данный код полезного не делает.
46:53
Просто знайте, что такое бывает.
46:55
И что вот так вот для частично примененной стрелки работает монада.
46:58
Если бы тут была какая-то монада reader int, то было бы проще.
47:05
Точнее, reader int int.
47:09
Мы поговорили с вами про то, как у нас базово использовать IEO в Haskell,
47:16
какие бывают функции для этого.
47:18
Там putstr, putstrlen, getline, getchar, print.
47:23
И как с ними работать с IEO-монадой.
47:25
Также поговорили про denotation.
47:27
И абсолютно везде, когда происходит какая-то работа с
47:31
нижним миром, возникают какие-то неожиданные проблемы.
47:35
Давайте уже разберемся, какие.
47:38
Давайте рассмотрим следующую функцию, которая с помощью readfile.
47:42
Как вы догадываетесь, она принимает имя файла
47:45
и возвращает в виде строчки его содержимое.
47:49
Считаем контент файла foo.ht, переменуем файл content.
47:54
А затем запишем в файл bar.ht.
47:58
Вот этот наш контент просто присоединен с присоединенной в начале буковкой a.
48:03
А затем еще раз прочитаем msbar и выведем его на экран.
48:09
Пока что проблемы никакой нет.
48:11
Все выглядит достаточно straightforward.
48:17
Представьте, что у нас нет контента файлов foo.
48:20
ht и bar.ht, что они, соответственно, равны foo и bar.
48:23
Соответственно, файл контент...
48:26
А, нет, господи, это я неправду сказал.
48:30
Что foo.ht – это foo line break bar.
48:34
Это я немного запутался.
48:36
Вот так выглядит наш файл foo.ht.
48:38
Запускаем нашу функцию main.
48:40
И что мы видим?
48:43
Мы читаем из файла foo вот следующую строчку, присоединяем к ней в начало a,
48:49
получается a foo bar, и пишем файл бар.
48:53
А потом мы читаем файл бар и пишем его на консоль.
48:56
Получается ровно то, что мы ожидали.
48:58
Соответственно, фу бар только присоединенный в начале буковкой a.
49:01
Такой вот довольно странный пример.
49:04
Но сейчас мы его немного видоизменим и поймем,
49:08
какие при минорном изменении такого даже простого кода можно встретить проблемы.
49:13
Давайте изменим его и будем читать из foo.ht и писать в foo.ht.
49:19
А потом опять читать из foo.ht и писать в консоль.
49:23
Есть ли какие-то подзрения насчет того, что что-то тут пойдет не так?
49:29
Это нормально, если их нет.
49:30
Потому что с виду данный код не предвещает никакой беды абсолютно.
49:35
Может быть, кто-то есть.
49:44
У нас же файл content в первой строчке do не то чтобы вычисляется, он биндится.
49:51
Возможно, из-за этого мы откроем файл, например, на
49:54
чтение и запись, и вот там будет неприятная ситуация.
49:57
Да, абсолютно верно.
50:00
Вспоминаем, что Haskell — это ленивый язык.
50:03
И несмотря на то, что, как я уже говорил до этого,
50:07
если мы рассматриваем цепочку монадических действий,
50:10
здесь вот этот эффект ленивости откладывается.
50:15
Потому что у нас каждое предыдущее действие исполняется перед следующим действием.
50:21
Но это абсолютно не значит, что результат этого действия
50:24
будет средуцирован до головной нормальной формы или нормальной формы.
50:29
Это значит, что данное действие просто выполнится.
50:31
И действительно, как вы уже сказали, вылезет такая ошибка.
50:39
Перевернуть сюда на секунду.
50:41
Да, функция readFile, если почитаете ее документацию,
50:45
здесь написано, что он читает контент файла лениво, когда он нам нужен.
50:50
Как и функция getContents, не обращайте внимания,
50:54
это другая функция из стандартной библиотеки.
50:57
Соответственно, действительно, связывание нашего
51:01
санка с контентом readFile происходит сразу же,
51:06
в силу того, как работают монадические вычисления.
51:08
Но непосредственное чтение из файла будет происходить тогда, когда это нужно.
51:14
Когда это нужно? Когда мы пишем в этот же файл.
51:17
Соответственно, у нас будет проблема с тем, что дескриптор файла у нас будет открыт
51:20
как на чтение, так и на запись одновременно.
51:23
И вылезет такая ошибка, что return busy, файл is locked.
51:28
Эта проблема называется lazy Ion.
51:31
И сейчас мы немного коснемся того, как ее решать.
51:37
Но когда вы работаете с…
51:41
Тут на самом деле речь абсолютно не про чтение и запись файла.
51:45
То есть это просто какой-то один из примеров,
51:47
когда можно выстрелить себе в ногу, работая
51:50
с Ion, забывая о том, что Haskell ленивый.
51:53
Это касается абсолютно всех вещей, как работы с сетью,
51:57
с какими-то опишками, с базой данных и так далее.
52:00
Нужно всегда понимать, что все действия Ion непосредственно,
52:04
если мы используем наши стандартные функции, которые ленивые.
52:07
Есть еще другие функции, которые force от вычисления.
52:11
Сейчас мы о них поговорим.
52:12
Нужно всегда держать в голове то, что на этапе
52:15
считывания фактического считывания не происходит.
52:19
Происходит просто связывание танка с контентом файла, с вот этой переменной.
52:24
И все, больше ничего.
52:25
А затем, когда мы ее используем, будет происходить считывание.
52:29
И важно понимать, чтобы это считывание не
52:31
конфликтовало с использованием данной переменной.
52:34
В данном случае оно конфликтует, потому что
52:37
использованием является запись в тот же самый файл.
52:43
Здесь у нас какая-то байка про то, что обычно, когда
52:46
идет что-то не так, мы идем читать документацию.
52:48
Но если мы достаточно подготовленные, то мы всегда сначала читаем документацию.
52:55
И наткаемся на вот такую штуку.
52:58
Давайте посмотрим еще один пример.
53:00
Который, на самом деле, особо ничем не отличается, кажется.
53:10
Есть еще такая функция withFile.
53:15
Что она делает?
53:16
Это функция, которая принимает название файла.
53:19
Режим, соответственно, это может быть чтение
53:21
ReadMod, WriteMod и также ReadWriteMod.
53:24
И принимает цепочку действий, которые мы с этим файлом делаем.
53:28
Здесь можно написать $do и то, что с дескриптором данного файла можно делать.
53:36
Как бы привести аналог.
53:38
Короче, данная функция используется...
53:43
Короче, функции в Haskell'е видят кто-то там, обычно берут какой-то ресурс,
53:50
затем принимают цепочку действий, которые
53:52
с этим ресурсом делать, и закрывают ресурс.
53:55
Соответственно, функция withFile после выполнения этой
54:00
цепочки действий, которую мы сюда кормим, а сюда кормим мы
54:03
всего лишь одно действие, мы закрываем ресурс.
54:07
И здесь продемонстрировано неправильное использование функции withFile.
54:10
Почему? Потому что мы считываем его контент и кладем в какую-то переменную,
54:16
но на момент печати содержимого файла в консоль данный файл уже будет закрыт.
54:23
Потому что мы прочитали, закрыли, а потом будем... точнее мы на момент записи,
54:29
как только у нас начинается запись.
54:31
Haskell берет, ага, мне нужна эта переменная, пойду-ка я ее прочитаю.
54:35
Берет, идет ее читает, такой все, я прочитал, закрываю файл.
54:40
Отдает функцию putstr строчку, но на самом деле файл уже закрыт.
54:47
И поэтому на момент вызова putstr дескриптор файла уже закрыт.
54:57
Поэтому мы не можем напечатать его на консоль, потому
55:00
что когда мы пойдем ее читать на самом-то деле,
55:04
будет уже поздно. На самом деле, мне кажется, получилось довольно невнятно.
55:09
Давайте я попробую еще раз объяснить, если у кого-то из вас есть вопросы.
55:16
Или же все более-менее понятно.
55:19
То, что на момент записи в консоль данного файла дескриптор файла был уже закрыт,
55:26
потому что он открылся и закрылся сразу же.
55:30
А уж когда нам actually нужно взять его пойти и прочитать, он уже закрыт.
55:41
Окей, я надеюсь, что это все-таки понятно.
55:44
Еще раз резюмирую.
55:45
Если вы видите в Haskell какую-то функцию, которая называется viz, что-то там,
55:51
всегда знайте, что это функция, которая берет какой-то ресурс,
55:55
делает с ним цепочку действий и закрывает этот ресурс.
55:59
Поэтому в данном случае правильным использованием
56:02
функции vizfile было бы поставить вот тут доллар,
56:06
поставить ту нотацию и ashget contents и putstr land написать вот в этой цепочке.
56:11
И написать вот в этом ту блоке внутри функции vizfile,
56:16
когда вот этот наш файл все еще открыт на чтение.
56:20
А не после, когда он уже закрыт на чтение.
56:23
Пример достаточно забористый, я признаю.
56:26
Но суть не в том, что функция vizfile какая-то плохая,
56:29
а суть опять же в том, что нужно всегда держать в голове
56:32
вот это не самое интуитивное поведение Haskell при работе с IO.
56:38
Давайте продолжим.
56:40
Да, и как же все-таки с этим жить?
56:42
Мы не будем подобно касаться того, как люди решают проблемы LazyIO,
56:46
потому что это достаточно комплексная проблема.
56:50
Самое легкое, самое простое, что мы можем делать, и проверенное временем решение,
56:55
это просто использовать какую-то библиотеку для стриминговой обработки данных,
57:02
в которую как раз-таки вшита нормальная и правильная работа с LazyIO,
57:07
и нельзя выстрелить себе в ногу.
57:08
Такие библиотеки — это Conduit, наверное, самая известная, также Pypes и Streaming.
57:14
Они просто предоставляют интерфейс для написания
57:16
каких-то пайплайнов работы с потоковыми данными,
57:20
которые в нужный момент форсятся, в нужный момент не форсятся,
57:24
для того чтобы поддерживать состояние вычисления рабочих.
57:30
Чтобы не было таких спецэффектов, как закрытый файловый дескриптор.
57:34
Логика этих библиотек достаточно продуманная, чтобы учитывать.
57:38
И есть еще один способ, как бороться с LazyIO.
57:43
Есть такой модуль, кстати, все эти функции вида
57:47
readfile и так далее находятся в модуле SystemIO.
57:54
И есть модуль, который называется SystemIO Streaming.
57:57
Все операции которого неленивые.
58:00
Соответственно, там не бывает спецэффекта LazyIO.
58:04
Но, к сожалению, это не панацея.
58:07
И использование строгого IEO тоже не очень хорошо.
58:10
Почему? Потому что если мы будем работать с файлами или данными,
58:14
размер которых достаточно велик и не влезает в оперативную память,
58:18
и мы бы хотели его обрабатывать как-то по кустам, чанками,
58:21
то SystemIO Streaming не позволит нам это сделать,
58:24
потому что в момент вызова функции readfile он пойдет, прочитает файл,
58:28
и сразу все его содержимое запихнет в строку,
58:31
вычисляя при этом до слабой головной нормальной формы.
58:36
Вот. Потому что это строгие вычисления.
58:38
Поэтому если вы уверены, что вы используете какие-то небольшие объемы данных,
58:42
можете для уменьшения рисков столкнуться с проблемой LazyIO
58:48
воспользоваться модулем SystemIO Stream из стандартной библиотеки.
58:53
Иначе, если вы пишете какую-то комплексную
58:55
логику для взаимодействия с внешними ресурсами,
58:58
рекомендуется использовать, допустим, Conduit.
59:00
Очень хорошая библиотечка.
59:02
С интерфейсом, очень сильно похожим на стандартную
59:05
библиотеку, просто с более умными функциями.
59:09
Давайте пойдем дальше.
59:13
И кратко осветим такую вещь, как FFI, Foreign Function Interface.
59:19
Это про то, как дергать C-шный код, и не только C-шный код на самом деле,
59:23
а любой другой код, где calling conventions совпадают,
59:29
а у C и Haskell они совпадают, из Haskell.
59:34
Давайте заведем на файл simple.c такую функцию int.
59:40
example, которая принимает два инта, возвращает a плюс b.
59:44
И для того, чтобы использовать данную функцию в Haskell,
59:47
мы пишем вот такое расширение, Foreign Function Interface,
59:51
импортируем следующий модуль, который содержит нужные типы.
59:58
Это, соответственно, просто репрезентации C-шных типов в Haskell,
1:00:02
можно так сказать, потому что C-шный тип int,
1:00:06
которые платформозависимые в Haskell, будет cint.
1:00:09
Просто для того, чтобы было логическое разделение
1:00:12
между int-ами Haskell и int-ами C-шными.
1:00:15
И, соответственно, мы можем с помощью вот такой магической надписи
1:00:20
Foreign Import C-Call Safe Example, имя функции,
1:00:26
объявить эквивалентную сигнатуру в Haskell.
1:00:29
Вот, соответственно, это будет cint, cint, cint.
1:00:32
Если типы не сойдутся, то печаль, оно упадет.
1:00:38
Соответственно, у нас уже есть хаткельная функция example,
1:00:40
которая на самом деле при вызове будет вызывать
1:00:43
C-шную функцию example, и мы ее можем использовать.
1:00:44
Соответственно, cint – это также имеет instance класс она.
1:00:51
И поэтому можно вызывать функцию example от констанции 0.2 и 0.
1:00:55
27, и просто принять результат.
1:00:59
Можете пояснить, что значит конкретно C-Call Safe,
1:01:04
и можно ли что-нибудь интересное вместо них написать? C-Call Safe.
1:01:08

1:01:11
Я, к сожалению, не работал с FFI, это достаточно редкая штука,
1:01:16
поэтому я даже затрудняюсь ответить, если честно.
1:01:19
Вот есть про это статейки какие-то, но если есть safe, то, видимо, есть и unsafe.
1:01:26
Но, если честно, это довольно редкий кейс, который особо не встречается на практике,
1:01:31
только разве что, если мы пишем какие-то performance-sensitive вещи,
1:01:37
где нам может потребоваться C-шный код, где у нас performance хастеля не хватает.
1:01:44
Единственное использование FFI, которое я
1:01:46
видел, выглядит как-то так и ничего умнее.
1:01:49
То есть мы просто пишем импорт ряда каких-то C-шных функций.
1:01:54
Я уверен, что с этим можно делать что-то интереснее,
1:01:56
но, к сожалению, да, не могу вам об этом ничего сказать содержательного.
1:02:05
Окей, если дальше вопросов нет, давайте поговорим о мутабельных данных.
1:02:16
Представьте, что у нас есть какой-то специальный тип данных
1:02:23
для мутабельной обертки над какими-то данными,
1:02:25
который предоставляет интерфейс read variable,
1:02:28
который принимает вот эту нашу пока еще загадочную мутабельную переменную,
1:02:33
и write variable.
1:02:35
И представим, что это все у нас чистое,
1:02:38
не находится ни в какой монаде ее, и так далее.
1:02:42
Какие у нас могут быть проблемы в данном коде?
1:02:45
То есть у нас есть какая-то магическая мутабельная переменная,
1:02:49
у которой следующий интерфейс read и write.
1:02:51
И все это у нас чистое.
1:02:52
Есть ли какие-то проблемы по-вашему?
1:03:02
Опять же, порядок вычислений.
1:03:04
Да, да, опять же, порядок вычислений, во-первых.
1:03:06
Во-вторых, здесь мы видим, что результат функции
1:03:08
write variable у нас никак не используется,
1:03:11
поэтому это большой вопрос, будет ли вызвана данная функция.
1:03:17
Спойлера не будет.
1:03:18
Поэтому да, ровно так же, как и с работой с внешним миром,
1:03:23
работа с мутабельностью также требует какого-то порядка и гарантии
1:03:30
исполнения операции.
1:03:31
Поэтому такой интерфейс в Haskell есть,
1:03:34
и он обязывает находиться у нас в контексте IOR.
1:03:38
Данная мутабельная переменная называется IORF,
1:03:42
которая имеет следующий интерфейс.
1:03:43
Оно все находится в модуле data IORF,
1:03:47
и оно предоставляет непосредственно сам тип данных IORF.
1:03:51
Это просто коробочка, параметризованная каким-то типом,
1:03:55
внутри которой находится значение этого типа.
1:03:57
Соответственно, можно ее создать.
1:03:58
new IORF от нуля.
1:04:03
К сожалению, у нас не будет сигнатур.
1:04:09
Давайте я тогда их проговорю.
1:04:10
Функция new IORF принимает какой-то тип A и возвращает IOR от IORF A.
1:04:17
Соответственно, он возвращает нам эту коробочку IORF с нужным типом,
1:04:21
дополнительно к тому же находясь в контексте ее.
1:04:23
То есть var A будет иметь тип IORF A,
1:04:27
где A это пока что какой-то произвольный...
1:04:29
Давайте для простоты скажем, что это int.
1:04:32
Мы-то знаем, что числовые литералы Haskell полиморфные.
1:04:35
Поэтому var A это IORF int.
1:04:39
Затем у нас есть функция read IORF,
1:04:40
которая принимает IORF и возвращает IOR от результата.
1:04:43
В данном случае у нас результат будет IOR int.
1:04:48
Также есть функция write IORF, которая принимает IORF,
1:04:50
принимает новое значение, и результат у него будет пустой кротеж.
1:04:57
IOR пустой кротеж.
1:04:58
Поэтому мы здесь пользуемся урезанным виндом нашей дунотации.
1:05:04
Затем мы опять читаем IORF и возвращаем соответственно A0 и A1.
1:05:09
И данный код, в отличие от кода выше,
1:05:11
в силу того, что он используется в контексте IEO,
1:05:16
и все плюсы работы с IEO он имеет из коробки,
1:05:22
данный код работает корректно.
1:05:23
В том плане, что он не дескаргит никакие операции,
1:05:26
он их ни в коем случае не дуплицирует и выполняет в правильном порядке.
1:05:32
То есть все, что нужно знать о мутабельных данных в Haskell пока,
1:05:35
пока речь не идет о каких-то примитивах синхронизации,
1:05:41
работы с многоподочностью и так далее, то есть у этих
1:05:45
данных IORF мутабельный, который хранит в себе какой-то тип.
1:05:46
Мы туда можем писать, можем читать, можем создавать новые.
1:05:49
Все это в IEO.
1:05:51
Есть очень много полезных функций, допустим, modify, IORF и так далее,
1:05:54
которые более-менее интуитивно понятны, как работают.
1:05:59
Соответственно, у нас будет правильно выведено Foo.
1:06:02
Foo – это 0,1.
1:06:07
Также наряду с мутабельными переменами у нас есть мутабельные
1:06:15
массивы в Haskell, которые находятся в пакете data.array.io.
1:06:17
Он предоставляет тип данных IORF и функции по аналогии с IORF для работы с ними.
1:06:25
Соответственно, new array принимает у нас картеж из индексов данного массива.
1:06:34
Соответственно, данный массив будет иметь индексы от 1 до 10.
1:06:39
Вот такой вот странный интерфейс.
1:06:41
И также... а, нет, сейчас.
1:06:45
Дайте-ка вспомнить.
1:06:52
Что-то странное.
1:06:53
Я, если честно, даже забыл, как этот array выглядит,
1:06:56
потому что, спойлер, никто пакетом data.array.io не пользуется.
1:07:00
Все пользуются пакетом vector.
1:07:01
Поэтому я этот код не видел ни разу в жизни, кроме как на этом слайде.
1:07:05
Короче, мы можем создавать массив.
1:07:07
Можем читать от мотива по индексу.
1:07:09
Можем писать массив по индексу какое-то значение.
1:07:14
И также можем читать.
1:07:15
Давайте все-таки хорошо захуглим.
1:07:18
Блин, позорится, я вам скажу.
1:07:20
New array.
1:07:27
Боже мой, тут есть еще очень многое.
1:07:31
Data.array.
1:07:36
io Это, видимо, настолько старый слайд, что такого типа даже нет.
1:07:39
Короче, предлагаю забить.
1:07:41
Предлагаю забить на type.array.
1:07:43
io и использовать вместо него, если вам вдруг нужно, будет type.
1:07:48
vector, который находится в соответственном пакете vector.
1:07:52
Просто знайте, что мутабельные массивы есть.
1:07:54
Я надеюсь, вам их в жизни никогда не придется
1:07:57
использовать, потому что это достаточно редкая тема.
1:08:01
Сигнатура не самая понятная.
1:08:02
Я действительно забыл, что тут эти штуки значат.
1:08:04
Но факт остается фактом.
1:08:06
Можно объявить мутабельный массив, можно туда
1:08:09
почитать по индексу, можно записать по индексу.
1:08:16
Даже тут говорится про то, что нужно вязать пакет vector,
1:08:20
который предоставляет как мутабельные, так и не
1:08:23
мутабельные массивы с константным доступом по индексу.
1:08:28
Такие дела.
1:08:33
Я предлагаю... Сейчас, давайте я посмотрю, сколько у нас с вами осталось уговорить.
1:08:40
Ладно, я предлагаю... Нам еще осталось, по моим предположениям, минут сорок.
1:08:44
Если вы хотите, мы можем идти сейчас на перерыв небольшой,
1:08:47
потому что у нас начинается относительно новая тема exception.
1:08:52
Также мы можем просто взять и продолжить, и пораньше уйдем.
1:08:57
Так что тут учитывать вам, скажите, как мы будем действовать.
1:09:06
Пораньше закончить.
1:09:07
Окей, окей.
1:09:09
Если никто не возражает... Да, все, в чате тоже пишут.
1:09:13
Окей, давайте.
1:09:15
Как мы знаем, везде, где у нас существует какая-то работа с внешним миром,
1:09:21
у нас могут возникать всякие разные исключительные ситуации.
1:09:24
Например, мы читаем из файла, который не существует.
1:09:28
Или же даже далеко хватить не надо.
1:09:30
Исключительные ситуации у нас бывают, когда мы работаем с чистыми функциями,
1:09:34
например, функция деления, которая выкидывает ошибку, если мы делим на ноль.
1:09:38
Сейчас мы очень кратко осветим, как механизм исключения
1:09:44
работает в Haskell, и какие есть вещи для работы с этим.
1:09:48
Начнем с функции throwIo,
1:09:50
которая принимает в качестве аргумента некий e,
1:09:54
который является exception,
1:09:56
и возвращаемый тип у него довольно странный, тип IoA.
1:09:59
Почему это так? Потому что, на самом деле, это расходящийся...
1:10:03
Логичный вопрос, откуда у нас берется A.
1:10:07
Все очень просто.
1:10:08
Когда мы бросаем exception, программа, точнее, наш поток заканчивает выполнение,
1:10:14
и, соответственно, результатом данной функции является bot.
1:10:19
Напоминаю, то есть невычисляемое, неэтифицируемое выражение.
1:10:23
Поэтому, в принципе, вместо IoA здесь могло бы быть
1:10:28
абсолютно что угодно, и это бы этифизировалось.
1:10:29
Это ровно то же самое, как у нас происходит с undefined.
1:10:32
То, что undefined у нас этифизируется любым типом.
1:10:35
Но просто так как у нас работа с исключениями по большей части тесно связана с Io,
1:10:44
используется тип IoA.
1:10:45
На самом деле тип возвращаемого значения здесь особо не играет роли,
1:10:49
потому что в случае вызова данной функции наша программа упадет.
1:10:54
Давайте посмотрим следующую функцию readAndDivide, которая возвращает IoInt.
1:11:01
Что она делает?
1:11:03
Она считывает два числа из консоли.
1:11:05
Представьте, что функция readDelay читает строчку и превращает ее в число.
1:11:10
Просто для простоты, чтобы было меньше кода.
1:11:12
Соответственно, мы считаем числа x и y, проверяем, что если y – это 0,
1:11:16
бросаем exceptionDivideBy0, который является одним из конструкторов ArithException.
1:11:23
Это тип суммы, который предоставляет собой
1:11:26
часто используемые исключения в арифметике,
1:11:31
которые взяты из модуля ControlException из стандартной библиотеки.
1:11:34
Короче, если y – это 0, мы кидаем exceptionDivideBy0,
1:11:38
иначе мы уверены, что y – это не 0, и возвращаем из нашей функции xDiv.
1:11:43
И давайте вызовем эту функцию в Garsci.
1:11:46
Соответственно, если вызвать функцию
1:11:48
readAndDivide, написать 7, 3 – это все отработает.
1:11:51
Если написать 3, 0, то у нас выйдет exceptionDivideBy0.
1:11:54
То есть наша программа закончит свое выполнение
1:11:57
с исключением на этой строчке, нашей doNotation.
1:12:02
Пока что ничего специфичного, что бы отличало Haskell от других языков.
1:12:09
Единственное, что возможно throw в многих языках – это оператор кейборда языка.
1:12:14
Здесь функция throwIo. Это просто функция из стандартной библиотеки.
1:12:20
Ничего в ней магического, на первый взгляд, и нет.
1:12:24
Если везде, когда речь встает про исключения,
1:12:27
очевидно, нам интересно не то, как их кидать, но также, как их ловить.
1:12:32
Для этого у нас существует функция catch, которая также требует от нашего типа E,
1:12:40
чтобы это был некий exception. Что такое exception?
1:12:43
Как вы уже догадались, это type class. Мы разберем через пару слайдов буквально.
1:12:47
Он принимает какое-то EO-шное действие и также принимает обработчик исключений.
1:12:53
Если в случае выполнения этого EO-шного действия EOA вылезет какое-то исключение E,
1:12:59
то мы обрабатываем это исключение, и результирующий тип также должен быть EOA.
1:13:05
И, соответственно, результирующий тип всей этой истории – это также EOA.
1:13:09
Соответственно, в этой нашей хендлер-функции, в catch,
1:13:14
мы можем почистить какие-то ресурсы и выбросить это исключение обратно,
1:13:18
потому что, напоминаю, тип функции throwIo – это EOA.
1:13:21
Также мы можем вернуть, например, какое-то дефолтное значение.
1:13:24
Поэтому это уже поведение специфицируется нами, как программистами.
1:13:29
Функция catch позволяет сделать оба этих действия.
1:13:33
Давайте посмотрим, как выглядит функция saveReturnDivide.
1:13:36
Соответственно, это вызов функции returnDivide определенный на прошлом слайде
1:13:40
и с соответствующим обработчиком исключений.
1:13:45
Если у нас вылетает исключение divide by 0, то мы возвращаем минус единицу.
1:13:50
Соответственно, вот эта функция имеет тип, напоминаю, exceptionE из EOA.
1:13:56
Мы ловим, паттерн-матчимся по исключению divide by 0 и return минус единицу.
1:14:04
Логичный был бы вопрос, а что будет, если сюда
1:14:09
прилетит какой-то другой экземпляр, а это exception.
1:14:10
К сожалению, это упадет тем, что у нас non-exhaustive pattern match.
1:14:15
Но здесь для простоты это мы приведем.
1:14:18
Здесь для простоты мы не стали unknown exception ловить.
1:14:24
Вот есть ли какие-то вопросы по тому, как на таком
1:14:29
достаточно интуитивном уровне пока что ловить исключения?
1:14:32
Верно ли, что по-хорошему мы должны были исправить
1:14:37
non-exhaustive pattern match каким-то методом?
1:14:43
Как не будете реализовать то, что если это не
1:14:46
division-базирует, то нужно это выкинуть обратно?
1:14:49
Или это так не делать?
1:14:53
В данном случае, знаете, довольно тяжело рассматривать
1:14:57
этот пример, потому что мы знаем, что функция return
1:14:59
divide ничего кроме divide by 0 не вылетает.
1:15:02
Но, допустим, если мы рассматриваем какой-то более реальный код,
1:15:04
очевидно, что нам нужно обрабатывать все кейсы pattern matching.
1:15:11
Потому что если у нас есть какая-то data my hero равно my hero 1 или my hero 2,
1:15:17
очевидно, нам не нужно ловить только my hero 1.
1:15:19
В случае my hero 2 нам нужно выкинуть какое-то исключение дальше.
1:15:26
То есть наша программа не должна падать с какими-то
1:15:28
хаскельными ошибками в духе non-exhaustive match.
1:15:31
В данном случае мы можем написать что-то типа, мы можем выбросить исключение,
1:15:35
добавив к нему то, что это исключение неожиданное,
1:15:38
то есть unexpected year, и просто перебросить это исключение дальше.
1:15:42
Да, конечно, данный пример просто, чтобы
1:15:45
уложился в одну строчку, написан для простоты.
1:15:48
Ничего более.
1:15:55
Ну, давайте пойдем дальше.
1:16:00
Тут вы видите две большие красные надписи про то, что на самом деле, как вы видите,
1:16:09
в IEO у нас могут быть выкинуто на самом деле любое исключение.
1:16:15
Здесь мы видим по ассигнатуре функции catch, что это
1:16:18
должен быть какой-то произвольный exception, которых много.
1:16:22
И оно не ограничивается одним лишь arith exception.
1:16:26
Про то, каким образом у нас здесь появился именно
1:16:29
arith exception, мы поговорим прямо сейчас.
1:16:31
Знаете то, что система exception в хаскеле,
1:16:34
ее называют по-другому untyped exceptions.
1:16:37
Потому что мы заранее не типизируем, не специфицируем типы исключений,
1:16:43
которые могут полететь из нашей функции, которую мы вызываем.
1:16:47
Когда мы пишем обработчик исключений какой-то функции, на
1:16:50
самом деле оттуда может вылететь более-менее любое исключение.
1:16:54
Сейчас мы об этом поговорим.
1:16:55
И это, к сожалению, никаким образом не представляется в системе типа в хаскеле.
1:17:01
Сейчас мы будем с этим бороться.
1:17:04
Я вставил сюда буквально пару слайдов про то, что же
1:17:07
все-таки такое exception в хаскеле и с чем их едят.
1:17:11
Давайте заведем какое-то data.myException равно data.
1:17:16
myException и задерайвим у него следующий type-класс show.
1:17:22
Понятно, мы можем его задерайвить.
1:17:25
Задерайвим какой-то непонятный type-класс
1:17:26
typable, который пока непонятно зачем нужен.
1:17:29
И также задерайвим type-класс exception.
1:17:31
Да, exception у нас может быть задерайвим.
1:17:34
И, соответственно, таким образом, при подключении соответствующих расширений.
1:17:40
Соответственно, таким образом, мы можем использовать наш type.
1:17:46
myException, а точнее один его конструктор data.myException в функции throw.io и catch.
1:17:53
Соответственно, если мы в GHCI напишем throw.
1:17:57
io data.myException, то никакой ошибки типов не произойдет.
1:18:02
Наш data.myException действительно является инстантом
1:18:05
эксепшена, и хаскель позволит нам его выкинуть.
1:18:08
Соответственно, если мы рассмотрим следующий блок кода, то в GHCI действительно
1:18:11
можно писать многострочные блоки кода с пользованием логикового синтеза.
1:18:15
Если мы кинем data.myException, и затем сразу же поймаем data.myException, и
1:18:19
напишем в нашем хейдлере, что data.myException is thrown, и вызовем данный код,
1:18:24
то действительно выявится то, что data.myException is thrown.
1:18:28
Пока что все весьма и весьма прямолинейно.
1:18:34
Давайте уже все-таки посмотрим, что же такое type-класс
1:18:39
exception, и какие связанные с ним дата-тайпы бывают.
1:18:43
Давайте пока на верхнюю строку забьем и посмотрим на type-класс exception.
1:18:50
Type-класс exception требует для себя следующие constraints.
1:18:53
Это show для того, чтобы наше исключение можно
1:18:56
было выводить на консоль функции display exception.
1:19:00
И также некоторый type-класс typable.
1:19:03
Type-класс typable – это такой специальный
1:19:05
type-класс, который будет освещен далее в курсе.
1:19:09
Я вам скажу очень кратко, что это type-класс, который
1:19:12
позволяет для типа E в рантайме извлекать информацию о типе.
1:19:16
Для того, чтобы понимать исключение какого именно типа мы выбрали.
1:19:20
Да, в таскеле есть некоторый аналог рефлекшена, который,
1:19:23
допустим, есть в Java, и он представлен type-классом typable.
1:19:27
Более детально данный type-класс будет озвучен, наверное, лекцией через 3-4.
1:19:31
Пока что знаете, что такой type-класс есть, его можно дерайвить, и на этом все.
1:19:36
В type-классе exception есть следующие функции.
1:19:38
Display exception, как мы уже говорили, который берет E и печатает ее строчку.
1:19:46
По дефолту это реализовано по кратке через show.
1:19:50
И также есть две очень интересные функции,
1:19:52
которые называются from exception и to exception.
1:19:56
И сейчас давайте же все-таки разбираться.
1:19:58
На exception в таскеле реализовано что-то типа наследования внезапно.
1:20:04
Потому что у нас есть некий тип данных some
1:20:07
exception, который выглядит следующим образом.
1:20:11
Можно не особо обращать внимание на то, как синтаксически он записан.
1:20:15
Потому что, опять же, это тема следующих лекций.
1:20:19
Но так как про exception мы говорим уже сейчас, важно хотя бы абсурдно понимать,
1:20:22
как работает механизм exception без углубления в детали.
1:20:25
Some exception – это, можно сказать, предок всех exception.
1:20:28
Если мы рассматриваем как такое псевдо-наследование.
1:20:32
Или же можно рассматривать some exception как какую-то коробочку,
1:20:35
тип данных коробка, в которой лежит какое-то exception.
1:20:39
В нем лежит какое-то е, которое является представителем этой класса exception.
1:20:46
Соответственно, у нас есть две функции.
1:20:47
From exception и to exception.
1:20:49
From exception пытается достать из коробки some
1:20:52
exception, в которой лежит какое-то исключение.
1:20:56
Он пытается его привести к нашему конкретному
1:20:58
исключению, для которого мы пишем instance.
1:21:00
Соответственно, здесь у нас есть maybe e.
1:21:02
Потому что у нас в общем случае в коробке some
1:21:05
exception может лежать абсолютно любое исключение,
1:21:07
как file not found, так там divide by zero или что-то еще.
1:21:11
И функция from exception позволяет, когда у нас есть какое-то
1:21:15
исключение, понять, нужное ли это исключение нам сейчас.
1:21:18
То ли это исключение, в котором мы работаем.
1:21:20
Потому что, допустим, для file not found у нас может быть отдельный обработчик.
1:21:23
А для другого исключения – другой обработчик.
1:21:25
Вот есть такая функция from exception.
1:21:27
Здесь как раз-таки играет роль наш type class typable,
1:21:30
который позволяет получить информацию о типе,
1:21:32
чтобы понять, то ли это исключение или нет.
1:21:34
И также есть функция to exception.
1:21:36
To exception просто запаковывает наше исключение e в коробку some exception.
1:21:41
Итого резюмируем.
1:21:43
Exception в Haskell это type class, у которого есть следующие функции.
1:21:48
Display exception, которые просто печатают строку.
1:21:51
И также две функции для конверсии из и в some exception.
1:21:56
Some exception – это коробочка, которая хранит любое исключение.
1:22:01
Либо же, если мы рассматриваем это как иерархию,
1:22:03
можно сказать, что some exception – это предок всех исключений.
1:22:07
Потому что он может быть с помощью to exception для
1:22:10
любого типа exception приведен к some exception.
1:22:17
И к чему, собственно, идет речь?
1:22:22
Речь идет к тому, что, как здесь уже писалось,
1:22:27
в Haskell и в IEO может быть выброшено абсолютно любое исключение.
1:22:31
И вот как раз-таки наша коробочка some exception нужна для того,
1:22:35
чтобы… это репрезентация как раз-таки любого исключения.
1:22:39
Some exception – это какое-то некоторое исключение, которое брошено.
1:22:43
И если же мы в нашей функции, в какой-нибудь обработчике,
1:22:46
хотим ловить любое исключение, мы должны ловить some exception.
1:22:51
Потому что здесь, допустим, если у нас функция read
1:22:53
and divide выбросила исключение file not found,
1:22:55
ну, бывает, допустим, если мы считываем чисел
1:22:58
из файла, то вот наш хендлер его не пропустит.
1:23:01
Он стригерится только, когда у нас будет arise exception,
1:23:05
конструктором которой является divide by zero.
1:23:07
Если уже у нас полетит какой-то другой
1:23:09
exception, данный хендлер просто не отработает.
1:23:11
Если же мы хотим в нашем хендлере поймать абсолютно
1:23:15
любое исключение, мы ловим здесь some exception.
1:23:17
И тогда наш хендлер стригерится абсолютно на любое исключение.
1:23:20
А уж потом этот some exception мы можем пощупать, распаковать, допустим,
1:23:23
с помощью form exception и понять, а это divide by zero или это file not found.
1:23:28
И если это там ничего, что нам неизвестно,
1:23:31
потому что exception на самом деле бесконечное
1:23:34
количество, мы можем для любого написать exception,
1:23:37
мы можем какое-то конечное множество exception потрогать,
1:23:40
посмотреть как-то специфичным образом, обработать вшивку.
1:23:44
Если у нас не получилось извлечь какой-то внятный
1:23:47
exception, который мы знаем, мы просто вытянем его обратно.
1:23:51
Соответственно, за этим вот этот some exception – это некоторый такой механизм
1:23:59
задать возможность ловить любой exception.
1:24:03
Потому что в Haskell нет наследования.
1:24:05
Нельзя просто взять и отнаследоваться от exception как в какой-нибудь джебе.
1:24:08
Пришлось вот так вот изгаляться.
1:24:10
Скажите, пожалуйста, насколько понятно то, что сейчас происходит?
1:24:14
Потому что это довольно сложновато, на мой взгляд.
1:24:29
Получается, Haskell – фп-язык, но exception
1:24:30
с наследованием, или я до конца не понимаю?
1:24:32
На самом деле, наследование я всегда употреблял в кавычках,
1:24:36
потому что никакого наследования, очевидно, нет.
1:24:39
Просто об этом удобно думать, что есть некоторые общие исключения,
1:24:45
которые являются как бы предками всех остальных исключений.
1:24:49
Но об этом можно думать.
1:24:52
Семантически это абсолютно не так.
1:24:54
Семантически вот эта иерархия реализована просто
1:24:57
запаковыванием какого-либо exception в коробочку.
1:24:59
То есть на деле никакого наследования нет.
1:25:01
Просто в силу того, что раньше вы работали с языками программирования,
1:25:07
в которых exception реализованы через наследование, об этом удобно думать.
1:25:12
Но на самом деле ничего, кроме запаковывания
1:25:14
и распаковывания коробки, тут не происходит.
1:25:17
Поэтому если вам неудобно об этом думать, как о наследовании, можете не думать.
1:25:20
Думайте как о коробке, в которой лежит год в мешке какой-то исключения.
1:25:30
Все, супер.
1:25:31
Давайте же, наконец-то, найдем применение тому, что я сейчас говорил,
1:25:36
и напишем какую-то функцию с использованием вот этого
1:25:39
сам эксепшена и механизма эксепшена в полной мере.
1:25:43
Давайте напишем функцию try, read and divide,
1:25:46
у которой имеется тип IO от either string in.
1:25:49
Соответственно, у нас может быть либо
1:25:51
стринговая ошибка, либо интовый результат в IO.
1:25:54
Заиспользуем нашу функцию read and divide и навесим на нее следующий хендлер.
1:25:59
Заметьте, здесь мы хотим ловить любое исключение,
1:26:03
поэтому мы явно указываем тип, что мы ловим сам эксепшен.
1:26:08
И делаем с ним следующее. Наш хендлер ловит
1:26:12
наиболее общий тип исключения, ловит сам эксепшен.
1:26:16
Соответственно, e – это у нас сам эксепшен, и мы
1:26:19
пытаемся его привести к эксепшену divide by zero,
1:26:22
чтобы в случае, если это divide by zero, вернуть
1:26:25
одну ошибку, а в другом случае – другую ошибку.
1:26:29
Соответственно, если у нас from exception – это
1:26:31
divide by zero, тут, к сожалению, пропущен maybe.
1:26:35
Но тут и должен быть just. Just divide by zero error –
1:26:39
это maybe divide by zero, потому что у нас вот тут maybe.
1:26:43
К сожалению, это ошибка. Когда я этот слайд готовил, я это не углядел.
1:26:46
Итого, мы ловим наиболее общее исключение и
1:26:48
пытаемся понять, что же нам с ним сделать.
1:26:51
Давайте попробуем с помощью функции from
1:26:54
exception привести его к эксепшену divide by zero.
1:26:56
Ага, если мы это смогли сделать, значит у нас настрой эксепшен,
1:26:59
который был кинут, на самом деле – это эксепшен divide by zero.
1:27:03
И давайте вернем left display exception divide by zero.
1:27:07
Соответственно, мы выведем надпись, какой-то текст,
1:27:11
который специфичен конкретно данному типу ошибки.
1:27:15
Если же у нас не получилось с помощью функции from exception получить
1:27:19
just что-то там, just divide by zero, здесь мы получаем nothing.
1:27:23
И если же мы получили nothing, значит это какой-то другой
1:27:26
неожиданный тип исключения, который мог быть брошен.
1:27:29
И мы с этим ничего отмысленного не можем сделать,
1:27:32
просто как вернуть left something else happened.
1:27:36
Логичный вопрос. Каким образом у нас здесь появляется сам эксепшен?
1:27:41
Ведь если мы вспомним функцию read done divide, мы кидаем divide by zero.
1:27:46
На самом деле, в Haskell, магическим образом, все
1:27:49
кинутые эксепшены могут заворачивать сам
1:27:53
эксепшен, если наш хендлер ожидает сам эксепшен.
1:27:55
Поэтому, несмотря на то, что мы кидаем divide by zero,
1:27:59
у нас работает некоторое неявное приведение типов.
1:28:02
На самом деле, это вызывает функцию doException, чтобы у нас,
1:28:06
как у программистов, была возможность поймать любое исключение.
1:28:11
Поэтому Haskell, магическим образом, может запаковывать любой
1:28:15
эксепшен в сам эксепшен, чтобы у нас была возможность его поймать.
1:28:22
В принципе, более-менее все про идею эксепшенов в Haskell.
1:28:31
Она, как вы видите, довольно странная.
1:28:35
Но внезапно она очень хорошо работает, и
1:28:38
очень хорошо легла в эту Haskell парадигму.
1:28:42
Потому что эксепшены в Haskell, исходя из моего опыта, с ними довольно удобны.
1:28:46
Несмотря на то, что сам эксепшен, на первый взгляд, кажется чем-то очень странным,
1:28:51
почему у нас происходит какая-то магическая
1:28:53
запаковка эксепшенов, потому что мы их как-то кастим.
1:28:57
На самом деле, а как по-другому?
1:28:59
Наследования-то нет на эксепшенах, поэтому приходится изгаляться.
1:29:03
Но это внезапно вышло довольно удобно.
1:29:05
Короче, если есть у кого какие-то вопросы по эксепшенам, задавайте.
1:29:10
Если нет, будем двигаться далее.
1:29:12
Поговорим еще чуть-чуть про них, и поговорим уже про другие интересные вещи.
1:29:18
Почему для типа результата используется either?
1:29:21
В плане нет ли какого-то аналога, у которого
1:29:24
вместо left и right были бы нормальные названия,
1:29:27
понятные типа error и result?
1:29:30
А что вызов непонятного-то?
1:29:34
Действительно используется either.
1:29:37
Где в Rust используется result, там в Haskell используется either.
1:29:40
Просто есть такая конвенция, что left это ошибка, right это результат.
1:29:44
Возможно, действительно имело бы смысл назвать
1:29:47
result, но называется either все привыкли.
1:30:00
Окей, если никаких вопросов нет про эту страшную
1:30:03
магию с эксепшенами, давайте продолжать.
1:30:06
Потому что эксепшены будут еще раз освещены,
1:30:09
тоже довольно подробно, в лекции про concurrency.
1:30:13
Пока что можно остановиться на каком-то
1:30:16
общем представлении о том, как это работает.
1:30:20
Поговорим еще про интересные функции работы с
1:30:22
исключениями в IO, которые есть в стандартной библиотеке.
1:30:26
Есть функция try, которая на самом деле является более-менее ее частным случаем.
1:30:33
Это функция, которая принимает иошное действие и возвращает IO от either е а,
1:30:38
где вот этот е – это исключение.
1:30:40
Как на самом деле реализован try?
1:30:42
Это просто вызывается иошное действие с
1:30:44
хендлером таким, что если мы поймали исключение, мы просто заворачиваем его в left.
1:30:49
Иначе мы возвращаем right.
1:30:50
Вот эта функция называется try.
1:30:52
Есть также функция try just, которая принимает, помимо всего этого,
1:30:56
какой-то конвертер из нашего исключения в какой-то тип данных maybe b.
1:31:01
Допустим, это выкипает некий фильтр для эксепшенов.
1:31:05
Потому что функции try just мы ловим не все эксепшены, как функции try,
1:31:10
а только те эксепшены, которые в случае вот этой конверсии превратились в just.
1:31:14
Допустим, мы можем написать, что если это какой-то нужный нам тип эксепшенов,
1:31:18
или какое-то логическое выражение, то тогда мы возвращаем just.
1:31:23
Если же это какой-то левый эксепшен, мы возвращаем not.
1:31:25
И таким образом try just у нас ловит только те эксепшены,
1:31:31
которые проходят эту проверку, можно так сказать.
1:31:35
Есть также функция finally, которая принимает два иошных действия.
1:31:40
Принимает иошное действие, которое запускается первым,
1:31:45
и также иошное действие, которое запускается по прошествии первого действия.
1:31:51
Даже если там было выброшенное исключение.
1:31:53
То есть, соответственно, там просто навишен хендлер,
1:31:55
который в случае исключения также исполняет вот это действие.
1:31:58
Если исключение не произошло, это действие также исполнится.
1:32:03
Ровно то же самое, что конструкция finally в других языках,
1:32:06
только в Haskell это функция, а не кейворд.
1:32:09
Суть и дело не меняет.
1:32:11
Также есть функция onException, которая похожа на finally,
1:32:14
но вот это второе наше действие не исполняет, если эксепшена не произошло.
1:32:18
То есть это действие, которое выполняется в случае, в одникновение, исключения.
1:32:23
И также есть достаточно важная функция, которая называется bracket,
1:32:26
которая представляет из себя вот эту idiom array,
1:32:31
resource acquisition is initialization.
1:32:37
Когда мы работаем с какими-то ресурсами, которые хочется
1:32:44
открывать и закрывать по прошествии работы с ними.
1:32:45
Вот функция withFile, которую мы рассматривали до этого,
1:32:49
она как раз таки тоже была написана в так называемом bracket pattern.
1:32:54
Давайте посмотрим, что такое bracket.
1:32:56
Она принимает в себя первым аргумент какое-то иошное действие с результатом типа a,
1:33:02
где a – это тип нашего ресурса.
1:33:04
То есть это действие, которое берет ресурс
1:33:07
и возвращает нам его в качестве результата.
1:33:10
Оно выполняется первым.
1:33:13
Вторым аргументом мы принимаем действие с этим ресурсом по закрытию ресурса.
1:33:18
Оно запускается последним.
1:33:20
То есть оно принимает наш ресурс и возвращает
1:33:23
какой-то iob, это результат закрытия ресурса.
1:33:25
Соответственно, это может быть, допустим, открытие
1:33:28
файла, а вот это может быть закрытие файла.
1:33:30
И третьим аргументом оно принимает computation to run in between.
1:33:34
Как раз таки какое-то действие, которое зависит от нашего ресурса,
1:33:37
принимает его в качестве аргумента и возвращает результат действия.
1:33:40
Соответственно, результатом всего этого будет ioc.
1:33:44
Как это происходит?
1:33:44
Берется ресурс, вызывается действие по взятию ресурса, возвращается ioa.
1:33:51
Потом этот ресурс скармливается в это действие, результатом которого ioc.
1:33:56
А после выполнения этого действия ресурс закрывается,
1:34:00
но вот это ioc возвращается как результат.
1:34:03
И эта функция очень удобна для взаимодействия с
1:34:07
киберфайлами или с открытием каких-нибудь сокетов,
1:34:10
потому что она обезопасивает нас от случаев,
1:34:13
когда возникает исключение, и ресурс не будет закрыт.
1:34:19
Вот в случае функции bracket, вот это computation to run last
1:34:22
вызывается всегда, вне зависимости от того, было ли выброшено исключение или нет.
1:34:28
И таким образом к концу работы функции bracket мы точно знаем,
1:34:30
что ресурс вначале был открыт, а в конце был закрыт.
1:34:33
Вот такая вот удобная функция с весьма страшной, на первый взгляд, сигнатурой,
1:34:37
но если ее посмотреть, все будет довольно понятно.
1:34:46
Давайте продолжать дальше, если нет никаких вопросов
1:34:50
по вот этим вот вспомогательным функциям по работе с исключениями.
1:34:56
Давайте посмотрим на такую вещь, как паттерн гарды.
1:35:01
Давайте особо не будем обращать внимание, что у нас есть
1:35:05
какая-то функция lookup из какой-то finite map и int в maybe int.
1:35:09
Давайте не будем погружаться в что такое finite map,
1:35:13
просто это какая-то функция, которая принимает какой-то объект, какой-то индекс
1:35:17
и возвращает maybe по индексу, есть ли там или нет.
1:35:21
И давайте посмотрим, что мы с этой функцией можем сделать.
1:35:24
Давайте напишем функцию addlookup, которая, что будет делать,
1:35:28
она в этой нашей мапе будет искать два числа,
1:35:31
если они оба just, их складывать, иначе возвращать nothing.
1:35:36
Это можно использовать с do notation,
1:35:39
во-первых, это можно в тупую написать через два кейса,
1:35:42
вложенных, как у вас было в предыдущей лекции,
1:35:44
просто кейс на lookup var1, потом lookup var2,
1:35:48
что может быть преобразовано на самом деле через mayb1ado,
1:35:53
допустим, в do notation.
1:35:54
Это очень удобно написать в do notation.
1:35:56
Но это также можно сделать с помощью альтернативного
1:35:59
синтекса, который называется pattern guards.
1:36:01
Это никак у нас не связано с IO, это просто ответвление в сторону.
1:36:06
Давайте напишем функцию addlookup,
1:36:08
которая принимает какой-то environment в виде нашего мапа
1:36:11
и принимает два индекса, которые мы будем искать.
1:36:13
Возвращает maybe int.
1:36:14
И вместо того, чтобы в самом теле функции начать матчиться по каким-то значениям,
1:36:20
мы можем начать матчиться по каким-то значениям в guard.
1:36:22
Почему нет?
1:36:23
Вы помните, что такое guard?
1:36:25
Это когда мы пишем логические выражения,
1:36:27
и если они эвалютируются в true, то выполняется тело функции.
1:36:31
Так вот, помимо логических выражений, там может быть матч.
1:36:34
Соответственно, в данное тело функции мы зайдем,
1:36:38
если вот этот вот матчинг и вот этот вот матчинг обработают корректно.
1:36:42
Соответственно, если lookup вот этот и lookup вот
1:36:45
этот вернут just, мы можем выполнить эту функцию.
1:36:48
Если же где-то здесь был nothing,
1:36:51
то вызывается какое-то из других уравнений,
1:36:53
других тел нашей функции addlookup, которая описана ниже.
1:36:59
Довольно незамысловатая конструкция.
1:37:01
Я надеюсь, тут все понятно.
1:37:03
Можно творить какие-то страшные нечитаемые вещи с этим.
1:37:06
Какие-то strange operations над списком,
1:37:09
если сумма списка – это 7,
1:37:11
если длина списка – это n,
1:37:13
такое, что n больше 5 и меньше 20,
1:37:15
тогда мы возвращаем iq.
1:37:17
Иначе что-то другое.
1:37:20
Все, что общего здесь есть с denotation и с monads,
1:37:24
это то, что используется в такой же синтезе стрелочки.
1:37:27
Но, пожалуйста, не путайте его с denotation.
1:37:31
Это другое.
1:37:32
То есть в гардах можно писать как паттерны,
1:37:35
как мы сейчас написали, так и логические выражения.
1:37:37
А можно их мешать, как видим вот здесь.
1:37:43
Это было такое немного ответвление стороны,
1:37:45
просто для того, чтобы, если будете читать какой-то код, вы не путались.
1:37:48

1:37:51
Давайте поговорим про такую вещь, как unsafe.
1:37:54
io и про то, каким образом в Haskell можно легко выстрелить себе в ногу,
1:37:59
работая с IO, не говоря уже о lazy.io.
1:38:03
Есть еще такая вещь, как unsafe.io.
1:38:05
В стандартной библиотеке есть такая функция, которая называется unsafe.perform.io.
1:38:13
У него тип из IO A.
1:38:16
Соответственно, оно берет и отбрасывает
1:38:19
какой-то наш IO контекст и возвращает результат.
1:38:22
На лекции про монады вы наверняка обсуждали то,
1:38:26
что, вообще говоря, достать значение из какой-либо
1:38:30
произвольной монады безопасным образом невозможно.
1:38:33
Так и в случае IO невозможно просто безопасным образом взять
1:38:37
и выйти из его контекста, если мы в него вошли.
1:38:40
Это может иметь довольно странные последствия.
1:38:43
Давайте сейчас это разберем.
1:38:45
Давайте посмотрим на функцию foo, точнее на константу foo.
1:38:49
Тело которой выглядит следующим образом.
1:38:51
Мы печатаем храчку foo в консоль.
1:38:53
Здесь тип данных IO пустой картеж.
1:38:55
И мы избавляемся от IO с помощью пустого картежа.
1:38:59
И также зайдем в функцию bar.
1:39:01
Также константу, да.
1:39:03
На самом деле константу не функция.
1:39:06
Которая в дунотации пишет в консоль bar, возвращает базу,
1:39:12
и все это магическим образом распаковывается из IO.
1:39:16
И, наконец, заиспользуем эти две функции в функции main.
1:39:19
Сначала мы напишем let f равно foo, а затем выведем bar.
1:39:24
Вот, скажите, пожалуйста, вопрос зал, что
1:39:26
же будет напечатано в консоль в этом случае?
1:39:29
Чисто на интуиции, пока что не особо знаю, как работает у нас с функцией foo.
1:39:46
Нет предположений?
1:39:52
Какие у нас есть варианты?
1:39:54
Может вывестись foo, bar и баз, например.
1:39:58
Может вывестись просто bar и баз, и foo будет проигнорировано.
1:40:01
Давайте же все-таки посмотрим.
1:40:04
Тут не пишется результат, но, короче, будет выведено bar и баз.
1:40:07
Почему? Потому что вот это вот наш результат функции foo.
1:40:12
Не используется, потому что мы ушли от его контекста,
1:40:16
который гарантирует нам выполнение всех операций и порядок на них.
1:40:20
Соответственно, у нас foo стало просто константой.
1:40:23
Так как мы ее нигде не используем, не требуется
1:40:26
вычисление ее до слабоголовной нормальной формы,
1:40:29
данное выражение просто берется и игнорируется.
1:40:32
А put to sterile end bar отрабатывает полностью,
1:40:35
потому что нам нужен результат функции bar,
1:40:39
константа bar, которая на самом деле выглядит
1:40:41
как функция, потому что тут есть действия разные.
1:40:45
Соответственно, когда мы вычисляем bar, у нас
1:40:47
происходит печать bar в консоль и возвращение баз.
1:40:50
А потом вот саму баз отпечатывается.
1:40:52
Короче, в результате будет выведено bar и баз, ровно в таком же порядке.
1:40:55
Согласитесь, данный код весьма и весьма неинтуитивный.
1:41:02
Поговорим о следующем примере.
1:41:04
Заведем такую функцию helper.
1:41:05
Так а зачем вообще в принципе использовать unsafeperform.
1:41:08
io, если он вызывает проблемы?
1:41:12
Если использовать его по-умному, иногда он бывает полезен.
1:41:15
Об этом мы поговорим немного попозже.
1:41:18
У unsafeperform.io есть полезные аппликейшены,
1:41:20
которые повсеместно используются в Haskell.
1:41:24
Просто нужно знать, сейчас мы о нем говорим.
1:41:27
Сейчас мы говорим об unsafeperform.io, чтобы понимать,
1:41:31
в каких случаях он может доставлять проблемы.
1:41:33
Потому что в каких-то случаях он их не доставляет.
1:41:35
И вот как раз таки у этих случаев есть довольно интересные и полезные применения.
1:41:41
Конечно, если бы это была абсолютно бесполезная вещь, мы бы о ней не говорили.
1:41:48
Давайте рассмотрим функцию helper, которая на самом деле тип из a в io.a.
1:41:54
Что она делает? Она принимает какое-то значение
1:41:57
произвольное, печатает его и возвращает.
1:42:01
Соответственно, у a должен быть constraint show, что немаловажно в данном случае.
1:42:07
Соответственно, мы печатаем и возвращаем ее в ёжном контексте.
1:42:10
И давайте напишем функцию main, которая сначала что делает?
1:42:14
Она вызывает helper от единицы, и его результат присваивает переменной 1.
1:42:18
Вызывает helper от двойки, присваивает результат переменной 2.
1:42:21
И печатает у нас 1 плюс 2.
1:42:25
Можем ли мы в данном случае гарантировать порядок?
1:42:28
Что будет выведено в консоли в данном случае?
1:42:32
Опять же вопрос в зал.
1:42:39
1, 2, 3.
1:42:41
Да, все правильно, потому что мы находимся в ио-контексте.
1:42:46
Потому что у нас порядок детерминирован, определен.
1:42:49
Ничего не идет не так.
1:42:50
И давайте потихоньку нашу функцию helper, как и функцию main,
1:42:54
потихоньку делать все более и более unsafe.
1:42:57
Давайте изменим тип функции helper, чтобы это был тип из a в a,
1:43:01
с помощью добавления unsafe performer 1 над всей вот этой штукой.
1:43:04
Соответственно, она спечатается, возвращается, а потом сбрасывается в его контекст.
1:43:08
И делаем как let 1 равно helper 1, let 2 равно helper 2, и print 1 плюс 2.
1:43:15
Как вы уже догадались, порядок на данных действиях мы гарантировать не можем.
1:43:20
И может быть выведено как 1, 2, 3, так и 2, 1, 3.
1:43:27
Давайте теперь сделаем ее частично unsafe.
1:43:32
Вернем функцию helper, как было, оставим ее иошной.
1:43:36
И для единички будем вызывать ее в иошной манере, в безопасном.
1:43:41
А для двойки обернем все это дело в unsafe.
1:43:45
Избавимся здесь от monad и используем обычный let.
1:43:48
Можем ли мы здесь иметь предположение над порядком?
1:43:51
Потому что казалось бы, у нас все логично.
1:43:54
Сначала вычисляется 1, потом вычисляется 2.
1:43:57
Мы же идем по нотации сверху вниз.
1:43:59
А потом 1 плюс 2 – это 3.
1:44:02
Или же здесь тоже какая-то собака зарыта.
1:44:05
И не все так очевидно.
1:44:06
Кажется, все еще зарыто.
1:44:09
Да.
1:44:11
Вот это let 2, оно же отбросило IO-контекст, поэтому
1:44:14
экземпляры реального мира не передаются никуда.
1:44:18
И компилятор может перестирать, что как хочет.
1:44:21
Да, абсолютно верно.
1:44:22
Абсолютно верно.
1:44:23
Более того, когда мы говорим о do-нотации, где идут перемешку бинды и let выражения,
1:44:32
нет абсолютно никакой гарантии того, что let выражения, вот
1:44:37
это let выражение, будет вычислено после вот этого бинда.
1:44:39
Почему?
1:44:40
Собственно, эти же выражения, они чистые.
1:44:42
Компилятор может переупорядочить их каким угодно образом,
1:44:45
очевидно, не теряя зависимости между let выражениями.
1:44:49
Таким образом, вот это let 2 может быть вычислено
1:44:52
сначала, а потом может быть вычислено 1.
1:44:55
Так что, да, тут возможные варианты того,
1:45:00
что сначала создается 1, потом создается 2,
1:45:06
потом tank 2 форсится и вычисляется 1 плюс 2.
1:45:09
Потом также возможен вариант того, что сначала создается tank 2 и форсится,
1:45:15
а потом вызывается helper от единички и вычисляется результат.
1:45:20
Сейчас мы немного подробнее взглянем на это
1:45:22
и поймем, почему же все-таки так происходит
1:45:25
и каким же все-таки образом у нас работает функция unsafeperform.
1:45:28
io, разберем ее реализацию.
1:45:32
Напоминаем, как у нас выглядит бинд для Monado.
1:45:37
io и каким образом этот real-world токен у нас передается.
1:45:40
То, что он сначала скармливается нашему первому
1:45:43
действию, получается какое-то новое состояние.
1:45:48
И затем оно передается дальше по цепочке.
1:45:56
Давайте на это не будем обращать внимания, мне это не очень нравится.
1:45:59
Как у нас работает в общем виде оператор урезанного бинда?
1:46:06
Вот это настоящий бинд, который принимает действие и стрелка placely.
1:46:12
А как будет работать у нас урезанный бинд?
1:46:14
На самом деле он все еще пропагейтит наш токен дальше.
1:46:19
Смотря на то, что результат первого действия он игнорирует, как мы видим здесь,
1:46:25
вот этот токен, который воспроизвело первое
1:46:28
действие, он все также учитывает во втором действии.
1:46:32
И как же работает все-таки функция unsafeperform.
1:46:35
io? То, что у нас где-то определенно на верхнем
1:46:39
уровне такая вещь, как fake state token.
1:46:42
Это просто какое-то значение типа state real world.
1:46:48
И как раз таки unsafeperform.io работает так, что мы
1:46:51
вызываем наше егоршное действие на каком-то фейковом токене,
1:46:55
а не на том токене, который нам откуда-то пришел.
1:46:58
Потому что в случае unsafeperform.io ему не откуда приходить.
1:47:02
Потому что это действие может быть вызвано в чистом контексте.
1:47:05
Мы вызываем наше f на каком-то фейковом токене,
1:47:08
получаем следующий токен, который идет за фейковым,
1:47:12
если рассматривать как-то их по порядку, и получаем результат.
1:47:15
Отбрасываем этот токен, который идет за фейковым, и возвращаем результат.
1:47:21
Так вот у нас довольно прямолинейно работает функция unsafeperform.io.
1:47:25
И давайте если мы развернем нашу функцию main, самую последнюю ее реализацию,
1:47:32
то посмотрим, как же она работает в дешугерином виде.
1:47:37
То, что сначала может вызываться helper1 от какого-то у нас изначального токена s0,
1:47:43
который пришел в функцию main.
1:47:45
Мы можем получить первый токен.
1:47:47
А затем, когда мы вызываем helper2, вот здесь вот, мы этот токен не используем.
1:47:53
Почему? Потому что мы вызываем это действие
1:47:55
unsafe, вызываем его на фейковом токене.
1:47:57
Соответственно, результат этого фейкового токена мы игнорируем,
1:48:01
и вот этот токен первый мы используем только здесь.
1:48:04
Соответственно, вот это действие пропущено в нашей цепочке действий.
1:48:08
То, что мы используем здесь состояние внешнего мира
1:48:11
не то, которое запродюсировало у нас вот это действие,
1:48:15
что по-хорошему, а мы используем состояние на предыдущем действии.
1:48:19
Это один из вариантов.
1:48:20
Это в случае, если у нас вычисление пойдет вот по этому сценарию.
1:48:25
Если же вычисление пойдет по второму сценарию,
1:48:28
то сначала мы обратимся к фейковому токену,
1:48:32
проигнорируем его, а затем вызовем на начальном токене, что тоже неправильно,
1:48:37
потому что у нас первым иошным действием произошло вот это действие.
1:48:41
Соответственно, нам нужно его токен использовать дальше как результат.
1:48:45
Но мы используем самый лишь начальный токен, который у нас
1:48:50
передали в функцию main, и затем используем его и получаем новый
1:48:53
токен S1, который мы передаем в функцию main.
1:48:57
Соответственно, как-то так это выглядит под лупой, можно так сказать.
1:49:04
И что хочется сказать в заключение на этот счет,
1:49:06
что если вам особо это не нужно, не используйте янца и функции в Haskell,
1:49:11
да и вообще в любом другом языке программирования.
1:49:15
И общий паттерн, когда unsafeperform.
1:49:19
io работает и особо не вызывает никаких проблем,
1:49:24
но там тоже есть нюансы, это когда мы находимся вне IOManada вообще.
1:49:28
Потому что нам не страшно потерять какой-то
1:49:30
контекст, если у нас этого контекста нет.
1:49:33
Когда мы находимся в IOManada, вы видите, что использование unsafeperform.
1:49:36
io рождает недетерминированность.
1:49:40
То есть в зависимости от того, как компилятор перепорядочит инструкции,
1:49:44
мы можем получить как один результат, так и другой.
1:49:47
Тут дело даже не в том, что в результате. Результат – это ладно, одни и те же.
1:49:51
Но наши функции, так как они IO, они умеют производить некоторые side-эффекты.
1:49:57
И эти side-эффекты могут зависеть друг от друга.
1:50:02
Side-эффекты, выполненные в одном порядке, могут давать одно состояние программы.
1:50:07
Один результат программы.
1:50:08
Side-эффекты, выполненные в другом состоянии,
1:50:10
могут давать другой результат программы.
1:50:12
Допустим, если речь идет о записи в базу данных.
1:50:15
То есть у нас могут быть строки, помененные местами или что-то там еще,
1:50:20
что очень трудно отображать и отследить.
1:50:23
Поэтому основная проблема в использовании unsafeperform.io находится в том,
1:50:29
что очень рекомендуется его использовать, находясь уже в IOCонтексте.
1:50:34
Если же мы находимся вне IOCонтекста, в большинстве случаев нам нечего терять.
1:50:40
В том плане, что у нас нет стейк-токена, который мы потеряем.
1:50:44
И поэтому может быть безопасно использовать unsafeperform.io.
1:50:46
И сейчас мы даже разберем, каким образом безопасно
1:50:49
он используется и как это облегчает жизнь.
1:50:54
Первым примером является модуль debug.
1:50:57
trace, который имеет следующие функции.
1:51:00
Функция trace, которая принимает строчку, значение и возвращает значение.
1:51:05
Что делает функция trace?
1:51:07
Трейс просто берет и пишет вот эту строчку в консоль.
1:51:13
Допустим, давайте посмотрим на пример функции trace.
1:51:17
Мы можем вызвать функцию trace, приставить туда какую-то строчку.
1:51:22
И когда Haskell будет вычислять это выражение, он напишет эту строчку в консоль.
1:51:27
Это в силу того, что в Haskell нет дебаггеров.
1:51:31
Если бы необходимый тулинг для дебаггера
1:51:33
был, было бы непонятно, как бы он выглядел.
1:51:36
Потому что идея прыгания по инструкции в Haskell неприменима.
1:51:40
Потому что инструкции здесь нет.
1:51:42
А дебаггер, который редуцирует выражение, это что-то странное и не особо нужное.
1:51:47
Поэтому, да, в Haskell нет дебаггера.
1:51:50
И приходится дебажить выводами.
1:51:52
А в силу того, что вывод – это всегда что-то иошное.
1:51:55
А у нас далеко не вся логика иошная.
1:51:57
Иошные логики стараются делать настолько мало, насколько это возможно.
1:52:01
Приходит на помощь пакет debug.trace.
1:52:03
С помощью которого можно трейсить промежуточные результаты нашей программы.
1:52:09
Функция trace, которая просто выводит строчку при вычислении выражения a.
1:52:13
Есть функция trace show, которая вместо строчки принимает какое-то значение,
1:52:18
которое можно привести к строке и распечатать, что оно и делает.
1:52:21
И также есть функция trace m, которая принимает какое-то аппликативное действие
1:52:25
и перед его выполнением печатает в консоль строчку.
1:52:29
Аппликативность существует по легаси причинам, я бы так сказал.
1:52:33
По-хорошему тут должна быть манана.
1:52:37
Но аппликатив что есть, то есть.
1:52:38
И как выглядит функция trace?
1:52:40
На самом деле это просто unsafe perform.io от следующего дублока.
1:52:43
Мы печатаем консоль строчку с помощью функции trace.io.
1:52:47
Можно сказать то же самое, что put strln,
1:52:50
просто с добавлением какой-то дебаг информации.
1:52:54
И мы возвращаем наше выражение.
1:52:56
Соответственно, trace печатает и возвращает.
1:52:59
Ровно так же, как наша функция helper, помните, которая была.
1:53:02
Так работает функция trace.
1:53:05
Можно рассмотреть пример ее использования в вычислении чисел Fibonacci.
1:53:10
В corner-кейсах мы не пишем никакого вывода,
1:53:13
а когда мы вызываем recursive, мы пишем, какое n мы вычисляем.
1:53:18
Соответственно, 4, 3, 2, 2.
1:53:22
А, ну мы тут дописали, потому что мы изначально ничего не пишем.
1:53:27
Вот. И результат будет только получается.
1:53:36
Есть ли какие-то вопросы по дебаггингу, по
1:53:39
трейсу или unsafe магии, если вдруг они созрели?
1:53:51
Хорошо, видимо, вопросов нет.
1:53:52
И сейчас, кажется, коснемся уже последней темы, про умные строки.
1:53:58
Точнее, про эффективные строки.
1:54:00
Строки в Haskell, которые string, как мы еще с первой лекции с вами заметили,
1:54:04
это просто список символов, что весьма и весьма неэффективно.
1:54:09
И сейчас мы разберемся, какие эффективные реализации строк у нас бывают в Haskell,
1:54:12
и, казалось бы, при чем тут и о, а вот тем более unsafe о.
1:54:17
Начнем с того, что, помните, мы с вами говорили про то,
1:54:21
что числовые литералы в Haskell полиморфны.
1:54:23
На самом деле, при подключении extension overloaded strings
1:54:27
можно сделать строковые литералы также полиморфными.
1:54:30
Это делается с помощью трек-класса isString с единственной функцией fromString,
1:54:35
которая позволяет нам из строчки сконвертить нужный нам тип.
1:54:38
Соответственно, если мы подключили без extension overloaded strings,
1:54:42
тип строчки full – это всегда строка, то есть список символов.
1:54:47
Если мы подключаем расширение overloaded strings,
1:54:50
то это некоторый а – такой, что а – это isString,
1:54:53
что как бы намекает нам на то, что в Haskell существуют разные реализации строк.
1:55:00
Первой эффективной реализацией является тип данных text,
1:55:04
который находится в модуле data.txt в пакете text.
1:55:09
Импортим мы его, как вы заметили, с использованием import qualified.
1:55:14
Это сделано намеренно, потому что большинство функций в модуле data.
1:55:21
txt пересекаются по именам, оверлапятся с функциями работы над строками.
1:55:25
И чтобы Haskell не ругался, мы используем qualified имена.
1:55:28
То есть данный модуль специально задизайнен так, чтобы его импортировали qualified.
1:55:33
И давайте посмотрим, как можно создавать новые экземпляры по данным текстам.
1:55:38
Для этого существует функция pack, которая
1:55:40
принимает строчку и запаковывает ее в текст.
1:55:43
Но также, если у нас подключено расширение overloaded strings,
1:55:46
мы можем просто написать строковый литерал, который сам зарезолвится в текст.
1:55:53
Для текста есть все удобные функции для работы с строками.
1:55:58
Взятие по индексу, взятие префикса, взятие суффикса, конкретинация,
1:56:03
все, что душе угодно, с эффективной, насколько это возможно, реализацией.
1:56:09
Отвечая на вопрос, который будет подробно освещен чуть позднее,
1:56:15
при чем тут вообще IO и при чем unsafe IO,
1:56:17
что на самом деле текст реализован просто через сипшный указатель.
1:56:22
То есть под капотом текста находится сипшный указатель на юникодный кодпоинт.
1:56:30
То есть это все реализовано просто через указатель, как это реализовано в сипке.
1:56:34
Что позволяет нам довольно эффективной манипуляции.
1:56:37
Но чтобы не делать всю логику работы с текстом IO,
1:56:40
в хастеле все это взяли и запрятали под unsafe perform IO.
1:56:45
Практика показывает, что здесь unsafe perform IO не мешает.
1:56:49
Потому что если использовать текст в чистых функциях, понятно почему,
1:56:55
но даже в овощных функциях, благо, создатели библиотеки постарались,
1:57:00
и оно не доставляет проблем, даже несмотря на то, что здесь используется unsafe IO.
1:57:06
Есть также другая эффективная реализация строк, которая называется байтстринг.
1:57:10
Судя из названия, понятно, что она работает со строками в бинарном представлении.
1:57:16
Несмотря на то, что у него также существует instance и string,
1:57:22
но вы знаете, что в байтстринге лежат байтики.
1:57:25
Соответственно, ваша строчка, которую вы написали в виде
1:57:30
строкового литерала, будет храниться в виде байтиков.
1:57:33
И у модуля байтстринг также существует множество удобных функций для конкатенации
1:57:40
и всем, чему душе угодно, для работы с байтовыми строками.
1:57:47
На вопрос, где же тут unsafe perform IO, если вы немного посмотрите на этот код,
1:57:52
на который мы, конечно же, не будем смотреть подробно, потому что зачем,
1:57:57
мы видим, что байтстринг – это, на самом деле, какой-то оберт над фаре-нпт,
1:58:03
как раз-таки поинтер, на Word8.
1:58:06
Word8 – это просто машинное слово.
1:58:09
То есть octet, так еще говорят.
1:58:14
8-бит.
1:58:19
Соответственно, у нас есть функция create,
1:58:21
которая принимает какую-то страшную сигнатуру,
1:58:27
принимает, видимо, какой-то индекс для аллокации,
1:58:30
потом количество байтов, сколько мы аллоцируем,
1:58:33
принимает какую-то функцию из поинтера в IO
1:58:36
и изучает IO-байтстринг.
1:58:38
И, соответственно, здесь у нас под капотом запрятано IO,
1:58:41
но с помощью unsafe perform IO функции для работы с байтстрингом
1:58:45
не требуют от нас нахождения в вашем коде.
1:58:48
Вот, допустим, есть функция unsafe create, которая просто unsafe perform IO надкреет.
1:58:52
И если рассматривать, в чем же все-таки разница между текстом и байтстрингом,
1:58:56
как мы уже говорили, текст оперирует уникодными символами,
1:59:02
а байтстринг оперирует octet, то есть Word8.
1:59:05
То есть элементарная единица строки разная.
1:59:11
Что же все-таки использовать?
1:59:13
Вопрос достаточно нетривиальный на самом-то деле,
1:59:18
потому что существует тонна реализаций строк, как вы видите на этих файлах.
1:59:23
Если же нам нужны бинарные данные, и они нужны в запакованном виде,
1:59:28
сейчас мы поймем, что это.
1:59:29
Если они нужны ленивые, существует пакет database.string.
1:59:33
lazy, который как раз-таки не эвалюирует стройку, пока это не нужно.
1:59:36
Также существует database.string.prost, который на самом
1:59:39
деле строгий, который будет вычислять наши байтстринги.
1:59:42
Также существует unpacked версия.
1:59:44
Это когда в куче под наш конструктор создается отдельная нода.
1:59:51
Можно так сказать, когда можно представлять наше значение в виде дерева,
1:59:56
и вот этот фанг нашего хаскерного типа данных,
1:59:59
можно сказать, что под конструктором в нем есть отдельные ноды.
2:00:02
Но есть также unpacked типа данных.
2:00:04
Это когда у нас как C-шную структуру, как все лежит друг за другом,
2:00:07
что более эффективно с точки зрения памяти.
2:00:09
Соответственно, есть байтстринг, еще и unpacked. Даже такое есть.
2:00:15
Соответственно, если нужна packed и lazy,
2:00:20
то тогда мы можем сказать database.string.lazy.char.8.
2:00:23
Короче, куча разных функций, точнее, куча разных типов данных,
2:00:29
но ничего кроме lazy.string.text и lazy.string.bait.
2:00:33
string на практике никогда не используется.
2:00:35
Соответственно, решайте, что вам нужно.
2:00:37
Если вы работаете с Unicorn, вы используете текст.
2:00:40
Если у вас большие строки, вы используете lazy, маленький и strict.
2:00:43
То же самое с бинарными данными.
2:00:44
Если у вас большие какие-то строки, вы используете байтстринг.
2:00:49
Если маленькие и не хотите нарваться на проблемы с NCPIO,
2:00:54
можете использовать строку.
2:00:55
Соответственно, но типов строк тут полный зоопарк,
2:00:59
большинство из которых я, если честно, там
2:01:02
впервые вижу, которые не особо-то используются.
2:01:03
Просто знайте, что такие есть.
2:01:05
И все это позволяет нам делать как раз-таки наше UnCPU,
2:01:10
если использовать его с умом.
2:01:13
Но, соответственно, тут, как обычно, куча ссылочек.
2:01:16
Из того, что я бы рекомендовал посмотреть, это вот эта статья на FB Complete про то,
2:01:22
как в Haskell и Arizona всякие разные примитивы,
2:01:24
когда мы с вами говорили про MagicHash и решеточку в конце типа.
2:01:30
Готов, если у вас есть какие-то вопросы, на них ответить.
2:01:33
Если вопросов нет, можем расходиться.
2:01:43
До свидания.
2:01:45
До свидания.
2:01:51
До свидания.
