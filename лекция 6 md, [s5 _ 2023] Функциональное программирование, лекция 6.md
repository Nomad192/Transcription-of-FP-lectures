# Text

Всё, супер, запись вроде началась. Сегодня у нас будет с вами лекция про взаимодействие с внешним миром, про то, как считывать, писать в консоль, общаться по сети и так далее, какие возможности для этого есть в Haskell, как такой общий механизм под названием Monado.io. Основные монады все помимо неё вы изучили на прошлой лекции, и сегодня речь коснётся именно её. Будем всю лекцию говорить об одной монаде. И, наконец-таки, с вами научимся писать Hello World на Haskell.

Сначала мы поймём, как в Haskell с моделью частоты на уровне типов придумаем с вами, как написать функцию getChart, которая читает что-то из консоли, один-единственный символ. Поговорим, наконец, про то, что такое Monado.io, как оно устроено. Также коснёмся такой вещи, которая называется дунотация, что это синтаксический сахар для удобного написания монадических вычислений. Поговорим про проблемы, которые бывают при взаимодействии с внешним миром в Haskell. Поговорим про такую вещь, как FFI, Foreign Function Interface, про то, как вызывать всякий разный C-шный код, и не только из Haskell.

Также поговорим про то, как в IEO у нас работать с мутабельными данными, потому что IEO позволяет это делать. Поговорим немного про эксепшены, про такую вещь, как UnsafeIO. И также поговорим про эффективную реализацию строк. Так как в самой первой лекции, если вы помните, мы говорили, что строки в Haskell достаточно неэффективны. И поговорим про эффективную реализацию под названием TextAbideString, и при чём же там всё-таки IEO.

Давайте разбираться. Давайте поставим такую задачу перед собой, написать функцию getChart, которая возвращает нам символ, который пользователь печатает в консоли. И, например, с её использованием напишем функцию getToCharts, которая с использованием getChart просто считает два символа. Скажите, пожалуйста, видите ли вы в этом какие-то проблемы? Даже не глядя на реализацию, просто по сигнатуре данной функции уже понятно, что что-то тут нечисто, что-то тут не так. Есть какие-нибудь предположения? ...

Да, это первая из проблем. Всё то, что не имеет аргументов у нас в Haskell, это консанта. Поэтому, казалось бы, судя по сигнатуре типа, когда и где бы мы не вызывали getChart, у нас должен вернуться только лишь единственный символ. С функцией getChart хорошо понятно. Давайте представим на секунду, что мы всё-таки каким-то образом реализовали функцию getChart правильно, чтобы она возвращала разные символы из консоли при разных моментах считывания.

Что же с функцией getToCharts? С ней тоже есть небольшая проблема. Окей, давайте тогда я скажу. Если вы помните, на самой первой лекции, когда мы с вами говорили про ленивую модель вычислений, которая задействована в Haskell, то речь касалась того, что редукция выражений в Haskell, в ленивой модели вычислений, вообще говоря, не определена. Точнее, порядок редукции, вообще говоря, не определен. Таким образом, ваше выражение может редуцироваться в каком угодно порядке, и поэтому абсолютно непонятно, в каком порядке в нашем результирующем списке окажется символ.

Компилятор может посчитать нужным сочетать сначала первый символ, а потом второй, или же сначала второй, а потом первый. Это вторая проблема. И сейчас мы потихоньку будем ее решать. Да, это как раз таки то, что мы с вами сейчас переговорили. И давайте попробуем все-таки как-то исхитриться и попробовать задать порядок на вызовах функций getChart, и также заставим ее возвращать разные символы.

Сделать это можно достаточно просто, на самом деле. Можно просто передавать функцию getChart int, допустим, порядковый номер символа из консоли, почему нет. И таким образом эта функция перестает быть константной. И мы можем просто скарливать туда int, и, соответственно, у нас будет отдавать разные символы. Но, к сожалению, она никак не решит проблему с порядком.

Потому что вызов второго getChart никак не зависит от вызова первого getChart. И таким образом компилятору ничего не мешает абсолютно перепорядочить вычисление и сначала вызвать второй getChart, а потом первый. Есть ли какие-то мысли насчет того, как это можно исправить? getChart взаимодействует с глобальным буфером, из которого достают значения по индексу. Непонятно, что есть глобальный буфер. Это, знаете, какая-то абстрактная вещь.

Пока что все, что мы умеем, это просто скарливать int. То есть оперировать какой-то чиселкой, суть которой в том, чтобы наша функция не была константной. И у нас, соответственно, проблема в том, что у нас вызовы getChart, если мы хотим прочитать два getChart, не зависят друг от друга. Как сделать их зависимыми друг от друга? Используя, на самом деле, более-менее тот же трюк, который мы использовали с int, просто добавив его в качестве аргумента. Может быть, сказать, что getChart2, прежде чем вызваться, должен вызвать getChart1? Вот, а как это сделать? Это то, что нам нужно сделать.

И, соответственно, интересует вопрос как? Как заставить компилятор сначала вызвать первую, а потом вторую? Репорсия какая-нибудь? На самом деле нет. Я вполне верю, что в случае с двумя чарами действительно так можно сделать. Но если рассматривать какую-то более общую модель, давайте посмотрим. На самом деле можно просто возвращать из функции getChart пару char int и возвращать оттуда следующий порядковый номер. Таким образом, у нас вызов второго getChart, следующий порядковый номер, который мы скормим следующему вызову getChart.

Таким образом, вызов функции getChart2 в данном случае будет зависеть от функции getChart1. Если мы изменим и будем возвращать пару, мы сначала вызовем getChart1 и вернем второе значение счетчика. И потом по второму значению счетчика вызовем уже второй getChart. Таким образом, компилятору ничего больше не остается делать, кроме как вычислить данные выражения в правильном порядке. Ну и соответственно, данная модель, к сожалению, не сказать, чтобы расширяема, потому что, допустим, мы хотим написать функцию get4charts, которая также вернет список, но это будет весьма и весьма неудобно, потому что вот такая запись также не подойдет.

И нам нужно сделать вот эти четыре промежуточных assignment, чтобы все-таки наши символы считались в правильном порядке. Так что при расширении этого на какие-то большие, при обобщении на какое-то большее количество символов, у нас все еще существует такая же проблема. И, соответственно, это про то, как все-таки исправить, переписать просто вот эту функцию так же, как мы переписывали get4charts. И вы не поверите, но мы сейчас с вами придумали то в общем виде, как монадическое IO работает в Haskell. Там, конечно, все немного похитрее, без каких-либо интов.

Сейчас мы с вами посмотрим. Давайте сначала зададим такой игрушечный тип, который будет называться IOA. Это просто будет функция из какого-то real world, из какого-то состояния реального мира, в котором мы с вами сейчас существуем. В результат этой функции и новое состояние реального мира. То есть мы просто заменили int каким-то более абстрактным дататайпом, который представляет состояние реального мира.

Собственно, в общих чертах так и выглядит механизм IO в Haskell. То есть вместо вот этого нашего int, который задает порядок на вычисление, у нас между вызовами иошных функций просто передается токен, который как-то модифицируется и задает порядок. Соответственно, когда вы делали домашнее задание, вы увидели то, что entry point программы в Haskell также является функция main, которая имеет тип IO пустой кортеж. Пустой кортеж используется тогда, когда у функции нет осмысленного результата, и нам нужно что-либо вернуть, и это такой dummy datatype, unit-тип, как еще говорят. Тип, у которого всего один элемент, пустой кортеж.

Соответственно, если раскрыть вот этот алиас, то у нас получается main принимает какой-то реальный мир, возвращает в ничего, то есть в пустой кортеж, и возвращает в другое состояние реального мира. И таким образом у нас выглядит переписанная функция getChar, ее сигнатура на новую модель, которую мы сейчас с вами задали. И, соответственно, так можно использовать ее, например, в функции main, если раскрыть вот этот type синоним. Все еще остаются вопросы. Может ли компилятор скипать или как-то переупорядочивать вызовы getChar, как вы думаете? Или данная модель позволяет нам достаточно безопасно быть уверенным в том, что порядок на наших вычислениях сохраняется? Ну, давайте не будем тянуть и отвечу сразу, что этого более-менее достаточно.

Для того, чтобы быть уверенным в том, что наша модель жизнеспособна. Потому что действительно скипать вызовы getChar мы не можем. Почему? Потому что каждый следующий зависит от предыдущего. А если в конечном итоге мы используем результат нашего последнего вызова getChar, то есть Haskell заэволюетит вот этот санк, который накопился. Санк, напомню, это какое-то невычисленное выражение.

Если же в конце концов мы печатаем это значение на консоль, или потом матчимся по нему, или сравниваем его с чем-то, оно редуцируется до слабоголовной нормальной формы. И все эти вызовы промежуточные getChar нам тоже нужны. Поэтому скипов не может быть. Свопов не может быть тоже, потому что мы задали линейный порядок на вычислениях. И также не бывает каких-то дополнительных вызовов getChar, потому что каждый раз они вызываются на разных токенах.

И каждый раз нам нужно вызвать эту функцию. И достаточно вызвать ее единую, чтобы получить ее результат. То есть таким вот достаточно нехитрым способом мы с вами решили проблему взаимодействия с внешним миром, а именно с заданием порядков на нем операции. Что являлось на самом деле основной проблемой, когда мы с вами рассматривали функцию getChar. Давайте посмотрим на реальную имплементацию IO, как она выглядит в стандартной библиотеке.

Выглядит она немного страшнее, но сути дела не меняет. Это у нас NewTypeIO, где A – это результат какого-то иошного вычисления. И есть у нас GetterOnIO, который также представляет функцию, только вместо TypeAlias это NewType, потому что так правильнее, как мы уже, наверное, с вами говорили на предыдущих лекциях. И вместо токена realworld используется странный тип state решетка realworld. И, в общем-то, все.

Пожалуйста, не путайте этот state с monad.state. State решетка – это просто такой маркерный тип данных, который позволяет нам… Вот этот маркер state на самом деле нужен для того, чтобы при исполнении иошных действий в разных потоках, в разных контекстах вычисления не мешались между собой. То есть state на самом деле – это просто какой-то маркерный тип, ничего общего с monad.state он не имеет. Благодаря этому вопросу, откуда все-таки взялась решетка, в Haskell есть такая конвенция про то, что когда мы оперируем какими-то низкоуровневыми вещами, имплементация которых, возможно, задана на языке C и используется FFI, ну, это, допустим так, на эти функции в Java какие-нибудь. Вот есть такое соглашение, что такие вещи имеют суффикс решетка в своем имени.

Соответственно, суффикс решетка на самом деле можете использовать и вы в вашем произвольном коде, просто это не будет соответствовать общепринятой конвенции, если же вы не пишете какие-то совсем уж низкоуровневые вещи. И использовать ее можно весьма просто, просто подключить решение magic-hash, и тогда данная синтез станет валидной. Соответственно, если вы пороетесь в стандартной библиотеке где-то в ее глубине, вы найдете достаточно много кода, которые используют идентификаторы с вот этой вот решеткой, которые говорят о том, что, чувак, мы здесь оперируем достаточно низкоуровневыми вещами. Как тут видно в этих примерах, вот это наш data.type.mystery, который мы определили, он абсолютно может также использоваться, он ничем не отличается от обычных, кроме своего имени. Тут, кстати, есть хорошая статья про то, как в Haskell реализованы различные примитивы.

Можете посчитать. Соответственно, да, у нас есть такой тип данных, маркерный, как state, с одной типовой переменной, и он как раз таки параметризовывается вот этим нашим real-world токеном. На то, как именно выглядит определение этих типов, мы не будем смотреть, нам оно на самом деле и без разницы, нам важен такой общий механизм того, как оно работает. И, как мы уже говорили в самом-самом начале лекции, когда рассматривали table of contents, IO является монадой, также, соответственно, оно является функтором и аппликативом, но эти инстанции здесь не приведены буквально для простоты. Я думаю, более-менее очевидно, как они пишутся для вот этого типа данных.

На самом деле, этот тип данных немного похож на монаду state, если вы обратите внимание, потому что у нас есть тоже какое-то состояние, только это не состояние вычисления, а состояние внешнего мира, которое задает нам порядок на вычислениях. И, соответственно, реализация бинда и ретерна выглядит довольно похожим образом. То, что у нас какое-то иошное действие n, если мы биндим с какой-то стрелкой клейстрика, то это в результате все еще получается иошное действие. Такое, что мы сначала применяем наше действие к первому реальному миру. Это иошное действие из какого-то стейта реального мира во что? В то, что мы применяем вот это наше иошное действие к состоянию внешнего мира.

Получаем новое состояние внешнего мира и результат. И, соответственно, потом мы применяем нашу стрелку клейстрика к этому результату и новому состоянию. Ну и здесь мы делаем an.io просто, чтобы тип сошлись. Потому что здесь мы уже указали то, что мы заворачиваем, это ио. И здесь нам это нужно просто развернуть.

Довольно механическая работа. Суть дела в том, что мы применяем наше действие к состоянию внешнего мира, потом применяем к нему стрелку клейстрика и присовываем к этому новое наше состояние внешнего мира, которое будет использоваться в дальнейших вычислениях. Return выглядит тривиально, как и его реализация для всех монад. Это просто мы запаковываем вот такую функцию, которая никак не меняет состояние нашего внешнего мира, в панадойю. Пожалуйста, есть ли какие-то вопросы по типу данных.

io, который определен в стандартной библиотеке, и по инстансу монада для него. Видимо, вопросов нет. Давайте продолжим. И поговорим про такую вещь, которая всегда идет где-то рядом с монадами в Haskell. Это doSyntax или doNotation, которая позволяет нам удобно в стиле, похожем на стиль написания в императивных языках, задавать монадические вычисления.

Вспомним, что у нас есть монадический оператор, так называемый урезанный бинт, птичка-птичка, который имеет тип monad m, mA, mB, mB. То есть он выполняет первое действие, выполняет второе действие и возвращает результат второго действия. Вот, соответственно, рассмотрим следующий пример. Здесь приведем его тип, специализированный для монада. io, для красоты, так как речь на этой лекции будет вестись только о ней.

Рассмотрим, во что у нас дешевелится вот это синтаксис. На самом деле это просто мы применяем наши действия сначала к первому миру, точнее к изначальному миру world0, получаем world1, и нас не интересует его результат. Затем мы этот world1 скармливаем второму действию, получаем b и world2 и возвращаем. Вот как это будет выглядеть в нашем dosyнтаксисе. Давайте, чтобы этот пример был хотя бы чуть-чуть реальный, заинтродюсим сразу функцию из стандартной библиотеки, которая называется put strln, которая принимает строчку и возвращает его в пустой кортеж.

Она печатает данную строчку на консоль. И посмотрим, как можем написать функцию main, заиспользовав в ней функцию put strln и do нотацию. Вот этот пример довольно тривиальный, потому что здесь dosyнтаксис содержит лишь одну строчку, и можно ее опустить. Но мы можем писать следующим образом. Мы можем писать main равно do, и затем одна за одной писать какие-то решенные действия.

Например, сначала вызвать функцию put strln от первой строки, потом от второй строки и потом от третьей. При этом никаких биндов, никаких операторов птичка-птичка нет. В основном, это дешевый рейд. Дешевый рейд – это то, что между каждой строчкой ставится вызов нашего оператора. Просто из-за того, что результат нам не нужен, мы можем никоим образом не изворачиваться, просто опустить данный синтаксис.

И вместо того, чтобы на каждой строчке дородить вот этот оператор, просто избавиться от него использованием do-нотаций. Соответственно, оно позволяет нам просто одну за одной писать вот эти наши действия, которые будут выполняться в том же порядке, в котором мы их написали. Почему они будут выполняться именно в нужном порядке, следует из реализации вот этого оператора, который мы сейчас посмотрели. То есть в отличие от каких-нибудь let-стейтментов, которые, если они не зависят друг от друга напрямую, один за одним, могут быть, вообще говоря, вычислены когда угодно. Монадические вычисления, написанные в do-нотации в том числе, лишены этого свойства, и они вычисляются прямо один за одним, как мы это скажем.

Просто в силу реализации. Поговорим еще вот о чем. Поговорим о том, как нам исполнять какую-то цепочку действий. Здесь мы тоже выполняли в каком-то смысле цепочку действий, но представим, что у нас есть какой-то список действий в Monad.io. Например, сначала распечатать что-то, потом… А, ну функция print на самом деле… Давайте потихоньку будем интродюсить функции стандартной библиотеки.

Буду вам о них рассказывать. Функция print на самом деле принимает произвольный аргумент, вызывает на нем show, и делает put strln. Соответственно, print – это show a, а a – его пустые карты. put str – это то же самое, что put strln, только не печатает line break. И также у нас есть функция getChart, которая также присутствует в стандартной библиотеке, и мы ее написали.

Она просто считывает символы в консоли. Соответственно, мы дискаргуем ее результат с помощью объединения с return пустой карты. Если у нас есть такой вот список, можно исполнить его следующим образом. Можно через do нотацию в каждой строчке по индексу обратиться к каждому элементу списка, и данное действие будет исполнено. Но это достаточно плохо, поэтому есть в стандартной библиотеке функция, которая называется sinkSequence, которая принимает список каких-то монадических действий и выполняет их последовательно с дискардингом результата.

Кажется, на предыдущих лекциях об этом должна вестись речь, что в Haskell существует такой naming conventions, что если какая-то функция не возвращает никакого результата, то есть она игнорирует результат, у нее последним символом в имени стоит underscore. Соответственно, есть функция sequence без underscore, которая возвращает список результатов. Но в данном случае никаких отмысленных результатов у нас в дейфе нет, поэтому мы используем функцию sequence с нижним подчеркиванием. И, соответственно, мы можем наш main определить просто как вызов функции sequence на этом списке. Давайте посмотрим.

Можно чуть подробнее про дискардинг результатов? Потому что если мы игнорируем результат от всего IO actions, то с учетом ленивости вычислений можно, грубо говоря, оптимизировать и сделать пустую программу, которая ничего не делает, если ее результат никому не важен. На самом деле нет, потому что пустой кортеж все-таки возвращается. Это во-первых. Потому что все-таки у нас не то, чтобы нет никакого результата, и не то, чтобы он нам не нужен. У нас результатом все-таки служит пустой кортеж, который в силу нашего определения монадического минда, этот результат пропагейтится из одной функции в другую.

И таким образом монадические вычисления не являются ленивыми. Потому что в терминах зависимости одного звена цепочки монадических вычислений от другого, в силу определения монадического инстанца, и вообще type class монады, у нас перед тем, как будет вызвано следующее действие, всегда, вне зависимости от того, нужен ли этот результат в конце или нет, будет использовано следующее действие. Просто в силу определения. Об этом мы еще говорили с вами тогда, когда мы писали функцию github. Мы тогда не говорили о дестардинге, но это в данном случае суть и дело не меняет.

Поэтому монадические вычисления не являются ленивыми. Конечно, каждое из этих действий, каждое из монадических действий, из звеньев цепочки биндов, соответственно, да, оно ленивое. Если мы посмотрим на реализацию, если мы посмотрим на то, как оно будет исполняться, как оно будет редуцироваться, конечно, там имеет место будет ленивость. Но если мы посмотрим вот так вот сверху, и будем рассматривать это действие как атомарное, то данная цепочка не является ленивой. И давайте, возможно, оно будет видно также из определения функции sequence, с нижним подчеркиванием, что на пустом списке мы просто не делаем ничего, а на списке из какой-то головы и какого-то хвоста мы просто вызываем действие в голове и рекурсивно вызываемся от хвоста, используя дунотации.

Соответственно, без дунотации можно было бы написать просто x, птичка-птичка, sequence от x. Вспомним теперь и про обычный бинд, который имеет вот такой тип. Если мы его специализируем до типа monad.io, и поговорим про то, каким образом данный бинд используется в дунотации. Потому что до этого у нас были довольно скучные цепочки вычислений, каждое действие в которых игнорирует результат предыдущего действия. В случае IO это, наверное, только лишь вызов функции print и put.stln и ничего более.

То есть функции, которые не возвращают результаты. Давайте же все-таки посмотрим на обычный бинд. Здесь у нас имеется развернутый тип. Как у нас выглядит обычный бинд? Как он у нас разворачивается, если мы развернем его определение. То, что мы сначала применяем наше действие к какому-то первому миру, к какому-то нулевому миру получаем результат и первый мир.

Соответственно, к результату и первому миру мы применяем action2, который напоминает стрелку от Лейсли, поэтому у него на один аргумент больше. Получаем второй мир. И, соответственно, возвращаем результат и второй мир. Вот таким образом это будет выглядеть. Посмотрим на следующую функцию, которая у нас определена в стандартной библиотеке, которая называется getline, которая просто считывает строчку из стандартного ввода и возвращает ее запакованную в monad.io.

Каким образом будет выглядеть doSyntaxes для бинда, если мы используем bin с функциями, которые возвращают какой-то осмысленный результат, в отличие от пустого картежа. Он будет выглядеть следующим образом. У нас появляется новый оператор, который имеет следующий вид, и который на самом деле похож на оператор присваивания. И что мы здесь видим? Мы связываем значение функции getline с идентификатором s. Тип s у нас будет string, потому что тип выражения, которое находится слева от нашего оператора стрелка, он всегда, тип выражения, которое находится в monad, только распакованный, без коробки.

Почему это так происходит, сейчас нам будет понятно, когда мы посмотрим на то, как это дешевляется. Соответственно, мы вызываем функцию getline и кладем его результат в переменную s. А затем эту переменную s, которая имеет тип string, мы можем спокойно использовать в функции плута стрелы. И выглядит все это достаточно незамысловато, потому что у нас вызывается обычный bind. И в качестве второго аргумента бинда используется lambda, как раз таки где результат функции getline связывается с переменной s, которая у нас доступна во всем дальнейшем скопе.

Соответственно, вот такая запись, у нас будет развернута вот такую запись. Все вызовы бинда просто берут и помещают результат первой функции, которая находится в аргументе лямбда, просто помещают ее в какую-то переменную для удобства в дальнейшей с ней работе. Мне кажется, что данная функция действительно весьма простая, и ее можно записать без дунотации и даже без лямбда, просто используя бинд. Если вы будете пользоваться этим в GHCI, то вы заметите довольно забавный специфик. GHCI на самом деле реализован достаточно просто.

Это просто бесконечный loop, бесконечный цикл в IOM-аналоге. Соответственно, если вы будете пользоваться синтексом этой стрелочки, то вы обнаружите то, что он вполне себе работает, и монадой будет у нас являться IOM. Соответственно, если вы будете использовать в GHCI какую-то полиморфную функцию, например, функцию return, допустим, напишите return true, то данный тип будет специализирован до типа монады IOM, потому что GHCI – это просто блок кода в монаде IOM. А если бы вы писали это в каком-то коде в хаскельном модуле, то данный тип был бы полиморфным. Потому что на самом деле return возвращает какую-то монаду, и пока что непонятно какую.

Это должно быть выведено из контекста. В GHCI есть такой странный спецфект. Пожалуйста, обратите на это внимание, если будете тестировать там какой-нибудь свой код. Давайте поговорим про какой-то более сложный пример. Попробуем развернуть вот такой doSyntax, который использует, соответственно, как и урезанный бинт для выражения, который не возвращает результат, так и бинт обычный, который имеет результат.

Соответственно, что мы делаем? Сначала мы печатаем в консоль what's your name, считываем строчку, потом печатаем how old are you, считываем строчку и печатаем на консоль пару из a и b. Принт, я напоминаю, просто вызывает show и печатает с помощью функции put strln. Это будет выглядеть следующим образом. Сначала мы вызываем putstr, он не возвращает нам никакого результата, поэтому здесь используется обычный, точнее, урезанный бинт. Затем мы вызываем функцию readln, которая возвращает нам строчку a, которая возвращает нам строчку, которую мы связываем с переменной a.

Затем в теле лямбды мы вызываем опять функцию putstr, которая не возвращает никакого результата. Опять вызываем функцию readln, которая возвращает у нас результат b. И просто печатаем a и b. Вот, таким образом оно разворачивается. Ставьте, пожалуйста, есть ли какие-то вопросы по донотации, правилам дешугеринга и так далее.

Хорошо, буду считать, что вопросов нет. Единственное, что добавлю, еще одно замечание по поводу применения донотации с вот этим нашим урезанным бинтом. Здесь, в примерах, вы видите, что всегда мы используем донотацию, которая не возвращает никакого результата, на функциях, у которых return type, это IO, пустой картеж. И это логично, потому что действительно нам нет смысла использовать обычный бинт и слева писать какой-то идентификатор, который будет равен пустому картежу. Поэтому мы используем вот так.

Но на самом деле мы не ограничены тем, чтобы использовать вот такой вот синтез на функциях с return type пустой картежи. Мы можем это использовать на функции, которая возвращает какой-то смысленный результат. Но если же мы не хотим связывать его ни с какой переменной, допустим, этот результат нам не интересен, мы просто можем это скипнуть. Вместо того, чтобы связывать его с какой-то переменной, которая будет не использоваться. Можно было бы просто написать нижнее подчеркивание стрелком влево и какая-то функция.

Но зачем? И да, повторюсь, основной пойнт в том, что здесь мы не ограничены функциями, которые возвращают пустой картеж. Мы можем использовать любые функции. Просто это не так уж и часто нужно. Наверное, в Хаскеле, если функция возвращает какой-то результат, наверное, все-таки он должен как-то использоваться. Теперь поговорим про return и его использование в дунотации.

Напомним, что return для monad.io будет выглядеть следующим образом. Когда мы писали instance, у нас была лямбда от world 0 в картеж world 0, но нам ничего не мешает подвинуть этот world 0 слева от знака равно. И так он выглядит, просто чуть-чуть с измененным телом в плане синтекса. Суть и дело не меняет. Давайте посмотрим, как у нас return используется в дунотации.

Допустим, мы хотим написать функцию getReversedLine типом iostring, которая читает строчку из консоли и возвращает ее в реверсном виде. Что мы делаем для этого? Сначала мы вызываем функцию getLine, и результат вкладываем в переменную s, которая имеет тип string. И вот если бы мы написали здесь без return reverse s, у нас бы не сошлись типы. Почему? Потому что результат конечного выражения у нас должен быть iostring. И, соответственно, если нам нужно в нашем конце дунотации сделать какое-то чистое действие с результатом предыдущих биндов, мы должны обернуть return.

По понятным причинам, просто для того, чтобы у нас сошлись типы, и для того, чтобы результат исходной цепочки выражений был монадическим. Мы не можем просто так взять и избавиться от iostring контекста, как любого другого монадического контекста, просто потому что, если это вызывает вопросы, просто вспомните, во что это разворачивается. И то, что у нас каждая из стрелок лейсли имеет возвращаемый тип mb. Соответственно, из a в mb. Здесь мы берем контекст m просто с помощью return.

И таким образом эту функцию можно использовать. Также в мейне считываем преверснутую строчку и печатаем ее. И вопрос в зал. Давайте рассмотрим следующий пример. Когда мы читаем строчку a из консоли.

Да, тут в презентации есть небольшой баг. Представьте, что мы используем на ней функцию read, которая приводит ее к end. Потому что строчки сравнивать с нулем мы не можем. Это просто такой лофтовер в презентации, который, к сожалению, не заметил изначально. Мы считываем число из консоли.

И если число больше либо равно нуля, мы делаем return простой кротеж. Иначе мы печатаем, что число негативное, что число отрицательное. А следующим действием мы печатаем, что a is a positive. И будет ли оно вызвано в случае, если мы туда передадим положительное число. Или же этот return отработает, как в императивных языках, и мы не дойдем до этого действия.

Мы дойдем до него. Мы не можем пропустить просто так. Побочное действие наше. Да, это вполне логично. Просто очень часто на первых порах люди путаются с тем, что у нас название функции return очень сильно похоже на название оператора return в плюсах или в джаве, который, соответственно, завершает выполнение функции и возвращает результат.

В хатскеле функция return просто запаковывает наш результат в монадический контекст. Здесь return сделает то, что результат этого экспрессиона в цепочке наших монадических вычислений будет равен пустому кротежу, завернутому в монад, в данном случае a. Соответственно, да, мы не можем просто так в хатскеле написать return, и у нас цепочка монадических вычислений не завершится. Нет, это просто для избежания путаницы. А можно глупый вопрос? Да.

Последнюю строчку не заберет себе do, который написан после слова else? Нет, это хороший вопрос. На самом деле вложенные do-блоки также присутствуют, как вы можете видеть. Это достаточно неинтересно, потому что он тривиально состоит из одной строчки. Тут дело в отступах, потому что этот do имеет в своем составе одну строчку с таким-то отступом. Соответственно, если бы у нас была вторая строчка, у нее должен был быть такой же отступ.

Но данная строчка в силу расстановки отступов принадлежит первому do-блоку. А мы можем и do с двумя стейтментами написать в одну строчку? Да, можете с использованием точки запятой. В Haskell есть точка запятой, если вы пишете в do нотации или в кейсе в одну строчку. Кажется, для этого есть вот такой синтез. В Haskell также есть фигурные сроки.

Оно не сказать, чтобы часто используется, но порой для экономии какого-то места к этому прибегает. Но это не является желательным код-стайлом. Вы также в gash-сайт. Точка с запятой может быть удобна в gash-сайт, если вы хотите написать несколько действий в одну строчку. Просто чтобы не заморачиваться.

Там, кажется, был еще какой-то вопрос. Ладно, видимо, не был. Давайте поговорим про использование let в do нотации. С самой первой лекции вы помните, что в Haskell есть такая вещь как let in для объявления промежуточных идентификаторов наших выражений. Так вот, конструкция let может быть использована в do нотации, но внезапно без in.

Сейчас мы посмотрим, как это выглядит. Давайте посмотрим на такую функцию main, на ту же функцию, которую мы писали до этого, где мы реверсим строчку. Считаем строчку, поместим ее в переменную s, и в переменную rs поместим результат reverse от s. И выведем на консоль reversed input двоеточие rs. Здесь, как вы заметите, отсутствует in просто по причине удобства.

Потому что, на самом деле, когда оно разворачивается, точнее, выражение после in, как само ключевое слово in, очевидно, присутствует. Просто в do нотации это является лишним. Потому что в let in оно кажется довольно логично, потому что если мы не рассматриваем do нотацию, то все в Haskell это выражение. И логично, что когда мы объявили цепочку каких-то промежуточных ассайментов, указать выражение, которым они используются. Но в случае do нотации, которая является синтактическим сахаром и дает нам некоторые ощущения того, что мы пишем императивный, в кавычках, код, где строчки исполняются одна за одной, решили просто разрешить не писать строчку in.

Просто для удобства, чтобы разрешить объявлять промежуточные идентификаторы. Но in по понятным причинам будет присутствовать, потому что это не какой-то новый синтактический конструкт. Это все тот же самый let in, просто чуть-чуть засахаренный. И самая частая ошибка, которая бывает у людей, которые работают с do нотацией, это когда они путаются между знаком равно и стрелочкой влево. Давайте рассмотрим пример.

Когда мы пишем let s равно getline, мы на самом деле не считываем строчку из консоли. Мы просто присваиваем функцию getline к какой-то другой функции s, которую мы можем потом вызвать. Но это присваивание не вызывает функцию. Если бы мы хотели считать что-то из консоли, то есть выполнить наше монадическое действие, мы бы использовали стрелку влево. Почему? Потому что стрелка влево – это синтактический сахар над биндом.

А вот такой let s равно getline – это ничего более, кроме как алиас для функции, который мы потом можем вызвать. И также есть следующая ошибка, когда мы в чистых значениях пытаемся, при вызове какой-то чистой функции справа от знака равно, мы пытаемся использовать стрелку влево. Это не работает, потому что справа от стрелки влево должно стоять у нас какое-то монадическое значение. В монаде m, в которой мы работаем, в нашем случае это айо. Несмотря на то, что список – это тоже монада, это абсолютно разные вещи, данная спойлерка в монаде айо.

Поэтому reverse s будет иметь тип string, и мы не можем просто так взять и поместить ее в переменную rs. Есть ли какие-то вопросы по этому поводу? Окей, давайте считать, что нет. Прошу прощения, я на полминуты прервусь. У меня сейчас сядет ноутбук, я его поставлю на зарядку и возобновлю. Прошу прощения, давайте продолжим.

И внезапно еще одна вещь, что мы можем использовать doSyntax без монад. Но я бы сказал, что он лишен какого-то смысла. Потому что все, что он нам позволяет сделать, это не писать ключевое слово in в цепочке let. Соответственно, вспоминаем нашу функцию Pythagoras с самой первой лекции, где у нас let x2, потом let y2, потом in x2 плюс y2. Можно просто написать do, сделать себе цепочку let без in, и в самой последней строчке написать результирующее выражение.

Просто знаете, что такое синтаксис есть, я бы не сказал, что он имеет какое-то практическое применение. Потому что я ни разу такого кода не видел. Как-то более привычно, если мы видим do, сразу представлять то, что у нас речь идет о каком-то монадическом вычислении. А тут чистая функция, и это очень и очень сильно запутывает. Вот.

Там даже есть какой-то пример внезапно. Можете тоже почитать. Я, если честно, даже не смотрел. Давайте разберем такой вот интересный пример. fu, функция isn't of int, которая внезапно используется до нотации по каким-то причинам.

И мы берем плюс один и складываем его результат в переменную a, а затем делаем return a умножить на два. То есть, пожалуйста, может ли кто-то рассказать, что здесь происходит? И почему это вообще работает? Точнее, почему это компилируется хотя бы? Как оно работает, мы разберем сразу же. Как только поймем, почему оно компилируется. Давайте, смотрите, у нас do почти всегда, кроме предыдущих наших слайдов, это какое-то монадическое вычисление. В какой-то монаде.

А тем более, если у нас есть стрелки влево, то это точно монадическое вычисление. Это не просто do в чьей-то функции. На какую из монад, которые вы изучали на прошлой лекции, хотя бы отдаленно похожа наша функция fu? Пример достаточно нетривиальный. Давайте я не буду вас томить. Скажу вам, что эта монада определенная для частично примененной стрелки.

Как вы помните, она является функтором и аппликативом. Это также определялось на соответствующей лекции. И когда на предыдущей лекции вы говорили про монаду ридер, речь заходила про то, что монада ридер – это просто newtype над частично примененной стрелкой с фиксированным аргументом e и справа результатом a. На самом деле, это оно у нас и есть. Это у нас монада ридер.

Или, так как мы используем ее без newtype, корректнее сказать, что это монада для частично примененной стрелки. И давайте посмотрим, каким образом это у нас работает. На самом деле, в данном случае у данной монады контекстом является выражение слева от стрелки. Соответственно, если бы мы сейчас решили потратить на этот пример достаточно большое количество времени, чтобы разобрать, мы бы выяснили, что каждое следующее действие насыщает нашу функцию, которую мы собираем. Потому что у нас монадическое вычисление – это функция isn't a wind, но также она могла быть и string a wind или чего-то еще.

И каждое из вот этих действий просто, так сказать… Это можно просто рассматривать как композицию, на самом деле. Вы же помните, что функция для частично примененной стрелки – это просто композиция. И вот, соответственно, здесь мы по кусочкам собираем функцию. То есть сначала мы говорим, что это плюс один, и ее результат какой-то a. А потом мы этот результат еще и домножаем на два.

И если мы применяем вот этот фу в тройке, сначала к нему прибавится один, а потом умножится на два. Это выглядит, на самом деле, довольно и довольно страшно. Но если это просто расписать как обычный wind, ничего там страшного не будет абсолютно. Данный пример тут просто находится для того, чтобы показать, что такие вещи тоже бывают. Не сказать, что они встречаются на практике.

Конечно, потому что ничего, кроме как запутать человека, данный код полезного не делает. Просто знайте, что такое бывает. И что вот так вот для частично примененной стрелки работает монада. Если бы тут была какая-то монада reader int, то было бы проще. Точнее, reader int int.

Мы поговорили с вами про то, как у нас базово использовать IEO в Haskell, какие бывают функции для этого. Там putstr, putstrlen, getline, getchar, print. И как с ними работать с IEO-монадой. Также поговорили про denotation. И абсолютно везде, когда происходит какая-то работа с нижним миром, возникают какие-то неожиданные проблемы.

Давайте уже разберемся, какие. Давайте рассмотрим следующую функцию, которая с помощью readfile. Как вы догадываетесь, она принимает имя файла и возвращает в виде строчки его содержимое. Считаем контент файла foo.ht, переменуем файл content. А затем запишем в файл bar.ht.

Вот этот наш контент просто присоединен с присоединенной в начале буковкой a. А затем еще раз прочитаем msbar и выведем его на экран. Пока что проблемы никакой нет. Все выглядит достаточно straightforward. Представьте, что у нас нет контента файлов foo.

ht и bar.ht, что они, соответственно, равны foo и bar. Соответственно, файл контент... А, нет, господи, это я неправду сказал. Что foo.ht – это foo line break bar. Это я немного запутался.

Вот так выглядит наш файл foo.ht. Запускаем нашу функцию main. И что мы видим? Мы читаем из файла foo вот следующую строчку, присоединяем к ней в начало a, получается a foo bar, и пишем файл бар. А потом мы читаем файл бар и пишем его на консоль. Получается ровно то, что мы ожидали.

Соответственно, фу бар только присоединенный в начале буковкой a. Такой вот довольно странный пример. Но сейчас мы его немного видоизменим и поймем, какие при минорном изменении такого даже простого кода можно встретить проблемы. Давайте изменим его и будем читать из foo.ht и писать в foo.ht. А потом опять читать из foo.ht и писать в консоль.

Есть ли какие-то подзрения насчет того, что что-то тут пойдет не так? Это нормально, если их нет. Потому что с виду данный код не предвещает никакой беды абсолютно. Может быть, кто-то есть. У нас же файл content в первой строчке do не то чтобы вычисляется, он биндится. Возможно, из-за этого мы откроем файл, например, на чтение и запись, и вот там будет неприятная ситуация.

Да, абсолютно верно. Вспоминаем, что Haskell — это ленивый язык. И несмотря на то, что, как я уже говорил до этого, если мы рассматриваем цепочку монадических действий, здесь вот этот эффект ленивости откладывается. Потому что у нас каждое предыдущее действие исполняется перед следующим действием. Но это абсолютно не значит, что результат этого действия будет средуцирован до головной нормальной формы или нормальной формы.

Это значит, что данное действие просто выполнится. И действительно, как вы уже сказали, вылезет такая ошибка. Перевернуть сюда на секунду. Да, функция readFile, если почитаете ее документацию, здесь написано, что он читает контент файла лениво, когда он нам нужен. Как и функция getContents, не обращайте внимания, это другая функция из стандартной библиотеки.

Соответственно, действительно, связывание нашего санка с контентом readFile происходит сразу же, в силу того, как работают монадические вычисления. Но непосредственное чтение из файла будет происходить тогда, когда это нужно. Когда это нужно? Когда мы пишем в этот же файл. Соответственно, у нас будет проблема с тем, что дескриптор файла у нас будет открыт как на чтение, так и на запись одновременно. И вылезет такая ошибка, что return busy, файл is locked.

Эта проблема называется lazy Ion. И сейчас мы немного коснемся того, как ее решать. Но когда вы работаете с… Тут на самом деле речь абсолютно не про чтение и запись файла. То есть это просто какой-то один из примеров, когда можно выстрелить себе в ногу, работая с Ion, забывая о том, что Haskell ленивый. Это касается абсолютно всех вещей, как работы с сетью, с какими-то опишками, с базой данных и так далее.

Нужно всегда понимать, что все действия Ion непосредственно, если мы используем наши стандартные функции, которые ленивые. Есть еще другие функции, которые force от вычисления. Сейчас мы о них поговорим. Нужно всегда держать в голове то, что на этапе считывания фактического считывания не происходит. Происходит просто связывание танка с контентом файла, с вот этой переменной.

И все, больше ничего. А затем, когда мы ее используем, будет происходить считывание. И важно понимать, чтобы это считывание не конфликтовало с использованием данной переменной. В данном случае оно конфликтует, потому что использованием является запись в тот же самый файл. Здесь у нас какая-то байка про то, что обычно, когда идет что-то не так, мы идем читать документацию.

Но если мы достаточно подготовленные, то мы всегда сначала читаем документацию. И наткаемся на вот такую штуку. Давайте посмотрим еще один пример. Который, на самом деле, особо ничем не отличается, кажется. Есть еще такая функция withFile.

Что она делает? Это функция, которая принимает название файла. Режим, соответственно, это может быть чтение ReadMod, WriteMod и также ReadWriteMod. И принимает цепочку действий, которые мы с этим файлом делаем. Здесь можно написать $do и то, что с дескриптором данного файла можно делать. Как бы привести аналог.

Короче, данная функция используется... Короче, функции в Haskell'е видят кто-то там, обычно берут какой-то ресурс, затем принимают цепочку действий, которые с этим ресурсом делать, и закрывают ресурс. Соответственно, функция withFile после выполнения этой цепочки действий, которую мы сюда кормим, а сюда кормим мы всего лишь одно действие, мы закрываем ресурс. И здесь продемонстрировано неправильное использование функции withFile. Почему? Потому что мы считываем его контент и кладем в какую-то переменную, но на момент печати содержимого файла в консоль данный файл уже будет закрыт.

Потому что мы прочитали, закрыли, а потом будем... точнее мы на момент записи, как только у нас начинается запись. Haskell берет, ага, мне нужна эта переменная, пойду-ка я ее прочитаю. Берет, идет ее читает, такой все, я прочитал, закрываю файл. Отдает функцию putstr строчку, но на самом деле файл уже закрыт.

И поэтому на момент вызова putstr дескриптор файла уже закрыт. Поэтому мы не можем напечатать его на консоль, потому что когда мы пойдем ее читать на самом-то деле, будет уже поздно. На самом деле, мне кажется, получилось довольно невнятно. Давайте я попробую еще раз объяснить, если у кого-то из вас есть вопросы. Или же все более-менее понятно.

То, что на момент записи в консоль данного файла дескриптор файла был уже закрыт, потому что он открылся и закрылся сразу же. А уж когда нам actually нужно взять его пойти и прочитать, он уже закрыт. Окей, я надеюсь, что это все-таки понятно. Еще раз резюмирую. Если вы видите в Haskell какую-то функцию, которая называется viz, что-то там, всегда знайте, что это функция, которая берет какой-то ресурс, делает с ним цепочку действий и закрывает этот ресурс.

Поэтому в данном случае правильным использованием функции vizfile было бы поставить вот тут доллар, поставить ту нотацию и ashget contents и putstr land написать вот в этой цепочке. И написать вот в этом ту блоке внутри функции vizfile, когда вот этот наш файл все еще открыт на чтение. А не после, когда он уже закрыт на чтение. Пример достаточно забористый, я признаю. Но суть не в том, что функция vizfile какая-то плохая, а суть опять же в том, что нужно всегда держать в голове вот это не самое интуитивное поведение Haskell при работе с IO.

Давайте продолжим. Да, и как же все-таки с этим жить? Мы не будем подобно касаться того, как люди решают проблемы LazyIO, потому что это достаточно комплексная проблема. Самое легкое, самое простое, что мы можем делать, и проверенное временем решение, это просто использовать какую-то библиотеку для стриминговой обработки данных, в которую как раз-таки вшита нормальная и правильная работа с LazyIO, и нельзя выстрелить себе в ногу. Такие библиотеки — это Conduit, наверное, самая известная, также Pypes и Streaming. Они просто предоставляют интерфейс для написания каких-то пайплайнов работы с потоковыми данными, которые в нужный момент форсятся, в нужный момент не форсятся, для того чтобы поддерживать состояние вычисления рабочих.

Чтобы не было таких спецэффектов, как закрытый файловый дескриптор. Логика этих библиотек достаточно продуманная, чтобы учитывать. И есть еще один способ, как бороться с LazyIO. Есть такой модуль, кстати, все эти функции вида readfile и так далее находятся в модуле SystemIO. И есть модуль, который называется SystemIO Streaming.

Все операции которого неленивые. Соответственно, там не бывает спецэффекта LazyIO. Но, к сожалению, это не панацея. И использование строгого IEO тоже не очень хорошо. Почему? Потому что если мы будем работать с файлами или данными, размер которых достаточно велик и не влезает в оперативную память, и мы бы хотели его обрабатывать как-то по кустам, чанками, то SystemIO Streaming не позволит нам это сделать, потому что в момент вызова функции readfile он пойдет, прочитает файл, и сразу все его содержимое запихнет в строку, вычисляя при этом до слабой головной нормальной формы.

Вот. Потому что это строгие вычисления. Поэтому если вы уверены, что вы используете какие-то небольшие объемы данных, можете для уменьшения рисков столкнуться с проблемой LazyIO воспользоваться модулем SystemIO Stream из стандартной библиотеки. Иначе, если вы пишете какую-то комплексную логику для взаимодействия с внешними ресурсами, рекомендуется использовать, допустим, Conduit. Очень хорошая библиотечка.

С интерфейсом, очень сильно похожим на стандартную библиотеку, просто с более умными функциями. Давайте пойдем дальше. И кратко осветим такую вещь, как FFI, Foreign Function Interface. Это про то, как дергать C-шный код, и не только C-шный код на самом деле, а любой другой код, где calling conventions совпадают, а у C и Haskell они совпадают, из Haskell. Давайте заведем на файл simple.c такую функцию int.

example, которая принимает два инта, возвращает a плюс b. И для того, чтобы использовать данную функцию в Haskell, мы пишем вот такое расширение, Foreign Function Interface, импортируем следующий модуль, который содержит нужные типы. Это, соответственно, просто репрезентации C-шных типов в Haskell, можно так сказать, потому что C-шный тип int, которые платформозависимые в Haskell, будет cint. Просто для того, чтобы было логическое разделение между int-ами Haskell и int-ами C-шными. И, соответственно, мы можем с помощью вот такой магической надписи Foreign Import C-Call Safe Example, имя функции, объявить эквивалентную сигнатуру в Haskell.

Вот, соответственно, это будет cint, cint, cint. Если типы не сойдутся, то печаль, оно упадет. Соответственно, у нас уже есть хаткельная функция example, которая на самом деле при вызове будет вызывать C-шную функцию example, и мы ее можем использовать. Соответственно, cint – это также имеет instance класс она. И поэтому можно вызывать функцию example от констанции 0.2 и 0.

, и просто принять результат. Можете пояснить, что значит конкретно C-Call Safe, и можно ли что-нибудь интересное вместо них написать? C-Call Safe. Я, к сожалению, не работал с FFI, это достаточно редкая штука, поэтому я даже затрудняюсь ответить, если честно. Вот есть про это статейки какие-то, но если есть safe, то, видимо, есть и unsafe. Но, если честно, это довольно редкий кейс, который особо не встречается на практике, только разве что, если мы пишем какие-то performance-sensitive вещи, где нам может потребоваться C-шный код, где у нас performance хастеля не хватает.

Единственное использование FFI, которое я видел, выглядит как-то так и ничего умнее. То есть мы просто пишем импорт ряда каких-то C-шных функций. Я уверен, что с этим можно делать что-то интереснее, но, к сожалению, да, не могу вам об этом ничего сказать содержательного. Окей, если дальше вопросов нет, давайте поговорим о мутабельных данных. Представьте, что у нас есть какой-то специальный тип данных для мутабельной обертки над какими-то данными, который предоставляет интерфейс read variable, который принимает вот эту нашу пока еще загадочную мутабельную переменную, и write variable.

И представим, что это все у нас чистое, не находится ни в какой монаде ее, и так далее. Какие у нас могут быть проблемы в данном коде? То есть у нас есть какая-то магическая мутабельная переменная, у которой следующий интерфейс read и write. И все это у нас чистое. Есть ли какие-то проблемы по-вашему? Опять же, порядок вычислений. Да, да, опять же, порядок вычислений, во-первых.

Во-вторых, здесь мы видим, что результат функции write variable у нас никак не используется, поэтому это большой вопрос, будет ли вызвана данная функция. Спойлера не будет. Поэтому да, ровно так же, как и с работой с внешним миром, работа с мутабельностью также требует какого-то порядка и гарантии исполнения операции. Поэтому такой интерфейс в Haskell есть, и он обязывает находиться у нас в контексте IOR. Данная мутабельная переменная называется IORF, которая имеет следующий интерфейс.

Оно все находится в модуле data IORF, и оно предоставляет непосредственно сам тип данных IORF. Это просто коробочка, параметризованная каким-то типом, внутри которой находится значение этого типа. Соответственно, можно ее создать. new IORF от нуля. К сожалению, у нас не будет сигнатур.

Давайте я тогда их проговорю. Функция new IORF принимает какой-то тип A и возвращает IOR от IORF A. Соответственно, он возвращает нам эту коробочку IORF с нужным типом, дополнительно к тому же находясь в контексте ее. То есть var A будет иметь тип IORF A, где A это пока что какой-то произвольный... Давайте для простоты скажем, что это int.

Мы-то знаем, что числовые литералы Haskell полиморфные. Поэтому var A это IORF int. Затем у нас есть функция read IORF, которая принимает IORF и возвращает IOR от результата. В данном случае у нас результат будет IOR int. Также есть функция write IORF, которая принимает IORF, принимает новое значение, и результат у него будет пустой кротеж.

IOR пустой кротеж. Поэтому мы здесь пользуемся урезанным виндом нашей дунотации. Затем мы опять читаем IORF и возвращаем соответственно A0 и A1. И данный код, в отличие от кода выше, в силу того, что он используется в контексте IEO, и все плюсы работы с IEO он имеет из коробки, данный код работает корректно. В том плане, что он не дескаргит никакие операции, он их ни в коем случае не дуплицирует и выполняет в правильном порядке.

То есть все, что нужно знать о мутабельных данных в Haskell пока, пока речь не идет о каких-то примитивах синхронизации, работы с многоподочностью и так далее, то есть у этих данных IORF мутабельный, который хранит в себе какой-то тип. Мы туда можем писать, можем читать, можем создавать новые. Все это в IEO. Есть очень много полезных функций, допустим, modify, IORF и так далее, которые более-менее интуитивно понятны, как работают. Соответственно, у нас будет правильно выведено Foo.

Foo – это 0,1. Также наряду с мутабельными переменами у нас есть мутабельные массивы в Haskell, которые находятся в пакете data.array.io. Он предоставляет тип данных IORF и функции по аналогии с IORF для работы с ними. Соответственно, new array принимает у нас картеж из индексов данного массива. Соответственно, данный массив будет иметь индексы от 1 до .

Вот такой вот странный интерфейс. И также... а, нет, сейчас. Дайте-ка вспомнить. Что-то странное.

Я, если честно, даже забыл, как этот array выглядит, потому что, спойлер, никто пакетом data.array.io не пользуется. Все пользуются пакетом vector. Поэтому я этот код не видел ни разу в жизни, кроме как на этом слайде. Короче, мы можем создавать массив. Можем читать от мотива по индексу.

Можем писать массив по индексу какое-то значение. И также можем читать. Давайте все-таки хорошо захуглим. Блин, позорится, я вам скажу. New array.

Боже мой, тут есть еще очень многое. Data.array. io Это, видимо, настолько старый слайд, что такого типа даже нет. Короче, предлагаю забить. Предлагаю забить на type.array.

io и использовать вместо него, если вам вдруг нужно, будет type. vector, который находится в соответственном пакете vector. Просто знайте, что мутабельные массивы есть. Я надеюсь, вам их в жизни никогда не придется использовать, потому что это достаточно редкая тема. Сигнатура не самая понятная.

Я действительно забыл, что тут эти штуки значат. Но факт остается фактом. Можно объявить мутабельный массив, можно туда почитать по индексу, можно записать по индексу. Даже тут говорится про то, что нужно вязать пакет vector, который предоставляет как мутабельные, так и не мутабельные массивы с константным доступом по индексу. Такие дела.

Я предлагаю... Сейчас, давайте я посмотрю, сколько у нас с вами осталось уговорить. Ладно, я предлагаю... Нам еще осталось, по моим предположениям, минут сорок. Если вы хотите, мы можем идти сейчас на перерыв небольшой, потому что у нас начинается относительно новая тема exception.

Также мы можем просто взять и продолжить, и пораньше уйдем. Так что тут учитывать вам, скажите, как мы будем действовать. Пораньше закончить. Окей, окей. Если никто не возражает...

Да, все, в чате тоже пишут. Окей, давайте. Как мы знаем, везде, где у нас существует какая-то работа с внешним миром, у нас могут возникать всякие разные исключительные ситуации. Например, мы читаем из файла, который не существует. Или же даже далеко хватить не надо.

Исключительные ситуации у нас бывают, когда мы работаем с чистыми функциями, например, функция деления, которая выкидывает ошибку, если мы делим на ноль. Сейчас мы очень кратко осветим, как механизм исключения работает в Haskell, и какие есть вещи для работы с этим. Начнем с функции throwIo, которая принимает в качестве аргумента некий e, который является exception, и возвращаемый тип у него довольно странный, тип IoA. Почему это так? Потому что, на самом деле, это расходящийся... Логичный вопрос, откуда у нас берется A.

Все очень просто. Когда мы бросаем exception, программа, точнее, наш поток заканчивает выполнение, и, соответственно, результатом данной функции является bot. Напоминаю, то есть невычисляемое, неэтифицируемое выражение. Поэтому, в принципе, вместо IoA здесь могло бы быть абсолютно что угодно, и это бы этифизировалось. Это ровно то же самое, как у нас происходит с undefined.

То, что undefined у нас этифизируется любым типом. Но просто так как у нас работа с исключениями по большей части тесно связана с Io, используется тип IoA. На самом деле тип возвращаемого значения здесь особо не играет роли, потому что в случае вызова данной функции наша программа упадет. Давайте посмотрим следующую функцию readAndDivide, которая возвращает IoInt. Что она делает? Она считывает два числа из консоли.

Представьте, что функция readDelay читает строчку и превращает ее в число. Просто для простоты, чтобы было меньше кода. Соответственно, мы считаем числа x и y, проверяем, что если y – это 0, бросаем exceptionDivideBy0, который является одним из конструкторов ArithException. Это тип суммы, который предоставляет собой часто используемые исключения в арифметике, которые взяты из модуля ControlException из стандартной библиотеки. Короче, если y – это 0, мы кидаем exceptionDivideBy0, иначе мы уверены, что y – это не 0, и возвращаем из нашей функции xDiv.

И давайте вызовем эту функцию в Garsci. Соответственно, если вызвать функцию readAndDivide, написать 7, 3 – это все отработает. Если написать 3, 0, то у нас выйдет exceptionDivideBy0. То есть наша программа закончит свое выполнение с исключением на этой строчке, нашей doNotation. Пока что ничего специфичного, что бы отличало Haskell от других языков.

Единственное, что возможно throw в многих языках – это оператор кейборда языка. Здесь функция throwIo. Это просто функция из стандартной библиотеки. Ничего в ней магического, на первый взгляд, и нет. Если везде, когда речь встает про исключения, очевидно, нам интересно не то, как их кидать, но также, как их ловить.

Для этого у нас существует функция catch, которая также требует от нашего типа E, чтобы это был некий exception. Что такое exception? Как вы уже догадались, это type class. Мы разберем через пару слайдов буквально. Он принимает какое-то EO-шное действие и также принимает обработчик исключений. Если в случае выполнения этого EO-шного действия EOA вылезет какое-то исключение E, то мы обрабатываем это исключение, и результирующий тип также должен быть EOA.

И, соответственно, результирующий тип всей этой истории – это также EOA. Соответственно, в этой нашей хендлер-функции, в catch, мы можем почистить какие-то ресурсы и выбросить это исключение обратно, потому что, напоминаю, тип функции throwIo – это EOA. Также мы можем вернуть, например, какое-то дефолтное значение. Поэтому это уже поведение специфицируется нами, как программистами. Функция catch позволяет сделать оба этих действия.

Давайте посмотрим, как выглядит функция saveReturnDivide. Соответственно, это вызов функции returnDivide определенный на прошлом слайде и с соответствующим обработчиком исключений. Если у нас вылетает исключение divide by 0, то мы возвращаем минус единицу. Соответственно, вот эта функция имеет тип, напоминаю, exceptionE из EOA. Мы ловим, паттерн-матчимся по исключению divide by 0 и return минус единицу.

Логичный был бы вопрос, а что будет, если сюда прилетит какой-то другой экземпляр, а это exception. К сожалению, это упадет тем, что у нас non-exhaustive pattern match. Но здесь для простоты это мы приведем. Здесь для простоты мы не стали unknown exception ловить. Вот есть ли какие-то вопросы по тому, как на таком достаточно интуитивном уровне пока что ловить исключения? Верно ли, что по-хорошему мы должны были исправить non-exhaustive pattern match каким-то методом? Как не будете реализовать то, что если это не division-базирует, то нужно это выкинуть обратно? Или это так не делать? В данном случае, знаете, довольно тяжело рассматривать этот пример, потому что мы знаем, что функция return divide ничего кроме divide by 0 не вылетает.

Но, допустим, если мы рассматриваем какой-то более реальный код, очевидно, что нам нужно обрабатывать все кейсы pattern matching. Потому что если у нас есть какая-то data my hero равно my hero 1 или my hero 2, очевидно, нам не нужно ловить только my hero 1. В случае my hero 2 нам нужно выкинуть какое-то исключение дальше. То есть наша программа не должна падать с какими-то хаскельными ошибками в духе non-exhaustive match. В данном случае мы можем написать что-то типа, мы можем выбросить исключение, добавив к нему то, что это исключение неожиданное, то есть unexpected year, и просто перебросить это исключение дальше.

Да, конечно, данный пример просто, чтобы уложился в одну строчку, написан для простоты. Ничего более. Ну, давайте пойдем дальше. Тут вы видите две большие красные надписи про то, что на самом деле, как вы видите, в IEO у нас могут быть выкинуто на самом деле любое исключение. Здесь мы видим по ассигнатуре функции catch, что это должен быть какой-то произвольный exception, которых много.

И оно не ограничивается одним лишь arith exception. Про то, каким образом у нас здесь появился именно arith exception, мы поговорим прямо сейчас. Знаете то, что система exception в хаскеле, ее называют по-другому untyped exceptions. Потому что мы заранее не типизируем, не специфицируем типы исключений, которые могут полететь из нашей функции, которую мы вызываем. Когда мы пишем обработчик исключений какой-то функции, на самом деле оттуда может вылететь более-менее любое исключение.

Сейчас мы об этом поговорим. И это, к сожалению, никаким образом не представляется в системе типа в хаскеле. Сейчас мы будем с этим бороться. Я вставил сюда буквально пару слайдов про то, что же все-таки такое exception в хаскеле и с чем их едят. Давайте заведем какое-то data.myException равно data.

myException и задерайвим у него следующий type-класс show. Понятно, мы можем его задерайвить. Задерайвим какой-то непонятный type-класс typable, который пока непонятно зачем нужен. И также задерайвим type-класс exception. Да, exception у нас может быть задерайвим.

И, соответственно, таким образом, при подключении соответствующих расширений. Соответственно, таким образом, мы можем использовать наш type. myException, а точнее один его конструктор data.myException в функции throw.io и catch. Соответственно, если мы в GHCI напишем throw. io data.myException, то никакой ошибки типов не произойдет.

Наш data.myException действительно является инстантом эксепшена, и хаскель позволит нам его выкинуть. Соответственно, если мы рассмотрим следующий блок кода, то в GHCI действительно можно писать многострочные блоки кода с пользованием логикового синтеза. Если мы кинем data.myException, и затем сразу же поймаем data.myException, и напишем в нашем хейдлере, что data.myException is thrown, и вызовем данный код, то действительно выявится то, что data.myException is thrown. Пока что все весьма и весьма прямолинейно. Давайте уже все-таки посмотрим, что же такое type-класс exception, и какие связанные с ним дата-тайпы бывают.

Давайте пока на верхнюю строку забьем и посмотрим на type-класс exception. Type-класс exception требует для себя следующие constraints. Это show для того, чтобы наше исключение можно было выводить на консоль функции display exception. И также некоторый type-класс typable. Type-класс typable – это такой специальный type-класс, который будет освещен далее в курсе.

Я вам скажу очень кратко, что это type-класс, который позволяет для типа E в рантайме извлекать информацию о типе. Для того, чтобы понимать исключение какого именно типа мы выбрали. Да, в таскеле есть некоторый аналог рефлекшена, который, допустим, есть в Java, и он представлен type-классом typable. Более детально данный type-класс будет озвучен, наверное, лекцией через 3-4. Пока что знаете, что такой type-класс есть, его можно дерайвить, и на этом все.

В type-классе exception есть следующие функции. Display exception, как мы уже говорили, который берет E и печатает ее строчку. По дефолту это реализовано по кратке через show. И также есть две очень интересные функции, которые называются from exception и to exception. И сейчас давайте же все-таки разбираться.

На exception в таскеле реализовано что-то типа наследования внезапно. Потому что у нас есть некий тип данных some exception, который выглядит следующим образом. Можно не особо обращать внимание на то, как синтаксически он записан. Потому что, опять же, это тема следующих лекций. Но так как про exception мы говорим уже сейчас, важно хотя бы абсурдно понимать, как работает механизм exception без углубления в детали.

Some exception – это, можно сказать, предок всех exception. Если мы рассматриваем как такое псевдо-наследование. Или же можно рассматривать some exception как какую-то коробочку, тип данных коробка, в которой лежит какое-то exception. В нем лежит какое-то е, которое является представителем этой класса exception. Соответственно, у нас есть две функции.

From exception и to exception. From exception пытается достать из коробки some exception, в которой лежит какое-то исключение. Он пытается его привести к нашему конкретному исключению, для которого мы пишем instance. Соответственно, здесь у нас есть maybe e. Потому что у нас в общем случае в коробке some exception может лежать абсолютно любое исключение, как file not found, так там divide by zero или что-то еще.

И функция from exception позволяет, когда у нас есть какое-то исключение, понять, нужное ли это исключение нам сейчас. То ли это исключение, в котором мы работаем. Потому что, допустим, для file not found у нас может быть отдельный обработчик. А для другого исключения – другой обработчик. Вот есть такая функция from exception.

Здесь как раз-таки играет роль наш type class typable, который позволяет получить информацию о типе, чтобы понять, то ли это исключение или нет. И также есть функция to exception. To exception просто запаковывает наше исключение e в коробку some exception. Итого резюмируем. Exception в Haskell это type class, у которого есть следующие функции.

Display exception, которые просто печатают строку. И также две функции для конверсии из и в some exception. Some exception – это коробочка, которая хранит любое исключение. Либо же, если мы рассматриваем это как иерархию, можно сказать, что some exception – это предок всех исключений. Потому что он может быть с помощью to exception для любого типа exception приведен к some exception.

И к чему, собственно, идет речь? Речь идет к тому, что, как здесь уже писалось, в Haskell и в IEO может быть выброшено абсолютно любое исключение. И вот как раз-таки наша коробочка some exception нужна для того, чтобы… это репрезентация как раз-таки любого исключения. Some exception – это какое-то некоторое исключение, которое брошено. И если же мы в нашей функции, в какой-нибудь обработчике, хотим ловить любое исключение, мы должны ловить some exception. Потому что здесь, допустим, если у нас функция read and divide выбросила исключение file not found, ну, бывает, допустим, если мы считываем чисел из файла, то вот наш хендлер его не пропустит.

Он стригерится только, когда у нас будет arise exception, конструктором которой является divide by zero. Если уже у нас полетит какой-то другой exception, данный хендлер просто не отработает. Если же мы хотим в нашем хендлере поймать абсолютно любое исключение, мы ловим здесь some exception. И тогда наш хендлер стригерится абсолютно на любое исключение. А уж потом этот some exception мы можем пощупать, распаковать, допустим, с помощью form exception и понять, а это divide by zero или это file not found.

И если это там ничего, что нам неизвестно, потому что exception на самом деле бесконечное количество, мы можем для любого написать exception, мы можем какое-то конечное множество exception потрогать, посмотреть как-то специфичным образом, обработать вшивку. Если у нас не получилось извлечь какой-то внятный exception, который мы знаем, мы просто вытянем его обратно. Соответственно, за этим вот этот some exception – это некоторый такой механизм задать возможность ловить любой exception. Потому что в Haskell нет наследования. Нельзя просто взять и отнаследоваться от exception как в какой-нибудь джебе.

Пришлось вот так вот изгаляться. Скажите, пожалуйста, насколько понятно то, что сейчас происходит? Потому что это довольно сложновато, на мой взгляд. Получается, Haskell – фп-язык, но exception с наследованием, или я до конца не понимаю? На самом деле, наследование я всегда употреблял в кавычках, потому что никакого наследования, очевидно, нет. Просто об этом удобно думать, что есть некоторые общие исключения, которые являются как бы предками всех остальных исключений. Но об этом можно думать.

Семантически это абсолютно не так. Семантически вот эта иерархия реализована просто запаковыванием какого-либо exception в коробочку. То есть на деле никакого наследования нет. Просто в силу того, что раньше вы работали с языками программирования, в которых exception реализованы через наследование, об этом удобно думать. Но на самом деле ничего, кроме запаковывания и распаковывания коробки, тут не происходит.

Поэтому если вам неудобно об этом думать, как о наследовании, можете не думать. Думайте как о коробке, в которой лежит год в мешке какой-то исключения. Все, супер. Давайте же, наконец-то, найдем применение тому, что я сейчас говорил, и напишем какую-то функцию с использованием вот этого сам эксепшена и механизма эксепшена в полной мере. Давайте напишем функцию try, read and divide, у которой имеется тип IO от either string in.

Соответственно, у нас может быть либо стринговая ошибка, либо интовый результат в IO. Заиспользуем нашу функцию read and divide и навесим на нее следующий хендлер. Заметьте, здесь мы хотим ловить любое исключение, поэтому мы явно указываем тип, что мы ловим сам эксепшен. И делаем с ним следующее. Наш хендлер ловит наиболее общий тип исключения, ловит сам эксепшен.

Соответственно, e – это у нас сам эксепшен, и мы пытаемся его привести к эксепшену divide by zero, чтобы в случае, если это divide by zero, вернуть одну ошибку, а в другом случае – другую ошибку. Соответственно, если у нас from exception – это divide by zero, тут, к сожалению, пропущен maybe. Но тут и должен быть just. Just divide by zero error – это maybe divide by zero, потому что у нас вот тут maybe. К сожалению, это ошибка.

Когда я этот слайд готовил, я это не углядел. Итого, мы ловим наиболее общее исключение и пытаемся понять, что же нам с ним сделать. Давайте попробуем с помощью функции from exception привести его к эксепшену divide by zero. Ага, если мы это смогли сделать, значит у нас настрой эксепшен, который был кинут, на самом деле – это эксепшен divide by zero. И давайте вернем left display exception divide by zero.

Соответственно, мы выведем надпись, какой-то текст, который специфичен конкретно данному типу ошибки. Если же у нас не получилось с помощью функции from exception получить just что-то там, just divide by zero, здесь мы получаем nothing. И если же мы получили nothing, значит это какой-то другой неожиданный тип исключения, который мог быть брошен. И мы с этим ничего отмысленного не можем сделать, просто как вернуть left something else happened. Логичный вопрос.

Каким образом у нас здесь появляется сам эксепшен? Ведь если мы вспомним функцию read done divide, мы кидаем divide by zero. На самом деле, в Haskell, магическим образом, все кинутые эксепшены могут заворачивать сам эксепшен, если наш хендлер ожидает сам эксепшен. Поэтому, несмотря на то, что мы кидаем divide by zero, у нас работает некоторое неявное приведение типов. На самом деле, это вызывает функцию doException, чтобы у нас, как у программистов, была возможность поймать любое исключение. Поэтому Haskell, магическим образом, может запаковывать любой эксепшен в сам эксепшен, чтобы у нас была возможность его поймать.

В принципе, более-менее все про идею эксепшенов в Haskell. Она, как вы видите, довольно странная. Но внезапно она очень хорошо работает, и очень хорошо легла в эту Haskell парадигму. Потому что эксепшены в Haskell, исходя из моего опыта, с ними довольно удобны. Несмотря на то, что сам эксепшен, на первый взгляд, кажется чем-то очень странным, почему у нас происходит какая-то магическая запаковка эксепшенов, потому что мы их как-то кастим.

На самом деле, а как по-другому? Наследования-то нет на эксепшенах, поэтому приходится изгаляться. Но это внезапно вышло довольно удобно. Короче, если есть у кого какие-то вопросы по эксепшенам, задавайте. Если нет, будем двигаться далее. Поговорим еще чуть-чуть про них, и поговорим уже про другие интересные вещи.

Почему для типа результата используется either? В плане нет ли какого-то аналога, у которого вместо left и right были бы нормальные названия, понятные типа error и result? А что вызов непонятного-то? Действительно используется either. Где в Rust используется result, там в Haskell используется either. Просто есть такая конвенция, что left это ошибка, right это результат. Возможно, действительно имело бы смысл назвать result, но называется either все привыкли. Окей, если никаких вопросов нет про эту страшную магию с эксепшенами, давайте продолжать.

Потому что эксепшены будут еще раз освещены, тоже довольно подробно, в лекции про concurrency. Пока что можно остановиться на каком-то общем представлении о том, как это работает. Поговорим еще про интересные функции работы с исключениями в IO, которые есть в стандартной библиотеке. Есть функция try, которая на самом деле является более-менее ее частным случаем. Это функция, которая принимает иошное действие и возвращает IO от either е а, где вот этот е – это исключение.

Как на самом деле реализован try? Это просто вызывается иошное действие с хендлером таким, что если мы поймали исключение, мы просто заворачиваем его в left. Иначе мы возвращаем right. Вот эта функция называется try. Есть также функция try just, которая принимает, помимо всего этого, какой-то конвертер из нашего исключения в какой-то тип данных maybe b. Допустим, это выкипает некий фильтр для эксепшенов.

Потому что функции try just мы ловим не все эксепшены, как функции try, а только те эксепшены, которые в случае вот этой конверсии превратились в just. Допустим, мы можем написать, что если это какой-то нужный нам тип эксепшенов, или какое-то логическое выражение, то тогда мы возвращаем just. Если же это какой-то левый эксепшен, мы возвращаем not. И таким образом try just у нас ловит только те эксепшены, которые проходят эту проверку, можно так сказать. Есть также функция finally, которая принимает два иошных действия.

Принимает иошное действие, которое запускается первым, и также иошное действие, которое запускается по прошествии первого действия. Даже если там было выброшенное исключение. То есть, соответственно, там просто навишен хендлер, который в случае исключения также исполняет вот это действие. Если исключение не произошло, это действие также исполнится. Ровно то же самое, что конструкция finally в других языках, только в Haskell это функция, а не кейворд.

Суть и дело не меняет. Также есть функция onException, которая похожа на finally, но вот это второе наше действие не исполняет, если эксепшена не произошло. То есть это действие, которое выполняется в случае, в одникновение, исключения. И также есть достаточно важная функция, которая называется bracket, которая представляет из себя вот эту idiom array, resource acquisition is initialization. Когда мы работаем с какими-то ресурсами, которые хочется открывать и закрывать по прошествии работы с ними.

Вот функция withFile, которую мы рассматривали до этого, она как раз таки тоже была написана в так называемом bracket pattern. Давайте посмотрим, что такое bracket. Она принимает в себя первым аргумент какое-то иошное действие с результатом типа a, где a – это тип нашего ресурса. То есть это действие, которое берет ресурс и возвращает нам его в качестве результата. Оно выполняется первым.

Вторым аргументом мы принимаем действие с этим ресурсом по закрытию ресурса. Оно запускается последним. То есть оно принимает наш ресурс и возвращает какой-то iob, это результат закрытия ресурса. Соответственно, это может быть, допустим, открытие файла, а вот это может быть закрытие файла. И третьим аргументом оно принимает computation to run in between.

Как раз таки какое-то действие, которое зависит от нашего ресурса, принимает его в качестве аргумента и возвращает результат действия. Соответственно, результатом всего этого будет ioc. Как это происходит? Берется ресурс, вызывается действие по взятию ресурса, возвращается ioa. Потом этот ресурс скармливается в это действие, результатом которого ioc. А после выполнения этого действия ресурс закрывается, но вот это ioc возвращается как результат.

И эта функция очень удобна для взаимодействия с киберфайлами или с открытием каких-нибудь сокетов, потому что она обезопасивает нас от случаев, когда возникает исключение, и ресурс не будет закрыт. Вот в случае функции bracket, вот это computation to run last вызывается всегда, вне зависимости от того, было ли выброшено исключение или нет. И таким образом к концу работы функции bracket мы точно знаем, что ресурс вначале был открыт, а в конце был закрыт. Вот такая вот удобная функция с весьма страшной, на первый взгляд, сигнатурой, но если ее посмотреть, все будет довольно понятно. Давайте продолжать дальше, если нет никаких вопросов по вот этим вот вспомогательным функциям по работе с исключениями.

Давайте посмотрим на такую вещь, как паттерн гарды. Давайте особо не будем обращать внимание, что у нас есть какая-то функция lookup из какой-то finite map и int в maybe int. Давайте не будем погружаться в что такое finite map, просто это какая-то функция, которая принимает какой-то объект, какой-то индекс и возвращает maybe по индексу, есть ли там или нет. И давайте посмотрим, что мы с этой функцией можем сделать. Давайте напишем функцию addlookup, которая, что будет делать, она в этой нашей мапе будет искать два числа, если они оба just, их складывать, иначе возвращать nothing.

Это можно использовать с do notation, во-первых, это можно в тупую написать через два кейса, вложенных, как у вас было в предыдущей лекции, просто кейс на lookup var1, потом lookup var2, что может быть преобразовано на самом деле через mayb1ado, допустим, в do notation. Это очень удобно написать в do notation. Но это также можно сделать с помощью альтернативного синтекса, который называется pattern guards. Это никак у нас не связано с IO, это просто ответвление в сторону. Давайте напишем функцию addlookup, которая принимает какой-то environment в виде нашего мапа и принимает два индекса, которые мы будем искать.

Возвращает maybe int. И вместо того, чтобы в самом теле функции начать матчиться по каким-то значениям, мы можем начать матчиться по каким-то значениям в guard. Почему нет? Вы помните, что такое guard? Это когда мы пишем логические выражения, и если они эвалютируются в true, то выполняется тело функции. Так вот, помимо логических выражений, там может быть матч. Соответственно, в данное тело функции мы зайдем, если вот этот вот матчинг и вот этот вот матчинг обработают корректно.

Соответственно, если lookup вот этот и lookup вот этот вернут just, мы можем выполнить эту функцию. Если же где-то здесь был nothing, то вызывается какое-то из других уравнений, других тел нашей функции addlookup, которая описана ниже. Довольно незамысловатая конструкция. Я надеюсь, тут все понятно. Можно творить какие-то страшные нечитаемые вещи с этим.

Какие-то strange operations над списком, если сумма списка – это 7, если длина списка – это n, такое, что n больше 5 и меньше , тогда мы возвращаем iq. Иначе что-то другое. Все, что общего здесь есть с denotation и с monads, это то, что используется в такой же синтезе стрелочки. Но, пожалуйста, не путайте его с denotation. Это другое.

То есть в гардах можно писать как паттерны, как мы сейчас написали, так и логические выражения. А можно их мешать, как видим вот здесь. Это было такое немного ответвление стороны, просто для того, чтобы, если будете читать какой-то код, вы не путались. Давайте поговорим про такую вещь, как unsafe. io и про то, каким образом в Haskell можно легко выстрелить себе в ногу, работая с IO, не говоря уже о lazy.io.

Есть еще такая вещь, как unsafe.io. В стандартной библиотеке есть такая функция, которая называется unsafe.perform.io. У него тип из IO A. Соответственно, оно берет и отбрасывает какой-то наш IO контекст и возвращает результат. На лекции про монады вы наверняка обсуждали то, что, вообще говоря, достать значение из какой-либо произвольной монады безопасным образом невозможно.

Так и в случае IO невозможно просто безопасным образом взять и выйти из его контекста, если мы в него вошли. Это может иметь довольно странные последствия. Давайте сейчас это разберем. Давайте посмотрим на функцию foo, точнее на константу foo. Тело которой выглядит следующим образом.

Мы печатаем храчку foo в консоль. Здесь тип данных IO пустой картеж. И мы избавляемся от IO с помощью пустого картежа. И также зайдем в функцию bar. Также константу, да.

На самом деле константу не функция. Которая в дунотации пишет в консоль bar, возвращает базу, и все это магическим образом распаковывается из IO. И, наконец, заиспользуем эти две функции в функции main. Сначала мы напишем let f равно foo, а затем выведем bar. Вот, скажите, пожалуйста, вопрос зал, что же будет напечатано в консоль в этом случае? Чисто на интуиции, пока что не особо знаю, как работает у нас с функцией foo.

Нет предположений? Какие у нас есть варианты? Может вывестись foo, bar и баз, например. Может вывестись просто bar и баз, и foo будет проигнорировано. Давайте же все-таки посмотрим. Тут не пишется результат, но, короче, будет выведено bar и баз. Почему? Потому что вот это вот наш результат функции foo.

Не используется, потому что мы ушли от его контекста, который гарантирует нам выполнение всех операций и порядок на них. Соответственно, у нас foo стало просто константой. Так как мы ее нигде не используем, не требуется вычисление ее до слабоголовной нормальной формы, данное выражение просто берется и игнорируется. А put to sterile end bar отрабатывает полностью, потому что нам нужен результат функции bar, константа bar, которая на самом деле выглядит как функция, потому что тут есть действия разные. Соответственно, когда мы вычисляем bar, у нас происходит печать bar в консоль и возвращение баз.

А потом вот саму баз отпечатывается. Короче, в результате будет выведено bar и баз, ровно в таком же порядке. Согласитесь, данный код весьма и весьма неинтуитивный. Поговорим о следующем примере. Заведем такую функцию helper.

Так а зачем вообще в принципе использовать unsafeperform. io, если он вызывает проблемы? Если использовать его по-умному, иногда он бывает полезен. Об этом мы поговорим немного попозже. У unsafeperform.io есть полезные аппликейшены, которые повсеместно используются в Haskell. Просто нужно знать, сейчас мы о нем говорим.

Сейчас мы говорим об unsafeperform.io, чтобы понимать, в каких случаях он может доставлять проблемы. Потому что в каких-то случаях он их не доставляет. И вот как раз таки у этих случаев есть довольно интересные и полезные применения. Конечно, если бы это была абсолютно бесполезная вещь, мы бы о ней не говорили. Давайте рассмотрим функцию helper, которая на самом деле тип из a в io.a.

Что она делает? Она принимает какое-то значение произвольное, печатает его и возвращает. Соответственно, у a должен быть constraint show, что немаловажно в данном случае. Соответственно, мы печатаем и возвращаем ее в ёжном контексте. И давайте напишем функцию main, которая сначала что делает? Она вызывает helper от единицы, и его результат присваивает переменной 1. Вызывает helper от двойки, присваивает результат переменной 2.

И печатает у нас 1 плюс 2. Можем ли мы в данном случае гарантировать порядок? Что будет выведено в консоли в данном случае? Опять же вопрос в зал. 1, 2, 3. Да, все правильно, потому что мы находимся в ио-контексте. Потому что у нас порядок детерминирован, определен.

Ничего не идет не так. И давайте потихоньку нашу функцию helper, как и функцию main, потихоньку делать все более и более unsafe. Давайте изменим тип функции helper, чтобы это был тип из a в a, с помощью добавления unsafe performer 1 над всей вот этой штукой. Соответственно, она спечатается, возвращается, а потом сбрасывается в его контекст. И делаем как let 1 равно helper 1, let 2 равно helper 2, и print 1 плюс 2.

Как вы уже догадались, порядок на данных действиях мы гарантировать не можем. И может быть выведено как 1, 2, 3, так и 2, 1, 3. Давайте теперь сделаем ее частично unsafe. Вернем функцию helper, как было, оставим ее иошной. И для единички будем вызывать ее в иошной манере, в безопасном.

А для двойки обернем все это дело в unsafe. Избавимся здесь от monad и используем обычный let. Можем ли мы здесь иметь предположение над порядком? Потому что казалось бы, у нас все логично. Сначала вычисляется 1, потом вычисляется 2. Мы же идем по нотации сверху вниз.

А потом 1 плюс 2 – это 3. Или же здесь тоже какая-то собака зарыта. И не все так очевидно. Кажется, все еще зарыто. Да.

Вот это let 2, оно же отбросило IO-контекст, поэтому экземпляры реального мира не передаются никуда. И компилятор может перестирать, что как хочет. Да, абсолютно верно. Абсолютно верно. Более того, когда мы говорим о do-нотации, где идут перемешку бинды и let выражения, нет абсолютно никакой гарантии того, что let выражения, вот это let выражение, будет вычислено после вот этого бинда.

Почему? Собственно, эти же выражения, они чистые. Компилятор может переупорядочить их каким угодно образом, очевидно, не теряя зависимости между let выражениями. Таким образом, вот это let 2 может быть вычислено сначала, а потом может быть вычислено 1. Так что, да, тут возможные варианты того, что сначала создается 1, потом создается 2, потом tank 2 форсится и вычисляется 1 плюс 2. Потом также возможен вариант того, что сначала создается tank 2 и форсится, а потом вызывается helper от единички и вычисляется результат.

Сейчас мы немного подробнее взглянем на это и поймем, почему же все-таки так происходит и каким же все-таки образом у нас работает функция unsafeperform. io, разберем ее реализацию. Напоминаем, как у нас выглядит бинд для Monado. io и каким образом этот real-world токен у нас передается. То, что он сначала скармливается нашему первому действию, получается какое-то новое состояние.

И затем оно передается дальше по цепочке. Давайте на это не будем обращать внимания, мне это не очень нравится. Как у нас работает в общем виде оператор урезанного бинда? Вот это настоящий бинд, который принимает действие и стрелка placely. А как будет работать у нас урезанный бинд? На самом деле он все еще пропагейтит наш токен дальше. Смотря на то, что результат первого действия он игнорирует, как мы видим здесь, вот этот токен, который воспроизвело первое действие, он все также учитывает во втором действии.

И как же работает все-таки функция unsafeperform. io? То, что у нас где-то определенно на верхнем уровне такая вещь, как fake state token. Это просто какое-то значение типа state real world. И как раз таки unsafeperform.io работает так, что мы вызываем наше егоршное действие на каком-то фейковом токене, а не на том токене, который нам откуда-то пришел. Потому что в случае unsafeperform.io ему не откуда приходить.

Потому что это действие может быть вызвано в чистом контексте. Мы вызываем наше f на каком-то фейковом токене, получаем следующий токен, который идет за фейковым, если рассматривать как-то их по порядку, и получаем результат. Отбрасываем этот токен, который идет за фейковым, и возвращаем результат. Так вот у нас довольно прямолинейно работает функция unsafeperform.io. И давайте если мы развернем нашу функцию main, самую последнюю ее реализацию, то посмотрим, как же она работает в дешугерином виде.

То, что сначала может вызываться helper1 от какого-то у нас изначального токена s0, который пришел в функцию main. Мы можем получить первый токен. А затем, когда мы вызываем helper2, вот здесь вот, мы этот токен не используем. Почему? Потому что мы вызываем это действие unsafe, вызываем его на фейковом токене. Соответственно, результат этого фейкового токена мы игнорируем, и вот этот токен первый мы используем только здесь.

Соответственно, вот это действие пропущено в нашей цепочке действий. То, что мы используем здесь состояние внешнего мира не то, которое запродюсировало у нас вот это действие, что по-хорошему, а мы используем состояние на предыдущем действии. Это один из вариантов. Это в случае, если у нас вычисление пойдет вот по этому сценарию. Если же вычисление пойдет по второму сценарию, то сначала мы обратимся к фейковому токену, проигнорируем его, а затем вызовем на начальном токене, что тоже неправильно, потому что у нас первым иошным действием произошло вот это действие.

Соответственно, нам нужно его токен использовать дальше как результат. Но мы используем самый лишь начальный токен, который у нас передали в функцию main, и затем используем его и получаем новый токен S1, который мы передаем в функцию main. Соответственно, как-то так это выглядит под лупой, можно так сказать. И что хочется сказать в заключение на этот счет, что если вам особо это не нужно, не используйте янца и функции в Haskell, да и вообще в любом другом языке программирования. И общий паттерн, когда unsafeperform.

io работает и особо не вызывает никаких проблем, но там тоже есть нюансы, это когда мы находимся вне IOManada вообще. Потому что нам не страшно потерять какой-то контекст, если у нас этого контекста нет. Когда мы находимся в IOManada, вы видите, что использование unsafeperform. io рождает недетерминированность. То есть в зависимости от того, как компилятор перепорядочит инструкции, мы можем получить как один результат, так и другой.

Тут дело даже не в том, что в результате. Результат – это ладно, одни и те же. Но наши функции, так как они IO, они умеют производить некоторые side-эффекты. И эти side-эффекты могут зависеть друг от друга. Side-эффекты, выполненные в одном порядке, могут давать одно состояние программы.

Один результат программы. Side-эффекты, выполненные в другом состоянии, могут давать другой результат программы. Допустим, если речь идет о записи в базу данных. То есть у нас могут быть строки, помененные местами или что-то там еще, что очень трудно отображать и отследить. Поэтому основная проблема в использовании unsafeperform.io находится в том, что очень рекомендуется его использовать, находясь уже в IOCонтексте.

Если же мы находимся вне IOCонтекста, в большинстве случаев нам нечего терять. В том плане, что у нас нет стейк-токена, который мы потеряем. И поэтому может быть безопасно использовать unsafeperform.io. И сейчас мы даже разберем, каким образом безопасно он используется и как это облегчает жизнь. Первым примером является модуль debug.

trace, который имеет следующие функции. Функция trace, которая принимает строчку, значение и возвращает значение. Что делает функция trace? Трейс просто берет и пишет вот эту строчку в консоль. Допустим, давайте посмотрим на пример функции trace. Мы можем вызвать функцию trace, приставить туда какую-то строчку.

И когда Haskell будет вычислять это выражение, он напишет эту строчку в консоль. Это в силу того, что в Haskell нет дебаггеров. Если бы необходимый тулинг для дебаггера был, было бы непонятно, как бы он выглядел. Потому что идея прыгания по инструкции в Haskell неприменима. Потому что инструкции здесь нет.

А дебаггер, который редуцирует выражение, это что-то странное и не особо нужное. Поэтому, да, в Haskell нет дебаггера. И приходится дебажить выводами. А в силу того, что вывод – это всегда что-то иошное. А у нас далеко не вся логика иошная.

Иошные логики стараются делать настолько мало, насколько это возможно. Приходит на помощь пакет debug.trace. С помощью которого можно трейсить промежуточные результаты нашей программы. Функция trace, которая просто выводит строчку при вычислении выражения a. Есть функция trace show, которая вместо строчки принимает какое-то значение, которое можно привести к строке и распечатать, что оно и делает.

И также есть функция trace m, которая принимает какое-то аппликативное действие и перед его выполнением печатает в консоль строчку. Аппликативность существует по легаси причинам, я бы так сказал. По-хорошему тут должна быть манана. Но аппликатив что есть, то есть. И как выглядит функция trace? На самом деле это просто unsafe perform.io от следующего дублока.

Мы печатаем консоль строчку с помощью функции trace.io. Можно сказать то же самое, что put strln, просто с добавлением какой-то дебаг информации. И мы возвращаем наше выражение. Соответственно, trace печатает и возвращает. Ровно так же, как наша функция helper, помните, которая была.

Так работает функция trace. Можно рассмотреть пример ее использования в вычислении чисел Fibonacci. В corner-кейсах мы не пишем никакого вывода, а когда мы вызываем recursive, мы пишем, какое n мы вычисляем. Соответственно, 4, 3, 2, 2. А, ну мы тут дописали, потому что мы изначально ничего не пишем.

Вот. И результат будет только получается. Есть ли какие-то вопросы по дебаггингу, по трейсу или unsafe магии, если вдруг они созрели? Хорошо, видимо, вопросов нет. И сейчас, кажется, коснемся уже последней темы, про умные строки. Точнее, про эффективные строки.

Строки в Haskell, которые string, как мы еще с первой лекции с вами заметили, это просто список символов, что весьма и весьма неэффективно. И сейчас мы разберемся, какие эффективные реализации строк у нас бывают в Haskell, и, казалось бы, при чем тут и о, а вот тем более unsafe о. Начнем с того, что, помните, мы с вами говорили про то, что числовые литералы в Haskell полиморфны. На самом деле, при подключении extension overloaded strings можно сделать строковые литералы также полиморфными. Это делается с помощью трек-класса isString с единственной функцией fromString, которая позволяет нам из строчки сконвертить нужный нам тип.

Соответственно, если мы подключили без extension overloaded strings, тип строчки full – это всегда строка, то есть список символов. Если мы подключаем расширение overloaded strings, то это некоторый а – такой, что а – это isString, что как бы намекает нам на то, что в Haskell существуют разные реализации строк. Первой эффективной реализацией является тип данных text, который находится в модуле data.txt в пакете text. Импортим мы его, как вы заметили, с использованием import qualified. Это сделано намеренно, потому что большинство функций в модуле data.

txt пересекаются по именам, оверлапятся с функциями работы над строками. И чтобы Haskell не ругался, мы используем qualified имена. То есть данный модуль специально задизайнен так, чтобы его импортировали qualified. И давайте посмотрим, как можно создавать новые экземпляры по данным текстам. Для этого существует функция pack, которая принимает строчку и запаковывает ее в текст.

Но также, если у нас подключено расширение overloaded strings, мы можем просто написать строковый литерал, который сам зарезолвится в текст. Для текста есть все удобные функции для работы с строками. Взятие по индексу, взятие префикса, взятие суффикса, конкретинация, все, что душе угодно, с эффективной, насколько это возможно, реализацией. Отвечая на вопрос, который будет подробно освещен чуть позднее, при чем тут вообще IO и при чем unsafe IO, что на самом деле текст реализован просто через сипшный указатель. То есть под капотом текста находится сипшный указатель на юникодный кодпоинт.

То есть это все реализовано просто через указатель, как это реализовано в сипке. Что позволяет нам довольно эффективной манипуляции. Но чтобы не делать всю логику работы с текстом IO, в хастеле все это взяли и запрятали под unsafe perform IO. Практика показывает, что здесь unsafe perform IO не мешает. Потому что если использовать текст в чистых функциях, понятно почему, но даже в овощных функциях, благо, создатели библиотеки постарались, и оно не доставляет проблем, даже несмотря на то, что здесь используется unsafe IO.

Есть также другая эффективная реализация строк, которая называется байтстринг. Судя из названия, понятно, что она работает со строками в бинарном представлении. Несмотря на то, что у него также существует instance и string, но вы знаете, что в байтстринге лежат байтики. Соответственно, ваша строчка, которую вы написали в виде строкового литерала, будет храниться в виде байтиков. И у модуля байтстринг также существует множество удобных функций для конкатенации и всем, чему душе угодно, для работы с байтовыми строками.

На вопрос, где же тут unsafe perform IO, если вы немного посмотрите на этот код, на который мы, конечно же, не будем смотреть подробно, потому что зачем, мы видим, что байтстринг – это, на самом деле, какой-то оберт над фаре-нпт, как раз-таки поинтер, на Word8. Word8 – это просто машинное слово. То есть octet, так еще говорят. 8-бит. Соответственно, у нас есть функция create, которая принимает какую-то страшную сигнатуру, принимает, видимо, какой-то индекс для аллокации, потом количество байтов, сколько мы аллоцируем, принимает какую-то функцию из поинтера в IO и изучает IO-байтстринг.

И, соответственно, здесь у нас под капотом запрятано IO, но с помощью unsafe perform IO функции для работы с байтстрингом не требуют от нас нахождения в вашем коде. Вот, допустим, есть функция unsafe create, которая просто unsafe perform IO надкреет. И если рассматривать, в чем же все-таки разница между текстом и байтстрингом, как мы уже говорили, текст оперирует уникодными символами, а байтстринг оперирует octet, то есть Word8. То есть элементарная единица строки разная. Что же все-таки использовать? Вопрос достаточно нетривиальный на самом-то деле, потому что существует тонна реализаций строк, как вы видите на этих файлах.

Если же нам нужны бинарные данные, и они нужны в запакованном виде, сейчас мы поймем, что это. Если они нужны ленивые, существует пакет database.string. lazy, который как раз-таки не эвалюирует стройку, пока это не нужно. Также существует database.string.prost, который на самом деле строгий, который будет вычислять наши байтстринги. Также существует unpacked версия.

Это когда в куче под наш конструктор создается отдельная нода. Можно так сказать, когда можно представлять наше значение в виде дерева, и вот этот фанг нашего хаскерного типа данных, можно сказать, что под конструктором в нем есть отдельные ноды. Но есть также unpacked типа данных. Это когда у нас как C-шную структуру, как все лежит друг за другом, что более эффективно с точки зрения памяти. Соответственно, есть байтстринг, еще и unpacked.

Даже такое есть. Соответственно, если нужна packed и lazy, то тогда мы можем сказать database.string.lazy.char.8. Короче, куча разных функций, точнее, куча разных типов данных, но ничего кроме lazy.string.text и lazy.string.bait. string на практике никогда не используется. Соответственно, решайте, что вам нужно.

Если вы работаете с Unicorn, вы используете текст. Если у вас большие строки, вы используете lazy, маленький и strict. То же самое с бинарными данными. Если у вас большие какие-то строки, вы используете байтстринг. Если маленькие и не хотите нарваться на проблемы с NCPIO, можете использовать строку.

Соответственно, но типов строк тут полный зоопарк, большинство из которых я, если честно, там впервые вижу, которые не особо-то используются. Просто знайте, что такие есть. И все это позволяет нам делать как раз-таки наше UnCPU, если использовать его с умом. Но, соответственно, тут, как обычно, куча ссылочек. Из того, что я бы рекомендовал посмотреть, это вот эта статья на FB Complete про то, как в Haskell и Arizona всякие разные примитивы, когда мы с вами говорили про MagicHash и решеточку в конце типа.

Готов, если у вас есть какие-то вопросы, на них ответить. Если вопросов нет, можем расходиться. До свидания. До свидания. До свидания.

