1
00:00:08,930 --> 00:00:10,931
Всё, супер, запись вроде началась.

2
00:00:13,960 --> 00:00:17,917
Сегодня у нас будет с вами лекция
про взаимодействие с внешним миром,

3
00:00:18,000 --> 00:00:24,000
про то, как считывать, писать в
консоль, общаться по сети и так далее,

4
00:00:24,120 --> 00:00:26,602
какие возможности
для этого есть в Haskell,

5
00:00:26,685 --> 00:00:30,120
как такой общий механизм
под названием Monado.io.

6
00:00:31,380 --> 00:00:34,817
Основные монады все
помимо неё вы изучили на

7
00:00:34,900 --> 00:00:37,280
прошлой лекции, и сегодня
речь коснётся именно её.

8
00:00:37,780 --> 00:00:40,251
Будем всю лекцию говорить об одной монаде.

9
00:00:40,680 --> 00:00:44,386
И, наконец-таки, с вами научимся
писать Hello World на Haskell.

10
00:00:46,020 --> 00:00:54,160
Сначала мы поймём, как в Haskell
с моделью частоты на уровне типов

11
00:00:54,860 --> 00:00:57,637
придумаем с вами, как
написать функцию getChart,

12
00:00:57,720 --> 00:01:01,880
которая читает что-то из консоли,
один-единственный символ.

13
00:01:02,280 --> 00:01:05,727
Поговорим, наконец, про то, что
такое Monado.io, как оно устроено.

14
00:01:05,810 --> 00:01:08,957
Также коснёмся такой вещи,
которая называется дунотация,

15
00:01:09,040 --> 00:01:13,511
что это синтаксический сахар для удобного
написания монадических вычислений.

16
00:01:13,860 --> 00:01:18,597
Поговорим про проблемы, которые бывают при
взаимодействии с внешним миром в Haskell.

17
00:01:18,680 --> 00:01:22,077
Поговорим про такую вещь,
как FFI, Foreign Function Interface,

18
00:01:22,160 --> 00:01:27,140
про то, как вызывать всякий разный
C-шный код, и не только из Haskell.

19
00:01:28,020 --> 00:01:34,300
Также поговорим про то,
как в IEO у нас работать с

20
00:01:34,301 --> 00:01:36,419
мутабельными данными, потому
что IEO позволяет это делать.

21
00:01:36,820 --> 00:01:41,680
Поговорим немного про эксепшены,
про такую вещь, как UnsafeIO.

22
00:01:42,560 --> 00:01:45,537
И также поговорим про
эффективную реализацию строк.

23
00:01:45,620 --> 00:01:48,627
Так как в самой первой лекции,
если вы помните, мы говорили,

24
00:01:48,710 --> 00:01:51,960
что строки в Haskell
достаточно неэффективны.

25
00:01:52,580 --> 00:01:56,920
И поговорим про эффективную
реализацию под названием TextAbideString,

26
00:01:57,560 --> 00:01:59,325
и при чём же там всё-таки IEO.

27
00:01:59,700 --> 00:02:00,780
Давайте разбираться.

28
00:02:00,781 --> 00:02:04,782
Давайте поставим такую задачу
перед собой, написать функцию getChart,

29
00:02:04,865 --> 00:02:08,697
которая возвращает нам символ,
который пользователь печатает в консоли.

30
00:02:08,780 --> 00:02:13,100
И, например, с её использованием
напишем функцию getToCharts,

31
00:02:13,520 --> 00:02:16,397
которая с использованием
getChart просто считает два символа.

32
00:02:16,480 --> 00:02:19,597
Скажите, пожалуйста, видите
ли вы в этом какие-то проблемы?

33
00:02:19,680 --> 00:02:24,840
Даже не глядя на реализацию,
просто по сигнатуре данной функции

34
00:02:25,440 --> 00:02:30,500
уже понятно, что что-то
тут нечисто, что-то тут не так.

35
00:02:31,260 --> 00:02:33,143
Есть какие-нибудь предположения?

36
00:02:33,720 --> 00:02:34,553
...

37
00:02:36,320 --> 00:02:38,440
Да, это первая из проблем.

38
00:02:41,500 --> 00:02:45,148
Всё то, что не имеет аргументов
у нас в Haskell, это консанта.

39
00:02:45,780 --> 00:02:48,428
Поэтому, казалось бы,
судя по сигнатуре типа,

40
00:02:48,860 --> 00:02:50,817
когда и где бы мы не вызывали getChart,

41
00:02:50,900 --> 00:02:54,136
у нас должен вернуться только
лишь единственный символ.

42
00:02:54,430 --> 00:02:56,580
С функцией getChart хорошо понятно.

43
00:02:56,680 --> 00:03:00,560
Давайте представим на секунду,
что мы всё-таки каким-то образом

44
00:03:01,240 --> 00:03:03,042
реализовали функцию getChart правильно,

45
00:03:03,125 --> 00:03:07,780
чтобы она возвращала разные символы из
консоли при разных моментах считывания.

46
00:03:08,200 --> 00:03:09,737
Что же с функцией getToCharts?

47
00:03:09,820 --> 00:03:12,700
С ней тоже есть небольшая проблема.

48
00:03:20,080 --> 00:03:21,728
Окей, давайте тогда я скажу.

49
00:03:21,900 --> 00:03:24,160
Если вы помните, на самой первой лекции,

50
00:03:24,220 --> 00:03:27,456
когда мы с вами говорили про
ленивую модель вычислений,

51
00:03:28,260 --> 00:03:30,143
которая задействована в Haskell,

52
00:03:30,440 --> 00:03:35,040
то речь касалась того, что
редукция выражений в Haskell,

53
00:03:35,440 --> 00:03:38,537
в ленивой модели вычислений,
вообще говоря, не определена.

54
00:03:38,620 --> 00:03:41,717
Точнее, порядок редукции,
вообще говоря, не определен.

55
00:03:41,800 --> 00:03:46,380
Таким образом, ваше выражение может
редуцироваться в каком угодно порядке,

56
00:03:46,480 --> 00:03:49,989
и поэтому абсолютно
непонятно, в каком порядке

57
00:03:50,031 --> 00:03:53,581
в нашем результирующем
списке окажется символ.

58
00:03:54,000 --> 00:03:56,517
Компилятор может посчитать нужным
сочетать сначала первый символ,

59
00:03:56,600 --> 00:03:59,477
а потом второй, или же
сначала второй, а потом первый.

60
00:03:59,560 --> 00:04:03,090
Это вторая проблема.
И сейчас мы потихоньку будем ее решать.

61
00:04:05,420 --> 00:04:08,891
Да, это как раз таки то, что
мы с вами сейчас переговорили.

62
00:04:09,880 --> 00:04:14,860
И давайте попробуем
все-таки как-то исхитриться

63
00:04:14,861 --> 00:04:21,040
и попробовать задать порядок
на вызовах функций getChart,

64
00:04:21,265 --> 00:04:27,620
и также заставим ее
возвращать разные символы.

65
00:04:27,940 --> 00:04:29,897
Сделать это можно достаточно
просто, на самом деле.

66
00:04:29,980 --> 00:04:32,628
Можно просто передавать
функцию getChart int,

67
00:04:33,740 --> 00:04:36,877
допустим, порядковый номер
символа из консоли, почему нет.

68
00:04:36,960 --> 00:04:40,196
И таким образом эта функция
перестает быть константной.

69
00:04:40,360 --> 00:04:45,660
И мы можем просто скарливать туда int,

70
00:04:46,100 --> 00:04:50,040
и, соответственно, у нас
будет отдавать разные символы.

71
00:04:50,041 --> 00:04:52,947
Но, к сожалению, она никак
не решит проблему с порядком.

72
00:04:53,030 --> 00:04:58,040
Потому что вызов второго getChart никак
не зависит от вызова первого getChart.

73
00:04:58,260 --> 00:05:01,877
И таким образом компилятору ничего не
мешает абсолютно перепорядочить вычисление

74
00:05:01,960 --> 00:05:04,697
и сначала вызвать второй
getChart, а потом первый.

75
00:05:04,780 --> 00:05:08,310
Есть ли какие-то мысли насчет
того, как это можно исправить?

76
00:05:21,030 --> 00:05:23,582
getChart взаимодействует
с глобальным буфером,

77
00:05:23,665 --> 00:05:26,018
из которого достают значения по индексу.

78
00:05:28,160 --> 00:05:29,917
Непонятно, что есть глобальный буфер.

79
00:05:30,000 --> 00:05:31,297
Это, знаете, какая-то абстрактная вещь.

80
00:05:31,380 --> 00:05:35,500
Пока что все, что мы умеем,
это просто скарливать int.

81
00:05:36,540 --> 00:05:39,800
То есть оперировать какой-то чиселкой,

82
00:05:41,980 --> 00:05:45,500
суть которой в том, чтобы наша
функция не была константной.

83
00:05:46,340 --> 00:05:49,317
И у нас, соответственно, проблема
в том, что у нас вызовы getChart,

84
00:05:49,400 --> 00:05:53,057
если мы хотим прочитать два
getChart, не зависят друг от друга.

85
00:05:53,140 --> 00:05:55,580
Как сделать их зависимыми друг от друга?

86
00:05:56,620 --> 00:05:58,717
Используя, на самом деле,
более-менее тот же трюк,

87
00:05:58,800 --> 00:06:02,977
который мы использовали с int,
просто добавив его в качестве аргумента.

88
00:06:04,290 --> 00:06:09,173
Может быть, сказать, что getChart2, прежде
чем вызваться, должен вызвать getChart1?

89
00:06:10,520 --> 00:06:11,873
Вот, а как это сделать?

90
00:06:12,260 --> 00:06:14,720
Это то, что нам нужно сделать.

91
00:06:14,920 --> 00:06:17,460
И, соответственно, интересует вопрос как?

92
00:06:20,810 --> 00:06:24,575
Как заставить компилятор сначала
вызвать первую, а потом вторую?

93
00:06:27,350 --> 00:06:28,645
Репорсия какая-нибудь?

94
00:06:32,495 --> 00:06:33,620
На самом деле нет.

95
00:06:34,020 --> 00:06:37,917
Я вполне верю, что в случае с двумя
чарами действительно так можно сделать.

96
00:06:38,000 --> 00:06:41,377
Но если рассматривать какую-то
более общую модель, давайте посмотрим.

97
00:06:41,460 --> 00:06:45,637
На самом деле можно просто возвращать
из функции getChart пару char int

98
00:06:46,560 --> 00:06:50,260
и возвращать оттуда
следующий порядковый номер.

99
00:06:50,700 --> 00:06:53,620
Таким образом, у нас
вызов второго getChart,

100
00:06:55,240 --> 00:06:58,817
следующий порядковый номер, который
мы скормим следующему вызову getChart.

101
00:06:58,900 --> 00:07:01,929
Таким образом, вызов
функции getChart2 в данном

102
00:07:01,972 --> 00:07:04,781
случае будет зависеть
от функции getChart1.

103
00:07:05,850 --> 00:07:09,646
Если мы изменим и будем
возвращать пару, мы сначала

104
00:07:09,688 --> 00:07:13,601
вызовем getChart1 и вернем
второе значение счетчика.

105
00:07:13,601 --> 00:07:16,872
И потом по второму значению
счетчика вызовем уже второй getChart.

106
00:07:16,955 --> 00:07:19,877
Таким образом, компилятору
ничего больше не остается делать,

107
00:07:19,960 --> 00:07:23,372
кроме как вычислить данные
выражения в правильном порядке.

108
00:07:29,800 --> 00:07:33,757
Ну и соответственно, данная модель, к
сожалению, не сказать, чтобы расширяема,

109
00:07:33,840 --> 00:07:37,311
потому что, допустим, мы хотим
написать функцию get4charts,

110
00:07:37,840 --> 00:07:41,697
которая также вернет список, но
это будет весьма и весьма неудобно,

111
00:07:41,780 --> 00:07:45,180
потому что вот такая
запись также не подойдет.

112
00:07:45,580 --> 00:07:49,110
И нам нужно сделать вот эти
четыре промежуточных assignment,

113
00:07:49,310 --> 00:07:53,140
чтобы все-таки наши символы
считались в правильном порядке.

114
00:07:53,490 --> 00:07:56,519
Так что при расширении
этого на какие-то большие, при

115
00:07:56,561 --> 00:07:59,458
обобщении на какое-то
большее количество символов,

116
00:07:59,540 --> 00:08:02,070
у нас все еще существует
такая же проблема.

117
00:08:04,540 --> 00:08:07,717
И, соответственно, это про
то, как все-таки исправить,

118
00:08:09,020 --> 00:08:13,315
переписать просто вот эту функцию
так же, как мы переписывали get4charts.

119
00:08:13,930 --> 00:08:18,380
И вы не поверите, но мы сейчас с
вами придумали то в общем виде,

120
00:08:18,805 --> 00:08:21,600
как монадическое IO работает в Haskell.

121
00:08:21,940 --> 00:08:25,293
Там, конечно, все немного
похитрее, без каких-либо интов.

122
00:08:26,320 --> 00:08:27,909
Сейчас мы с вами посмотрим.

123
00:08:30,920 --> 00:08:35,332
Давайте сначала зададим такой игрушечный
тип, который будет называться IOA.

124
00:08:36,260 --> 00:08:39,220
Это просто будет функция
из какого-то real world,

125
00:08:39,460 --> 00:08:43,207
из какого-то состояния реального мира,
в котором мы с вами сейчас существуем.

126
00:08:43,290 --> 00:08:47,720
В результат этой функции и
новое состояние реального мира.

127
00:08:47,820 --> 00:08:50,997
То есть мы просто заменили int
каким-то более абстрактным дататайпом,

128
00:08:51,080 --> 00:08:53,786
который представляет
состояние реального мира.

129
00:08:54,230 --> 00:08:57,497
Собственно, в общих чертах так
и выглядит механизм IO в Haskell.

130
00:08:57,580 --> 00:09:01,933
То есть вместо вот этого нашего int,
который задает порядок на вычисление,

131
00:09:02,380 --> 00:09:06,180
у нас между вызовами иошных
функций просто передается токен,

132
00:09:06,960 --> 00:09:09,725
который как-то модифицируется
и задает порядок.

133
00:09:11,440 --> 00:09:13,937
Соответственно, когда вы
делали домашнее задание,

134
00:09:14,020 --> 00:09:18,760
вы увидели то, что entry point программы
в Haskell также является функция main,

135
00:09:19,160 --> 00:09:21,780
которая имеет тип IO пустой кортеж.

136
00:09:21,920 --> 00:09:25,837
Пустой кортеж используется тогда, когда
у функции нет осмысленного результата,

137
00:09:25,920 --> 00:09:29,280
и нам нужно что-либо вернуть,
и это такой dummy datatype,

138
00:09:29,420 --> 00:09:30,950
unit-тип, как еще говорят.

139
00:09:31,140 --> 00:09:33,997
Тип, у которого всего один
элемент, пустой кортеж.

140
00:09:34,080 --> 00:09:36,117
Соответственно, если
раскрыть вот этот алиас,

141
00:09:36,200 --> 00:09:39,553
то у нас получается main
принимает какой-то реальный мир,

142
00:09:39,680 --> 00:09:41,537
возвращает в ничего,
то есть в пустой кортеж,

143
00:09:41,620 --> 00:09:44,385
и возвращает в другое
состояние реального мира.

144
00:09:45,680 --> 00:09:49,780
И таким образом у нас выглядит
переписанная функция getChar,

145
00:09:50,360 --> 00:09:55,200
ее сигнатура на новую модель,
которую мы сейчас с вами задали.

146
00:09:56,300 --> 00:09:59,937
И, соответственно, так можно
использовать ее, например,

147
00:10:00,020 --> 00:10:02,780
в функции main, если
раскрыть вот этот type синоним.

148
00:10:08,160 --> 00:10:09,587
Все еще остаются вопросы.

149
00:10:09,670 --> 00:10:17,130
Может ли компилятор скипать или
как-то переупорядочивать вызовы getChar,

150
00:10:17,370 --> 00:10:18,253
как вы думаете?

151
00:10:19,890 --> 00:10:25,290
Или данная модель позволяет нам
достаточно безопасно быть уверенным в том,

152
00:10:25,460 --> 00:10:28,108
что порядок на наших
вычислениях сохраняется?

153
00:10:34,160 --> 00:10:38,487
Ну, давайте не будем тянуть и отвечу
сразу, что этого более-менее достаточно.

154
00:10:38,570 --> 00:10:44,770
Для того, чтобы быть уверенным в
том, что наша модель жизнеспособна.

155
00:10:46,070 --> 00:10:50,150
Потому что действительно скипать
вызовы getChar мы не можем.

156
00:10:50,390 --> 00:10:53,861
Почему? Потому что каждый
следующий зависит от предыдущего.

157
00:10:54,190 --> 00:10:59,931
А если в конечном итоге мы используем
результат нашего последнего вызова getChar,

158
00:11:00,310 --> 00:11:04,450
то есть Haskell заэволюетит
вот этот санк, который накопился.

159
00:11:04,570 --> 00:11:07,107
Санк, напомню, это какое-то
невычисленное выражение.

160
00:11:07,190 --> 00:11:10,210
Если же в конце концов мы
печатаем это значение на консоль,

161
00:11:10,290 --> 00:11:13,585
или потом матчимся по нему,
или сравниваем его с чем-то,

162
00:11:16,000 --> 00:11:19,000
оно редуцируется до
слабоголовной нормальной формы.

163
00:11:19,110 --> 00:11:22,410
И все эти вызовы промежуточные
getChar нам тоже нужны.

164
00:11:22,550 --> 00:11:24,256
Поэтому скипов не может быть.

165
00:11:24,610 --> 00:11:28,447
Свопов не может быть тоже, потому что
мы задали линейный порядок на вычислениях.

166
00:11:28,530 --> 00:11:32,670
И также не бывает каких-то
дополнительных вызовов getChar,

167
00:11:32,770 --> 00:11:36,006
потому что каждый раз они
вызываются на разных токенах.

168
00:11:36,420 --> 00:11:39,360
И каждый раз нам нужно
вызвать эту функцию.

169
00:11:39,460 --> 00:11:42,777
И достаточно вызвать ее единую,
чтобы получить ее результат.

170
00:11:42,860 --> 00:11:45,818
То есть таким вот достаточно
нехитрым способом мы с

171
00:11:45,860 --> 00:11:48,918
вами решили проблему
взаимодействия с внешним миром,

172
00:11:49,000 --> 00:11:51,648
а именно с заданием
порядков на нем операции.

173
00:11:52,120 --> 00:11:54,814
Что являлось на самом
деле основной проблемой,

174
00:11:54,857 --> 00:11:57,592
когда мы с вами
рассматривали функцию getChar.

175
00:11:58,190 --> 00:12:00,811
Давайте посмотрим на
реальную имплементацию

176
00:12:00,853 --> 00:12:03,701
IO, как она выглядит в
стандартной библиотеке.

177
00:12:03,701 --> 00:12:07,020
Выглядит она немного
страшнее, но сути дела не меняет.

178
00:12:07,480 --> 00:12:12,120
Это у нас NewTypeIO, где A – это
результат какого-то иошного вычисления.

179
00:12:13,700 --> 00:12:18,320
И есть у нас GetterOnIO, который
также представляет функцию,

180
00:12:18,440 --> 00:12:22,480
только вместо TypeAlias это
NewType, потому что так правильнее,

181
00:12:22,610 --> 00:12:26,860
как мы уже, наверное, с вами
говорили на предыдущих лекциях.

182
00:12:27,360 --> 00:12:33,200
И вместо токена realworld используется
странный тип state решетка realworld.

183
00:12:34,820 --> 00:12:35,917
И, в общем-то, все.

184
00:12:36,000 --> 00:12:38,824
Пожалуйста, не путайте
этот state с monad.state.

185
00:12:39,240 --> 00:12:45,860
State решетка – это просто такой маркерный
тип данных, который позволяет нам…

186
00:12:47,600 --> 00:12:50,097
Вот этот маркер state на
самом деле нужен для того,

187
00:12:50,180 --> 00:12:56,220
чтобы при исполнении иошных
действий в разных потоках,

188
00:12:56,221 --> 00:12:58,280
в разных контекстах вычисления
не мешались между собой.

189
00:12:58,680 --> 00:13:00,757
То есть state на самом
деле – это просто какой-то

190
00:13:00,840 --> 00:13:03,193
маркерный тип, ничего общего
с monad.state он не имеет.

191
00:13:04,470 --> 00:13:07,657
Благодаря этому вопросу,
откуда все-таки взялась решетка,

192
00:13:07,740 --> 00:13:12,360
в Haskell есть такая конвенция про
то, что когда мы оперируем какими-то

193
00:13:12,361 --> 00:13:18,060
низкоуровневыми вещами, имплементация
которых, возможно, задана на языке C

194
00:13:18,360 --> 00:13:23,040
и используется FFI, ну, это, допустим
так, на эти функции в Java какие-нибудь.

195
00:13:23,240 --> 00:13:31,020
Вот есть такое соглашение, что такие
вещи имеют суффикс решетка в своем имени.

196
00:13:31,540 --> 00:13:33,522
Соответственно, суффикс
решетка на самом деле

197
00:13:33,565 --> 00:13:35,858
можете использовать и вы
в вашем произвольном коде,

198
00:13:35,940 --> 00:13:38,640
просто это не будет соответствовать
общепринятой конвенции,

199
00:13:38,720 --> 00:13:42,250
если же вы не пишете какие-то
совсем уж низкоуровневые вещи.

200
00:13:42,400 --> 00:13:46,357
И использовать ее можно
весьма просто, просто подключить

201
00:13:46,440 --> 00:13:48,417
решение magic-hash, и тогда
данная синтез станет валидной.

202
00:13:48,500 --> 00:13:52,561
Соответственно, если вы
пороетесь в стандартной библиотеке

203
00:13:52,561 --> 00:13:54,958
где-то в ее глубине, вы найдете
достаточно много кода, которые

204
00:13:55,000 --> 00:13:57,974
используют идентификаторы
с вот этой вот решеткой,

205
00:13:58,060 --> 00:14:00,577
которые говорят о том,
что, чувак, мы здесь

206
00:14:00,620 --> 00:14:03,238
оперируем достаточно
низкоуровневыми вещами.

207
00:14:05,300 --> 00:14:09,877
Как тут видно в этих примерах, вот это наш
data.type.mystery, который мы определили,

208
00:14:09,960 --> 00:14:12,727
он абсолютно может также
использоваться, он ничем

209
00:14:12,769 --> 00:14:15,348
не отличается от обычных,
кроме своего имени.

210
00:14:15,430 --> 00:14:19,047
Тут, кстати, есть
хорошая статья про то, как

211
00:14:19,089 --> 00:14:22,581
в Haskell реализованы различные примитивы.

212
00:14:24,020 --> 00:14:25,140
Можете посчитать.

213
00:14:27,380 --> 00:14:32,040
Соответственно, да, у нас есть
такой тип данных, маркерный, как state,

214
00:14:33,220 --> 00:14:35,713
с одной типовой
переменной, и он как раз таки

215
00:14:35,756 --> 00:14:38,798
параметризовывается вот
этим нашим real-world токеном.

216
00:14:38,880 --> 00:14:42,018
На то, как именно выглядит
определение этих типов, мы

217
00:14:42,061 --> 00:14:45,361
не будем смотреть, нам оно
на самом деле и без разницы,

218
00:14:45,500 --> 00:14:49,000
нам важен такой общий
механизм того, как оно работает.

219
00:14:49,860 --> 00:14:52,514
И, как мы уже говорили
в самом-самом начале

220
00:14:52,557 --> 00:14:55,441
лекции, когда рассматривали
table of contents,

221
00:14:56,520 --> 00:15:00,898
IO является монадой, также, соответственно,
оно является функтором и аппликативом,

222
00:15:00,980 --> 00:15:04,700
но эти инстанции здесь не
приведены буквально для простоты.

223
00:15:04,701 --> 00:15:09,840
Я думаю, более-менее очевидно, как
они пишутся для вот этого типа данных.

224
00:15:10,120 --> 00:15:12,759
На самом деле, этот
тип данных немного похож

225
00:15:12,801 --> 00:15:15,421
на монаду state, если
вы обратите внимание,

226
00:15:15,660 --> 00:15:18,778
потому что у нас есть тоже какое-то
состояние, только это не состояние вычисления,

227
00:15:18,860 --> 00:15:23,640
а состояние внешнего мира, которое
задает нам порядок на вычислениях.

228
00:15:23,960 --> 00:15:30,400
И, соответственно, реализация бинда и
ретерна выглядит довольно похожим образом.

229
00:15:30,401 --> 00:15:32,799
То, что у нас какое-то иошное действие n,

230
00:15:32,842 --> 00:15:35,579
если мы биндим с какой-то
стрелкой клейстрика,

231
00:15:35,820 --> 00:15:38,940
то это в результате все еще
получается иошное действие.

232
00:15:39,000 --> 00:15:45,720
Такое, что мы сначала применяем
наше действие к первому реальному миру.

233
00:15:47,320 --> 00:15:51,140
Это иошное действие из какого-то
стейта реального мира во что?

234
00:15:53,100 --> 00:15:57,600
В то, что мы применяем вот это наше
иошное действие к состоянию внешнего мира.

235
00:15:57,601 --> 00:16:00,601
Получаем новое состояние
внешнего мира и результат.

236
00:16:00,885 --> 00:16:04,184
И, соответственно, потом
мы применяем нашу стрелку

237
00:16:04,227 --> 00:16:07,501
клейстрика к этому
результату и новому состоянию.

238
00:16:07,920 --> 00:16:10,837
Ну и здесь мы делаем an.io
просто, чтобы тип сошлись.

239
00:16:10,920 --> 00:16:14,097
Потому что здесь мы уже указали
то, что мы заворачиваем, это ио.

240
00:16:14,180 --> 00:16:16,533
И здесь нам это нужно просто развернуть.

241
00:16:16,680 --> 00:16:18,386
Довольно механическая работа.

242
00:16:18,880 --> 00:16:23,240
Суть дела в том, что мы применяем
наше действие к состоянию внешнего мира,

243
00:16:23,540 --> 00:16:27,263
потом применяем к
нему стрелку клейстрика и

244
00:16:27,306 --> 00:16:32,121
присовываем к этому новое
наше состояние внешнего мира,

245
00:16:32,280 --> 00:16:35,137
которое будет использоваться
в дальнейших вычислениях.

246
00:16:35,220 --> 00:16:42,500
Return выглядит тривиально, как
и его реализация для всех монад.

247
00:16:42,840 --> 00:16:45,944
Это просто мы запаковываем
вот такую функцию, которая

248
00:16:45,987 --> 00:16:49,489
никак не меняет состояние
нашего внешнего мира, в панадойю.

249
00:16:51,480 --> 00:16:53,817
Пожалуйста, есть ли какие-то
вопросы по типу данных.

250
00:16:53,859 --> 00:16:58,625
io, который определен в стандартной
библиотеке, и по инстансу монада для него.

251
00:17:10,380 --> 00:17:12,733
Видимо, вопросов нет. Давайте продолжим.

252
00:17:13,330 --> 00:17:19,720
И поговорим про такую вещь, которая всегда
идет где-то рядом с монадами в Haskell.

253
00:17:19,920 --> 00:17:22,140
Это doSyntax или doNotation,

254
00:17:22,141 --> 00:17:26,312
которая позволяет нам удобно в
стиле, похожем на стиль написания

255
00:17:26,355 --> 00:17:30,041
в императивных языках,
задавать монадические вычисления.

256
00:17:31,020 --> 00:17:36,680
Вспомним, что у нас есть монадический
оператор, так называемый урезанный бинт,

257
00:17:37,250 --> 00:17:42,440
птичка-птичка, который
имеет тип monad m, mA, mB, mB.

258
00:17:42,720 --> 00:17:45,655
То есть он выполняет первое
действие, выполняет второе

259
00:17:45,697 --> 00:17:48,398
действие и возвращает
результат второго действия.

260
00:17:48,480 --> 00:17:50,780
Вот, соответственно,
рассмотрим следующий пример.

261
00:17:50,860 --> 00:17:54,436
Здесь приведем его тип,
специализированный для монада.

262
00:17:54,478 --> 00:17:58,273
io, для красоты, так как речь на этой
лекции будет вестись только о ней.

263
00:18:00,040 --> 00:18:04,640
Рассмотрим, во что у нас
дешевелится вот это синтаксис.

264
00:18:04,980 --> 00:18:09,600
На самом деле это просто мы применяем
наши действия сначала к первому миру,

265
00:18:11,540 --> 00:18:14,058
точнее к изначальному
миру world0, получаем

266
00:18:14,100 --> 00:18:16,600
world1, и нас не интересует его результат.

267
00:18:16,900 --> 00:18:19,240
Затем мы этот world1 скармливаем второму

268
00:18:19,283 --> 00:18:21,843
действию, получаем b
и world2 и возвращаем.

269
00:18:22,170 --> 00:18:25,460
Вот как это будет выглядеть
в нашем dosyнтаксисе.

270
00:18:25,660 --> 00:18:28,497
Давайте, чтобы этот пример
был хотя бы чуть-чуть реальный,

271
00:18:28,580 --> 00:18:32,497
заинтродюсим сразу функцию из стандартной
библиотеки, которая называется put strln,

272
00:18:32,580 --> 00:18:36,600
которая принимает строчку и
возвращает его в пустой кортеж.

273
00:18:36,800 --> 00:18:39,095
Она печатает данную строчку на консоль.

274
00:18:39,500 --> 00:18:42,618
И посмотрим, как можем
написать функцию main,

275
00:18:42,660 --> 00:18:46,241
заиспользовав в ней
функцию put strln и do нотацию.

276
00:18:47,340 --> 00:18:50,146
Вот этот пример довольно
тривиальный, потому что

277
00:18:50,188 --> 00:18:54,640
здесь dosyнтаксис содержит лишь
одну строчку, и можно ее опустить.

278
00:18:54,740 --> 00:18:56,517
Но мы можем писать следующим образом.

279
00:18:56,600 --> 00:18:59,379
Мы можем писать main
равно do, и затем одна

280
00:18:59,421 --> 00:19:02,241
за одной писать какие-то
решенные действия.

281
00:19:02,241 --> 00:19:06,240
Например, сначала вызвать
функцию put strln от первой строки,

282
00:19:06,840 --> 00:19:08,642
потом от второй строки и потом от третьей.

283
00:19:08,725 --> 00:19:13,700
При этом никаких биндов, никаких
операторов птичка-птичка нет.

284
00:19:14,460 --> 00:19:15,797
В основном, это дешевый рейд.

285
00:19:15,880 --> 00:19:21,800
Дешевый рейд – это то, что между каждой
строчкой ставится вызов нашего оператора.

286
00:19:22,180 --> 00:19:25,740
Просто из-за того, что
результат нам не нужен,

287
00:19:26,020 --> 00:19:31,060
мы можем никоим образом не изворачиваться,
просто опустить данный синтаксис.

288
00:19:31,800 --> 00:19:35,860
И вместо того, чтобы на каждой
строчке дородить вот этот оператор,

289
00:19:35,920 --> 00:19:38,697
просто избавиться от него
использованием do-нотаций.

290
00:19:38,780 --> 00:19:40,231
Соответственно, оно позволяет нам просто

291
00:19:40,274 --> 00:19:41,878
одну за одной писать
вот эти наши действия,

292
00:19:41,960 --> 00:19:45,817
которые будут выполняться в том
же порядке, в котором мы их написали.

293
00:19:45,900 --> 00:19:48,897
Почему они будут выполняться
именно в нужном порядке,

294
00:19:48,980 --> 00:19:52,577
следует из реализации вот этого
оператора, который мы сейчас посмотрели.

295
00:19:52,660 --> 00:19:55,237
То есть в отличие от
каких-нибудь let-стейтментов,

296
00:19:55,320 --> 00:19:58,557
которые, если они не зависят друг
от друга напрямую, один за одним,

297
00:19:58,640 --> 00:20:01,760
могут быть, вообще говоря,
вычислены когда угодно.

298
00:20:02,600 --> 00:20:04,759
Монадические вычисления, написанные в

299
00:20:04,802 --> 00:20:07,538
do-нотации в том числе,
лишены этого свойства,

300
00:20:07,620 --> 00:20:10,677
и они вычисляются прямо один
за одним, как мы это скажем.

301
00:20:10,760 --> 00:20:12,231
Просто в силу реализации.

302
00:20:14,080 --> 00:20:15,357
Поговорим еще вот о чем.

303
00:20:15,440 --> 00:20:19,880
Поговорим о том, как нам
исполнять какую-то цепочку действий.

304
00:20:20,500 --> 00:20:23,320
Здесь мы тоже выполняли в
каком-то смысле цепочку действий,

305
00:20:23,321 --> 00:20:28,300
но представим, что у нас есть
какой-то список действий в Monad.io.

306
00:20:28,560 --> 00:20:32,700
Например, сначала
распечатать что-то, потом…

307
00:20:32,825 --> 00:20:34,580
А, ну функция print на самом деле…

308
00:20:34,581 --> 00:20:38,581
Давайте потихоньку будем интродюсить
функции стандартной библиотеки.

309
00:20:38,760 --> 00:20:39,737
Буду вам о них рассказывать.

310
00:20:39,820 --> 00:20:43,908
Функция print на самом
деле принимает произвольный

311
00:20:43,990 --> 00:20:45,320
аргумент, вызывает на
нем show, и делает put strln.

312
00:20:45,860 --> 00:20:49,331
Соответственно, print – это
show a, а a – его пустые карты.

313
00:20:50,360 --> 00:20:55,300
put str – это то же самое, что put
strln, только не печатает line break.

314
00:20:56,280 --> 00:20:58,337
И также у нас есть
функция getChart, которая

315
00:20:58,380 --> 00:21:01,437
также присутствует в стандартной
библиотеке, и мы ее написали.

316
00:21:01,520 --> 00:21:03,815
Она просто считывает символы в консоли.

317
00:21:04,080 --> 00:21:06,656
Соответственно, мы дискаргуем ее результат

318
00:21:06,699 --> 00:21:09,441
с помощью объединения
с return пустой карты.

319
00:21:11,880 --> 00:21:16,540
Если у нас есть такой вот список,
можно исполнить его следующим образом.

320
00:21:16,865 --> 00:21:19,195
Можно через do нотацию в каждой строчке по

321
00:21:19,237 --> 00:21:23,860
индексу обратиться к каждому элементу
списка, и данное действие будет исполнено.

322
00:21:24,110 --> 00:21:28,740
Но это достаточно плохо,
поэтому есть в стандартной

323
00:21:28,800 --> 00:21:30,683
библиотеке функция, которая
называется sinkSequence,

324
00:21:31,345 --> 00:21:35,120
которая принимает список
каких-то монадических действий

325
00:21:35,420 --> 00:21:40,040
и выполняет их последовательно
с дискардингом результата.

326
00:21:40,780 --> 00:21:44,167
Кажется, на предыдущих лекциях
об этом должна вестись речь,

327
00:21:44,250 --> 00:21:46,497
что в Haskell существует
такой naming conventions,

328
00:21:46,580 --> 00:21:52,800
что если какая-то функция
не возвращает никакого

329
00:21:52,880 --> 00:21:54,677
результата, то есть она
игнорирует результат,

330
00:21:54,760 --> 00:21:58,180
у нее последним символом
в имени стоит underscore.

331
00:21:58,860 --> 00:22:02,180
Соответственно, есть функция
sequence без underscore,

332
00:22:02,300 --> 00:22:04,317
которая возвращает список результатов.

333
00:22:04,400 --> 00:22:07,380
Но в данном случае никаких
отмысленных результатов у нас в дейфе нет,

334
00:22:07,460 --> 00:22:10,787
поэтому мы используем функцию
sequence с нижним подчеркиванием.

335
00:22:10,870 --> 00:22:13,622
И, соответственно, мы
можем наш main определить

336
00:22:13,665 --> 00:22:16,577
просто как вызов функции
sequence на этом списке.

337
00:22:18,100 --> 00:22:19,159
Давайте посмотрим.

338
00:22:19,360 --> 00:22:22,280
Можно чуть подробнее
про дискардинг результатов?

339
00:22:22,700 --> 00:22:26,230
Потому что если мы игнорируем
результат от всего IO actions,

340
00:22:26,760 --> 00:22:30,417
то с учетом ленивости вычислений
можно, грубо говоря, оптимизировать

341
00:22:30,500 --> 00:22:32,757
и сделать пустую программу, которая ничего

342
00:22:32,840 --> 00:22:34,840
не делает, если ее
результат никому не важен.

343
00:22:35,560 --> 00:22:36,840
На самом деле нет,

344
00:22:36,990 --> 00:22:40,480
потому что пустой кортеж
все-таки возвращается.

345
00:22:42,260 --> 00:22:43,120
Это во-первых.

346
00:22:43,380 --> 00:22:47,560
Потому что все-таки у нас
не то, чтобы нет никакого

347
00:22:47,640 --> 00:22:48,577
результата, и не то,
чтобы он нам не нужен.

348
00:22:48,660 --> 00:22:51,237
У нас результатом все-таки
служит пустой кортеж,

349
00:22:51,320 --> 00:22:56,360
который в силу нашего
определения монадического минда,

350
00:22:57,410 --> 00:23:00,217
этот результат пропагейтится
из одной функции в другую.

351
00:23:00,300 --> 00:23:04,060
И таким образом монадические
вычисления не являются ленивыми.

352
00:23:04,061 --> 00:23:10,924
Потому что в терминах
зависимости одного звена

353
00:23:10,967 --> 00:23:17,421
цепочки монадических
вычислений от другого,

354
00:23:18,020 --> 00:23:23,000
в силу определения монадического
инстанца, и вообще type class монады,

355
00:23:23,080 --> 00:23:25,677
у нас перед тем, как будет
вызвано следующее действие,

356
00:23:25,760 --> 00:23:28,997
всегда, вне зависимости от
того, нужен ли этот результат

357
00:23:29,080 --> 00:23:30,960
в конце или нет, будет
использовано следующее действие.

358
00:23:31,000 --> 00:23:32,530
Просто в силу определения.

359
00:23:33,210 --> 00:23:39,640
Об этом мы еще говорили с вами
тогда, когда мы писали функцию github.

360
00:23:39,780 --> 00:23:43,857
Мы тогда не говорили о дестардинге, но
это в данном случае суть и дело не меняет.

361
00:23:43,940 --> 00:23:46,597
Поэтому монадические
вычисления не являются ленивыми.

362
00:23:46,680 --> 00:23:50,760
Конечно, каждое из этих действий,
каждое из монадических действий,

363
00:23:51,080 --> 00:23:56,380
из звеньев цепочки биндов,
соответственно, да, оно ленивое.

364
00:23:57,830 --> 00:24:00,232
Если мы посмотрим на реализацию, если мы

365
00:24:00,274 --> 00:24:02,901
посмотрим на то, как
оно будет исполняться,

366
00:24:03,000 --> 00:24:06,720
как оно будет редуцироваться,
конечно, там имеет место будет ленивость.

367
00:24:06,780 --> 00:24:08,758
Но если мы посмотрим вот так вот сверху, и

368
00:24:08,801 --> 00:24:11,061
будем рассматривать это
действие как атомарное,

369
00:24:11,140 --> 00:24:13,376
то данная цепочка не является ленивой.

370
00:24:18,850 --> 00:24:24,360
И давайте, возможно, оно будет видно
также из определения функции sequence,

371
00:24:24,960 --> 00:24:29,640
с нижним подчеркиванием, что на
пустом списке мы просто не делаем ничего,

372
00:24:30,340 --> 00:24:32,295
а на списке из какой-то головы и какого-то

373
00:24:32,337 --> 00:24:34,381
хвоста мы просто
вызываем действие в голове

374
00:24:34,381 --> 00:24:37,597
и рекурсивно вызываемся от
хвоста, используя дунотации.

375
00:24:37,680 --> 00:24:41,377
Соответственно, без
дунотации можно было бы

376
00:24:41,460 --> 00:24:42,620
написать просто x,
птичка-птичка, sequence от x.

377
00:24:48,240 --> 00:24:51,867
Вспомним теперь и про обычный
бинд, который имеет вот такой тип.

378
00:24:51,950 --> 00:24:58,660
Если мы его специализируем до
типа monad.io, и поговорим про то,

379
00:24:58,820 --> 00:25:00,817
каким образом данный бинд
используется в дунотации.

380
00:25:00,900 --> 00:25:04,842
Потому что до этого у нас были
довольно скучные цепочки вычислений,

381
00:25:05,760 --> 00:25:09,117
каждое действие в которых игнорирует
результат предыдущего действия.

382
00:25:09,200 --> 00:25:12,846
В случае IO это, наверное,
только лишь вызов

383
00:25:12,889 --> 00:25:16,241
функции print и put.stln и ничего более.

384
00:25:16,605 --> 00:25:18,687
То есть функции, которые
не возвращают результаты.

385
00:25:18,770 --> 00:25:22,520
Давайте же все-таки
посмотрим на обычный бинд.

386
00:25:25,160 --> 00:25:27,077
Здесь у нас имеется развернутый тип.

387
00:25:27,160 --> 00:25:29,043
Как у нас выглядит обычный бинд?

388
00:25:29,720 --> 00:25:34,300
Как он у нас разворачивается,
если мы развернем его определение.

389
00:25:34,400 --> 00:25:38,400
То, что мы сначала применяем наше
действие к какому-то первому миру,

390
00:25:38,880 --> 00:25:42,700
к какому-то нулевому миру
получаем результат и первый мир.

391
00:25:43,100 --> 00:25:47,860
Соответственно, к результату и
первому миру мы применяем action2,

392
00:25:47,861 --> 00:25:51,277
который напоминает стрелку от Лейсли,
поэтому у него на один аргумент больше.

393
00:25:51,360 --> 00:25:52,537
Получаем второй мир.

394
00:25:52,620 --> 00:25:55,738
И, соответственно, возвращаем
результат и второй мир.

395
00:25:55,900 --> 00:25:58,136
Вот таким образом это будет выглядеть.

396
00:25:58,220 --> 00:26:01,477
Посмотрим на следующую функцию, которая
у нас определена в стандартной библиотеке,

397
00:26:01,560 --> 00:26:06,247
которая называется getline,
которая просто считывает строчку

398
00:26:06,330 --> 00:26:08,683
из стандартного ввода и возвращает
ее запакованную в monad.io.

399
00:26:09,740 --> 00:26:13,860
Каким образом будет
выглядеть doSyntaxes для бинда,

400
00:26:13,861 --> 00:26:16,195
если мы используем
bin с функциями, которые

401
00:26:16,238 --> 00:26:20,346
возвращают какой-то осмысленный
результат, в отличие от пустого картежа.

402
00:26:20,900 --> 00:26:24,260
Он будет выглядеть следующим образом.

403
00:26:25,180 --> 00:26:29,180
У нас появляется новый оператор,
который имеет следующий вид,

404
00:26:29,720 --> 00:26:32,956
и который на самом деле
похож на оператор присваивания.

405
00:26:33,400 --> 00:26:34,500
И что мы здесь видим?

406
00:26:34,580 --> 00:26:39,160
Мы связываем значение функции
getline с идентификатором s.

407
00:26:39,610 --> 00:26:47,040
Тип s у нас будет string,
потому что тип выражения,

408
00:26:47,060 --> 00:26:52,280
которое находится слева
от нашего оператора стрелка,

409
00:26:52,800 --> 00:26:55,318
он всегда, тип выражения,
которое находится

410
00:26:55,360 --> 00:26:57,919
в monad, только
распакованный, без коробки.

411
00:26:58,120 --> 00:27:00,400
Почему это так происходит,
сейчас нам будет понятно,

412
00:27:00,440 --> 00:27:02,657
когда мы посмотрим на
то, как это дешевляется.

413
00:27:02,740 --> 00:27:05,878
Соответственно, мы вызываем функцию getline
и кладем его результат в переменную s.

414
00:27:05,960 --> 00:27:08,057
А затем эту переменную
s, которая имеет тип string,

415
00:27:08,140 --> 00:27:11,317
мы можем спокойно использовать
в функции плута стрелы.

416
00:27:11,880 --> 00:27:14,603
И выглядит все это
достаточно незамысловато,

417
00:27:14,645 --> 00:27:17,221
потому что у нас вызывается обычный bind.

418
00:27:18,640 --> 00:27:21,993
И в качестве второго аргумента
бинда используется lambda,

419
00:27:22,240 --> 00:27:27,720
как раз таки где результат функции
getline связывается с переменной s,

420
00:27:27,800 --> 00:27:30,624
которая у нас доступна
во всем дальнейшем скопе.

421
00:27:31,320 --> 00:27:36,380
Соответственно, вот такая запись, у
нас будет развернута вот такую запись.

422
00:27:36,540 --> 00:27:43,060
Все вызовы бинда просто
берут и помещают результат

423
00:27:43,100 --> 00:27:45,840
первой функции, которая
находится в аргументе лямбда,

424
00:27:46,200 --> 00:27:50,906
просто помещают ее в какую-то переменную
для удобства в дальнейшей с ней работе.

425
00:27:53,060 --> 00:27:56,100
Мне кажется, что данная функция
действительно весьма простая,

426
00:27:56,101 --> 00:28:02,140
и ее можно записать без дунотации и
даже без лямбда, просто используя бинд.

427
00:28:04,920 --> 00:28:10,080
Если вы будете пользоваться этим в GHCI,
то вы заметите довольно забавный специфик.

428
00:28:11,580 --> 00:28:14,440
GHCI на самом деле
реализован достаточно просто.

429
00:28:14,540 --> 00:28:19,120
Это просто бесконечный loop,
бесконечный цикл в IOM-аналоге.

430
00:28:19,420 --> 00:28:23,860
Соответственно, если вы будете
пользоваться синтексом этой стрелочки,

431
00:28:24,310 --> 00:28:26,975
то вы обнаружите то, что он вполне себе

432
00:28:27,018 --> 00:28:30,141
работает, и монадой
будет у нас являться IOM.

433
00:28:31,680 --> 00:28:36,961
Соответственно, если вы будете использовать
в GHCI какую-то полиморфную функцию,

434
00:28:37,000 --> 00:28:41,580
например, функцию return,
допустим, напишите return true,

435
00:28:41,980 --> 00:28:45,720
то данный тип будет
специализирован до типа монады IOM,

436
00:28:45,860 --> 00:28:50,920
потому что GHCI – это просто
блок кода в монаде IOM.

437
00:28:51,270 --> 00:28:54,637
А если бы вы писали это в каком-то коде в

438
00:28:54,720 --> 00:28:56,597
хаскельном модуле, то данный
тип был бы полиморфным.

439
00:28:56,680 --> 00:28:59,797
Потому что на самом деле return возвращает

440
00:28:59,880 --> 00:29:01,600
какую-то монаду, и
пока что непонятно какую.

441
00:29:01,800 --> 00:29:03,907
Это должно быть выведено из контекста.

442
00:29:03,990 --> 00:29:06,108
В GHCI есть такой странный спецфект.

443
00:29:06,700 --> 00:29:08,837
Пожалуйста, обратите на это внимание, если

444
00:29:08,879 --> 00:29:11,213
будете тестировать там
какой-нибудь свой код.

445
00:29:11,295 --> 00:29:14,354
Давайте поговорим про
какой-то более сложный пример.

446
00:29:14,940 --> 00:29:19,560
Попробуем развернуть вот такой doSyntax,
который использует, соответственно,

447
00:29:20,200 --> 00:29:24,032
как и урезанный бинт для выражения,
который не возвращает результат,

448
00:29:24,115 --> 00:29:27,200
так и бинт обычный,
который имеет результат.

449
00:29:27,480 --> 00:29:28,547
Соответственно, что мы делаем?

450
00:29:28,630 --> 00:29:31,395
Сначала мы печатаем в
консоль what's your name,

451
00:29:33,260 --> 00:29:36,057
считываем строчку, потом
печатаем how old are you,

452
00:29:36,140 --> 00:29:39,620
считываем строчку и печатаем
на консоль пару из a и b.

453
00:29:39,770 --> 00:29:44,476
Принт, я напоминаю, просто вызывает show
и печатает с помощью функции put strln.

454
00:29:44,570 --> 00:29:46,806
Это будет выглядеть следующим образом.

455
00:29:47,010 --> 00:29:51,069
Сначала мы вызываем putstr, он не
возвращает нам никакого результата,

456
00:29:52,360 --> 00:29:56,650
поэтому здесь используется
обычный, точнее, урезанный бинт.

457
00:29:57,440 --> 00:30:01,382
Затем мы вызываем функцию readln,
которая возвращает нам строчку a,

458
00:30:02,790 --> 00:30:05,937
которая возвращает нам строчку,
которую мы связываем с переменной a.

459
00:30:06,020 --> 00:30:08,654
Затем в теле лямбды мы
вызываем опять функцию

460
00:30:08,696 --> 00:30:11,669
putstr, которая не возвращает
никакого результата.

461
00:30:11,980 --> 00:30:14,977
Опять вызываем функцию readln,
которая возвращает у нас результат b.

462
00:30:15,060 --> 00:30:16,480
И просто печатаем a и b.

463
00:30:18,340 --> 00:30:20,137
Вот, таким образом оно разворачивается.

464
00:30:20,220 --> 00:30:23,691
Ставьте, пожалуйста, есть ли
какие-то вопросы по донотации,

465
00:30:25,040 --> 00:30:26,982
правилам дешугеринга и так далее.

466
00:30:36,760 --> 00:30:38,130
Хорошо, буду считать, что вопросов нет.

467
00:30:38,131 --> 00:30:42,669
Единственное, что добавлю,
еще одно замечание по поводу

468
00:30:42,712 --> 00:30:47,291
применения донотации с вот
этим нашим урезанным бинтом.

469
00:30:48,150 --> 00:30:53,130
Здесь, в примерах, вы видите, что
всегда мы используем донотацию,

470
00:30:53,910 --> 00:30:57,847
которая не возвращает
никакого результата, на

471
00:30:57,930 --> 00:30:59,225
функциях, у которых return
type, это IO, пустой картеж.

472
00:30:59,910 --> 00:31:04,590
И это логично, потому что действительно
нам нет смысла использовать обычный бинт

473
00:31:04,591 --> 00:31:09,750
и слева писать какой-то идентификатор,
который будет равен пустому картежу.

474
00:31:09,810 --> 00:31:10,770
Поэтому мы используем вот так.

475
00:31:10,850 --> 00:31:14,858
Но на самом деле мы не ограничены
тем, чтобы использовать вот

476
00:31:14,901 --> 00:31:18,751
такой вот синтез на функциях
с return type пустой картежи.

477
00:31:18,810 --> 00:31:20,567
Мы можем это использовать
на функции, которая

478
00:31:20,609 --> 00:31:22,248
возвращает какой-то смысленный результат.

479
00:31:22,330 --> 00:31:24,807
Но если же мы не хотим
связывать его ни с какой переменной,

480
00:31:24,890 --> 00:31:28,770
допустим, этот результат нам не
интересен, мы просто можем это скипнуть.

481
00:31:28,850 --> 00:31:31,319
Вместо того, чтобы
связывать его с какой-то

482
00:31:31,362 --> 00:31:33,931
переменной, которая
будет не использоваться.

483
00:31:33,931 --> 00:31:36,478
Можно было бы просто написать нижнее

484
00:31:36,520 --> 00:31:39,971
подчеркивание стрелком
влево и какая-то функция.

485
00:31:40,050 --> 00:31:40,883
Но зачем?

486
00:31:41,110 --> 00:31:45,010
И да, повторюсь, основной
пойнт в том, что здесь мы не

487
00:31:45,070 --> 00:31:46,147
ограничены функциями, которые
возвращают пустой картеж.

488
00:31:46,230 --> 00:31:48,287
Мы можем использовать любые функции.

489
00:31:48,370 --> 00:31:50,429
Просто это не так уж и часто нужно.

490
00:31:50,530 --> 00:31:53,567
Наверное, в Хаскеле, если функция
возвращает какой-то результат,

491
00:31:53,650 --> 00:31:56,650
наверное, все-таки он
должен как-то использоваться.

492
00:32:00,870 --> 00:32:06,610
Теперь поговорим про return и
его использование в дунотации.

493
00:32:06,611 --> 00:32:11,850
Напомним, что return для monad.io
будет выглядеть следующим образом.

494
00:32:12,690 --> 00:32:17,350
Когда мы писали instance, у нас
была лямбда от world 0 в картеж world 0,

495
00:32:17,470 --> 00:32:21,470
но нам ничего не мешает подвинуть
этот world 0 слева от знака равно.

496
00:32:22,130 --> 00:32:28,170
И так он выглядит, просто чуть-чуть с
измененным телом в плане синтекса.

497
00:32:28,870 --> 00:32:30,165
Суть и дело не меняет.

498
00:32:33,100 --> 00:32:35,890
Давайте посмотрим, как у нас
return используется в дунотации.

499
00:32:35,891 --> 00:32:39,833
Допустим, мы хотим написать
функцию getReversedLine типом iostring,

500
00:32:40,210 --> 00:32:46,770
которая читает строчку из консоли
и возвращает ее в реверсном виде.

501
00:32:47,290 --> 00:32:48,210
Что мы делаем для этого?

502
00:32:48,290 --> 00:32:51,847
Сначала мы вызываем
функцию getLine, и результат

503
00:32:51,930 --> 00:32:53,227
вкладываем в переменную
s, которая имеет тип string.

504
00:32:53,310 --> 00:32:58,430
И вот если бы мы написали здесь без return
reverse s, у нас бы не сошлись типы.

505
00:32:58,590 --> 00:33:02,887
Почему? Потому что результат конечного
выражения у нас должен быть iostring.

506
00:33:02,970 --> 00:33:09,350
И, соответственно, если нам
нужно в нашем конце дунотации

507
00:33:09,351 --> 00:33:14,670
сделать какое-то чистое действие
с результатом предыдущих биндов,

508
00:33:15,080 --> 00:33:16,467
мы должны обернуть return.

509
00:33:16,550 --> 00:33:19,387
По понятным причинам, просто
для того, чтобы у нас сошлись типы,

510
00:33:19,470 --> 00:33:24,250
и для того, чтобы результат исходной
цепочки выражений был монадическим.

511
00:33:24,670 --> 00:33:29,310
Мы не можем просто так взять и
избавиться от iostring контекста,

512
00:33:29,425 --> 00:33:31,457
как любого другого
монадического контекста,

513
00:33:31,540 --> 00:33:34,175
просто потому что, если
это вызывает вопросы,

514
00:33:34,217 --> 00:33:36,894
просто вспомните, во
что это разворачивается.

515
00:33:37,110 --> 00:33:42,930
И то, что у нас каждая из стрелок
лейсли имеет возвращаемый тип mb.

516
00:33:43,390 --> 00:33:44,920
Соответственно, из a в mb.

517
00:33:45,310 --> 00:33:48,870
Здесь мы берем контекст
m просто с помощью return.

518
00:33:50,110 --> 00:33:52,437
И таким образом эту
функцию можно использовать.

519
00:33:52,520 --> 00:33:58,230
Также в мейне считываем
преверснутую строчку и печатаем ее.

520
00:34:00,520 --> 00:34:03,579
И вопрос в зал.
Давайте рассмотрим следующий пример.

521
00:34:04,090 --> 00:34:06,690
Когда мы читаем строчку a из консоли.

522
00:34:09,080 --> 00:34:11,107
Да, тут в презентации есть небольшой баг.

523
00:34:11,190 --> 00:34:15,779
Представьте, что мы используем на ней
функцию read, которая приводит ее к end.

524
00:34:16,020 --> 00:34:19,630
Потому что строчки
сравнивать с нулем мы не можем.

525
00:34:20,330 --> 00:34:22,449
Это просто такой лофтовер в презентации,

526
00:34:22,491 --> 00:34:24,868
который, к сожалению,
не заметил изначально.

527
00:34:24,950 --> 00:34:26,715
Мы считываем число из консоли.

528
00:34:27,240 --> 00:34:31,390
И если число больше либо равно
нуля, мы делаем return простой кротеж.

529
00:34:32,150 --> 00:34:36,050
Иначе мы печатаем, что число
негативное, что число отрицательное.

530
00:34:36,450 --> 00:34:40,450
А следующим действием мы
печатаем, что a is a positive.

531
00:34:41,510 --> 00:34:47,730
И будет ли оно вызвано в случае, если
мы туда передадим положительное число.

532
00:34:48,170 --> 00:34:51,613
Или же этот return
отработает, как в императивных

533
00:34:51,655 --> 00:34:54,571
языках, и мы не дойдем до этого действия.

534
00:34:55,670 --> 00:34:59,090
Мы дойдем до него.
Мы не можем пропустить просто так.

535
00:35:00,790 --> 00:35:02,143
Побочное действие наше.

536
00:35:02,370 --> 00:35:03,723
Да, это вполне логично.

537
00:35:06,390 --> 00:35:10,014
Просто очень часто на
первых порах люди путаются

538
00:35:10,056 --> 00:35:13,111
с тем, что у нас название функции return

539
00:35:13,410 --> 00:35:17,527
очень сильно похоже на название
оператора return в плюсах или в джаве,

540
00:35:17,610 --> 00:35:21,247
который, соответственно, завершает
выполнение функции и возвращает результат.

541
00:35:21,330 --> 00:35:25,344
В хатскеле функция
return просто запаковывает

542
00:35:25,386 --> 00:35:28,811
наш результат в монадический контекст.

543
00:35:29,930 --> 00:35:32,703
Здесь return сделает
то, что результат этого

544
00:35:32,745 --> 00:35:36,071
экспрессиона в цепочке
наших монадических вычислений

545
00:35:36,370 --> 00:35:41,050
будет равен пустому кротежу,
завернутому в монад, в данном случае a.

546
00:35:41,670 --> 00:35:45,687
Соответственно, да, мы не можем
просто так в хатскеле написать return,

547
00:35:45,770 --> 00:35:49,210
и у нас цепочка монадических
вычислений не завершится.

548
00:35:49,360 --> 00:35:53,210
Нет, это просто для избежания путаницы.

549
00:35:54,815 --> 00:35:56,170
А можно глупый вопрос?

550
00:35:56,550 --> 00:35:56,710
Да.

551
00:35:56,830 --> 00:36:01,070
Последнюю строчку не заберет себе
do, который написан после слова else?

552
00:36:01,730 --> 00:36:04,450
Нет, это хороший вопрос.

553
00:36:04,710 --> 00:36:09,970
На самом деле вложенные do-блоки
также присутствуют, как вы можете видеть.

554
00:36:10,390 --> 00:36:13,130
Это достаточно неинтересно, потому что
он тривиально состоит из одной строчки.

555
00:36:13,131 --> 00:36:19,799
Тут дело в отступах,
потому что этот do имеет в

556
00:36:19,842 --> 00:36:26,551
своем составе одну
строчку с таким-то отступом.

557
00:36:26,630 --> 00:36:28,469
Соответственно, если бы у нас была вторая

558
00:36:28,512 --> 00:36:30,668
строчка, у нее должен
был быть такой же отступ.

559
00:36:30,750 --> 00:36:37,490
Но данная строчка в силу расстановки
отступов принадлежит первому do-блоку.

560
00:36:39,140 --> 00:36:42,729
А мы можем и do с двумя
стейтментами написать в одну строчку?

561
00:36:43,530 --> 00:36:45,967
Да, можете с использованием точки запятой.

562
00:36:46,050 --> 00:36:49,822
В Haskell есть точка
запятой, если вы пишете

563
00:36:49,864 --> 00:36:53,331
в do нотации или в кейсе в одну строчку.

564
00:36:55,710 --> 00:36:59,450
Кажется, для этого есть вот такой синтез.

565
00:37:04,880 --> 00:37:07,380
В Haskell также есть фигурные сроки.

566
00:37:08,150 --> 00:37:11,050
Оно не сказать, чтобы
часто используется, но порой

567
00:37:11,093 --> 00:37:13,858
для экономии какого-то
места к этому прибегает.

568
00:37:13,940 --> 00:37:16,417
Но это не является
желательным код-стайлом.

569
00:37:16,500 --> 00:37:17,840
Вы также в gash-сайт.

570
00:37:19,200 --> 00:37:22,209
Точка с запятой может
быть удобна в gash-сайт, если

571
00:37:22,251 --> 00:37:25,421
вы хотите написать несколько
действий в одну строчку.

572
00:37:25,480 --> 00:37:27,304
Просто чтобы не заморачиваться.

573
00:37:31,490 --> 00:37:33,726
Там, кажется, был еще какой-то вопрос.

574
00:37:36,830 --> 00:37:38,125
Ладно, видимо, не был.

575
00:37:38,890 --> 00:37:42,610
Давайте поговорим про
использование let в do нотации.

576
00:37:43,830 --> 00:37:48,861
С самой первой лекции вы помните,
что в Haskell есть такая вещь как

577
00:37:48,903 --> 00:37:54,051
let in для объявления промежуточных
идентификаторов наших выражений.

578
00:37:54,670 --> 00:38:00,591
Так вот, конструкция let может быть
использована в do нотации, но внезапно без in.

579
00:38:01,330 --> 00:38:03,427
Сейчас мы посмотрим, как это выглядит.

580
00:38:03,510 --> 00:38:08,193
Давайте посмотрим на такую
функцию main, на ту же функцию,

581
00:38:08,235 --> 00:38:12,471
которую мы писали до этого,
где мы реверсим строчку.

582
00:38:13,750 --> 00:38:16,586
Считаем строчку, поместим
ее в переменную s, и

583
00:38:16,628 --> 00:38:19,631
в переменную rs поместим
результат reverse от s.

584
00:38:20,670 --> 00:38:25,290
И выведем на консоль
reversed input двоеточие rs.

585
00:38:25,950 --> 00:38:31,330
Здесь, как вы заметите, отсутствует
in просто по причине удобства.

586
00:38:31,605 --> 00:38:35,873
Потому что, на самом деле,
когда оно разворачивается, точнее,

587
00:38:35,915 --> 00:38:40,931
выражение после in, как само
ключевое слово in, очевидно, присутствует.

588
00:38:41,010 --> 00:38:43,750
Просто в do нотации это является лишним.

589
00:38:43,890 --> 00:38:48,216
Потому что в let in оно кажется
довольно логично, потому что если

590
00:38:48,258 --> 00:38:52,491
мы не рассматриваем do нотацию,
то все в Haskell это выражение.

591
00:38:53,310 --> 00:38:57,005
И логично, что когда мы объявили
цепочку каких-то промежуточных

592
00:38:57,048 --> 00:39:00,429
ассайментов, указать выражение,
которым они используются.

593
00:39:00,540 --> 00:39:04,327
Но в случае do нотации, которая
является синтактическим сахаром и дает

594
00:39:04,370 --> 00:39:08,308
нам некоторые ощущения того,
что мы пишем императивный,

595
00:39:08,390 --> 00:39:11,031
в кавычках, код, где строчки
исполняются одна за одной,

596
00:39:11,074 --> 00:39:14,251
решили просто разрешить
не писать строчку in.

597
00:39:14,410 --> 00:39:20,270
Просто для удобства, чтобы разрешить
объявлять промежуточные идентификаторы.

598
00:39:20,390 --> 00:39:24,219
Но in по понятным причинам
будет присутствовать, потому

599
00:39:24,262 --> 00:39:27,851
что это не какой-то новый
синтактический конструкт.

600
00:39:27,851 --> 00:39:31,322
Это все тот же самый let in,
просто чуть-чуть засахаренный.

601
00:39:33,010 --> 00:39:37,626
И самая частая ошибка, которая
бывает у людей, которые работают с do

602
00:39:37,668 --> 00:39:42,531
нотацией, это когда они путаются
между знаком равно и стрелочкой влево.

603
00:39:42,750 --> 00:39:46,108
Давайте рассмотрим пример.
Когда мы пишем let s равно

604
00:39:46,151 --> 00:39:49,871
getline, мы на самом деле не
считываем строчку из консоли.

605
00:39:49,950 --> 00:39:52,698
Мы просто присваиваем
функцию getline к какой-то

606
00:39:52,740 --> 00:39:55,588
другой функции s, которую
мы можем потом вызвать.

607
00:39:55,670 --> 00:39:58,023
Но это присваивание не вызывает функцию.

608
00:39:59,890 --> 00:40:03,871
Если бы мы хотели считать
что-то из консоли, то есть выполнить

609
00:40:03,913 --> 00:40:07,871
наше монадическое действие,
мы бы использовали стрелку влево.

610
00:40:08,430 --> 00:40:13,830
Почему? Потому что стрелка влево –
это синтактический сахар над биндом.

611
00:40:15,200 --> 00:40:18,984
А вот такой let s равно getline
– это ничего более, кроме

612
00:40:19,027 --> 00:40:22,651
как алиас для функции,
который мы потом можем вызвать.

613
00:40:23,200 --> 00:40:27,460
И также есть следующая ошибка,
когда мы в чистых значениях

614
00:40:27,502 --> 00:40:32,471
пытаемся, при вызове какой-то
чистой функции справа от знака равно,

615
00:40:34,170 --> 00:40:36,207
мы пытаемся использовать стрелку влево.

616
00:40:36,290 --> 00:40:39,197
Это не работает, потому
что справа от стрелки влево

617
00:40:39,240 --> 00:40:42,188
должно стоять у нас какое-то
монадическое значение.

618
00:40:42,270 --> 00:40:45,527
В монаде m, в которой мы
работаем, в нашем случае это айо.

619
00:40:45,610 --> 00:40:48,662
Несмотря на то, что
список – это тоже монада, это

620
00:40:48,705 --> 00:40:52,051
абсолютно разные вещи,
данная спойлерка в монаде айо.

621
00:40:52,150 --> 00:40:56,181
Поэтому reverse s будет
иметь тип string, и мы не

622
00:40:56,223 --> 00:41:00,711
можем просто так взять и
поместить ее в переменную rs.

623
00:41:03,480 --> 00:41:05,892
Есть ли какие-то вопросы по этому поводу?

624
00:41:12,130 --> 00:41:16,047
Окей, давайте считать, что нет.
Прошу прощения, я на полминуты прервусь.

625
00:41:16,130 --> 00:41:20,290
У меня сейчас сядет ноутбук, я его
поставлю на зарядку и возобновлю.

626
00:42:16,610 --> 00:42:18,610
Прошу прощения, давайте продолжим.

627
00:42:22,140 --> 00:42:27,070
И внезапно еще одна вещь, что мы
можем использовать doSyntax без монад.

628
00:42:27,650 --> 00:42:30,770
Но я бы сказал, что он
лишен какого-то смысла.

629
00:42:31,590 --> 00:42:34,225
Потому что все, что он
нам позволяет сделать,

630
00:42:34,267 --> 00:42:37,003
это не писать ключевое
слово in в цепочке let.

631
00:42:38,210 --> 00:42:41,407
Соответственно, вспоминаем нашу
функцию Pythagoras с самой первой лекции,

632
00:42:41,490 --> 00:42:45,150
где у нас let x2, потом
let y2, потом in x2 плюс y2.

633
00:42:46,115 --> 00:42:49,890
Можно просто написать do,
сделать себе цепочку let без in,

634
00:42:50,210 --> 00:42:53,858
и в самой последней строчке
написать результирующее выражение.

635
00:42:54,470 --> 00:42:56,912
Просто знаете, что такое
синтаксис есть, я бы не

636
00:42:56,954 --> 00:42:59,748
сказал, что он имеет какое-то
практическое применение.

637
00:42:59,830 --> 00:43:01,747
Потому что я ни разу такого кода не видел.

638
00:43:01,830 --> 00:43:06,290
Как-то более привычно, если мы
видим do, сразу представлять то,

639
00:43:06,330 --> 00:43:09,247
что у нас речь идет о каком-то
монадическом вычислении.

640
00:43:09,330 --> 00:43:12,860
А тут чистая функция, и это
очень и очень сильно запутывает.

641
00:43:13,970 --> 00:43:14,803
Вот.

642
00:43:16,990 --> 00:43:19,450
Там даже есть какой-то пример внезапно.

643
00:43:20,130 --> 00:43:23,307
Можете тоже почитать.
Я, если честно, даже не смотрел.

644
00:43:24,070 --> 00:43:26,718
Давайте разберем такой
вот интересный пример.

645
00:43:27,150 --> 00:43:29,608
fu, функция isn't of int, которая внезапно

646
00:43:29,650 --> 00:43:32,328
используется до нотации
по каким-то причинам.

647
00:43:33,090 --> 00:43:38,310
И мы берем плюс один и складываем
его результат в переменную a,

648
00:43:38,930 --> 00:43:41,247
а затем делаем return a умножить на два.

649
00:43:41,330 --> 00:43:45,047
То есть, пожалуйста, может ли кто-то
рассказать, что здесь происходит?

650
00:43:45,130 --> 00:43:46,836
И почему это вообще работает?

651
00:43:48,800 --> 00:43:50,647
Точнее, почему это компилируется хотя бы?

652
00:43:50,730 --> 00:43:53,150
Как оно работает, мы разберем сразу же.

653
00:43:53,370 --> 00:43:55,959
Как только поймем,
почему оно компилируется.

654
00:44:03,420 --> 00:44:09,360
Давайте, смотрите, у нас do
почти всегда, кроме предыдущих

655
00:44:09,460 --> 00:44:11,637
наших слайдов, это какое-то
монадическое вычисление.

656
00:44:11,840 --> 00:44:12,897
В какой-то монаде.

657
00:44:12,980 --> 00:44:16,201
А тем более, если у нас есть стрелки влево,
то это точно монадическое вычисление.

658
00:44:16,201 --> 00:44:19,060
Это не просто do в чьей-то функции.

659
00:44:20,040 --> 00:44:23,360
На какую из монад, которые
вы изучали на прошлой лекции,

660
00:44:23,620 --> 00:44:26,100
хотя бы отдаленно похожа наша функция fu?

661
00:44:40,550 --> 00:44:42,337
Пример достаточно нетривиальный.

662
00:44:42,420 --> 00:44:44,117
Давайте я не буду вас томить.

663
00:44:44,200 --> 00:44:49,860
Скажу вам, что эта монада определенная
для частично примененной стрелки.

664
00:44:50,380 --> 00:44:53,557
Как вы помните, она является
функтором и аппликативом.

665
00:44:54,140 --> 00:44:56,837
Это также определялось
на соответствующей лекции.

666
00:44:56,920 --> 00:45:00,177
И когда на предыдущей лекции
вы говорили про монаду ридер,

667
00:45:00,260 --> 00:45:02,830
речь заходила про то,
что монада ридер – это

668
00:45:02,872 --> 00:45:05,721
просто newtype над частично
примененной стрелкой

669
00:45:05,770 --> 00:45:09,120
с фиксированным аргументом
e и справа результатом a.

670
00:45:09,840 --> 00:45:11,958
На самом деле, это оно у нас и есть.

671
00:45:12,620 --> 00:45:14,460
Это у нас монада ридер.

672
00:45:14,720 --> 00:45:17,600
Или, так как мы используем ее без newtype,

673
00:45:18,350 --> 00:45:22,351
корректнее сказать, что это монада
для частично примененной стрелки.

674
00:45:22,540 --> 00:45:24,640
И давайте посмотрим, каким
образом это у нас работает.

675
00:45:24,641 --> 00:45:29,397
На самом деле, в данном
случае у данной монады

676
00:45:29,439 --> 00:45:34,341
контекстом является
выражение слева от стрелки.

677
00:45:36,570 --> 00:45:38,998
Соответственно, если бы
мы сейчас решили потратить

678
00:45:39,040 --> 00:45:41,658
на этот пример достаточно
большое количество времени,

679
00:45:41,740 --> 00:45:46,211
чтобы разобрать, мы бы
выяснили, что каждое следующее

680
00:45:46,254 --> 00:45:50,681
действие насыщает нашу
функцию, которую мы собираем.

681
00:45:50,880 --> 00:45:53,642
Потому что у нас монадическое
вычисление – это функция isn't a wind,

682
00:45:53,725 --> 00:45:56,817
но также она могла быть и
string a wind или чего-то еще.

683
00:45:56,900 --> 00:46:02,060
И каждое из вот этих
действий просто, так сказать…

684
00:46:02,061 --> 00:46:04,640
Это можно просто рассматривать
как композицию, на самом деле.

685
00:46:04,720 --> 00:46:06,754
Вы же помните, что функция для частично

686
00:46:06,796 --> 00:46:09,138
примененной стрелки –
это просто композиция.

687
00:46:09,220 --> 00:46:12,017
И вот, соответственно, здесь мы
по кусочкам собираем функцию.

688
00:46:12,100 --> 00:46:16,560
То есть сначала мы говорим, что это
плюс один, и ее результат какой-то a.

689
00:46:16,840 --> 00:46:19,227
А потом мы этот результат
еще и домножаем на два.

690
00:46:19,310 --> 00:46:22,420
И если мы применяем вот этот фу в тройке,

691
00:46:22,980 --> 00:46:27,680
сначала к нему прибавится
один, а потом умножится на два.

692
00:46:29,260 --> 00:46:32,613
Это выглядит, на самом деле,
довольно и довольно страшно.

693
00:46:32,900 --> 00:46:35,239
Но если это просто расписать как обычный

694
00:46:35,281 --> 00:46:38,019
wind, ничего там страшного
не будет абсолютно.

695
00:46:39,340 --> 00:46:41,969
Данный пример тут
просто находится для того,

696
00:46:42,011 --> 00:46:44,621
чтобы показать, что
такие вещи тоже бывают.

697
00:46:45,080 --> 00:46:47,512
Не сказать, что они
встречаются на практике.

698
00:46:47,595 --> 00:46:50,633
Конечно, потому что
ничего, кроме как запутать

699
00:46:50,676 --> 00:46:53,421
человека, данный код полезного не делает.

700
00:46:53,920 --> 00:46:55,277
Просто знайте, что такое бывает.

701
00:46:55,360 --> 00:46:58,817
И что вот так вот для частично
примененной стрелки работает монада.

702
00:46:58,900 --> 00:47:03,600
Если бы тут была какая-то
монада reader int, то было бы проще.

703
00:47:05,280 --> 00:47:06,633
Точнее, reader int int.

704
00:47:09,900 --> 00:47:16,300
Мы поговорили с вами про то, как у
нас базово использовать IEO в Haskell,

705
00:47:16,460 --> 00:47:17,977
какие бывают функции для этого.

706
00:47:18,060 --> 00:47:22,060
Там putstr, putstrlen,
getline, getchar, print.

707
00:47:23,040 --> 00:47:25,420
И как с ними работать с IEO-монадой.

708
00:47:25,480 --> 00:47:27,363
Также поговорили про denotation.

709
00:47:27,720 --> 00:47:31,146
И абсолютно везде, когда
происходит какая-то работа с

710
00:47:31,188 --> 00:47:34,721
нижним миром, возникают
какие-то неожиданные проблемы.

711
00:47:35,470 --> 00:47:38,140
Давайте уже разберемся, какие.

712
00:47:38,880 --> 00:47:42,247
Давайте рассмотрим следующую
функцию, которая с помощью readfile.

713
00:47:42,330 --> 00:47:45,157
Как вы догадываетесь,
она принимает имя файла

714
00:47:45,200 --> 00:47:47,941
и возвращает в виде
строчки его содержимое.

715
00:47:49,520 --> 00:47:53,200
Считаем контент файла
foo.ht, переменуем файл content.

716
00:47:54,260 --> 00:47:56,900
А затем запишем в файл bar.ht.

717
00:47:58,880 --> 00:48:03,410
Вот этот наш контент просто присоединен
с присоединенной в начале буковкой a.

718
00:48:03,940 --> 00:48:07,500
А затем еще раз прочитаем
msbar и выведем его на экран.

719
00:48:09,620 --> 00:48:11,057
Пока что проблемы никакой нет.

720
00:48:11,140 --> 00:48:16,360
Все выглядит достаточно straightforward.

721
00:48:17,540 --> 00:48:20,182
Представьте, что у нас
нет контента файлов foo.

722
00:48:20,225 --> 00:48:23,018
ht и bar.ht, что они,
соответственно, равны foo и bar.

723
00:48:23,100 --> 00:48:25,980
Соответственно, файл контент...

724
00:48:26,930 --> 00:48:29,300
А, нет, господи, это я неправду сказал.

725
00:48:30,640 --> 00:48:34,360
Что foo.ht – это foo line break bar.

726
00:48:34,850 --> 00:48:35,957
Это я немного запутался.

727
00:48:36,040 --> 00:48:37,982
Вот так выглядит наш файл foo.ht.

728
00:48:38,620 --> 00:48:40,268
Запускаем нашу функцию main.

729
00:48:40,640 --> 00:48:41,523
И что мы видим?

730
00:48:43,210 --> 00:48:49,700
Мы читаем из файла foo вот следующую
строчку, присоединяем к ней в начало a,

731
00:48:49,875 --> 00:48:52,680
получается a foo bar, и пишем файл бар.

732
00:48:53,360 --> 00:48:56,177
А потом мы читаем файл
бар и пишем его на консоль.

733
00:48:56,260 --> 00:48:58,017
Получается ровно то, что мы ожидали.

734
00:48:58,100 --> 00:49:01,827
Соответственно, фу бар только
присоединенный в начале буковкой a.

735
00:49:01,910 --> 00:49:03,969
Такой вот довольно странный пример.

736
00:49:04,240 --> 00:49:07,700
Но сейчас мы его немного
видоизменим и поймем,

737
00:49:08,800 --> 00:49:13,506
какие при минорном изменении такого даже
простого кода можно встретить проблемы.

738
00:49:13,860 --> 00:49:18,180
Давайте изменим его и будем
читать из foo.ht и писать в foo.ht.

739
00:49:19,030 --> 00:49:21,972
А потом опять читать из
foo.ht и писать в консоль.

740
00:49:23,430 --> 00:49:27,489
Есть ли какие-то подзрения насчет
того, что что-то тут пойдет не так?

741
00:49:29,250 --> 00:49:30,360
Это нормально, если их нет.

742
00:49:30,440 --> 00:49:34,323
Потому что с виду данный код не
предвещает никакой беды абсолютно.

743
00:49:35,600 --> 00:49:37,012
Может быть, кто-то есть.

744
00:49:44,890 --> 00:49:50,270
У нас же файл content в первой строчке
do не то чтобы вычисляется, он биндится.

745
00:49:51,170 --> 00:49:54,887
Возможно, из-за этого мы
откроем файл, например, на

746
00:49:54,970 --> 00:49:57,088
чтение и запись, и вот там
будет неприятная ситуация.

747
00:49:57,410 --> 00:49:58,587
Да, абсолютно верно.

748
00:50:00,630 --> 00:50:03,190
Вспоминаем, что Haskell
— это ленивый язык.

749
00:50:03,850 --> 00:50:06,792
И несмотря на то, что,
как я уже говорил до этого,

750
00:50:07,570 --> 00:50:10,347
если мы рассматриваем
цепочку монадических действий,

751
00:50:10,430 --> 00:50:15,230
здесь вот этот эффект
ленивости откладывается.

752
00:50:15,231 --> 00:50:21,251
Потому что у нас каждое предыдущее действие
исполняется перед следующим действием.

753
00:50:21,350 --> 00:50:24,670
Но это абсолютно не значит,
что результат этого действия

754
00:50:24,671 --> 00:50:28,910
будет средуцирован до головной
нормальной формы или нормальной формы.

755
00:50:29,190 --> 00:50:30,947
Это значит, что данное
действие просто выполнится.

756
00:50:31,030 --> 00:50:36,510
И действительно, как вы уже
сказали, вылезет такая ошибка.

757
00:50:39,890 --> 00:50:41,130
Перевернуть сюда на секунду.

758
00:50:41,131 --> 00:50:44,249
Да, функция readFile, если
почитаете ее документацию,

759
00:50:45,230 --> 00:50:50,070
здесь написано, что он читает контент
файла лениво, когда он нам нужен.

760
00:50:50,810 --> 00:50:53,870
Как и функция getContents,
не обращайте внимания,

761
00:50:54,055 --> 00:50:56,703
это другая функция из
стандартной библиотеки.

762
00:50:57,030 --> 00:51:01,314
Соответственно, действительно,
связывание нашего

763
00:51:01,356 --> 00:51:05,591
санка с контентом readFile
происходит сразу же,

764
00:51:06,350 --> 00:51:08,530
в силу того, как работают
монадические вычисления.

765
00:51:08,531 --> 00:51:14,010
Но непосредственное чтение из файла
будет происходить тогда, когда это нужно.

766
00:51:14,280 --> 00:51:16,990
Когда это нужно?
Когда мы пишем в этот же файл.

767
00:51:17,070 --> 00:51:20,891
Соответственно, у нас будет проблема с тем,
что дескриптор файла у нас будет открыт

768
00:51:20,915 --> 00:51:23,307
как на чтение, так и на
запись одновременно.

769
00:51:23,390 --> 00:51:27,230
И вылезет такая ошибка,
что return busy, файл is locked.

770
00:51:28,510 --> 00:51:30,970
Эта проблема называется lazy Ion.

771
00:51:31,870 --> 00:51:35,130
И сейчас мы немного
коснемся того, как ее решать.

772
00:51:37,990 --> 00:51:40,130
Но когда вы работаете с…

773
00:51:41,270 --> 00:51:45,070
Тут на самом деле речь абсолютно
не про чтение и запись файла.

774
00:51:45,350 --> 00:51:47,207
То есть это просто
какой-то один из примеров,

775
00:51:47,290 --> 00:51:50,567
когда можно выстрелить
себе в ногу, работая

776
00:51:50,610 --> 00:51:53,851
с Ion, забывая о том, что Haskell ленивый.

777
00:51:53,970 --> 00:51:57,148
Это касается абсолютно всех
вещей, как работы с сетью,

778
00:51:57,190 --> 00:52:00,111
с какими-то опишками, с
базой данных и так далее.

779
00:52:00,230 --> 00:52:04,210
Нужно всегда понимать, что
все действия Ion непосредственно,

780
00:52:04,211 --> 00:52:07,800
если мы используем наши
стандартные функции, которые ленивые.

781
00:52:07,910 --> 00:52:11,090
Есть еще другие функции,
которые force от вычисления.

782
00:52:11,190 --> 00:52:12,427
Сейчас мы о них поговорим.

783
00:52:12,510 --> 00:52:15,848
Нужно всегда держать
в голове то, что на этапе

784
00:52:15,891 --> 00:52:19,491
считывания фактического
считывания не происходит.

785
00:52:19,670 --> 00:52:24,370
Происходит просто связывание танка с
контентом файла, с вот этой переменной.

786
00:52:24,610 --> 00:52:25,767
И все, больше ничего.

787
00:52:25,850 --> 00:52:29,150
А затем, когда мы ее используем,
будет происходить считывание.

788
00:52:29,151 --> 00:52:31,651
И важно понимать, чтобы это считывание не

789
00:52:31,694 --> 00:52:34,731
конфликтовало с использованием
данной переменной.

790
00:52:34,850 --> 00:52:37,365
В данном случае оно
конфликтует, потому что

791
00:52:37,408 --> 00:52:40,440
использованием является
запись в тот же самый файл.

792
00:52:43,330 --> 00:52:46,131
Здесь у нас какая-то байка
про то, что обычно, когда

793
00:52:46,174 --> 00:52:48,798
идет что-то не так, мы
идем читать документацию.

794
00:52:48,880 --> 00:52:54,080
Но если мы достаточно подготовленные,
то мы всегда сначала читаем документацию.

795
00:52:55,480 --> 00:52:57,304
И наткаемся на вот такую штуку.

796
00:52:58,150 --> 00:53:00,150
Давайте посмотрим еще один пример.

797
00:53:00,600 --> 00:53:06,160
Который, на самом деле, особо
ничем не отличается, кажется.

798
00:53:10,715 --> 00:53:12,598
Есть еще такая функция withFile.

799
00:53:15,210 --> 00:53:15,880
Что она делает?

800
00:53:16,060 --> 00:53:18,766
Это функция, которая
принимает название файла.

801
00:53:19,400 --> 00:53:21,758
Режим, соответственно,
это может быть чтение

802
00:53:21,801 --> 00:53:23,928
ReadMod, WriteMod и также ReadWriteMod.

803
00:53:24,010 --> 00:53:28,040
И принимает цепочку действий,
которые мы с этим файлом делаем.

804
00:53:28,900 --> 00:53:35,280
Здесь можно написать $do и то, что с
дескриптором данного файла можно делать.

805
00:53:36,280 --> 00:53:37,633
Как бы привести аналог.

806
00:53:38,080 --> 00:53:40,316
Короче, данная функция используется...

807
00:53:43,385 --> 00:53:49,240
Короче, функции в Haskell'е видят
кто-то там, обычно берут какой-то ресурс,

808
00:53:50,500 --> 00:53:52,697
затем принимают цепочку действий, которые

809
00:53:52,740 --> 00:53:55,088
с этим ресурсом делать,
и закрывают ресурс.

810
00:53:55,170 --> 00:54:00,500
Соответственно, функция
withFile после выполнения этой

811
00:54:00,600 --> 00:54:03,293
цепочки действий, которую мы
сюда кормим, а сюда кормим мы

812
00:54:03,336 --> 00:54:06,481
всего лишь одно действие,
мы закрываем ресурс.

813
00:54:07,120 --> 00:54:10,197
И здесь продемонстрировано неправильное
использование функции withFile.

814
00:54:10,280 --> 00:54:15,440
Почему? Потому что мы считываем его
контент и кладем в какую-то переменную,

815
00:54:16,420 --> 00:54:22,740
но на момент печати содержимого файла
в консоль данный файл уже будет закрыт.

816
00:54:23,340 --> 00:54:29,040
Потому что мы прочитали, закрыли, а
потом будем... точнее мы на момент записи,

817
00:54:29,340 --> 00:54:31,357
как только у нас начинается запись.

818
00:54:31,440 --> 00:54:35,499
Haskell берет, ага, мне нужна эта
переменная, пойду-ка я ее прочитаю.

819
00:54:35,720 --> 00:54:39,600
Берет, идет ее читает, такой
все, я прочитал, закрываю файл.

820
00:54:40,120 --> 00:54:46,800
Отдает функцию putstr строчку,
но на самом деле файл уже закрыт.

821
00:54:47,650 --> 00:54:57,240
И поэтому на момент вызова
putstr дескриптор файла уже закрыт.

822
00:54:57,460 --> 00:55:00,568
Поэтому мы не можем
напечатать его на консоль, потому

823
00:55:00,610 --> 00:55:03,403
что когда мы пойдем ее
читать на самом-то деле,

824
00:55:04,260 --> 00:55:09,080
будет уже поздно. На самом деле, мне
кажется, получилось довольно невнятно.

825
00:55:09,400 --> 00:55:13,695
Давайте я попробую еще раз объяснить,
если у кого-то из вас есть вопросы.

826
00:55:16,790 --> 00:55:18,614
Или же все более-менее понятно.

827
00:55:19,090 --> 00:55:25,990
То, что на момент записи в консоль данного
файла дескриптор файла был уже закрыт,

828
00:55:26,250 --> 00:55:29,050
потому что он открылся
и закрылся сразу же.

829
00:55:30,610 --> 00:55:34,905
А уж когда нам actually нужно взять
его пойти и прочитать, он уже закрыт.

830
00:55:41,280 --> 00:55:43,751
Окей, я надеюсь, что это все-таки понятно.

831
00:55:44,990 --> 00:55:45,870
Еще раз резюмирую.

832
00:55:45,871 --> 00:55:50,460
Если вы видите в Haskell какую-то функцию,
которая называется viz, что-то там,

833
00:55:51,210 --> 00:55:54,858
всегда знайте, что это функция,
которая берет какой-то ресурс,

834
00:55:55,930 --> 00:55:59,590
делает с ним цепочку действий
и закрывает этот ресурс.

835
00:55:59,650 --> 00:56:02,709
Поэтому в данном случае
правильным использованием

836
00:56:02,751 --> 00:56:05,851
функции vizfile было бы
поставить вот тут доллар,

837
00:56:06,370 --> 00:56:11,870
поставить ту нотацию и ashget contents
и putstr land написать вот в этой цепочке.

838
00:56:11,871 --> 00:56:16,810
И написать вот в этом ту
блоке внутри функции vizfile,

839
00:56:16,910 --> 00:56:20,090
когда вот этот наш файл
все еще открыт на чтение.

840
00:56:20,150 --> 00:56:22,621
А не после, когда он уже закрыт на чтение.

841
00:56:23,530 --> 00:56:25,883
Пример достаточно забористый, я признаю.

842
00:56:26,450 --> 00:56:29,850
Но суть не в том, что
функция vizfile какая-то плохая,

843
00:56:29,930 --> 00:56:32,850
а суть опять же в том, что
нужно всегда держать в голове

844
00:56:32,900 --> 00:56:36,990
вот это не самое интуитивное
поведение Haskell при работе с IO.

845
00:56:38,250 --> 00:56:39,309
Давайте продолжим.

846
00:56:40,500 --> 00:56:42,501
Да, и как же все-таки с этим жить?

847
00:56:42,770 --> 00:56:46,790
Мы не будем подобно касаться того,
как люди решают проблемы LazyIO,

848
00:56:46,910 --> 00:56:49,675
потому что это достаточно
комплексная проблема.

849
00:56:50,030 --> 00:56:55,590
Самое легкое, самое простое, что мы можем
делать, и проверенное временем решение,

850
00:56:55,750 --> 00:57:00,340
это просто использовать какую-то библиотеку
для стриминговой обработки данных,

851
00:57:02,600 --> 00:57:06,990
в которую как раз-таки вшита
нормальная и правильная работа с LazyIO,

852
00:57:07,150 --> 00:57:08,467
и нельзя выстрелить себе в ногу.

853
00:57:08,550 --> 00:57:13,433
Такие библиотеки — это Conduit, наверное,
самая известная, также Pypes и Streaming.

854
00:57:14,060 --> 00:57:16,914
Они просто предоставляют
интерфейс для написания

855
00:57:16,956 --> 00:57:19,851
каких-то пайплайнов работы
с потоковыми данными,

856
00:57:20,970 --> 00:57:24,270
которые в нужный момент форсятся,
в нужный момент не форсятся,

857
00:57:24,271 --> 00:57:30,650
для того чтобы поддерживать
состояние вычисления рабочих.

858
00:57:30,930 --> 00:57:34,147
Чтобы не было таких спецэффектов,
как закрытый файловый дескриптор.

859
00:57:34,230 --> 00:57:37,878
Логика этих библиотек достаточно
продуманная, чтобы учитывать.

860
00:57:38,190 --> 00:57:41,790
И есть еще один способ,
как бороться с LazyIO.

861
00:57:43,330 --> 00:57:47,900
Есть такой модуль, кстати,
все эти функции вида

862
00:57:47,943 --> 00:57:52,751
readfile и так далее
находятся в модуле SystemIO.

863
00:57:54,050 --> 00:57:57,168
И есть модуль, который
называется SystemIO Streaming.

864
00:57:57,840 --> 00:57:59,723
Все операции которого неленивые.

865
00:58:00,270 --> 00:58:03,790
Соответственно, там не
бывает спецэффекта LazyIO.

866
00:58:04,340 --> 00:58:06,510
Но, к сожалению, это не панацея.

867
00:58:07,760 --> 00:58:10,087
И использование строгого
IEO тоже не очень хорошо.

868
00:58:10,170 --> 00:58:13,935
Почему? Потому что если мы будем
работать с файлами или данными,

869
00:58:14,490 --> 00:58:18,167
размер которых достаточно велик
и не влезает в оперативную память,

870
00:58:18,250 --> 00:58:21,662
и мы бы хотели его обрабатывать
как-то по кустам, чанками,

871
00:58:21,970 --> 00:58:24,750
то SystemIO Streaming не
позволит нам это сделать,

872
00:58:24,810 --> 00:58:28,750
потому что в момент вызова функции
readfile он пойдет, прочитает файл,

873
00:58:28,751 --> 00:58:31,850
и сразу все его содержимое
запихнет в строку,

874
00:58:31,910 --> 00:58:35,950
вычисляя при этом до слабой
головной нормальной формы.

875
00:58:36,450 --> 00:58:38,667
Вот. Потому что это строгие вычисления.

876
00:58:38,750 --> 00:58:42,788
Поэтому если вы уверены, что вы используете
какие-то небольшие объемы данных,

877
00:58:42,870 --> 00:58:47,670
можете для уменьшения рисков
столкнуться с проблемой LazyIO

878
00:58:48,870 --> 00:58:52,753
воспользоваться модулем SystemIO
Stream из стандартной библиотеки.

879
00:58:53,010 --> 00:58:55,790
Иначе, если вы пишете какую-то комплексную

880
00:58:55,791 --> 00:58:58,144
логику для взаимодействия
с внешними ресурсами,

881
00:58:58,390 --> 00:59:00,847
рекомендуется использовать,
допустим, Conduit.

882
00:59:00,930 --> 00:59:02,460
Очень хорошая библиотечка.

883
00:59:02,550 --> 00:59:05,727
С интерфейсом, очень
сильно похожим на стандартную

884
00:59:05,810 --> 00:59:07,693
библиотеку, просто с
более умными функциями.

885
00:59:09,570 --> 00:59:10,865
Давайте пойдем дальше.

886
00:59:13,580 --> 00:59:18,650
И кратко осветим такую вещь,
как FFI, Foreign Function Interface.

887
00:59:19,970 --> 00:59:23,550
Это про то, как дергать C-шный код, и
не только C-шный код на самом деле,

888
00:59:23,551 --> 00:59:29,410
а любой другой код, где
calling conventions совпадают,

889
00:59:29,750 --> 00:59:33,470
а у C и Haskell они совпадают, из Haskell.

890
00:59:34,415 --> 00:59:40,590
Давайте заведем на файл
simple.c такую функцию int.

891
00:59:40,710 --> 00:59:43,534
example, которая принимает
два инта, возвращает a плюс b.

892
00:59:44,260 --> 00:59:47,507
И для того, чтобы использовать
данную функцию в Haskell,

893
00:59:47,590 --> 00:59:51,002
мы пишем вот такое расширение,
Foreign Function Interface,

894
00:59:51,930 --> 00:59:58,330
импортируем следующий модуль,
который содержит нужные типы.

895
00:59:58,910 --> 01:00:02,250
Это, соответственно, просто
репрезентации C-шных типов в Haskell,

896
01:00:02,330 --> 01:00:06,030
можно так сказать,
потому что C-шный тип int,

897
01:00:06,190 --> 01:00:09,073
которые платформозависимые
в Haskell, будет cint.

898
01:00:09,210 --> 01:00:12,593
Просто для того, чтобы
было логическое разделение

899
01:00:12,635 --> 01:00:15,431
между int-ами Haskell и int-ами C-шными.

900
01:00:15,980 --> 01:00:20,090
И, соответственно, мы можем с
помощью вот такой магической надписи

901
01:00:20,091 --> 01:00:24,770
Foreign Import C-Call Safe
Example, имя функции,

902
01:00:26,770 --> 01:00:29,590
объявить эквивалентную
сигнатуру в Haskell.

903
01:00:29,990 --> 01:00:32,107
Вот, соответственно,
это будет cint, cint, cint.

904
01:00:32,190 --> 01:00:37,890
Если типы не сойдутся,
то печаль, оно упадет.

905
01:00:38,290 --> 01:00:40,387
Соответственно, у нас уже есть
хаткельная функция example,

906
01:00:40,470 --> 01:00:43,502
которая на самом деле
при вызове будет вызывать

907
01:00:43,585 --> 01:00:44,767
C-шную функцию example, и
мы ее можем использовать.

908
01:00:44,850 --> 01:00:48,630
Соответственно, cint – это
также имеет instance класс она.

909
01:00:51,050 --> 01:00:55,370
И поэтому можно вызывать
функцию example от констанции 0.2 и 0.

910
01:00:55,550 --> 01:00:57,139
27, и просто принять результат.

911
01:00:59,370 --> 01:01:03,770
Можете пояснить, что
значит конкретно C-Call Safe,

912
01:01:04,030 --> 01:01:07,148
и можно ли что-нибудь интересное
вместо них написать? C-Call Safe.

913
01:01:08,190 --> 01:01:09,370


914
01:01:11,560 --> 01:01:16,030
Я, к сожалению, не работал с
FFI, это достаточно редкая штука,

915
01:01:16,130 --> 01:01:19,090
поэтому я даже затрудняюсь
ответить, если честно.

916
01:01:19,780 --> 01:01:25,920
Вот есть про это статейки какие-то, но
если есть safe, то, видимо, есть и unsafe.

917
01:01:26,670 --> 01:01:31,190
Но, если честно, это довольно редкий кейс,
который особо не встречается на практике,

918
01:01:31,191 --> 01:01:36,830
только разве что, если мы пишем
какие-то performance-sensitive вещи,

919
01:01:37,790 --> 01:01:42,062
где нам может потребоваться C-шный код,
где у нас performance хастеля не хватает.

920
01:01:44,550 --> 01:01:46,847
Единственное использование FFI, которое я

921
01:01:46,930 --> 01:01:49,130
видел, выглядит как-то так и ничего умнее.

922
01:01:49,270 --> 01:01:53,690
То есть мы просто пишем импорт
ряда каких-то C-шных функций.

923
01:01:54,230 --> 01:01:56,270
Я уверен, что с этим можно
делать что-то интереснее,

924
01:01:56,271 --> 01:02:01,310
но, к сожалению, да, не могу вам об
этом ничего сказать содержательного.

925
01:02:05,990 --> 01:02:11,710
Окей, если дальше вопросов нет,
давайте поговорим о мутабельных данных.

926
01:02:16,200 --> 01:02:22,030
Представьте, что у нас есть
какой-то специальный тип данных

927
01:02:23,470 --> 01:02:25,890
для мутабельной обертки
над какими-то данными,

928
01:02:25,891 --> 01:02:28,597
который предоставляет
интерфейс read variable,

929
01:02:28,770 --> 01:02:33,130
который принимает вот эту нашу пока
еще загадочную мутабельную переменную,

930
01:02:33,390 --> 01:02:34,390
и write variable.

931
01:02:35,250 --> 01:02:38,650
И представим, что это все у нас чистое,

932
01:02:38,910 --> 01:02:41,675
не находится ни в какой
монаде ее, и так далее.

933
01:02:42,050 --> 01:02:44,850
Какие у нас могут быть
проблемы в данном коде?

934
01:02:45,170 --> 01:02:48,818
То есть у нас есть какая-то
магическая мутабельная переменная,

935
01:02:49,030 --> 01:02:51,047
у которой следующий
интерфейс read и write.

936
01:02:51,130 --> 01:02:52,483
И все это у нас чистое.

937
01:02:52,860 --> 01:02:55,230
Есть ли какие-то проблемы по-вашему?

938
01:03:02,205 --> 01:03:03,911
Опять же, порядок вычислений.

939
01:03:04,100 --> 01:03:06,327
Да, да, опять же, порядок
вычислений, во-первых.

940
01:03:06,410 --> 01:03:08,804
Во-вторых, здесь мы
видим, что результат функции

941
01:03:08,846 --> 01:03:11,028
write variable у нас
никак не используется,

942
01:03:11,110 --> 01:03:15,150
поэтому это большой вопрос,
будет ли вызвана данная функция.

943
01:03:17,430 --> 01:03:18,489
Спойлера не будет.

944
01:03:18,770 --> 01:03:23,790
Поэтому да, ровно так же, как
и с работой с внешним миром,

945
01:03:23,791 --> 01:03:28,790
работа с мутабельностью также
требует какого-то порядка и гарантии

946
01:03:30,210 --> 01:03:31,510
исполнения операции.

947
01:03:31,610 --> 01:03:33,905
Поэтому такой интерфейс в Haskell есть,

948
01:03:34,010 --> 01:03:38,330
и он обязывает находиться
у нас в контексте IOR.

949
01:03:38,940 --> 01:03:41,646
Данная мутабельная
переменная называется IORF,

950
01:03:42,130 --> 01:03:43,747
которая имеет следующий интерфейс.

951
01:03:43,830 --> 01:03:46,370
Оно все находится в модуле data IORF,

952
01:03:47,890 --> 01:03:51,570
и оно предоставляет
непосредственно сам тип данных IORF.

953
01:03:51,571 --> 01:03:54,930
Это просто коробочка,
параметризованная каким-то типом,

954
01:03:55,110 --> 01:03:57,127
внутри которой находится
значение этого типа.

955
01:03:57,210 --> 01:03:58,647
Соответственно, можно ее создать.

956
01:03:58,730 --> 01:03:59,930
new IORF от нуля.

957
01:04:03,820 --> 01:04:08,890
К сожалению, у нас не будет сигнатур.

958
01:04:09,150 --> 01:04:10,407
Давайте я тогда их проговорю.

959
01:04:10,490 --> 01:04:16,770
Функция new IORF принимает какой-то
тип A и возвращает IOR от IORF A.

960
01:04:17,490 --> 01:04:21,491
Соответственно, он возвращает нам
эту коробочку IORF с нужным типом,

961
01:04:21,650 --> 01:04:23,627
дополнительно к тому же
находясь в контексте ее.

962
01:04:23,710 --> 01:04:27,450
То есть var A будет иметь тип IORF A,

963
01:04:27,690 --> 01:04:29,710
где A это пока что
какой-то произвольный...

964
01:04:29,711 --> 01:04:32,123
Давайте для простоты скажем, что это int.

965
01:04:32,930 --> 01:04:35,667
Мы-то знаем, что числовые
литералы Haskell полиморфные.

966
01:04:35,750 --> 01:04:37,790
Поэтому var A это IORF int.

967
01:04:39,210 --> 01:04:40,870
Затем у нас есть функция read IORF,

968
01:04:40,930 --> 01:04:43,870
которая принимает IORF и
возвращает IOR от результата.

969
01:04:43,930 --> 01:04:46,636
В данном случае у нас
результат будет IOR int.

970
01:04:48,100 --> 01:04:50,727
Также есть функция write
IORF, которая принимает IORF,

971
01:04:50,810 --> 01:04:56,930
принимает новое значение, и
результат у него будет пустой кротеж.

972
01:04:57,050 --> 01:04:58,109
IOR пустой кротеж.

973
01:04:58,270 --> 01:05:03,450
Поэтому мы здесь пользуемся
урезанным виндом нашей дунотации.

974
01:05:04,030 --> 01:05:09,010
Затем мы опять читаем IORF и
возвращаем соответственно A0 и A1.

975
01:05:09,530 --> 01:05:11,210
И данный код, в отличие от кода выше,

976
01:05:11,211 --> 01:05:16,090
в силу того, что он
используется в контексте IEO,

977
01:05:16,670 --> 01:05:21,290
и все плюсы работы с
IEO он имеет из коробки,

978
01:05:22,340 --> 01:05:23,667
данный код работает корректно.

979
01:05:23,750 --> 01:05:26,692
В том плане, что он не
дескаргит никакие операции,

980
01:05:26,790 --> 01:05:31,490
он их ни в коем случае не дуплицирует
и выполняет в правильном порядке.

981
01:05:32,650 --> 01:05:35,390
То есть все, что нужно знать о
мутабельных данных в Haskell пока,

982
01:05:35,391 --> 01:05:40,390
пока речь не идет о каких-то
примитивах синхронизации,

983
01:05:41,130 --> 01:05:45,530
работы с многоподочностью
и так далее, то есть у этих

984
01:05:45,550 --> 01:05:46,887
данных IORF мутабельный,
который хранит в себе какой-то тип.

985
01:05:46,970 --> 01:05:49,767
Мы туда можем писать, можем
читать, можем создавать новые.

986
01:05:49,850 --> 01:05:50,683
Все это в IEO.

987
01:05:51,375 --> 01:05:54,327
Есть очень много полезных функций,
допустим, modify, IORF и так далее,

988
01:05:54,410 --> 01:05:57,528
которые более-менее
интуитивно понятны, как работают.

989
01:05:59,270 --> 01:06:02,310
Соответственно, у нас будет
правильно выведено Foo.

990
01:06:02,990 --> 01:06:04,610
Foo – это 0,1.

991
01:06:07,470 --> 01:06:14,990
Также наряду с мутабельными
переменами у нас есть мутабельные

992
01:06:15,030 --> 01:06:17,442
массивы в Haskell, которые
находятся в пакете data.array.io.

993
01:06:17,550 --> 01:06:24,670
Он предоставляет тип данных IORF и функции
по аналогии с IORF для работы с ними.

994
01:06:25,320 --> 01:06:33,510
Соответственно, new array принимает у
нас картеж из индексов данного массива.

995
01:06:34,370 --> 01:06:38,710
Соответственно, данный массив
будет иметь индексы от 1 до 10.

996
01:06:39,310 --> 01:06:41,027
Вот такой вот странный интерфейс.

997
01:06:41,110 --> 01:06:44,370
И также... а, нет, сейчас.

998
01:06:45,930 --> 01:06:47,190
Дайте-ка вспомнить.

999
01:06:52,150 --> 01:06:52,990
Что-то странное.

1000
01:06:53,030 --> 01:06:56,047
Я, если честно, даже забыл,
как этот array выглядит,

1001
01:06:56,130 --> 01:06:59,836
потому что, спойлер, никто
пакетом data.array.io не пользуется.

1002
01:07:00,010 --> 01:07:01,775
Все пользуются пакетом vector.

1003
01:07:01,970 --> 01:07:05,387
Поэтому я этот код не видел ни разу
в жизни, кроме как на этом слайде.

1004
01:07:05,470 --> 01:07:07,470
Короче, мы можем создавать массив.

1005
01:07:07,690 --> 01:07:09,290
Можем читать от мотива по индексу.

1006
01:07:09,370 --> 01:07:14,270
Можем писать массив по
индексу какое-то значение.

1007
01:07:14,350 --> 01:07:15,070
И также можем читать.

1008
01:07:15,130 --> 01:07:17,072
Давайте все-таки хорошо захуглим.

1009
01:07:18,250 --> 01:07:19,956
Блин, позорится, я вам скажу.

1010
01:07:20,310 --> 01:07:21,143
New array.

1011
01:07:27,190 --> 01:07:30,470
Боже мой, тут есть еще очень многое.

1012
01:07:31,790 --> 01:07:32,830
Data.array.

1013
01:07:36,610 --> 01:07:39,327
io Это, видимо, настолько старый
слайд, что такого типа даже нет.

1014
01:07:39,410 --> 01:07:40,881
Короче, предлагаю забить.

1015
01:07:41,180 --> 01:07:43,007
Предлагаю забить на type.array.

1016
01:07:43,090 --> 01:07:47,350
io и использовать вместо него,
если вам вдруг нужно, будет type.

1017
01:07:48,230 --> 01:07:51,172
vector, который находится в
соответственном пакете vector.

1018
01:07:52,010 --> 01:07:54,599
Просто знайте, что
мутабельные массивы есть.

1019
01:07:54,790 --> 01:07:56,987
Я надеюсь, вам их в
жизни никогда не придется

1020
01:07:57,070 --> 01:07:59,306
использовать, потому что
это достаточно редкая тема.

1021
01:08:01,290 --> 01:08:02,617
Сигнатура не самая понятная.

1022
01:08:02,700 --> 01:08:04,767
Я действительно забыл,
что тут эти штуки значат.

1023
01:08:04,850 --> 01:08:05,970
Но факт остается фактом.

1024
01:08:06,050 --> 01:08:09,050
Можно объявить мутабельный
массив, можно туда

1025
01:08:09,110 --> 01:08:10,640
почитать по индексу,
можно записать по индексу.

1026
01:08:16,570 --> 01:08:19,923
Даже тут говорится про то,
что нужно вязать пакет vector,

1027
01:08:20,050 --> 01:08:23,070
который предоставляет
как мутабельные, так и не

1028
01:08:23,071 --> 01:08:26,490
мутабельные массивы с
константным доступом по индексу.

1029
01:08:28,090 --> 01:08:28,923
Такие дела.

1030
01:08:33,720 --> 01:08:38,740
Я предлагаю... Сейчас, давайте я посмотрю,
сколько у нас с вами осталось уговорить.

1031
01:08:40,340 --> 01:08:44,598
Ладно, я предлагаю... Нам еще осталось,
по моим предположениям, минут сорок.

1032
01:08:44,940 --> 01:08:47,960
Если вы хотите, мы можем идти
сейчас на перерыв небольшой,

1033
01:08:47,961 --> 01:08:51,609
потому что у нас начинается
относительно новая тема exception.

1034
01:08:52,345 --> 01:08:56,240
Также мы можем просто взять и
продолжить, и пораньше уйдем.

1035
01:08:57,620 --> 01:09:01,209
Так что тут учитывать вам,
скажите, как мы будем действовать.

1036
01:09:06,510 --> 01:09:07,628
Пораньше закончить.

1037
01:09:07,930 --> 01:09:08,930
Окей, окей.

1038
01:09:09,070 --> 01:09:12,510
Если никто не возражает...
Да, все, в чате тоже пишут.

1039
01:09:13,070 --> 01:09:13,903
Окей, давайте.

1040
01:09:15,300 --> 01:09:20,270
Как мы знаем, везде, где у нас существует
какая-то работа с внешним миром,

1041
01:09:21,050 --> 01:09:24,580
у нас могут возникать всякие
разные исключительные ситуации.

1042
01:09:24,810 --> 01:09:28,150
Например, мы читаем из
файла, который не существует.

1043
01:09:28,570 --> 01:09:30,537
Или же даже далеко хватить не надо.

1044
01:09:30,620 --> 01:09:34,010
Исключительные ситуации у нас бывают,
когда мы работаем с чистыми функциями,

1045
01:09:34,050 --> 01:09:38,407
например, функция деления, которая
выкидывает ошибку, если мы делим на ноль.

1046
01:09:38,490 --> 01:09:44,430
Сейчас мы очень кратко
осветим, как механизм исключения

1047
01:09:44,530 --> 01:09:46,648
работает в Haskell, и какие
есть вещи для работы с этим.

1048
01:09:48,390 --> 01:09:50,190
Начнем с функции throwIo,

1049
01:09:50,770 --> 01:09:53,790
которая принимает в
качестве аргумента некий e,

1050
01:09:54,140 --> 01:09:55,729
который является exception,

1051
01:09:56,070 --> 01:09:59,270
и возвращаемый тип у него
довольно странный, тип IoA.

1052
01:09:59,970 --> 01:10:03,850
Почему это так? Потому что, на
самом деле, это расходящийся...

1053
01:10:03,851 --> 01:10:06,410
Логичный вопрос, откуда у нас берется A.

1054
01:10:07,030 --> 01:10:08,030
Все очень просто.

1055
01:10:08,630 --> 01:10:13,670
Когда мы бросаем exception, программа,
точнее, наш поток заканчивает выполнение,

1056
01:10:14,390 --> 01:10:17,861
и, соответственно, результатом
данной функции является bot.

1057
01:10:19,510 --> 01:10:23,040
Напоминаю, то есть невычисляемое,
неэтифицируемое выражение.

1058
01:10:23,435 --> 01:10:28,270
Поэтому, в принципе, вместо
IoA здесь могло бы быть

1059
01:10:28,330 --> 01:10:29,470
абсолютно что угодно, и
это бы этифизировалось.

1060
01:10:29,510 --> 01:10:32,347
Это ровно то же самое, как
у нас происходит с undefined.

1061
01:10:32,430 --> 01:10:35,372
То, что undefined у нас
этифизируется любым типом.

1062
01:10:35,590 --> 01:10:43,011
Но просто так как у нас работа с исключениями
по большей части тесно связана с Io,

1063
01:10:44,050 --> 01:10:45,286
используется тип IoA.

1064
01:10:45,870 --> 01:10:49,410
На самом деле тип возвращаемого
значения здесь особо не играет роли,

1065
01:10:49,450 --> 01:10:53,215
потому что в случае вызова данной
функции наша программа упадет.

1066
01:10:54,000 --> 01:11:00,430
Давайте посмотрим следующую функцию
readAndDivide, которая возвращает IoInt.

1067
01:11:01,530 --> 01:11:02,413
Что она делает?

1068
01:11:03,530 --> 01:11:05,430
Она считывает два числа из консоли.

1069
01:11:05,470 --> 01:11:10,410
Представьте, что функция readDelay
читает строчку и превращает ее в число.

1070
01:11:10,430 --> 01:11:12,367
Просто для простоты,
чтобы было меньше кода.

1071
01:11:12,450 --> 01:11:16,477
Соответственно, мы считаем числа
x и y, проверяем, что если y – это 0,

1072
01:11:16,560 --> 01:11:22,611
бросаем exceptionDivideBy0, который является
одним из конструкторов ArithException.

1073
01:11:23,290 --> 01:11:26,836
Это тип суммы, который предоставляет собой

1074
01:11:26,878 --> 01:11:30,551
часто используемые
исключения в арифметике,

1075
01:11:31,630 --> 01:11:34,747
которые взяты из модуля ControlException
из стандартной библиотеки.

1076
01:11:34,830 --> 01:11:37,948
Короче, если y – это 0, мы
кидаем exceptionDivideBy0,

1077
01:11:38,170 --> 01:11:42,610
иначе мы уверены, что y – это не 0, и
возвращаем из нашей функции xDiv.

1078
01:11:43,630 --> 01:11:45,925
И давайте вызовем эту функцию в Garsci.

1079
01:11:46,060 --> 01:11:48,161
Соответственно, если вызвать функцию

1080
01:11:48,203 --> 01:11:51,179
readAndDivide, написать
7, 3 – это все отработает.

1081
01:11:51,370 --> 01:11:54,367
Если написать 3, 0, то у нас
выйдет exceptionDivideBy0.

1082
01:11:54,450 --> 01:11:57,654
То есть наша программа
закончит свое выполнение

1083
01:11:57,696 --> 01:12:01,011
с исключением на этой
строчке, нашей doNotation.

1084
01:12:02,160 --> 01:12:08,690
Пока что ничего специфичного, что
бы отличало Haskell от других языков.

1085
01:12:09,470 --> 01:12:14,770
Единственное, что возможно throw в многих
языках – это оператор кейборда языка.

1086
01:12:14,870 --> 01:12:19,170
Здесь функция throwIo. Это просто
функция из стандартной библиотеки.

1087
01:12:20,050 --> 01:12:22,992
Ничего в ней магического,
на первый взгляд, и нет.

1088
01:12:24,110 --> 01:12:27,410
Если везде, когда речь
встает про исключения,

1089
01:12:27,870 --> 01:12:31,988
очевидно, нам интересно не то,
как их кидать, но также, как их ловить.

1090
01:12:32,310 --> 01:12:39,970
Для этого у нас существует функция catch,
которая также требует от нашего типа E,

1091
01:12:40,070 --> 01:12:42,952
чтобы это был некий exception.
Что такое exception?

1092
01:12:43,035 --> 01:12:47,327
Как вы уже догадались, это type class.
Мы разберем через пару слайдов буквально.

1093
01:12:47,410 --> 01:12:52,058
Он принимает какое-то EO-шное действие
и также принимает обработчик исключений.

1094
01:12:53,450 --> 01:12:58,391
Если в случае выполнения этого EO-шного
действия EOA вылезет какое-то исключение E,

1095
01:12:59,230 --> 01:13:04,470
то мы обрабатываем это исключение, и
результирующий тип также должен быть EOA.

1096
01:13:05,620 --> 01:13:09,327
И, соответственно, результирующий
тип всей этой истории – это также EOA.

1097
01:13:09,410 --> 01:13:13,930
Соответственно, в этой
нашей хендлер-функции, в catch,

1098
01:13:14,050 --> 01:13:18,090
мы можем почистить какие-то ресурсы
и выбросить это исключение обратно,

1099
01:13:18,170 --> 01:13:21,288
потому что, напоминаю,
тип функции throwIo – это EOA.

1100
01:13:21,570 --> 01:13:24,407
Также мы можем вернуть, например,
какое-то дефолтное значение.

1101
01:13:24,490 --> 01:13:29,090
Поэтому это уже поведение
специфицируется нами, как программистами.

1102
01:13:29,310 --> 01:13:32,252
Функция catch позволяет
сделать оба этих действия.

1103
01:13:33,270 --> 01:13:36,127
Давайте посмотрим, как
выглядит функция saveReturnDivide.

1104
01:13:36,210 --> 01:13:40,431
Соответственно, это вызов функции
returnDivide определенный на прошлом слайде

1105
01:13:40,431 --> 01:13:44,150
и с соответствующим
обработчиком исключений.

1106
01:13:45,770 --> 01:13:50,182
Если у нас вылетает исключение divide
by 0, то мы возвращаем минус единицу.

1107
01:13:50,450 --> 01:13:56,470
Соответственно, вот эта функция
имеет тип, напоминаю, exceptionE из EOA.

1108
01:13:56,930 --> 01:14:01,570
Мы ловим, паттерн-матчимся по исключению
divide by 0 и return минус единицу.

1109
01:14:04,350 --> 01:14:08,987
Логичный был бы вопрос,
а что будет, если сюда

1110
01:14:09,070 --> 01:14:10,012
прилетит какой-то другой
экземпляр, а это exception.

1111
01:14:10,250 --> 01:14:15,350
К сожалению, это упадет тем, что
у нас non-exhaustive pattern match.

1112
01:14:15,830 --> 01:14:18,027
Но здесь для простоты это мы приведем.

1113
01:14:18,110 --> 01:14:21,405
Здесь для простоты мы не
стали unknown exception ловить.

1114
01:14:24,220 --> 01:14:29,500
Вот есть ли какие-то
вопросы по тому, как на таком

1115
01:14:29,501 --> 01:14:31,090
достаточно интуитивном уровне
пока что ловить исключения?

1116
01:14:32,740 --> 01:14:37,105
Верно ли, что по-хорошему
мы должны были исправить

1117
01:14:37,147 --> 01:14:41,201
non-exhaustive pattern
match каким-то методом?

1118
01:14:43,410 --> 01:14:46,044
Как не будете реализовать
то, что если это не

1119
01:14:46,087 --> 01:14:49,000
division-базирует, то нужно
это выкинуть обратно?

1120
01:14:49,590 --> 01:14:50,885
Или это так не делать?

1121
01:14:53,020 --> 01:14:57,440
В данном случае, знаете,
довольно тяжело рассматривать

1122
01:14:57,520 --> 01:14:59,582
этот пример, потому что
мы знаем, что функция return

1123
01:14:59,625 --> 01:15:01,998
divide ничего кроме
divide by 0 не вылетает.

1124
01:15:02,080 --> 01:15:04,737
Но, допустим, если мы рассматриваем
какой-то более реальный код,

1125
01:15:04,820 --> 01:15:10,440
очевидно, что нам нужно
обрабатывать все кейсы pattern matching.

1126
01:15:11,160 --> 01:15:16,900
Потому что если у нас есть какая-то data
my hero равно my hero 1 или my hero 2,

1127
01:15:17,300 --> 01:15:19,557
очевидно, нам не нужно
ловить только my hero 1.

1128
01:15:19,640 --> 01:15:26,080
В случае my hero 2 нам нужно
выкинуть какое-то исключение дальше.

1129
01:15:26,580 --> 01:15:28,934
То есть наша программа
не должна падать с какими-то

1130
01:15:28,976 --> 01:15:31,278
хаскельными ошибками в
духе non-exhaustive match.

1131
01:15:31,360 --> 01:15:35,417
В данном случае мы можем написать что-то
типа, мы можем выбросить исключение,

1132
01:15:35,500 --> 01:15:38,442
добавив к нему то, что это
исключение неожиданное,

1133
01:15:38,560 --> 01:15:42,561
то есть unexpected year, и просто
перебросить это исключение дальше.

1134
01:15:42,750 --> 01:15:45,089
Да, конечно, данный пример просто, чтобы

1135
01:15:45,131 --> 01:15:47,869
уложился в одну строчку,
написан для простоты.

1136
01:15:48,180 --> 01:15:49,013
Ничего более.

1137
01:15:55,960 --> 01:15:57,490
Ну, давайте пойдем дальше.

1138
01:16:00,230 --> 01:16:08,610
Тут вы видите две большие красные надписи
про то, что на самом деле, как вы видите,

1139
01:16:09,690 --> 01:16:14,550
в IEO у нас могут быть выкинуто
на самом деле любое исключение.

1140
01:16:15,200 --> 01:16:18,396
Здесь мы видим по ассигнатуре
функции catch, что это

1141
01:16:18,438 --> 01:16:22,111
должен быть какой-то произвольный
exception, которых много.

1142
01:16:22,530 --> 01:16:26,070
И оно не ограничивается
одним лишь arith exception.

1143
01:16:26,590 --> 01:16:29,135
Про то, каким образом у
нас здесь появился именно

1144
01:16:29,178 --> 01:16:31,448
arith exception, мы
поговорим прямо сейчас.

1145
01:16:31,530 --> 01:16:34,483
Знаете то, что система
exception в хаскеле,

1146
01:16:34,526 --> 01:16:37,451
ее называют по-другому untyped exceptions.

1147
01:16:37,850 --> 01:16:43,590
Потому что мы заранее не типизируем,
не специфицируем типы исключений,

1148
01:16:43,670 --> 01:16:47,590
которые могут полететь из нашей
функции, которую мы вызываем.

1149
01:16:47,880 --> 01:16:50,745
Когда мы пишем обработчик
исключений какой-то функции, на

1150
01:16:50,787 --> 01:16:53,948
самом деле оттуда может вылететь
более-менее любое исключение.

1151
01:16:54,030 --> 01:16:55,678
Сейчас мы об этом поговорим.

1152
01:16:55,950 --> 01:17:00,598
И это, к сожалению, никаким образом не
представляется в системе типа в хаскеле.

1153
01:17:01,070 --> 01:17:02,953
Сейчас мы будем с этим бороться.

1154
01:17:04,180 --> 01:17:07,455
Я вставил сюда буквально
пару слайдов про то, что же

1155
01:17:07,498 --> 01:17:10,751
все-таки такое exception
в хаскеле и с чем их едят.

1156
01:17:11,550 --> 01:17:16,157
Давайте заведем какое-то
data.myException равно data.

1157
01:17:16,200 --> 01:17:22,431
myException и задерайвим у
него следующий type-класс show.

1158
01:17:22,670 --> 01:17:24,671
Понятно, мы можем его задерайвить.

1159
01:17:25,090 --> 01:17:26,933
Задерайвим какой-то непонятный type-класс

1160
01:17:26,976 --> 01:17:28,998
typable, который пока
непонятно зачем нужен.

1161
01:17:29,080 --> 01:17:31,047
И также задерайвим type-класс exception.

1162
01:17:31,130 --> 01:17:33,650
Да, exception у нас может быть задерайвим.

1163
01:17:34,830 --> 01:17:39,410
И, соответственно, таким образом, при
подключении соответствующих расширений.

1164
01:17:40,930 --> 01:17:46,819
Соответственно, таким образом,
мы можем использовать наш type.

1165
01:17:46,861 --> 01:17:52,791
myException, а точнее один его конструктор
data.myException в функции throw.io и catch.

1166
01:17:53,440 --> 01:17:57,200
Соответственно, если
мы в GHCI напишем throw.

1167
01:17:57,242 --> 01:18:01,771
io data.myException, то никакой
ошибки типов не произойдет.

1168
01:18:02,450 --> 01:18:05,513
Наш data.myException
действительно является инстантом

1169
01:18:05,555 --> 01:18:08,308
эксепшена, и хаскель
позволит нам его выкинуть.

1170
01:18:08,390 --> 01:18:11,889
Соответственно, если мы рассмотрим
следующий блок кода, то в GHCI действительно

1171
01:18:11,931 --> 01:18:15,158
можно писать многострочные блоки
кода с пользованием логикового синтеза.

1172
01:18:15,240 --> 01:18:19,693
Если мы кинем data.myException, и
затем сразу же поймаем data.myException, и

1173
01:18:19,736 --> 01:18:24,408
напишем в нашем хейдлере, что data.myException
is thrown, и вызовем данный код,

1174
01:18:24,490 --> 01:18:28,079
то действительно выявится то,
что data.myException is thrown.

1175
01:18:28,520 --> 01:18:32,110
Пока что все весьма и весьма прямолинейно.

1176
01:18:34,090 --> 01:18:38,968
Давайте уже все-таки
посмотрим, что же такое type-класс

1177
01:18:39,010 --> 01:18:43,751
exception, и какие связанные
с ним дата-тайпы бывают.

1178
01:18:43,751 --> 01:18:48,104
Давайте пока на верхнюю строку забьем
и посмотрим на type-класс exception.

1179
01:18:50,180 --> 01:18:53,567
Type-класс exception требует
для себя следующие constraints.

1180
01:18:53,650 --> 01:18:56,577
Это show для того, чтобы
наше исключение можно

1181
01:18:56,620 --> 01:18:59,911
было выводить на консоль
функции display exception.

1182
01:19:00,690 --> 01:19:02,867
И также некоторый type-класс typable.

1183
01:19:03,270 --> 01:19:05,749
Type-класс typable – это такой специальный

1184
01:19:05,791 --> 01:19:08,671
type-класс, который будет
освещен далее в курсе.

1185
01:19:09,020 --> 01:19:12,538
Я вам скажу очень кратко,
что это type-класс, который

1186
01:19:12,581 --> 01:19:16,611
позволяет для типа E в рантайме
извлекать информацию о типе.

1187
01:19:16,650 --> 01:19:20,197
Для того, чтобы понимать исключение
какого именно типа мы выбрали.

1188
01:19:20,280 --> 01:19:23,516
Да, в таскеле есть некоторый
аналог рефлекшена, который,

1189
01:19:23,558 --> 01:19:27,128
допустим, есть в Java, и он
представлен type-классом typable.

1190
01:19:27,210 --> 01:19:31,247
Более детально данный type-класс будет
озвучен, наверное, лекцией через 3-4.

1191
01:19:31,330 --> 01:19:35,917
Пока что знаете, что такой type-класс
есть, его можно дерайвить, и на этом все.

1192
01:19:36,000 --> 01:19:38,107
В type-классе exception
есть следующие функции.

1193
01:19:38,190 --> 01:19:45,590
Display exception, как мы уже говорили,
который берет E и печатает ее строчку.

1194
01:19:46,950 --> 01:19:49,774
По дефолту это реализовано
по кратке через show.

1195
01:19:50,130 --> 01:19:52,586
И также есть две очень интересные функции,

1196
01:19:52,629 --> 01:19:55,543
которые называются from
exception и to exception.

1197
01:19:56,350 --> 01:19:58,627
И сейчас давайте же все-таки разбираться.

1198
01:19:58,710 --> 01:20:03,970
На exception в таскеле реализовано
что-то типа наследования внезапно.

1199
01:20:04,370 --> 01:20:07,015
Потому что у нас есть
некий тип данных some

1200
01:20:07,057 --> 01:20:09,931
exception, который выглядит
следующим образом.

1201
01:20:11,190 --> 01:20:15,270
Можно не особо обращать внимание
на то, как синтаксически он записан.

1202
01:20:15,710 --> 01:20:19,190
Потому что, опять же, это
тема следующих лекций.

1203
01:20:19,330 --> 01:20:22,470
Но так как про exception мы говорим уже
сейчас, важно хотя бы абсурдно понимать,

1204
01:20:22,550 --> 01:20:25,667
как работает механизм
exception без углубления в детали.

1205
01:20:25,750 --> 01:20:28,707
Some exception – это, можно
сказать, предок всех exception.

1206
01:20:28,790 --> 01:20:32,450
Если мы рассматриваем как
такое псевдо-наследование.

1207
01:20:32,750 --> 01:20:35,827
Или же можно рассматривать some
exception как какую-то коробочку,

1208
01:20:35,910 --> 01:20:39,570
тип данных коробка, в которой
лежит какое-то exception.

1209
01:20:39,910 --> 01:20:44,499
В нем лежит какое-то е, которое является
представителем этой класса exception.

1210
01:20:46,120 --> 01:20:47,607
Соответственно, у нас есть две функции.

1211
01:20:47,690 --> 01:20:49,455
From exception и to exception.

1212
01:20:49,570 --> 01:20:52,479
From exception пытается
достать из коробки some

1213
01:20:52,521 --> 01:20:55,471
exception, в которой
лежит какое-то исключение.

1214
01:20:56,100 --> 01:20:58,481
Он пытается его привести
к нашему конкретному

1215
01:20:58,523 --> 01:21:00,838
исключению, для
которого мы пишем instance.

1216
01:21:00,920 --> 01:21:02,827
Соответственно, здесь у нас есть maybe e.

1217
01:21:02,910 --> 01:21:05,227
Потому что у нас в общем
случае в коробке some

1218
01:21:05,269 --> 01:21:07,833
exception может лежать
абсолютно любое исключение,

1219
01:21:07,915 --> 01:21:11,287
как file not found, так там
divide by zero или что-то еще.

1220
01:21:11,370 --> 01:21:15,727
И функция from exception
позволяет, когда у нас есть какое-то

1221
01:21:15,810 --> 01:21:17,990
исключение, понять, нужное
ли это исключение нам сейчас.

1222
01:21:18,630 --> 01:21:20,490
То ли это исключение,
в котором мы работаем.

1223
01:21:20,570 --> 01:21:23,790
Потому что, допустим, для file not found
у нас может быть отдельный обработчик.

1224
01:21:23,870 --> 01:21:25,590
А для другого исключения
– другой обработчик.

1225
01:21:25,670 --> 01:21:27,307
Вот есть такая функция from exception.

1226
01:21:27,390 --> 01:21:30,227
Здесь как раз-таки играет
роль наш type class typable,

1227
01:21:30,310 --> 01:21:32,445
который позволяет
получить информацию о типе,

1228
01:21:32,488 --> 01:21:34,568
чтобы понять, то ли
это исключение или нет.

1229
01:21:34,650 --> 01:21:36,287
И также есть функция to exception.

1230
01:21:36,370 --> 01:21:40,841
To exception просто запаковывает наше
исключение e в коробку some exception.

1231
01:21:41,970 --> 01:21:42,970
Итого резюмируем.

1232
01:21:43,170 --> 01:21:47,910
Exception в Haskell это type class, у
которого есть следующие функции.

1233
01:21:48,490 --> 01:21:51,087
Display exception, которые
просто печатают строку.

1234
01:21:51,170 --> 01:21:56,030
И также две функции для
конверсии из и в some exception.

1235
01:21:56,031 --> 01:22:00,770
Some exception – это коробочка,
которая хранит любое исключение.

1236
01:22:01,190 --> 01:22:03,070
Либо же, если мы
рассматриваем это как иерархию,

1237
01:22:03,150 --> 01:22:07,330
можно сказать, что some exception
– это предок всех исключений.

1238
01:22:07,390 --> 01:22:10,379
Потому что он может быть
с помощью to exception для

1239
01:22:10,422 --> 01:22:13,274
любого типа exception
приведен к some exception.

1240
01:22:17,690 --> 01:22:21,550
И к чему, собственно, идет речь?

1241
01:22:22,250 --> 01:22:24,956
Речь идет к тому, что,
как здесь уже писалось,

1242
01:22:27,395 --> 01:22:31,278
в Haskell и в IEO может быть
выброшено абсолютно любое исключение.

1243
01:22:31,450 --> 01:22:35,215
И вот как раз-таки наша коробочка
some exception нужна для того,

1244
01:22:35,930 --> 01:22:39,450
чтобы… это репрезентация
как раз-таки любого исключения.

1245
01:22:39,590 --> 01:22:42,927
Some exception – это какое-то
некоторое исключение, которое брошено.

1246
01:22:43,010 --> 01:22:46,710
И если же мы в нашей функции,
в какой-нибудь обработчике,

1247
01:22:46,730 --> 01:22:50,436
хотим ловить любое исключение,
мы должны ловить some exception.

1248
01:22:51,120 --> 01:22:53,486
Потому что здесь, допустим,
если у нас функция read

1249
01:22:53,529 --> 01:22:55,748
and divide выбросила
исключение file not found,

1250
01:22:55,830 --> 01:22:58,587
ну, бывает, допустим,
если мы считываем чисел

1251
01:22:58,670 --> 01:23:00,788
из файла, то вот наш
хендлер его не пропустит.

1252
01:23:01,610 --> 01:23:04,963
Он стригерится только, когда
у нас будет arise exception,

1253
01:23:05,170 --> 01:23:07,167
конструктором которой
является divide by zero.

1254
01:23:07,250 --> 01:23:09,192
Если уже у нас полетит какой-то другой

1255
01:23:09,235 --> 01:23:11,688
exception, данный хендлер
просто не отработает.

1256
01:23:11,770 --> 01:23:15,687
Если же мы хотим в нашем
хендлере поймать абсолютно

1257
01:23:15,770 --> 01:23:17,337
любое исключение, мы
ловим здесь some exception.

1258
01:23:17,420 --> 01:23:20,527
И тогда наш хендлер стригерится
абсолютно на любое исключение.

1259
01:23:20,610 --> 01:23:23,830
А уж потом этот some exception мы
можем пощупать, распаковать, допустим,

1260
01:23:23,870 --> 01:23:28,357
с помощью form exception и понять, а
это divide by zero или это file not found.

1261
01:23:28,440 --> 01:23:31,330
И если это там ничего, что нам неизвестно,

1262
01:23:31,650 --> 01:23:34,057
потому что exception на
самом деле бесконечное

1263
01:23:34,140 --> 01:23:36,850
количество, мы можем для
любого написать exception,

1264
01:23:37,295 --> 01:23:40,267
мы можем какое-то конечное
множество exception потрогать,

1265
01:23:40,350 --> 01:23:44,230
посмотреть как-то специфичным
образом, обработать вшивку.

1266
01:23:44,580 --> 01:23:47,827
Если у нас не получилось
извлечь какой-то внятный

1267
01:23:47,910 --> 01:23:49,675
exception, который мы знаем,
мы просто вытянем его обратно.

1268
01:23:51,180 --> 01:23:56,410
Соответственно, за этим вот этот some
exception – это некоторый такой механизм

1269
01:23:59,030 --> 01:24:01,501
задать возможность ловить любой exception.

1270
01:24:03,600 --> 01:24:05,210
Потому что в Haskell нет наследования.

1271
01:24:05,290 --> 01:24:08,767
Нельзя просто взять и отнаследоваться
от exception как в какой-нибудь джебе.

1272
01:24:08,850 --> 01:24:10,377
Пришлось вот так вот изгаляться.

1273
01:24:10,460 --> 01:24:14,284
Скажите, пожалуйста, насколько
понятно то, что сейчас происходит?

1274
01:24:14,470 --> 01:24:17,412
Потому что это довольно
сложновато, на мой взгляд.

1275
01:24:29,210 --> 01:24:30,907
Получается, Haskell –
фп-язык, но exception

1276
01:24:30,950 --> 01:24:32,688
с наследованием, или
я до конца не понимаю?

1277
01:24:32,770 --> 01:24:35,947
На самом деле, наследование
я всегда употреблял в кавычках,

1278
01:24:36,030 --> 01:24:38,854
потому что никакого
наследования, очевидно, нет.

1279
01:24:39,530 --> 01:24:43,780
Просто об этом удобно думать, что
есть некоторые общие исключения,

1280
01:24:45,580 --> 01:24:48,977
которые являются как бы
предками всех остальных исключений.

1281
01:24:49,060 --> 01:24:52,850
Но об этом можно думать.

1282
01:24:52,910 --> 01:24:54,170
Семантически это абсолютно не так.

1283
01:24:54,250 --> 01:24:56,988
Семантически вот эта
иерархия реализована просто

1284
01:24:57,031 --> 01:24:59,868
запаковыванием какого-либо
exception в коробочку.

1285
01:24:59,950 --> 01:25:01,707
То есть на деле никакого наследования нет.

1286
01:25:01,790 --> 01:25:05,908
Просто в силу того, что раньше вы
работали с языками программирования,

1287
01:25:07,055 --> 01:25:12,070
в которых exception реализованы через
наследование, об этом удобно думать.

1288
01:25:12,610 --> 01:25:14,837
Но на самом деле ничего,
кроме запаковывания

1289
01:25:14,880 --> 01:25:17,148
и распаковывания
коробки, тут не происходит.

1290
01:25:17,230 --> 01:25:20,747
Поэтому если вам неудобно об этом думать,
как о наследовании, можете не думать.

1291
01:25:20,830 --> 01:25:25,007
Думайте как о коробке, в которой
лежит год в мешке какой-то исключения.

1292
01:25:30,230 --> 01:25:31,063
Все, супер.

1293
01:25:31,620 --> 01:25:36,770
Давайте же, наконец-то, найдем
применение тому, что я сейчас говорил,

1294
01:25:36,830 --> 01:25:39,937
и напишем какую-то функцию
с использованием вот этого

1295
01:25:39,979 --> 01:25:42,949
сам эксепшена и механизма
эксепшена в полной мере.

1296
01:25:43,490 --> 01:25:46,449
Давайте напишем
функцию try, read and divide,

1297
01:25:46,491 --> 01:25:49,491
у которой имеется
тип IO от either string in.

1298
01:25:49,640 --> 01:25:51,801
Соответственно, у нас может быть либо

1299
01:25:51,844 --> 01:25:54,642
стринговая ошибка, либо
интовый результат в IO.

1300
01:25:54,910 --> 01:25:59,440
Заиспользуем нашу функцию read and
divide и навесим на нее следующий хендлер.

1301
01:25:59,770 --> 01:26:03,325
Заметьте, здесь мы хотим
ловить любое исключение,

1302
01:26:03,367 --> 01:26:07,551
поэтому мы явно указываем
тип, что мы ловим сам эксепшен.

1303
01:26:08,990 --> 01:26:12,083
И делаем с ним следующее.
Наш хендлер ловит

1304
01:26:12,126 --> 01:26:15,771
наиболее общий тип
исключения, ловит сам эксепшен.

1305
01:26:16,300 --> 01:26:19,361
Соответственно, e – это
у нас сам эксепшен, и мы

1306
01:26:19,404 --> 01:26:22,571
пытаемся его привести к
эксепшену divide by zero,

1307
01:26:22,930 --> 01:26:25,769
чтобы в случае, если
это divide by zero, вернуть

1308
01:26:25,811 --> 01:26:28,631
одну ошибку, а в другом
случае – другую ошибку.

1309
01:26:29,170 --> 01:26:31,922
Соответственно, если
у нас from exception – это

1310
01:26:31,965 --> 01:26:34,877
divide by zero, тут, к
сожалению, пропущен maybe.

1311
01:26:35,740 --> 01:26:39,080
Но тут и должен быть
just. Just divide by zero error –

1312
01:26:39,122 --> 01:26:42,691
это maybe divide by zero,
потому что у нас вот тут maybe.

1313
01:26:43,090 --> 01:26:46,167
К сожалению, это ошибка. Когда я
этот слайд готовил, я это не углядел.

1314
01:26:46,250 --> 01:26:48,930
Итого, мы ловим наиболее
общее исключение и

1315
01:26:48,973 --> 01:26:51,631
пытаемся понять, что же нам с ним сделать.

1316
01:26:51,950 --> 01:26:54,032
Давайте попробуем с помощью функции from

1317
01:26:54,074 --> 01:26:56,728
exception привести его к
эксепшену divide by zero.

1318
01:26:56,810 --> 01:26:59,907
Ага, если мы это смогли сделать,
значит у нас настрой эксепшен,

1319
01:26:59,950 --> 01:27:03,088
который был кинут, на самом
деле – это эксепшен divide by zero.

1320
01:27:03,170 --> 01:27:07,710
И давайте вернем left
display exception divide by zero.

1321
01:27:07,960 --> 01:27:11,677
Соответственно, мы выведем
надпись, какой-то текст,

1322
01:27:11,720 --> 01:27:15,331
который специфичен
конкретно данному типу ошибки.

1323
01:27:15,550 --> 01:27:19,564
Если же у нас не получилось с
помощью функции from exception получить

1324
01:27:19,606 --> 01:27:23,368
just что-то там, just divide by
zero, здесь мы получаем nothing.

1325
01:27:23,450 --> 01:27:26,409
И если же мы получили nothing,
значит это какой-то другой

1326
01:27:26,451 --> 01:27:29,188
неожиданный тип исключения,
который мог быть брошен.

1327
01:27:29,270 --> 01:27:32,141
И мы с этим ничего
отмысленного не можем сделать,

1328
01:27:32,183 --> 01:27:35,036
просто как вернуть left
something else happened.

1329
01:27:36,260 --> 01:27:40,990
Логичный вопрос. Каким образом у
нас здесь появляется сам эксепшен?

1330
01:27:41,170 --> 01:27:45,465
Ведь если мы вспомним функцию read
done divide, мы кидаем divide by zero.

1331
01:27:46,170 --> 01:27:49,593
На самом деле, в Haskell,
магическим образом, все

1332
01:27:49,636 --> 01:27:53,171
кинутые эксепшены могут заворачивать сам

1333
01:27:53,230 --> 01:27:55,466
эксепшен, если наш хендлер
ожидает сам эксепшен.

1334
01:27:55,980 --> 01:27:59,215
Поэтому, несмотря на то,
что мы кидаем divide by zero,

1335
01:27:59,257 --> 01:28:02,291
у нас работает некоторое
неявное приведение типов.

1336
01:28:02,291 --> 01:28:06,214
На самом деле, это вызывает
функцию doException, чтобы у нас,

1337
01:28:06,257 --> 01:28:10,351
как у программистов, была
возможность поймать любое исключение.

1338
01:28:11,510 --> 01:28:15,085
Поэтому Haskell, магическим
образом, может запаковывать любой

1339
01:28:15,128 --> 01:28:19,041
эксепшен в сам эксепшен, чтобы у
нас была возможность его поймать.

1340
01:28:22,990 --> 01:28:30,360
В принципе, более-менее все
про идею эксепшенов в Haskell.

1341
01:28:31,160 --> 01:28:34,080
Она, как вы видите, довольно странная.

1342
01:28:35,870 --> 01:28:38,754
Но внезапно она очень хорошо работает, и

1343
01:28:38,796 --> 01:28:41,941
очень хорошо легла в
эту Haskell парадигму.

1344
01:28:42,830 --> 01:28:46,397
Потому что эксепшены в Haskell, исходя
из моего опыта, с ними довольно удобны.

1345
01:28:46,480 --> 01:28:51,158
Несмотря на то, что сам эксепшен, на первый
взгляд, кажется чем-то очень странным,

1346
01:28:51,240 --> 01:28:53,750
почему у нас происходит
какая-то магическая

1347
01:28:53,793 --> 01:28:56,938
запаковка эксепшенов,
потому что мы их как-то кастим.

1348
01:28:57,020 --> 01:28:59,040
На самом деле, а как по-другому?

1349
01:28:59,540 --> 01:29:03,157
Наследования-то нет на эксепшенах,
поэтому приходится изгаляться.

1350
01:29:03,240 --> 01:29:05,476
Но это внезапно вышло довольно удобно.

1351
01:29:05,620 --> 01:29:09,562
Короче, если есть у кого какие-то
вопросы по эксепшенам, задавайте.

1352
01:29:10,790 --> 01:29:12,617
Если нет, будем двигаться далее.

1353
01:29:12,700 --> 01:29:17,171
Поговорим еще чуть-чуть про них, и
поговорим уже про другие интересные вещи.

1354
01:29:18,210 --> 01:29:21,160
Почему для типа результата
используется either?

1355
01:29:21,710 --> 01:29:24,285
В плане нет ли какого-то
аналога, у которого

1356
01:29:24,328 --> 01:29:27,182
вместо left и right были
бы нормальные названия,

1357
01:29:27,300 --> 01:29:29,280
понятные типа error и result?

1358
01:29:30,600 --> 01:29:32,220
А что вызов непонятного-то?

1359
01:29:34,320 --> 01:29:36,320
Действительно используется either.

1360
01:29:37,090 --> 01:29:40,577
Где в Rust используется result,
там в Haskell используется either.

1361
01:29:40,660 --> 01:29:44,517
Просто есть такая конвенция, что
left это ошибка, right это результат.

1362
01:29:44,600 --> 01:29:47,296
Возможно, действительно
имело бы смысл назвать

1363
01:29:47,338 --> 01:29:49,837
result, но называется either все привыкли.

1364
01:30:00,340 --> 01:30:03,489
Окей, если никаких
вопросов нет про эту страшную

1365
01:30:03,532 --> 01:30:06,191
магию с эксепшенами, давайте продолжать.

1366
01:30:06,270 --> 01:30:09,190
Потому что эксепшены
будут еще раз освещены,

1367
01:30:09,233 --> 01:30:12,531
тоже довольно подробно,
в лекции про concurrency.

1368
01:30:13,770 --> 01:30:16,051
Пока что можно остановиться на каком-то

1369
01:30:16,093 --> 01:30:18,713
общем представлении
о том, как это работает.

1370
01:30:20,355 --> 01:30:22,808
Поговорим еще про
интересные функции работы с

1371
01:30:22,851 --> 01:30:26,011
исключениями в IO, которые
есть в стандартной библиотеке.

1372
01:30:26,011 --> 01:30:31,930
Есть функция try, которая на самом деле
является более-менее ее частным случаем.

1373
01:30:33,130 --> 01:30:38,170
Это функция, которая принимает иошное
действие и возвращает IO от either е а,

1374
01:30:38,410 --> 01:30:40,293
где вот этот е – это исключение.

1375
01:30:40,715 --> 01:30:42,167
Как на самом деле реализован try?

1376
01:30:42,250 --> 01:30:44,414
Это просто вызывается иошное действие с

1377
01:30:44,457 --> 01:30:48,967
хендлером таким, что если мы поймали
исключение, мы просто заворачиваем его в left.

1378
01:30:49,050 --> 01:30:50,580
Иначе мы возвращаем right.

1379
01:30:50,710 --> 01:30:52,534
Вот эта функция называется try.

1380
01:30:52,700 --> 01:30:56,287
Есть также функция try just, которая
принимает, помимо всего этого,

1381
01:30:56,370 --> 01:31:00,930
какой-то конвертер из нашего
исключения в какой-то тип данных maybe b.

1382
01:31:01,430 --> 01:31:04,930
Допустим, это выкипает
некий фильтр для эксепшенов.

1383
01:31:05,150 --> 01:31:09,830
Потому что функции try just мы ловим
не все эксепшены, как функции try,

1384
01:31:10,135 --> 01:31:14,087
а только те эксепшены, которые в случае
вот этой конверсии превратились в just.

1385
01:31:14,170 --> 01:31:18,700
Допустим, мы можем написать, что если
это какой-то нужный нам тип эксепшенов,

1386
01:31:18,870 --> 01:31:22,730
или какое-то логическое выражение,
то тогда мы возвращаем just.

1387
01:31:23,200 --> 01:31:25,787
Если же это какой-то левый
эксепшен, мы возвращаем not.

1388
01:31:25,870 --> 01:31:31,150
И таким образом try just у
нас ловит только те эксепшены,

1389
01:31:31,270 --> 01:31:34,230
которые проходят эту
проверку, можно так сказать.

1390
01:31:35,310 --> 01:31:39,630
Есть также функция finally, которая
принимает два иошных действия.

1391
01:31:40,375 --> 01:31:45,270
Принимает иошное действие,
которое запускается первым,

1392
01:31:45,520 --> 01:31:51,191
и также иошное действие, которое
запускается по прошествии первого действия.

1393
01:31:51,230 --> 01:31:53,287
Даже если там было выброшенное исключение.

1394
01:31:53,370 --> 01:31:54,927
То есть, соответственно,
там просто навишен хендлер,

1395
01:31:55,010 --> 01:31:58,107
который в случае исключения
также исполняет вот это действие.

1396
01:31:58,190 --> 01:32:01,720
Если исключение не произошло,
это действие также исполнится.

1397
01:32:03,270 --> 01:32:06,350
Ровно то же самое, что
конструкция finally в других языках,

1398
01:32:06,430 --> 01:32:08,960
только в Haskell это
функция, а не кейворд.

1399
01:32:09,290 --> 01:32:10,585
Суть и дело не меняет.

1400
01:32:11,870 --> 01:32:14,727
Также есть функция onException,
которая похожа на finally,

1401
01:32:14,810 --> 01:32:18,597
но вот это второе наше действие не
исполняет, если эксепшена не произошло.

1402
01:32:18,680 --> 01:32:23,328
То есть это действие, которое выполняется
в случае, в одникновение, исключения.

1403
01:32:23,670 --> 01:32:26,907
И также есть достаточно важная
функция, которая называется bracket,

1404
01:32:26,990 --> 01:32:31,430
которая представляет
из себя вот эту idiom array,

1405
01:32:31,670 --> 01:32:36,830
resource acquisition is initialization.

1406
01:32:37,430 --> 01:32:44,350
Когда мы работаем с какими-то
ресурсами, которые хочется

1407
01:32:44,351 --> 01:32:45,887
открывать и закрывать по
прошествии работы с ними.

1408
01:32:45,970 --> 01:32:49,350
Вот функция withFile, которую
мы рассматривали до этого,

1409
01:32:49,750 --> 01:32:53,830
она как раз таки тоже была написана
в так называемом bracket pattern.

1410
01:32:54,710 --> 01:32:56,532
Давайте посмотрим, что такое bracket.

1411
01:32:56,615 --> 01:33:02,091
Она принимает в себя первым аргумент какое-то
иошное действие с результатом типа a,

1412
01:33:02,530 --> 01:33:04,690
где a – это тип нашего ресурса.

1413
01:33:04,740 --> 01:33:07,500
То есть это действие, которое берет ресурс

1414
01:33:07,543 --> 01:33:10,411
и возвращает нам его
в качестве результата.

1415
01:33:10,890 --> 01:33:12,243
Оно выполняется первым.

1416
01:33:13,505 --> 01:33:18,450
Вторым аргументом мы принимаем действие
с этим ресурсом по закрытию ресурса.

1417
01:33:18,590 --> 01:33:20,107
Оно запускается последним.

1418
01:33:20,190 --> 01:33:23,661
То есть оно принимает
наш ресурс и возвращает

1419
01:33:23,750 --> 01:33:25,574
какой-то iob, это
результат закрытия ресурса.

1420
01:33:25,870 --> 01:33:28,787
Соответственно, это может
быть, допустим, открытие

1421
01:33:28,870 --> 01:33:30,802
файла, а вот это может
быть закрытие файла.

1422
01:33:30,885 --> 01:33:33,987
И третьим аргументом оно
принимает computation to run in between.

1423
01:33:34,070 --> 01:33:37,310
Как раз таки какое-то действие,
которое зависит от нашего ресурса,

1424
01:33:37,390 --> 01:33:40,607
принимает его в качестве аргумента
и возвращает результат действия.

1425
01:33:40,690 --> 01:33:43,632
Соответственно, результатом
всего этого будет ioc.

1426
01:33:44,070 --> 01:33:44,690
Как это происходит?

1427
01:33:44,810 --> 01:33:49,770
Берется ресурс, вызывается действие
по взятию ресурса, возвращается ioa.

1428
01:33:51,070 --> 01:33:55,365
Потом этот ресурс скармливается в
это действие, результатом которого ioc.

1429
01:33:56,450 --> 01:34:00,030
А после выполнения этого
действия ресурс закрывается,

1430
01:34:00,370 --> 01:34:02,841
но вот это ioc возвращается как результат.

1431
01:34:03,310 --> 01:34:07,370
И эта функция очень
удобна для взаимодействия с

1432
01:34:07,371 --> 01:34:10,370
киберфайлами или с
открытием каких-нибудь сокетов,

1433
01:34:10,610 --> 01:34:13,690
потому что она
обезопасивает нас от случаев,

1434
01:34:13,790 --> 01:34:19,390
когда возникает исключение,
и ресурс не будет закрыт.

1435
01:34:19,430 --> 01:34:22,907
Вот в случае функции bracket,
вот это computation to run last

1436
01:34:22,990 --> 01:34:28,011
вызывается всегда, вне зависимости от
того, было ли выброшено исключение или нет.

1437
01:34:28,070 --> 01:34:30,547
И таким образом к концу работы
функции bracket мы точно знаем,

1438
01:34:30,630 --> 01:34:33,407
что ресурс вначале был
открыт, а в конце был закрыт.

1439
01:34:33,490 --> 01:34:37,650
Вот такая вот удобная функция с весьма
страшной, на первый взгляд, сигнатурой,

1440
01:34:37,730 --> 01:34:40,672
но если ее посмотреть,
все будет довольно понятно.

1441
01:34:46,630 --> 01:34:50,130
Давайте продолжать дальше,
если нет никаких вопросов

1442
01:34:50,180 --> 01:34:54,063
по вот этим вот вспомогательным
функциям по работе с исключениями.

1443
01:34:56,640 --> 01:35:00,310
Давайте посмотрим на
такую вещь, как паттерн гарды.

1444
01:35:01,890 --> 01:35:05,650
Давайте особо не будем
обращать внимание, что у нас есть

1445
01:35:05,651 --> 01:35:09,270
какая-то функция lookup из
какой-то finite map и int в maybe int.

1446
01:35:09,530 --> 01:35:12,650
Давайте не будем погружаться
в что такое finite map,

1447
01:35:13,010 --> 01:35:17,658
просто это какая-то функция, которая
принимает какой-то объект, какой-то индекс

1448
01:35:17,940 --> 01:35:20,941
и возвращает maybe по
индексу, есть ли там или нет.

1449
01:35:21,310 --> 01:35:24,047
И давайте посмотрим, что мы с
этой функцией можем сделать.

1450
01:35:24,130 --> 01:35:28,150
Давайте напишем функцию
addlookup, которая, что будет делать,

1451
01:35:28,250 --> 01:35:30,898
она в этой нашей мапе
будет искать два числа,

1452
01:35:31,710 --> 01:35:36,430
если они оба just, их складывать,
иначе возвращать nothing.

1453
01:35:36,990 --> 01:35:39,167
Это можно использовать с do notation,

1454
01:35:39,450 --> 01:35:41,927
во-первых, это можно в
тупую написать через два кейса,

1455
01:35:42,010 --> 01:35:44,716
вложенных, как у вас
было в предыдущей лекции,

1456
01:35:44,850 --> 01:35:48,110
просто кейс на lookup
var1, потом lookup var2,

1457
01:35:48,660 --> 01:35:52,072
что может быть преобразовано
на самом деле через mayb1ado,

1458
01:35:53,030 --> 01:35:54,087
допустим, в do notation.

1459
01:35:54,170 --> 01:35:56,307
Это очень удобно написать в do notation.

1460
01:35:56,390 --> 01:35:59,347
Но это также можно сделать
с помощью альтернативного

1461
01:35:59,430 --> 01:36:01,430
синтекса, который
называется pattern guards.

1462
01:36:01,670 --> 01:36:06,030
Это никак у нас не связано с IO,
это просто ответвление в сторону.

1463
01:36:06,910 --> 01:36:08,527
Давайте напишем функцию addlookup,

1464
01:36:08,610 --> 01:36:11,057
которая принимает какой-то
environment в виде нашего мапа

1465
01:36:11,140 --> 01:36:13,310
и принимает два индекса,
которые мы будем искать.

1466
01:36:13,390 --> 01:36:14,626
Возвращает maybe int.

1467
01:36:14,850 --> 01:36:20,770
И вместо того, чтобы в самом теле функции
начать матчиться по каким-то значениям,

1468
01:36:20,790 --> 01:36:22,847
мы можем начать матчиться
по каким-то значениям в guard.

1469
01:36:22,930 --> 01:36:23,370
Почему нет?

1470
01:36:23,450 --> 01:36:25,017
Вы помните, что такое guard?

1471
01:36:25,100 --> 01:36:27,453
Это когда мы пишем логические выражения,

1472
01:36:27,930 --> 01:36:31,387
и если они эвалютируются в
true, то выполняется тело функции.

1473
01:36:31,470 --> 01:36:34,487
Так вот, помимо логических
выражений, там может быть матч.

1474
01:36:34,570 --> 01:36:37,810
Соответственно, в данное
тело функции мы зайдем,

1475
01:36:38,250 --> 01:36:42,050
если вот этот вот матчинг и вот этот
вот матчинг обработают корректно.

1476
01:36:42,051 --> 01:36:45,707
Соответственно, если
lookup вот этот и lookup вот

1477
01:36:45,790 --> 01:36:47,990
этот вернут just, мы можем
выполнить эту функцию.

1478
01:36:48,530 --> 01:36:50,490
Если же где-то здесь был nothing,

1479
01:36:51,130 --> 01:36:53,790
то вызывается какое-то
из других уравнений,

1480
01:36:53,910 --> 01:36:57,850
других тел нашей функции
addlookup, которая описана ниже.

1481
01:36:59,150 --> 01:37:01,268
Довольно незамысловатая конструкция.

1482
01:37:01,390 --> 01:37:02,979
Я надеюсь, тут все понятно.

1483
01:37:03,450 --> 01:37:06,557
Можно творить какие-то
страшные нечитаемые вещи с этим.

1484
01:37:06,640 --> 01:37:08,993
Какие-то strange operations над списком,

1485
01:37:09,330 --> 01:37:11,150
если сумма списка – это 7,

1486
01:37:11,650 --> 01:37:13,670
если длина списка – это n,

1487
01:37:13,790 --> 01:37:15,790
такое, что n больше 5 и меньше 20,

1488
01:37:15,910 --> 01:37:17,510
тогда мы возвращаем iq.

1489
01:37:17,910 --> 01:37:19,930
Иначе что-то другое.

1490
01:37:20,550 --> 01:37:24,710
Все, что общего здесь
есть с denotation и с monads,

1491
01:37:24,950 --> 01:37:27,367
это то, что используется в
такой же синтезе стрелочки.

1492
01:37:27,450 --> 01:37:30,870
Но, пожалуйста, не
путайте его с denotation.

1493
01:37:31,070 --> 01:37:32,010
Это другое.

1494
01:37:32,650 --> 01:37:35,180
То есть в гардах можно
писать как паттерны,

1495
01:37:35,390 --> 01:37:37,270
как мы сейчас написали,
так и логические выражения.

1496
01:37:37,271 --> 01:37:39,566
А можно их мешать, как видим вот здесь.

1497
01:37:43,780 --> 01:37:45,567
Это было такое немного
ответвление стороны,

1498
01:37:45,650 --> 01:37:48,427
просто для того, чтобы, если будете
читать какой-то код, вы не путались.

1499
01:37:48,510 --> 01:37:49,393


1500
01:37:51,090 --> 01:37:54,210
Давайте поговорим про
такую вещь, как unsafe.

1501
01:37:54,970 --> 01:37:59,410
io и про то, каким образом в Haskell
можно легко выстрелить себе в ногу,

1502
01:37:59,630 --> 01:38:03,590
работая с IO, не говоря уже о lazy.io.

1503
01:38:03,810 --> 01:38:05,869
Есть еще такая вещь, как unsafe.io.

1504
01:38:05,970 --> 01:38:10,795
В стандартной библиотеке есть такая функция,
которая называется unsafe.perform.io.

1505
01:38:13,330 --> 01:38:14,760
У него тип из IO A.

1506
01:38:16,980 --> 01:38:19,259
Соответственно, оно берет и отбрасывает

1507
01:38:19,302 --> 01:38:22,158
какой-то наш IO контекст
и возвращает результат.

1508
01:38:22,280 --> 01:38:26,040
На лекции про монады
вы наверняка обсуждали то,

1509
01:38:26,150 --> 01:38:30,660
что, вообще говоря, достать
значение из какой-либо

1510
01:38:30,661 --> 01:38:32,426
произвольной монады
безопасным образом невозможно.

1511
01:38:33,370 --> 01:38:36,900
Так и в случае IO невозможно
просто безопасным образом взять

1512
01:38:37,000 --> 01:38:39,765
и выйти из его контекста,
если мы в него вошли.

1513
01:38:40,120 --> 01:38:42,900
Это может иметь довольно
странные последствия.

1514
01:38:43,020 --> 01:38:44,920
Давайте сейчас это разберем.

1515
01:38:45,300 --> 01:38:48,712
Давайте посмотрим на функцию
foo, точнее на константу foo.

1516
01:38:49,260 --> 01:38:51,360
Тело которой выглядит следующим образом.

1517
01:38:51,440 --> 01:38:53,382
Мы печатаем храчку foo в консоль.

1518
01:38:53,820 --> 01:38:55,777
Здесь тип данных IO пустой картеж.

1519
01:38:55,860 --> 01:38:58,743
И мы избавляемся от IO с
помощью пустого картежа.

1520
01:38:59,595 --> 01:39:01,301
И также зайдем в функцию bar.

1521
01:39:01,820 --> 01:39:02,997
Также константу, да.

1522
01:39:03,440 --> 01:39:05,499
На самом деле константу не функция.

1523
01:39:06,100 --> 01:39:11,760
Которая в дунотации пишет в
консоль bar, возвращает базу,

1524
01:39:12,360 --> 01:39:15,360
и все это магическим
образом распаковывается из IO.

1525
01:39:16,150 --> 01:39:19,445
И, наконец, заиспользуем эти
две функции в функции main.

1526
01:39:19,890 --> 01:39:23,620
Сначала мы напишем let f
равно foo, а затем выведем bar.

1527
01:39:24,520 --> 01:39:26,918
Вот, скажите, пожалуйста, вопрос зал, что

1528
01:39:26,960 --> 01:39:29,578
же будет напечатано в
консоль в этом случае?

1529
01:39:29,660 --> 01:39:34,190
Чисто на интуиции, пока что не особо
знаю, как работает у нас с функцией foo.

1530
01:39:46,050 --> 01:39:47,109
Нет предположений?

1531
01:39:52,900 --> 01:39:54,177
Какие у нас есть варианты?

1532
01:39:54,260 --> 01:39:58,320
Может вывестись foo, bar и баз, например.

1533
01:39:58,750 --> 01:40:01,737
Может вывестись просто bar и
баз, и foo будет проигнорировано.

1534
01:40:01,820 --> 01:40:03,585
Давайте же все-таки посмотрим.

1535
01:40:04,040 --> 01:40:07,077
Тут не пишется результат, но,
короче, будет выведено bar и баз.

1536
01:40:07,160 --> 01:40:11,900
Почему? Потому что вот это
вот наш результат функции foo.

1537
01:40:12,650 --> 01:40:16,480
Не используется, потому
что мы ушли от его контекста,

1538
01:40:16,580 --> 01:40:20,463
который гарантирует нам выполнение
всех операций и порядок на них.

1539
01:40:20,640 --> 01:40:23,197
Соответственно, у нас foo
стало просто константой.

1540
01:40:23,280 --> 01:40:26,033
Так как мы ее нигде не
используем, не требуется

1541
01:40:26,075 --> 01:40:28,929
вычисление ее до
слабоголовной нормальной формы,

1542
01:40:29,460 --> 01:40:32,225
данное выражение просто
берется и игнорируется.

1543
01:40:32,820 --> 01:40:35,633
А put to sterile end bar
отрабатывает полностью,

1544
01:40:35,676 --> 01:40:38,233
потому что нам нужен
результат функции bar,

1545
01:40:39,320 --> 01:40:41,954
константа bar, которая
на самом деле выглядит

1546
01:40:41,997 --> 01:40:44,910
как функция, потому что
тут есть действия разные.

1547
01:40:45,300 --> 01:40:47,815
Соответственно, когда
мы вычисляем bar, у нас

1548
01:40:47,857 --> 01:40:50,698
происходит печать bar в
консоль и возвращение баз.

1549
01:40:50,780 --> 01:40:52,257
А потом вот саму баз отпечатывается.

1550
01:40:52,340 --> 01:40:55,717
Короче, в результате будет выведено
bar и баз, ровно в таком же порядке.

1551
01:40:55,800 --> 01:40:59,120
Согласитесь, данный код
весьма и весьма неинтуитивный.

1552
01:41:02,220 --> 01:41:04,060
Поговорим о следующем примере.

1553
01:41:04,340 --> 01:41:05,600
Заведем такую функцию helper.

1554
01:41:05,601 --> 01:41:08,304
Так а зачем вообще в принципе
использовать unsafeperform.

1555
01:41:08,346 --> 01:41:11,221
io, если он вызывает проблемы?

1556
01:41:12,040 --> 01:41:14,990
Если использовать его по-умному,
иногда он бывает полезен.

1557
01:41:15,033 --> 01:41:17,841
Об этом мы поговорим немного попозже.

1558
01:41:18,080 --> 01:41:20,775
У unsafeperform.io есть
полезные аппликейшены,

1559
01:41:20,818 --> 01:41:23,376
которые повсеместно
используются в Haskell.

1560
01:41:24,080 --> 01:41:27,420
Просто нужно знать,
сейчас мы о нем говорим.

1561
01:41:27,960 --> 01:41:30,988
Сейчас мы говорим об
unsafeperform.io, чтобы понимать,

1562
01:41:31,030 --> 01:41:33,588
в каких случаях он может
доставлять проблемы.

1563
01:41:33,670 --> 01:41:35,897
Потому что в каких-то
случаях он их не доставляет.

1564
01:41:35,980 --> 01:41:40,745
И вот как раз таки у этих случаев есть
довольно интересные и полезные применения.

1565
01:41:41,950 --> 01:41:46,539
Конечно, если бы это была абсолютно
бесполезная вещь, мы бы о ней не говорили.

1566
01:41:48,190 --> 01:41:53,850
Давайте рассмотрим функцию helper,
которая на самом деле тип из a в io.a.

1567
01:41:54,370 --> 01:41:57,591
Что она делает? Она
принимает какое-то значение

1568
01:41:57,634 --> 01:42:00,411
произвольное, печатает его и возвращает.

1569
01:42:01,740 --> 01:42:06,550
Соответственно, у a должен быть constraint
show, что немаловажно в данном случае.

1570
01:42:07,310 --> 01:42:10,807
Соответственно, мы печатаем и
возвращаем ее в ёжном контексте.

1571
01:42:10,890 --> 01:42:14,510
И давайте напишем функцию
main, которая сначала что делает?

1572
01:42:14,890 --> 01:42:18,867
Она вызывает helper от единицы, и
его результат присваивает переменной 1.

1573
01:42:18,950 --> 01:42:21,667
Вызывает helper от двойки,
присваивает результат переменной 2.

1574
01:42:21,750 --> 01:42:23,870
И печатает у нас 1 плюс 2.

1575
01:42:25,090 --> 01:42:28,290
Можем ли мы в данном
случае гарантировать порядок?

1576
01:42:28,690 --> 01:42:31,338
Что будет выведено в
консоли в данном случае?

1577
01:42:32,790 --> 01:42:34,085
Опять же вопрос в зал.

1578
01:42:39,680 --> 01:42:40,770
1, 2, 3.

1579
01:42:41,850 --> 01:42:45,710
Да, все правильно, потому что
мы находимся в ио-контексте.

1580
01:42:46,010 --> 01:42:49,010
Потому что у нас порядок
детерминирован, определен.

1581
01:42:49,170 --> 01:42:50,465
Ничего не идет не так.

1582
01:42:50,840 --> 01:42:54,670
И давайте потихоньку нашу
функцию helper, как и функцию main,

1583
01:42:54,970 --> 01:42:57,377
потихоньку делать все
более и более unsafe.

1584
01:42:57,460 --> 01:43:01,166
Давайте изменим тип функции
helper, чтобы это был тип из a в a,

1585
01:43:01,290 --> 01:43:04,087
с помощью добавления unsafe
performer 1 над всей вот этой штукой.

1586
01:43:04,170 --> 01:43:08,868
Соответственно, она спечатается, возвращается,
а потом сбрасывается в его контекст.

1587
01:43:08,950 --> 01:43:14,230
И делаем как let 1 равно helper 1,
let 2 равно helper 2, и print 1 плюс 2.

1588
01:43:15,130 --> 01:43:20,450
Как вы уже догадались, порядок на данных
действиях мы гарантировать не можем.

1589
01:43:20,910 --> 01:43:23,990
И может быть выведено
как 1, 2, 3, так и 2, 1, 3.

1590
01:43:27,010 --> 01:43:30,490
Давайте теперь сделаем ее частично unsafe.

1591
01:43:32,410 --> 01:43:35,650
Вернем функцию helper,
как было, оставим ее иошной.

1592
01:43:36,070 --> 01:43:40,830
И для единички будем вызывать
ее в иошной манере, в безопасном.

1593
01:43:41,175 --> 01:43:43,705
А для двойки обернем
все это дело в unsafe.

1594
01:43:45,230 --> 01:43:48,172
Избавимся здесь от monad
и используем обычный let.

1595
01:43:48,450 --> 01:43:51,590
Можем ли мы здесь иметь
предположение над порядком?

1596
01:43:51,690 --> 01:43:54,570
Потому что казалось бы, у нас все логично.

1597
01:43:54,571 --> 01:43:57,190
Сначала вычисляется
1, потом вычисляется 2.

1598
01:43:57,350 --> 01:43:59,287
Мы же идем по нотации сверху вниз.

1599
01:43:59,370 --> 01:44:00,841
А потом 1 плюс 2 – это 3.

1600
01:44:02,770 --> 01:44:05,182
Или же здесь тоже какая-то собака зарыта.

1601
01:44:05,650 --> 01:44:06,690
И не все так очевидно.

1602
01:44:06,730 --> 01:44:08,670
Кажется, все еще зарыто.

1603
01:44:09,750 --> 01:44:10,583
Да.

1604
01:44:11,090 --> 01:44:14,862
Вот это let 2, оно же
отбросило IO-контекст, поэтому

1605
01:44:14,904 --> 01:44:18,351
экземпляры реального
мира не передаются никуда.

1606
01:44:18,730 --> 01:44:21,207
И компилятор может
перестирать, что как хочет.

1607
01:44:21,290 --> 01:44:22,570
Да, абсолютно верно.

1608
01:44:22,870 --> 01:44:23,707
Абсолютно верно.

1609
01:44:23,790 --> 01:44:31,790
Более того, когда мы говорим о do-нотации,
где идут перемешку бинды и let выражения,

1610
01:44:32,570 --> 01:44:37,550
нет абсолютно никакой гарантии
того, что let выражения, вот

1611
01:44:37,610 --> 01:44:39,787
это let выражение, будет
вычислено после вот этого бинда.

1612
01:44:39,870 --> 01:44:40,210
Почему?

1613
01:44:40,720 --> 01:44:42,467
Собственно, эти же выражения, они чистые.

1614
01:44:42,550 --> 01:44:45,867
Компилятор может переупорядочить
их каким угодно образом,

1615
01:44:45,950 --> 01:44:49,068
очевидно, не теряя зависимости
между let выражениями.

1616
01:44:49,350 --> 01:44:52,293
Таким образом, вот это
let 2 может быть вычислено

1617
01:44:52,335 --> 01:44:54,771
сначала, а потом может быть вычислено 1.

1618
01:44:55,510 --> 01:45:00,320
Так что, да, тут возможные варианты того,

1619
01:45:00,363 --> 01:45:05,451
что сначала создается
1, потом создается 2,

1620
01:45:06,030 --> 01:45:08,678
потом tank 2 форсится
и вычисляется 1 плюс 2.

1621
01:45:09,470 --> 01:45:14,310
Потом также возможен вариант того,
что сначала создается tank 2 и форсится,

1622
01:45:15,270 --> 01:45:19,010
а потом вызывается helper от
единички и вычисляется результат.

1623
01:45:20,290 --> 01:45:22,669
Сейчас мы немного
подробнее взглянем на это

1624
01:45:22,711 --> 01:45:25,131
и поймем, почему же
все-таки так происходит

1625
01:45:25,131 --> 01:45:28,447
и каким же все-таки образом у
нас работает функция unsafeperform.

1626
01:45:28,530 --> 01:45:31,030
io, разберем ее реализацию.

1627
01:45:32,090 --> 01:45:36,990
Напоминаем, как у нас
выглядит бинд для Monado.

1628
01:45:37,240 --> 01:45:40,476
io и каким образом этот
real-world токен у нас передается.

1629
01:45:40,630 --> 01:45:43,797
То, что он сначала
скармливается нашему первому

1630
01:45:43,880 --> 01:45:47,390
действию, получается
какое-то новое состояние.

1631
01:45:48,050 --> 01:45:50,462
И затем оно передается дальше по цепочке.

1632
01:45:56,610 --> 01:45:59,647
Давайте на это не будем обращать
внимания, мне это не очень нравится.

1633
01:45:59,730 --> 01:46:03,570
Как у нас работает в общем
виде оператор урезанного бинда?

1634
01:46:06,150 --> 01:46:12,210
Вот это настоящий бинд, который
принимает действие и стрелка placely.

1635
01:46:12,211 --> 01:46:14,682
А как будет работать у нас урезанный бинд?

1636
01:46:14,870 --> 01:46:19,510
На самом деле он все еще
пропагейтит наш токен дальше.

1637
01:46:19,870 --> 01:46:24,519
Смотря на то, что результат первого
действия он игнорирует, как мы видим здесь,

1638
01:46:25,770 --> 01:46:28,285
вот этот токен, который
воспроизвело первое

1639
01:46:28,327 --> 01:46:31,419
действие, он все также
учитывает во втором действии.

1640
01:46:32,310 --> 01:46:35,312
И как же работает все-таки
функция unsafeperform.

1641
01:46:35,395 --> 01:46:39,060
io? То, что у нас где-то
определенно на верхнем

1642
01:46:39,103 --> 01:46:42,551
уровне такая вещь, как fake state token.

1643
01:46:42,910 --> 01:46:47,670
Это просто какое-то
значение типа state real world.

1644
01:46:48,530 --> 01:46:51,859
И как раз таки unsafeperform.io
работает так, что мы

1645
01:46:51,902 --> 01:46:55,791
вызываем наше егоршное действие
на каком-то фейковом токене,

1646
01:46:55,810 --> 01:46:58,627
а не на том токене, который
нам откуда-то пришел.

1647
01:46:58,710 --> 01:47:01,967
Потому что в случае unsafeperform.io
ему не откуда приходить.

1648
01:47:02,050 --> 01:47:05,307
Потому что это действие может
быть вызвано в чистом контексте.

1649
01:47:05,390 --> 01:47:08,427
Мы вызываем наше f на
каком-то фейковом токене,

1650
01:47:08,470 --> 01:47:11,811
получаем следующий токен,
который идет за фейковым,

1651
01:47:12,110 --> 01:47:15,547
если рассматривать как-то их
по порядку, и получаем результат.

1652
01:47:15,630 --> 01:47:19,925
Отбрасываем этот токен, который идет
за фейковым, и возвращаем результат.

1653
01:47:21,010 --> 01:47:25,127
Так вот у нас довольно прямолинейно
работает функция unsafeperform.io.

1654
01:47:25,210 --> 01:47:32,590
И давайте если мы развернем нашу функцию
main, самую последнюю ее реализацию,

1655
01:47:32,770 --> 01:47:36,650
то посмотрим, как же она
работает в дешугерином виде.

1656
01:47:37,270 --> 01:47:43,630
То, что сначала может вызываться helper1
от какого-то у нас изначального токена s0,

1657
01:47:43,790 --> 01:47:45,087
который пришел в функцию main.

1658
01:47:45,170 --> 01:47:46,994
Мы можем получить первый токен.

1659
01:47:47,450 --> 01:47:53,530
А затем, когда мы вызываем helper2, вот
здесь вот, мы этот токен не используем.

1660
01:47:53,531 --> 01:47:55,601
Почему? Потому что мы
вызываем это действие

1661
01:47:55,644 --> 01:47:57,608
unsafe, вызываем его на фейковом токене.

1662
01:47:57,690 --> 01:48:00,927
Соответственно, результат этого
фейкового токена мы игнорируем,

1663
01:48:01,010 --> 01:48:04,010
и вот этот токен первый
мы используем только здесь.

1664
01:48:04,110 --> 01:48:08,570
Соответственно, вот это действие
пропущено в нашей цепочке действий.

1665
01:48:08,780 --> 01:48:11,871
То, что мы используем здесь
состояние внешнего мира

1666
01:48:11,914 --> 01:48:15,231
не то, которое запродюсировало
у нас вот это действие,

1667
01:48:15,550 --> 01:48:19,427
что по-хорошему, а мы используем
состояние на предыдущем действии.

1668
01:48:19,510 --> 01:48:20,870
Это один из вариантов.

1669
01:48:20,945 --> 01:48:24,769
Это в случае, если у нас вычисление
пойдет вот по этому сценарию.

1670
01:48:25,150 --> 01:48:28,437
Если же вычисление
пойдет по второму сценарию,

1671
01:48:28,480 --> 01:48:31,591
то сначала мы обратимся
к фейковому токену,

1672
01:48:32,730 --> 01:48:37,750
проигнорируем его, а затем вызовем на
начальном токене, что тоже неправильно,

1673
01:48:37,850 --> 01:48:41,607
потому что у нас первым иошным
действием произошло вот это действие.

1674
01:48:41,690 --> 01:48:45,808
Соответственно, нам нужно его токен
использовать дальше как результат.

1675
01:48:45,950 --> 01:48:50,458
Но мы используем самый лишь
начальный токен, который у нас

1676
01:48:50,540 --> 01:48:53,029
передали в функцию main, и затем
используем его и получаем новый

1677
01:48:53,071 --> 01:48:55,991
токен S1, который мы
передаем в функцию main.

1678
01:48:57,130 --> 01:49:01,410
Соответственно, как-то так это
выглядит под лупой, можно так сказать.

1679
01:49:04,070 --> 01:49:06,047
И что хочется сказать в
заключение на этот счет,

1680
01:49:06,130 --> 01:49:11,270
что если вам особо это не нужно, не
используйте янца и функции в Haskell,

1681
01:49:11,650 --> 01:49:15,170
да и вообще в любом другом
языке программирования.

1682
01:49:15,870 --> 01:49:19,673
И общий паттерн, когда unsafeperform.

1683
01:49:19,715 --> 01:49:24,151
io работает и особо не
вызывает никаких проблем,

1684
01:49:24,270 --> 01:49:28,247
но там тоже есть нюансы, это когда
мы находимся вне IOManada вообще.

1685
01:49:28,330 --> 01:49:30,642
Потому что нам не
страшно потерять какой-то

1686
01:49:30,684 --> 01:49:32,928
контекст, если у нас этого контекста нет.

1687
01:49:33,010 --> 01:49:36,909
Когда мы находимся в IOManada, вы
видите, что использование unsafeperform.

1688
01:49:36,952 --> 01:49:40,091
io рождает недетерминированность.

1689
01:49:40,570 --> 01:49:44,367
То есть в зависимости от того, как
компилятор перепорядочит инструкции,

1690
01:49:44,450 --> 01:49:47,451
мы можем получить как
один результат, так и другой.

1691
01:49:47,650 --> 01:49:51,167
Тут дело даже не в том, что в результате.
Результат – это ладно, одни и те же.

1692
01:49:51,250 --> 01:49:57,470
Но наши функции, так как они IO, они
умеют производить некоторые side-эффекты.

1693
01:49:57,950 --> 01:50:00,950
И эти side-эффекты могут
зависеть друг от друга.

1694
01:50:02,270 --> 01:50:07,035
Side-эффекты, выполненные в одном порядке,
могут давать одно состояние программы.

1695
01:50:07,650 --> 01:50:08,667
Один результат программы.

1696
01:50:08,750 --> 01:50:10,773
Side-эффекты, выполненные
в другом состоянии,

1697
01:50:10,816 --> 01:50:12,651
могут давать другой результат программы.

1698
01:50:12,651 --> 01:50:15,790
Допустим, если речь идет
о записи в базу данных.

1699
01:50:15,930 --> 01:50:20,107
То есть у нас могут быть строки,
помененные местами или что-то там еще,

1700
01:50:20,410 --> 01:50:23,030
что очень трудно отображать и отследить.

1701
01:50:23,230 --> 01:50:28,930
Поэтому основная проблема в использовании
unsafeperform.io находится в том,

1702
01:50:29,030 --> 01:50:33,810
что очень рекомендуется его
использовать, находясь уже в IOCонтексте.

1703
01:50:34,770 --> 01:50:40,530
Если же мы находимся вне IOCонтекста,
в большинстве случаев нам нечего терять.

1704
01:50:40,780 --> 01:50:44,187
В том плане, что у нас нет
стейк-токена, который мы потеряем.

1705
01:50:44,270 --> 01:50:46,767
И поэтому может быть безопасно
использовать unsafeperform.io.

1706
01:50:46,850 --> 01:50:49,782
И сейчас мы даже разберем,
каким образом безопасно

1707
01:50:49,824 --> 01:50:52,322
он используется и как это облегчает жизнь.

1708
01:50:54,010 --> 01:50:57,627
Первым примером является модуль debug.

1709
01:50:57,670 --> 01:51:00,331
trace, который имеет следующие функции.

1710
01:51:00,490 --> 01:51:04,785
Функция trace, которая принимает
строчку, значение и возвращает значение.

1711
01:51:05,730 --> 01:51:07,201
Что делает функция trace?

1712
01:51:07,300 --> 01:51:12,930
Трейс просто берет и пишет
вот эту строчку в консоль.

1713
01:51:13,170 --> 01:51:16,810
Допустим, давайте посмотрим
на пример функции trace.

1714
01:51:17,490 --> 01:51:21,610
Мы можем вызвать функцию trace,
приставить туда какую-то строчку.

1715
01:51:22,010 --> 01:51:26,717
И когда Haskell будет вычислять это
выражение, он напишет эту строчку в консоль.

1716
01:51:27,970 --> 01:51:31,030
Это в силу того, что в
Haskell нет дебаггеров.

1717
01:51:31,310 --> 01:51:33,640
Если бы необходимый тулинг для дебаггера

1718
01:51:33,682 --> 01:51:36,231
был, было бы непонятно,
как бы он выглядел.

1719
01:51:36,231 --> 01:51:40,650
Потому что идея прыгания по
инструкции в Haskell неприменима.

1720
01:51:40,810 --> 01:51:42,427
Потому что инструкции здесь нет.

1721
01:51:42,510 --> 01:51:47,270
А дебаггер, который редуцирует выражение,
это что-то странное и не особо нужное.

1722
01:51:47,390 --> 01:51:49,567
Поэтому, да, в Haskell нет дебаггера.

1723
01:51:50,450 --> 01:51:52,147
И приходится дебажить выводами.

1724
01:51:52,230 --> 01:51:55,247
А в силу того, что вывод –
это всегда что-то иошное.

1725
01:51:55,330 --> 01:51:57,470
А у нас далеко не вся логика иошная.

1726
01:51:57,790 --> 01:52:01,767
Иошные логики стараются делать
настолько мало, насколько это возможно.

1727
01:52:01,850 --> 01:52:03,472
Приходит на помощь пакет debug.trace.

1728
01:52:03,555 --> 01:52:09,310
С помощью которого можно трейсить
промежуточные результаты нашей программы.

1729
01:52:09,630 --> 01:52:13,087
Функция trace, которая просто выводит
строчку при вычислении выражения a.

1730
01:52:13,170 --> 01:52:18,010
Есть функция trace show, которая вместо
строчки принимает какое-то значение,

1731
01:52:18,090 --> 01:52:21,627
которое можно привести к строке
и распечатать, что оно и делает.

1732
01:52:21,710 --> 01:52:25,507
И также есть функция trace m, которая
принимает какое-то аппликативное действие

1733
01:52:25,590 --> 01:52:28,591
и перед его выполнением
печатает в консоль строчку.

1734
01:52:29,410 --> 01:52:33,116
Аппликативность существует по
легаси причинам, я бы так сказал.

1735
01:52:33,635 --> 01:52:35,694
По-хорошему тут должна быть манана.

1736
01:52:37,150 --> 01:52:38,647
Но аппликатив что есть, то есть.

1737
01:52:38,730 --> 01:52:40,152
И как выглядит функция trace?

1738
01:52:40,235 --> 01:52:43,567
На самом деле это просто unsafe
perform.io от следующего дублока.

1739
01:52:43,650 --> 01:52:46,886
Мы печатаем консоль строчку
с помощью функции trace.io.

1740
01:52:47,110 --> 01:52:50,218
Можно сказать то же самое, что put strln,

1741
01:52:50,261 --> 01:52:53,871
просто с добавлением
какой-то дебаг информации.

1742
01:52:54,540 --> 01:52:56,070
И мы возвращаем наше выражение.

1743
01:52:56,071 --> 01:52:59,030
Соответственно, trace
печатает и возвращает.

1744
01:52:59,050 --> 01:53:02,227
Ровно так же, как наша функция
helper, помните, которая была.

1745
01:53:02,310 --> 01:53:03,899
Так работает функция trace.

1746
01:53:05,870 --> 01:53:10,047
Можно рассмотреть пример ее использования
в вычислении чисел Fibonacci.

1747
01:53:10,310 --> 01:53:12,970
В corner-кейсах мы не
пишем никакого вывода,

1748
01:53:13,490 --> 01:53:18,030
а когда мы вызываем recursive,
мы пишем, какое n мы вычисляем.

1749
01:53:18,110 --> 01:53:19,699
Соответственно, 4, 3, 2, 2.

1750
01:53:22,055 --> 01:53:26,370
А, ну мы тут дописали, потому
что мы изначально ничего не пишем.

1751
01:53:27,280 --> 01:53:32,770
Вот. И результат будет только получается.

1752
01:53:36,530 --> 01:53:39,942
Есть ли какие-то вопросы по дебаггингу, по

1753
01:53:39,984 --> 01:53:43,931
трейсу или unsafe магии,
если вдруг они созрели?

1754
01:53:51,190 --> 01:53:52,530
Хорошо, видимо, вопросов нет.

1755
01:53:52,531 --> 01:53:57,610
И сейчас, кажется, коснемся уже
последней темы, про умные строки.

1756
01:53:58,450 --> 01:54:00,247
Точнее, про эффективные строки.

1757
01:54:00,330 --> 01:54:03,927
Строки в Haskell, которые string, как
мы еще с первой лекции с вами заметили,

1758
01:54:04,010 --> 01:54:08,810
это просто список символов, что
весьма и весьма неэффективно.

1759
01:54:09,210 --> 01:54:12,487
И сейчас мы разберемся, какие эффективные
реализации строк у нас бывают в Haskell,

1760
01:54:12,570 --> 01:54:15,982
и, казалось бы, при чем тут
и о, а вот тем более unsafe о.

1761
01:54:17,190 --> 01:54:21,130
Начнем с того, что, помните,
мы с вами говорили про то,

1762
01:54:21,131 --> 01:54:23,661
что числовые литералы
в Haskell полиморфны.

1763
01:54:23,990 --> 01:54:27,287
На самом деле, при подключении
extension overloaded strings

1764
01:54:27,370 --> 01:54:30,187
можно сделать строковые
литералы также полиморфными.

1765
01:54:30,270 --> 01:54:34,919
Это делается с помощью трек-класса isString
с единственной функцией fromString,

1766
01:54:35,070 --> 01:54:38,870
которая позволяет нам из строчки
сконвертить нужный нам тип.

1767
01:54:38,930 --> 01:54:42,867
Соответственно, если мы подключили
без extension overloaded strings,

1768
01:54:42,950 --> 01:54:47,030
тип строчки full – это всегда
строка, то есть список символов.

1769
01:54:47,330 --> 01:54:50,157
Если мы подключаем
расширение overloaded strings,

1770
01:54:50,240 --> 01:54:53,150
то это некоторый а –
такой, что а – это isString,

1771
01:54:53,730 --> 01:54:58,437
что как бы намекает нам на то, что в
Haskell существуют разные реализации строк.

1772
01:55:00,370 --> 01:55:04,590
Первой эффективной реализацией
является тип данных text,

1773
01:55:04,790 --> 01:55:08,130
который находится в
модуле data.txt в пакете text.

1774
01:55:09,410 --> 01:55:13,530
Импортим мы его, как вы заметили,
с использованием import qualified.

1775
01:55:14,490 --> 01:55:19,290
Это сделано намеренно, потому что
большинство функций в модуле data.

1776
01:55:21,270 --> 01:55:25,267
txt пересекаются по именам, оверлапятся
с функциями работы над строками.

1777
01:55:25,350 --> 01:55:28,407
И чтобы Haskell не ругался,
мы используем qualified имена.

1778
01:55:28,490 --> 01:55:33,348
То есть данный модуль специально задизайнен
так, чтобы его импортировали qualified.

1779
01:55:33,430 --> 01:55:38,370
И давайте посмотрим, как можно создавать
новые экземпляры по данным текстам.

1780
01:55:38,430 --> 01:55:40,888
Для этого существует функция pack, которая

1781
01:55:40,930 --> 01:55:43,549
принимает строчку и
запаковывает ее в текст.

1782
01:55:43,930 --> 01:55:46,877
Но также, если у нас подключено
расширение overloaded strings,

1783
01:55:46,960 --> 01:55:51,490
мы можем просто написать строковый
литерал, который сам зарезолвится в текст.

1784
01:55:53,230 --> 01:55:58,050
Для текста есть все удобные
функции для работы с строками.

1785
01:55:58,210 --> 01:56:02,950
Взятие по индексу, взятие префикса,
взятие суффикса, конкретинация,

1786
01:56:03,050 --> 01:56:08,330
все, что душе угодно, с эффективной,
насколько это возможно, реализацией.

1787
01:56:09,190 --> 01:56:14,790
Отвечая на вопрос, который будет
подробно освещен чуть позднее,

1788
01:56:15,290 --> 01:56:17,607
при чем тут вообще IO и при чем unsafe IO,

1789
01:56:17,690 --> 01:56:21,590
что на самом деле текст реализован
просто через сипшный указатель.

1790
01:56:22,505 --> 01:56:29,550
То есть под капотом текста находится
сипшный указатель на юникодный кодпоинт.

1791
01:56:30,170 --> 01:56:34,807
То есть это все реализовано просто через
указатель, как это реализовано в сипке.

1792
01:56:34,890 --> 01:56:37,647
Что позволяет нам довольно
эффективной манипуляции.

1793
01:56:37,730 --> 01:56:40,330
Но чтобы не делать всю
логику работы с текстом IO,

1794
01:56:40,331 --> 01:56:45,270
в хастеле все это взяли и
запрятали под unsafe perform IO.

1795
01:56:45,650 --> 01:56:49,190
Практика показывает, что
здесь unsafe perform IO не мешает.

1796
01:56:49,585 --> 01:56:55,650
Потому что если использовать текст
в чистых функциях, понятно почему,

1797
01:56:55,790 --> 01:57:00,110
но даже в овощных функциях, благо,
создатели библиотеки постарались,

1798
01:57:00,810 --> 01:57:05,693
и оно не доставляет проблем, даже несмотря
на то, что здесь используется unsafe IO.

1799
01:57:06,310 --> 01:57:10,387
Есть также другая эффективная реализация
строк, которая называется байтстринг.

1800
01:57:10,470 --> 01:57:16,171
Судя из названия, понятно, что она работает
со строками в бинарном представлении.

1801
01:57:16,650 --> 01:57:20,910
Несмотря на то, что у него
также существует instance и string,

1802
01:57:22,010 --> 01:57:25,530
но вы знаете, что в
байтстринге лежат байтики.

1803
01:57:25,790 --> 01:57:30,350
Соответственно, ваша строчка,
которую вы написали в виде

1804
01:57:30,430 --> 01:57:32,313
строкового литерала, будет
храниться в виде байтиков.

1805
01:57:33,490 --> 01:57:40,050
И у модуля байтстринг также существует
множество удобных функций для конкатенации

1806
01:57:40,051 --> 01:57:45,930
и всем, чему душе угодно, для
работы с байтовыми строками.

1807
01:57:47,450 --> 01:57:52,710
На вопрос, где же тут unsafe perform IO,
если вы немного посмотрите на этот код,

1808
01:57:52,790 --> 01:57:57,026
на который мы, конечно же, не будем
смотреть подробно, потому что зачем,

1809
01:57:57,500 --> 01:58:02,930
мы видим, что байтстринг – это, на
самом деле, какой-то оберт над фаре-нпт,

1810
01:58:03,350 --> 01:58:06,210
как раз-таки поинтер, на Word8.

1811
01:58:06,890 --> 01:58:08,890
Word8 – это просто машинное слово.

1812
01:58:09,390 --> 01:58:14,150
То есть octet, так еще говорят.

1813
01:58:14,870 --> 01:58:17,230
8-бит.

1814
01:58:19,290 --> 01:58:21,748
Соответственно, у нас есть функция create,

1815
01:58:21,790 --> 01:58:24,527
которая принимает
какую-то страшную сигнатуру,

1816
01:58:27,100 --> 01:58:29,983
принимает, видимо, какой-то
индекс для аллокации,

1817
01:58:30,730 --> 01:58:33,484
потом количество байтов,
сколько мы аллоцируем,

1818
01:58:33,526 --> 01:58:36,084
принимает какую-то
функцию из поинтера в IO

1819
01:58:36,240 --> 01:58:37,652
и изучает IO-байтстринг.

1820
01:58:38,050 --> 01:58:41,345
И, соответственно, здесь у
нас под капотом запрятано IO,

1821
01:58:41,490 --> 01:58:45,255
но с помощью unsafe perform IO
функции для работы с байтстрингом

1822
01:58:45,450 --> 01:58:47,921
не требуют от нас нахождения в вашем коде.

1823
01:58:48,140 --> 01:58:52,677
Вот, допустим, есть функция unsafe create,
которая просто unsafe perform IO надкреет.

1824
01:58:52,760 --> 01:58:56,327
И если рассматривать, в чем же все-таки
разница между текстом и байтстрингом,

1825
01:58:56,410 --> 01:59:02,050
как мы уже говорили, текст
оперирует уникодными символами,

1826
01:59:02,670 --> 01:59:05,450
а байтстринг оперирует
octet, то есть Word8.

1827
01:59:05,570 --> 01:59:10,630
То есть элементарная
единица строки разная.

1828
01:59:11,770 --> 01:59:13,710
Что же все-таки использовать?

1829
01:59:13,950 --> 01:59:17,730
Вопрос достаточно
нетривиальный на самом-то деле,

1830
01:59:18,030 --> 01:59:22,442
потому что существует тонна реализаций
строк, как вы видите на этих файлах.

1831
01:59:23,230 --> 01:59:27,990
Если же нам нужны бинарные данные,
и они нужны в запакованном виде,

1832
01:59:28,250 --> 01:59:29,780
сейчас мы поймем, что это.

1833
01:59:29,910 --> 01:59:33,387
Если они нужны ленивые,
существует пакет database.string.

1834
01:59:33,470 --> 01:59:36,487
lazy, который как раз-таки не
эвалюирует стройку, пока это не нужно.

1835
01:59:36,570 --> 01:59:39,390
Также существует
database.string.prost, который на самом

1836
01:59:39,470 --> 01:59:41,882
деле строгий, который будет
вычислять наши байтстринги.

1837
01:59:42,350 --> 01:59:44,770
Также существует unpacked версия.

1838
01:59:44,920 --> 01:59:51,050
Это когда в куче под наш
конструктор создается отдельная нода.

1839
01:59:51,550 --> 01:59:55,786
Можно так сказать, когда можно
представлять наше значение в виде дерева,

1840
01:59:56,030 --> 01:59:59,250
и вот этот фанг нашего
хаскерного типа данных,

1841
01:59:59,535 --> 02:00:02,647
можно сказать, что под конструктором
в нем есть отдельные ноды.

1842
02:00:02,730 --> 02:00:04,627
Но есть также unpacked типа данных.

1843
02:00:04,710 --> 02:00:07,607
Это когда у нас как C-шную
структуру, как все лежит друг за другом,

1844
02:00:07,690 --> 02:00:09,807
что более эффективно
с точки зрения памяти.

1845
02:00:09,890 --> 02:00:13,714
Соответственно, есть байтстринг,
еще и unpacked. Даже такое есть.

1846
02:00:15,790 --> 02:00:20,230
Соответственно, если нужна packed и lazy,

1847
02:00:20,350 --> 02:00:23,247
то тогда мы можем сказать
database.string.lazy.char.8.

1848
02:00:23,330 --> 02:00:28,470
Короче, куча разных функций,
точнее, куча разных типов данных,

1849
02:00:29,370 --> 02:00:33,031
но ничего кроме
lazy.string.text и lazy.string.bait.

1850
02:00:33,073 --> 02:00:35,371
string на практике
никогда не используется.

1851
02:00:35,770 --> 02:00:37,550
Соответственно, решайте, что вам нужно.

1852
02:00:37,610 --> 02:00:39,967
Если вы работаете с
Unicorn, вы используете текст.

1853
02:00:40,050 --> 02:00:43,257
Если у вас большие строки, вы
используете lazy, маленький и strict.

1854
02:00:43,340 --> 02:00:44,707
То же самое с бинарными данными.

1855
02:00:44,790 --> 02:00:49,270
Если у вас большие какие-то
строки, вы используете байтстринг.

1856
02:00:49,810 --> 02:00:53,610
Если маленькие и не хотите
нарваться на проблемы с NCPIO,

1857
02:00:54,090 --> 02:00:55,537
можете использовать строку.

1858
02:00:55,620 --> 02:00:58,650
Соответственно, но типов
строк тут полный зоопарк,

1859
02:00:59,410 --> 02:01:02,207
большинство из которых я, если честно, там

1860
02:01:02,290 --> 02:01:03,667
впервые вижу, которые
не особо-то используются.

1861
02:01:03,750 --> 02:01:05,515
Просто знайте, что такие есть.

1862
02:01:05,910 --> 02:01:10,530
И все это позволяет нам
делать как раз-таки наше UnCPU,

1863
02:01:10,970 --> 02:01:12,676
если использовать его с умом.

1864
02:01:13,570 --> 02:01:16,527
Но, соответственно, тут,
как обычно, куча ссылочек.

1865
02:01:16,610 --> 02:01:22,110
Из того, что я бы рекомендовал посмотреть,
это вот эта статья на FB Complete про то,

1866
02:01:22,410 --> 02:01:24,847
как в Haskell и Arizona
всякие разные примитивы,

1867
02:01:24,930 --> 02:01:28,695
когда мы с вами говорили про
MagicHash и решеточку в конце типа.

1868
02:01:30,290 --> 02:01:33,643
Готов, если у вас есть какие-то
вопросы, на них ответить.

1869
02:01:33,850 --> 02:01:36,027
Если вопросов нет, можем расходиться.

1870
02:01:43,960 --> 02:01:45,060
До свидания.

1871
02:01:45,420 --> 02:01:46,253
До свидания.

1872
02:01:51,930 --> 02:01:53,030
До свидания.

